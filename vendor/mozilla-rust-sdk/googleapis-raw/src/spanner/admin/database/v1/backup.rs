// This file is generated by rust-protobuf 2.22.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/spanner/admin/database/v1/backup.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_22_0;

#[derive(PartialEq,Clone,Default)]
pub struct Backup {
    // message fields
    pub database: ::std::string::String,
    pub version_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub expire_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub name: ::std::string::String,
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub size_bytes: i64,
    pub state: Backup_State,
    pub referencing_databases: ::protobuf::RepeatedField<::std::string::String>,
    pub encryption_info: ::protobuf::SingularPtrField<super::common::EncryptionInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Backup {
    fn default() -> &'a Backup {
        <Backup as ::protobuf::Message>::default_instance()
    }
}

impl Backup {
    pub fn new() -> Backup {
        ::std::default::Default::default()
    }

    // string database = 2;


    pub fn get_database(&self) -> &str {
        &self.database
    }
    pub fn clear_database(&mut self) {
        self.database.clear();
    }

    // Param is passed by value, moved
    pub fn set_database(&mut self, v: ::std::string::String) {
        self.database = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_database(&mut self) -> &mut ::std::string::String {
        &mut self.database
    }

    // Take field
    pub fn take_database(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.database, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp version_time = 9;


    pub fn get_version_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.version_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_version_time(&mut self) {
        self.version_time.clear();
    }

    pub fn has_version_time(&self) -> bool {
        self.version_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.version_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.version_time.is_none() {
            self.version_time.set_default();
        }
        self.version_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_version_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.version_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp expire_time = 3;


    pub fn get_expire_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.expire_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_expire_time(&mut self) {
        self.expire_time.clear();
    }

    pub fn has_expire_time(&self) -> bool {
        self.expire_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expire_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.expire_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expire_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.expire_time.is_none() {
            self.expire_time.set_default();
        }
        self.expire_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_expire_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.expire_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp create_time = 4;


    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // int64 size_bytes = 5;


    pub fn get_size_bytes(&self) -> i64 {
        self.size_bytes
    }
    pub fn clear_size_bytes(&mut self) {
        self.size_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_size_bytes(&mut self, v: i64) {
        self.size_bytes = v;
    }

    // .google.spanner.admin.database.v1.Backup.State state = 6;


    pub fn get_state(&self) -> Backup_State {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = Backup_State::STATE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: Backup_State) {
        self.state = v;
    }

    // repeated string referencing_databases = 7;


    pub fn get_referencing_databases(&self) -> &[::std::string::String] {
        &self.referencing_databases
    }
    pub fn clear_referencing_databases(&mut self) {
        self.referencing_databases.clear();
    }

    // Param is passed by value, moved
    pub fn set_referencing_databases(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.referencing_databases = v;
    }

    // Mutable pointer to the field.
    pub fn mut_referencing_databases(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.referencing_databases
    }

    // Take field
    pub fn take_referencing_databases(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.referencing_databases, ::protobuf::RepeatedField::new())
    }

    // .google.spanner.admin.database.v1.EncryptionInfo encryption_info = 8;


    pub fn get_encryption_info(&self) -> &super::common::EncryptionInfo {
        self.encryption_info.as_ref().unwrap_or_else(|| <super::common::EncryptionInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_encryption_info(&mut self) {
        self.encryption_info.clear();
    }

    pub fn has_encryption_info(&self) -> bool {
        self.encryption_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_info(&mut self, v: super::common::EncryptionInfo) {
        self.encryption_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_info(&mut self) -> &mut super::common::EncryptionInfo {
        if self.encryption_info.is_none() {
            self.encryption_info.set_default();
        }
        self.encryption_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryption_info(&mut self) -> super::common::EncryptionInfo {
        self.encryption_info.take().unwrap_or_else(|| super::common::EncryptionInfo::new())
    }
}

impl ::protobuf::Message for Backup {
    fn is_initialized(&self) -> bool {
        for v in &self.version_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.expire_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.encryption_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.database)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.version_time)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expire_time)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size_bytes = tmp;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 6, &mut self.unknown_fields)?
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.referencing_databases)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.encryption_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.database.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.database);
        }
        if let Some(ref v) = self.version_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.expire_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.size_bytes != 0 {
            my_size += ::protobuf::rt::value_size(5, self.size_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.state != Backup_State::STATE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(6, self.state);
        }
        for value in &self.referencing_databases {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(ref v) = self.encryption_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.database.is_empty() {
            os.write_string(2, &self.database)?;
        }
        if let Some(ref v) = self.version_time.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.expire_time.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.size_bytes != 0 {
            os.write_int64(5, self.size_bytes)?;
        }
        if self.state != Backup_State::STATE_UNSPECIFIED {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        for v in &self.referencing_databases {
            os.write_string(7, &v)?;
        };
        if let Some(ref v) = self.encryption_info.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Backup {
        Backup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "database",
                |m: &Backup| { &m.database },
                |m: &mut Backup| { &mut m.database },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "version_time",
                |m: &Backup| { &m.version_time },
                |m: &mut Backup| { &mut m.version_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "expire_time",
                |m: &Backup| { &m.expire_time },
                |m: &mut Backup| { &mut m.expire_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Backup| { &m.name },
                |m: &mut Backup| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "create_time",
                |m: &Backup| { &m.create_time },
                |m: &mut Backup| { &mut m.create_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "size_bytes",
                |m: &Backup| { &m.size_bytes },
                |m: &mut Backup| { &mut m.size_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Backup_State>>(
                "state",
                |m: &Backup| { &m.state },
                |m: &mut Backup| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "referencing_databases",
                |m: &Backup| { &m.referencing_databases },
                |m: &mut Backup| { &mut m.referencing_databases },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::EncryptionInfo>>(
                "encryption_info",
                |m: &Backup| { &m.encryption_info },
                |m: &mut Backup| { &mut m.encryption_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Backup>(
                "Backup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Backup {
        static instance: ::protobuf::rt::LazyV2<Backup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Backup::new)
    }
}

impl ::protobuf::Clear for Backup {
    fn clear(&mut self) {
        self.database.clear();
        self.version_time.clear();
        self.expire_time.clear();
        self.name.clear();
        self.create_time.clear();
        self.size_bytes = 0;
        self.state = Backup_State::STATE_UNSPECIFIED;
        self.referencing_databases.clear();
        self.encryption_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Backup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Backup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Backup_State {
    STATE_UNSPECIFIED = 0,
    CREATING = 1,
    READY = 2,
}

impl ::protobuf::ProtobufEnum for Backup_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Backup_State> {
        match value {
            0 => ::std::option::Option::Some(Backup_State::STATE_UNSPECIFIED),
            1 => ::std::option::Option::Some(Backup_State::CREATING),
            2 => ::std::option::Option::Some(Backup_State::READY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Backup_State] = &[
            Backup_State::STATE_UNSPECIFIED,
            Backup_State::CREATING,
            Backup_State::READY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Backup_State>("Backup.State", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Backup_State {
}

impl ::std::default::Default for Backup_State {
    fn default() -> Self {
        Backup_State::STATE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Backup_State {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateBackupRequest {
    // message fields
    pub parent: ::std::string::String,
    pub backup_id: ::std::string::String,
    pub backup: ::protobuf::SingularPtrField<Backup>,
    pub encryption_config: ::protobuf::SingularPtrField<CreateBackupEncryptionConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateBackupRequest {
    fn default() -> &'a CreateBackupRequest {
        <CreateBackupRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateBackupRequest {
    pub fn new() -> CreateBackupRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string backup_id = 2;


    pub fn get_backup_id(&self) -> &str {
        &self.backup_id
    }
    pub fn clear_backup_id(&mut self) {
        self.backup_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_backup_id(&mut self, v: ::std::string::String) {
        self.backup_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backup_id(&mut self) -> &mut ::std::string::String {
        &mut self.backup_id
    }

    // Take field
    pub fn take_backup_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.backup_id, ::std::string::String::new())
    }

    // .google.spanner.admin.database.v1.Backup backup = 3;


    pub fn get_backup(&self) -> &Backup {
        self.backup.as_ref().unwrap_or_else(|| <Backup as ::protobuf::Message>::default_instance())
    }
    pub fn clear_backup(&mut self) {
        self.backup.clear();
    }

    pub fn has_backup(&self) -> bool {
        self.backup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backup(&mut self, v: Backup) {
        self.backup = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backup(&mut self) -> &mut Backup {
        if self.backup.is_none() {
            self.backup.set_default();
        }
        self.backup.as_mut().unwrap()
    }

    // Take field
    pub fn take_backup(&mut self) -> Backup {
        self.backup.take().unwrap_or_else(|| Backup::new())
    }

    // .google.spanner.admin.database.v1.CreateBackupEncryptionConfig encryption_config = 4;


    pub fn get_encryption_config(&self) -> &CreateBackupEncryptionConfig {
        self.encryption_config.as_ref().unwrap_or_else(|| <CreateBackupEncryptionConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_encryption_config(&mut self) {
        self.encryption_config.clear();
    }

    pub fn has_encryption_config(&self) -> bool {
        self.encryption_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_config(&mut self, v: CreateBackupEncryptionConfig) {
        self.encryption_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_config(&mut self) -> &mut CreateBackupEncryptionConfig {
        if self.encryption_config.is_none() {
            self.encryption_config.set_default();
        }
        self.encryption_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryption_config(&mut self) -> CreateBackupEncryptionConfig {
        self.encryption_config.take().unwrap_or_else(|| CreateBackupEncryptionConfig::new())
    }
}

impl ::protobuf::Message for CreateBackupRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.backup {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.encryption_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.backup_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.backup)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.encryption_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.backup_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.backup_id);
        }
        if let Some(ref v) = self.backup.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.encryption_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.backup_id.is_empty() {
            os.write_string(2, &self.backup_id)?;
        }
        if let Some(ref v) = self.backup.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.encryption_config.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateBackupRequest {
        CreateBackupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &CreateBackupRequest| { &m.parent },
                |m: &mut CreateBackupRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "backup_id",
                |m: &CreateBackupRequest| { &m.backup_id },
                |m: &mut CreateBackupRequest| { &mut m.backup_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Backup>>(
                "backup",
                |m: &CreateBackupRequest| { &m.backup },
                |m: &mut CreateBackupRequest| { &mut m.backup },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CreateBackupEncryptionConfig>>(
                "encryption_config",
                |m: &CreateBackupRequest| { &m.encryption_config },
                |m: &mut CreateBackupRequest| { &mut m.encryption_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateBackupRequest>(
                "CreateBackupRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateBackupRequest {
        static instance: ::protobuf::rt::LazyV2<CreateBackupRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateBackupRequest::new)
    }
}

impl ::protobuf::Clear for CreateBackupRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.backup_id.clear();
        self.backup.clear();
        self.encryption_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateBackupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateBackupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateBackupMetadata {
    // message fields
    pub name: ::std::string::String,
    pub database: ::std::string::String,
    pub progress: ::protobuf::SingularPtrField<super::common::OperationProgress>,
    pub cancel_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateBackupMetadata {
    fn default() -> &'a CreateBackupMetadata {
        <CreateBackupMetadata as ::protobuf::Message>::default_instance()
    }
}

impl CreateBackupMetadata {
    pub fn new() -> CreateBackupMetadata {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string database = 2;


    pub fn get_database(&self) -> &str {
        &self.database
    }
    pub fn clear_database(&mut self) {
        self.database.clear();
    }

    // Param is passed by value, moved
    pub fn set_database(&mut self, v: ::std::string::String) {
        self.database = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_database(&mut self) -> &mut ::std::string::String {
        &mut self.database
    }

    // Take field
    pub fn take_database(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.database, ::std::string::String::new())
    }

    // .google.spanner.admin.database.v1.OperationProgress progress = 3;


    pub fn get_progress(&self) -> &super::common::OperationProgress {
        self.progress.as_ref().unwrap_or_else(|| <super::common::OperationProgress as ::protobuf::Message>::default_instance())
    }
    pub fn clear_progress(&mut self) {
        self.progress.clear();
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: super::common::OperationProgress) {
        self.progress = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_progress(&mut self) -> &mut super::common::OperationProgress {
        if self.progress.is_none() {
            self.progress.set_default();
        }
        self.progress.as_mut().unwrap()
    }

    // Take field
    pub fn take_progress(&mut self) -> super::common::OperationProgress {
        self.progress.take().unwrap_or_else(|| super::common::OperationProgress::new())
    }

    // .google.protobuf.Timestamp cancel_time = 4;


    pub fn get_cancel_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.cancel_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cancel_time(&mut self) {
        self.cancel_time.clear();
    }

    pub fn has_cancel_time(&self) -> bool {
        self.cancel_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cancel_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.cancel_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cancel_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.cancel_time.is_none() {
            self.cancel_time.set_default();
        }
        self.cancel_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_cancel_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.cancel_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for CreateBackupMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.progress {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cancel_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.database)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.progress)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cancel_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.database.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.database);
        }
        if let Some(ref v) = self.progress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cancel_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.database.is_empty() {
            os.write_string(2, &self.database)?;
        }
        if let Some(ref v) = self.progress.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cancel_time.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateBackupMetadata {
        CreateBackupMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CreateBackupMetadata| { &m.name },
                |m: &mut CreateBackupMetadata| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "database",
                |m: &CreateBackupMetadata| { &m.database },
                |m: &mut CreateBackupMetadata| { &mut m.database },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::OperationProgress>>(
                "progress",
                |m: &CreateBackupMetadata| { &m.progress },
                |m: &mut CreateBackupMetadata| { &mut m.progress },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "cancel_time",
                |m: &CreateBackupMetadata| { &m.cancel_time },
                |m: &mut CreateBackupMetadata| { &mut m.cancel_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateBackupMetadata>(
                "CreateBackupMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateBackupMetadata {
        static instance: ::protobuf::rt::LazyV2<CreateBackupMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateBackupMetadata::new)
    }
}

impl ::protobuf::Clear for CreateBackupMetadata {
    fn clear(&mut self) {
        self.name.clear();
        self.database.clear();
        self.progress.clear();
        self.cancel_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateBackupMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateBackupMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateBackupRequest {
    // message fields
    pub backup: ::protobuf::SingularPtrField<Backup>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateBackupRequest {
    fn default() -> &'a UpdateBackupRequest {
        <UpdateBackupRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateBackupRequest {
    pub fn new() -> UpdateBackupRequest {
        ::std::default::Default::default()
    }

    // .google.spanner.admin.database.v1.Backup backup = 1;


    pub fn get_backup(&self) -> &Backup {
        self.backup.as_ref().unwrap_or_else(|| <Backup as ::protobuf::Message>::default_instance())
    }
    pub fn clear_backup(&mut self) {
        self.backup.clear();
    }

    pub fn has_backup(&self) -> bool {
        self.backup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backup(&mut self, v: Backup) {
        self.backup = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backup(&mut self) -> &mut Backup {
        if self.backup.is_none() {
            self.backup.set_default();
        }
        self.backup.as_mut().unwrap()
    }

    // Take field
    pub fn take_backup(&mut self) -> Backup {
        self.backup.take().unwrap_or_else(|| Backup::new())
    }

    // .google.protobuf.FieldMask update_mask = 2;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for UpdateBackupRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.backup {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.backup)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.backup.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.backup.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateBackupRequest {
        UpdateBackupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Backup>>(
                "backup",
                |m: &UpdateBackupRequest| { &m.backup },
                |m: &mut UpdateBackupRequest| { &mut m.backup },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "update_mask",
                |m: &UpdateBackupRequest| { &m.update_mask },
                |m: &mut UpdateBackupRequest| { &mut m.update_mask },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateBackupRequest>(
                "UpdateBackupRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateBackupRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateBackupRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateBackupRequest::new)
    }
}

impl ::protobuf::Clear for UpdateBackupRequest {
    fn clear(&mut self) {
        self.backup.clear();
        self.update_mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateBackupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateBackupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBackupRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBackupRequest {
    fn default() -> &'a GetBackupRequest {
        <GetBackupRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetBackupRequest {
    pub fn new() -> GetBackupRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetBackupRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBackupRequest {
        GetBackupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetBackupRequest| { &m.name },
                |m: &mut GetBackupRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetBackupRequest>(
                "GetBackupRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetBackupRequest {
        static instance: ::protobuf::rt::LazyV2<GetBackupRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetBackupRequest::new)
    }
}

impl ::protobuf::Clear for GetBackupRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBackupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBackupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteBackupRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteBackupRequest {
    fn default() -> &'a DeleteBackupRequest {
        <DeleteBackupRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteBackupRequest {
    pub fn new() -> DeleteBackupRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteBackupRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteBackupRequest {
        DeleteBackupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DeleteBackupRequest| { &m.name },
                |m: &mut DeleteBackupRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteBackupRequest>(
                "DeleteBackupRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteBackupRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteBackupRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteBackupRequest::new)
    }
}

impl ::protobuf::Clear for DeleteBackupRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteBackupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteBackupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListBackupsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub filter: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListBackupsRequest {
    fn default() -> &'a ListBackupsRequest {
        <ListBackupsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListBackupsRequest {
    pub fn new() -> ListBackupsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string filter = 2;


    pub fn get_filter(&self) -> &str {
        &self.filter
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }

    // int32 page_size = 3;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 4;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListBackupsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.filter);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.filter.is_empty() {
            os.write_string(2, &self.filter)?;
        }
        if self.page_size != 0 {
            os.write_int32(3, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(4, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListBackupsRequest {
        ListBackupsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListBackupsRequest| { &m.parent },
                |m: &mut ListBackupsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &ListBackupsRequest| { &m.filter },
                |m: &mut ListBackupsRequest| { &mut m.filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListBackupsRequest| { &m.page_size },
                |m: &mut ListBackupsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListBackupsRequest| { &m.page_token },
                |m: &mut ListBackupsRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListBackupsRequest>(
                "ListBackupsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListBackupsRequest {
        static instance: ::protobuf::rt::LazyV2<ListBackupsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListBackupsRequest::new)
    }
}

impl ::protobuf::Clear for ListBackupsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.filter.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListBackupsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListBackupsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListBackupsResponse {
    // message fields
    pub backups: ::protobuf::RepeatedField<Backup>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListBackupsResponse {
    fn default() -> &'a ListBackupsResponse {
        <ListBackupsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListBackupsResponse {
    pub fn new() -> ListBackupsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.spanner.admin.database.v1.Backup backups = 1;


    pub fn get_backups(&self) -> &[Backup] {
        &self.backups
    }
    pub fn clear_backups(&mut self) {
        self.backups.clear();
    }

    // Param is passed by value, moved
    pub fn set_backups(&mut self, v: ::protobuf::RepeatedField<Backup>) {
        self.backups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_backups(&mut self) -> &mut ::protobuf::RepeatedField<Backup> {
        &mut self.backups
    }

    // Take field
    pub fn take_backups(&mut self) -> ::protobuf::RepeatedField<Backup> {
        ::std::mem::replace(&mut self.backups, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListBackupsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.backups {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.backups)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.backups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.backups {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListBackupsResponse {
        ListBackupsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Backup>>(
                "backups",
                |m: &ListBackupsResponse| { &m.backups },
                |m: &mut ListBackupsResponse| { &mut m.backups },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListBackupsResponse| { &m.next_page_token },
                |m: &mut ListBackupsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListBackupsResponse>(
                "ListBackupsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListBackupsResponse {
        static instance: ::protobuf::rt::LazyV2<ListBackupsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListBackupsResponse::new)
    }
}

impl ::protobuf::Clear for ListBackupsResponse {
    fn clear(&mut self) {
        self.backups.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListBackupsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListBackupsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListBackupOperationsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub filter: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListBackupOperationsRequest {
    fn default() -> &'a ListBackupOperationsRequest {
        <ListBackupOperationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListBackupOperationsRequest {
    pub fn new() -> ListBackupOperationsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string filter = 2;


    pub fn get_filter(&self) -> &str {
        &self.filter
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }

    // int32 page_size = 3;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 4;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListBackupOperationsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.filter);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.filter.is_empty() {
            os.write_string(2, &self.filter)?;
        }
        if self.page_size != 0 {
            os.write_int32(3, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(4, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListBackupOperationsRequest {
        ListBackupOperationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListBackupOperationsRequest| { &m.parent },
                |m: &mut ListBackupOperationsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &ListBackupOperationsRequest| { &m.filter },
                |m: &mut ListBackupOperationsRequest| { &mut m.filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListBackupOperationsRequest| { &m.page_size },
                |m: &mut ListBackupOperationsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListBackupOperationsRequest| { &m.page_token },
                |m: &mut ListBackupOperationsRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListBackupOperationsRequest>(
                "ListBackupOperationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListBackupOperationsRequest {
        static instance: ::protobuf::rt::LazyV2<ListBackupOperationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListBackupOperationsRequest::new)
    }
}

impl ::protobuf::Clear for ListBackupOperationsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.filter.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListBackupOperationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListBackupOperationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListBackupOperationsResponse {
    // message fields
    pub operations: ::protobuf::RepeatedField<super::operations::Operation>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListBackupOperationsResponse {
    fn default() -> &'a ListBackupOperationsResponse {
        <ListBackupOperationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListBackupOperationsResponse {
    pub fn new() -> ListBackupOperationsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.longrunning.Operation operations = 1;


    pub fn get_operations(&self) -> &[super::operations::Operation] {
        &self.operations
    }
    pub fn clear_operations(&mut self) {
        self.operations.clear();
    }

    // Param is passed by value, moved
    pub fn set_operations(&mut self, v: ::protobuf::RepeatedField<super::operations::Operation>) {
        self.operations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_operations(&mut self) -> &mut ::protobuf::RepeatedField<super::operations::Operation> {
        &mut self.operations
    }

    // Take field
    pub fn take_operations(&mut self) -> ::protobuf::RepeatedField<super::operations::Operation> {
        ::std::mem::replace(&mut self.operations, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListBackupOperationsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.operations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.operations)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.operations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.operations {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListBackupOperationsResponse {
        ListBackupOperationsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::operations::Operation>>(
                "operations",
                |m: &ListBackupOperationsResponse| { &m.operations },
                |m: &mut ListBackupOperationsResponse| { &mut m.operations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListBackupOperationsResponse| { &m.next_page_token },
                |m: &mut ListBackupOperationsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListBackupOperationsResponse>(
                "ListBackupOperationsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListBackupOperationsResponse {
        static instance: ::protobuf::rt::LazyV2<ListBackupOperationsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListBackupOperationsResponse::new)
    }
}

impl ::protobuf::Clear for ListBackupOperationsResponse {
    fn clear(&mut self) {
        self.operations.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListBackupOperationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListBackupOperationsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BackupInfo {
    // message fields
    pub backup: ::std::string::String,
    pub version_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub source_database: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BackupInfo {
    fn default() -> &'a BackupInfo {
        <BackupInfo as ::protobuf::Message>::default_instance()
    }
}

impl BackupInfo {
    pub fn new() -> BackupInfo {
        ::std::default::Default::default()
    }

    // string backup = 1;


    pub fn get_backup(&self) -> &str {
        &self.backup
    }
    pub fn clear_backup(&mut self) {
        self.backup.clear();
    }

    // Param is passed by value, moved
    pub fn set_backup(&mut self, v: ::std::string::String) {
        self.backup = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backup(&mut self) -> &mut ::std::string::String {
        &mut self.backup
    }

    // Take field
    pub fn take_backup(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.backup, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp version_time = 4;


    pub fn get_version_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.version_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_version_time(&mut self) {
        self.version_time.clear();
    }

    pub fn has_version_time(&self) -> bool {
        self.version_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.version_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.version_time.is_none() {
            self.version_time.set_default();
        }
        self.version_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_version_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.version_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp create_time = 2;


    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string source_database = 3;


    pub fn get_source_database(&self) -> &str {
        &self.source_database
    }
    pub fn clear_source_database(&mut self) {
        self.source_database.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_database(&mut self, v: ::std::string::String) {
        self.source_database = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_database(&mut self) -> &mut ::std::string::String {
        &mut self.source_database
    }

    // Take field
    pub fn take_source_database(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_database, ::std::string::String::new())
    }
}

impl ::protobuf::Message for BackupInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.version_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.backup)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.version_time)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source_database)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.backup.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.backup);
        }
        if let Some(ref v) = self.version_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.source_database.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.source_database);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.backup.is_empty() {
            os.write_string(1, &self.backup)?;
        }
        if let Some(ref v) = self.version_time.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.source_database.is_empty() {
            os.write_string(3, &self.source_database)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BackupInfo {
        BackupInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "backup",
                |m: &BackupInfo| { &m.backup },
                |m: &mut BackupInfo| { &mut m.backup },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "version_time",
                |m: &BackupInfo| { &m.version_time },
                |m: &mut BackupInfo| { &mut m.version_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "create_time",
                |m: &BackupInfo| { &m.create_time },
                |m: &mut BackupInfo| { &mut m.create_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "source_database",
                |m: &BackupInfo| { &m.source_database },
                |m: &mut BackupInfo| { &mut m.source_database },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BackupInfo>(
                "BackupInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BackupInfo {
        static instance: ::protobuf::rt::LazyV2<BackupInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BackupInfo::new)
    }
}

impl ::protobuf::Clear for BackupInfo {
    fn clear(&mut self) {
        self.backup.clear();
        self.version_time.clear();
        self.create_time.clear();
        self.source_database.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BackupInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BackupInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateBackupEncryptionConfig {
    // message fields
    pub encryption_type: CreateBackupEncryptionConfig_EncryptionType,
    pub kms_key_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateBackupEncryptionConfig {
    fn default() -> &'a CreateBackupEncryptionConfig {
        <CreateBackupEncryptionConfig as ::protobuf::Message>::default_instance()
    }
}

impl CreateBackupEncryptionConfig {
    pub fn new() -> CreateBackupEncryptionConfig {
        ::std::default::Default::default()
    }

    // .google.spanner.admin.database.v1.CreateBackupEncryptionConfig.EncryptionType encryption_type = 1;


    pub fn get_encryption_type(&self) -> CreateBackupEncryptionConfig_EncryptionType {
        self.encryption_type
    }
    pub fn clear_encryption_type(&mut self) {
        self.encryption_type = CreateBackupEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_encryption_type(&mut self, v: CreateBackupEncryptionConfig_EncryptionType) {
        self.encryption_type = v;
    }

    // string kms_key_name = 2;


    pub fn get_kms_key_name(&self) -> &str {
        &self.kms_key_name
    }
    pub fn clear_kms_key_name(&mut self) {
        self.kms_key_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_kms_key_name(&mut self, v: ::std::string::String) {
        self.kms_key_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kms_key_name(&mut self) -> &mut ::std::string::String {
        &mut self.kms_key_name
    }

    // Take field
    pub fn take_kms_key_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kms_key_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateBackupEncryptionConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.encryption_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kms_key_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.encryption_type != CreateBackupEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.encryption_type);
        }
        if !self.kms_key_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.kms_key_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.encryption_type != CreateBackupEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.encryption_type))?;
        }
        if !self.kms_key_name.is_empty() {
            os.write_string(2, &self.kms_key_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateBackupEncryptionConfig {
        CreateBackupEncryptionConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CreateBackupEncryptionConfig_EncryptionType>>(
                "encryption_type",
                |m: &CreateBackupEncryptionConfig| { &m.encryption_type },
                |m: &mut CreateBackupEncryptionConfig| { &mut m.encryption_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kms_key_name",
                |m: &CreateBackupEncryptionConfig| { &m.kms_key_name },
                |m: &mut CreateBackupEncryptionConfig| { &mut m.kms_key_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateBackupEncryptionConfig>(
                "CreateBackupEncryptionConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateBackupEncryptionConfig {
        static instance: ::protobuf::rt::LazyV2<CreateBackupEncryptionConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateBackupEncryptionConfig::new)
    }
}

impl ::protobuf::Clear for CreateBackupEncryptionConfig {
    fn clear(&mut self) {
        self.encryption_type = CreateBackupEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED;
        self.kms_key_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateBackupEncryptionConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateBackupEncryptionConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CreateBackupEncryptionConfig_EncryptionType {
    ENCRYPTION_TYPE_UNSPECIFIED = 0,
    USE_DATABASE_ENCRYPTION = 1,
    GOOGLE_DEFAULT_ENCRYPTION = 2,
    CUSTOMER_MANAGED_ENCRYPTION = 3,
}

impl ::protobuf::ProtobufEnum for CreateBackupEncryptionConfig_EncryptionType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CreateBackupEncryptionConfig_EncryptionType> {
        match value {
            0 => ::std::option::Option::Some(CreateBackupEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(CreateBackupEncryptionConfig_EncryptionType::USE_DATABASE_ENCRYPTION),
            2 => ::std::option::Option::Some(CreateBackupEncryptionConfig_EncryptionType::GOOGLE_DEFAULT_ENCRYPTION),
            3 => ::std::option::Option::Some(CreateBackupEncryptionConfig_EncryptionType::CUSTOMER_MANAGED_ENCRYPTION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CreateBackupEncryptionConfig_EncryptionType] = &[
            CreateBackupEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED,
            CreateBackupEncryptionConfig_EncryptionType::USE_DATABASE_ENCRYPTION,
            CreateBackupEncryptionConfig_EncryptionType::GOOGLE_DEFAULT_ENCRYPTION,
            CreateBackupEncryptionConfig_EncryptionType::CUSTOMER_MANAGED_ENCRYPTION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CreateBackupEncryptionConfig_EncryptionType>("CreateBackupEncryptionConfig.EncryptionType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CreateBackupEncryptionConfig_EncryptionType {
}

impl ::std::default::Default for CreateBackupEncryptionConfig_EncryptionType {
    fn default() -> Self {
        CreateBackupEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateBackupEncryptionConfig_EncryptionType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n-google/spanner/admin/database/v1/backup.proto\x12\x20google.spanner.a\
    dmin.database.v1\x1a\x1fgoogle/api/field_behavior.proto\x1a\x19google/ap\
    i/resource.proto\x1a#google/longrunning/operations.proto\x1a\x20google/p\
    rotobuf/field_mask.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a-goog\
    le/spanner/admin/database/v1/common.proto\"\xe0\x05\n\x06Backup\x12@\n\
    \x08database\x18\x02\x20\x01(\tR\x08databaseB$\xfaA!\n\x1fspanner.google\
    apis.com/Database\x12=\n\x0cversion_time\x18\t\x20\x01(\x0b2\x1a.google.\
    protobuf.TimestampR\x0bversionTime\x12;\n\x0bexpire_time\x18\x03\x20\x01\
    (\x0b2\x1a.google.protobuf.TimestampR\nexpireTime\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12@\n\x0bcreate_time\x18\x04\x20\x01(\x0b2\x1a\
    .google.protobuf.TimestampR\ncreateTimeB\x03\xe0A\x03\x12\"\n\nsize_byte\
    s\x18\x05\x20\x01(\x03R\tsizeBytesB\x03\xe0A\x03\x12I\n\x05state\x18\x06\
    \x20\x01(\x0e2..google.spanner.admin.database.v1.Backup.StateR\x05stateB\
    \x03\xe0A\x03\x12\\\n\x15referencing_databases\x18\x07\x20\x03(\tR\x14re\
    ferencingDatabasesB'\xfaA!\n\x1fspanner.googleapis.com/Database\xe0A\x03\
    \x12^\n\x0fencryption_info\x18\x08\x20\x01(\x0b20.google.spanner.admin.d\
    atabase.v1.EncryptionInfoR\x0eencryptionInfoB\x03\xe0A\x03\"7\n\x05State\
    \x12\x15\n\x11STATE_UNSPECIFIED\x10\0\x12\x0c\n\x08CREATING\x10\x01\x12\
    \t\n\x05READY\x10\x02:\\\xeaAY\n\x1dspanner.googleapis.com/Backup\x128pr\
    ojects/{project}/instances/{instance}/backups/{backup}\"\xb1\x02\n\x13Cr\
    eateBackupRequest\x12?\n\x06parent\x18\x01\x20\x01(\tR\x06parentB'\xe0A\
    \x02\xfaA!\n\x1fspanner.googleapis.com/Instance\x12\x20\n\tbackup_id\x18\
    \x02\x20\x01(\tR\x08backupIdB\x03\xe0A\x02\x12E\n\x06backup\x18\x03\x20\
    \x01(\x0b2(.google.spanner.admin.database.v1.BackupR\x06backupB\x03\xe0A\
    \x02\x12p\n\x11encryption_config\x18\x04\x20\x01(\x0b2>.google.spanner.a\
    dmin.database.v1.CreateBackupEncryptionConfigR\x10encryptionConfigB\x03\
    \xe0A\x01\"\x9e\x02\n\x14CreateBackupMetadata\x126\n\x04name\x18\x01\x20\
    \x01(\tR\x04nameB\"\xfaA\x1f\n\x1dspanner.googleapis.com/Backup\x12@\n\
    \x08database\x18\x02\x20\x01(\tR\x08databaseB$\xfaA!\n\x1fspanner.google\
    apis.com/Database\x12O\n\x08progress\x18\x03\x20\x01(\x0b23.google.spann\
    er.admin.database.v1.OperationProgressR\x08progress\x12;\n\x0bcancel_tim\
    e\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\ncancelTime\"\x9e\
    \x01\n\x13UpdateBackupRequest\x12E\n\x06backup\x18\x01\x20\x01(\x0b2(.go\
    ogle.spanner.admin.database.v1.BackupR\x06backupB\x03\xe0A\x02\x12@\n\
    \x0bupdate_mask\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.FieldMaskR\nup\
    dateMaskB\x03\xe0A\x02\"M\n\x10GetBackupRequest\x129\n\x04name\x18\x01\
    \x20\x01(\tR\x04nameB%\xe0A\x02\xfaA\x1f\n\x1dspanner.googleapis.com/Bac\
    kup\"P\n\x13DeleteBackupRequest\x129\n\x04name\x18\x01\x20\x01(\tR\x04na\
    meB%\xfaA\x1f\n\x1dspanner.googleapis.com/Backup\xe0A\x02\"\xa9\x01\n\
    \x12ListBackupsRequest\x12?\n\x06parent\x18\x01\x20\x01(\tR\x06parentB'\
    \xe0A\x02\xfaA!\n\x1fspanner.googleapis.com/Instance\x12\x16\n\x06filter\
    \x18\x02\x20\x01(\tR\x06filter\x12\x1b\n\tpage_size\x18\x03\x20\x01(\x05\
    R\x08pageSize\x12\x1d\n\npage_token\x18\x04\x20\x01(\tR\tpageToken\"\x81\
    \x01\n\x13ListBackupsResponse\x12B\n\x07backups\x18\x01\x20\x03(\x0b2(.g\
    oogle.spanner.admin.database.v1.BackupR\x07backups\x12&\n\x0fnext_page_t\
    oken\x18\x02\x20\x01(\tR\rnextPageToken\"\xb2\x01\n\x1bListBackupOperati\
    onsRequest\x12?\n\x06parent\x18\x01\x20\x01(\tR\x06parentB'\xfaA!\n\x1fs\
    panner.googleapis.com/Instance\xe0A\x02\x12\x16\n\x06filter\x18\x02\x20\
    \x01(\tR\x06filter\x12\x1b\n\tpage_size\x18\x03\x20\x01(\x05R\x08pageSiz\
    e\x12\x1d\n\npage_token\x18\x04\x20\x01(\tR\tpageToken\"\x85\x01\n\x1cLi\
    stBackupOperationsResponse\x12=\n\noperations\x18\x01\x20\x03(\x0b2\x1d.\
    google.longrunning.OperationR\noperations\x12&\n\x0fnext_page_token\x18\
    \x02\x20\x01(\tR\rnextPageToken\"\x93\x02\n\nBackupInfo\x12:\n\x06backup\
    \x18\x01\x20\x01(\tR\x06backupB\"\xfaA\x1f\n\x1dspanner.googleapis.com/B\
    ackup\x12=\n\x0cversion_time\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.T\
    imestampR\x0bversionTime\x12;\n\x0bcreate_time\x18\x02\x20\x01(\x0b2\x1a\
    .google.protobuf.TimestampR\ncreateTime\x12M\n\x0fsource_database\x18\
    \x03\x20\x01(\tR\x0esourceDatabaseB$\xfaA!\n\x1fspanner.googleapis.com/D\
    atabase\"\xf9\x02\n\x1cCreateBackupEncryptionConfig\x12{\n\x0fencryption\
    _type\x18\x01\x20\x01(\x0e2M.google.spanner.admin.database.v1.CreateBack\
    upEncryptionConfig.EncryptionTypeR\x0eencryptionTypeB\x03\xe0A\x02\x12K\
    \n\x0ckms_key_name\x18\x02\x20\x01(\tR\nkmsKeyNameB)\xfaA#\n!cloudkms.go\
    ogleapis.com/CryptoKey\xe0A\x01\"\x8e\x01\n\x0eEncryptionType\x12\x1f\n\
    \x1bENCRYPTION_TYPE_UNSPECIFIED\x10\0\x12\x1b\n\x17USE_DATABASE_ENCRYPTI\
    ON\x10\x01\x12\x1d\n\x19GOOGLE_DEFAULT_ENCRYPTION\x10\x02\x12\x1f\n\x1bC\
    USTOMER_MANAGED_ENCRYPTION\x10\x03B\xff\x01\n$com.google.spanner.admin.d\
    atabase.v1B\x0bBackupProtoP\x01ZHgoogle.golang.org/genproto/googleapis/s\
    panner/admin/database/v1;database\xaa\x02&Google.Cloud.Spanner.Admin.Dat\
    abase.V1\xca\x02&Google\\Cloud\\Spanner\\Admin\\Database\\V1\xea\x02+Goo\
    gle::Cloud::Spanner::Admin::Database::V1J\xf2\x94\x01\n\x07\x12\x05\x0e\
    \0\xcc\x03\x01\n\xbc\x04\n\x01\x0c\x12\x03\x0e\0\x122\xb1\x04\x20Copyrig\
    ht\x202021\x20Google\x20LLC\n\n\x20Licensed\x20under\x20the\x20Apache\
    \x20License,\x20Version\x202.0\x20(the\x20\"License\");\n\x20you\x20may\
    \x20not\x20use\x20this\x20file\x20except\x20in\x20compliance\x20with\x20\
    the\x20License.\n\x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20L\
    icense\x20at\n\n\x20\x20\x20\x20\x20http://www.apache.org/licenses/LICEN\
    SE-2.0\n\n\x20Unless\x20required\x20by\x20applicable\x20law\x20or\x20agr\
    eed\x20to\x20in\x20writing,\x20software\n\x20distributed\x20under\x20the\
    \x20License\x20is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\
    \x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20e\
    ither\x20express\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20\
    the\x20specific\x20language\x20governing\x20permissions\x20and\n\x20limi\
    tations\x20under\x20the\x20License.\n\n\x08\n\x01\x02\x12\x03\x10\0)\n\t\
    \n\x02\x03\0\x12\x03\x12\0)\n\t\n\x02\x03\x01\x12\x03\x13\0#\n\t\n\x02\
    \x03\x02\x12\x03\x14\0-\n\t\n\x02\x03\x03\x12\x03\x15\0*\n\t\n\x02\x03\
    \x04\x12\x03\x16\0)\n\t\n\x02\x03\x05\x12\x03\x17\07\n\x08\n\x01\x08\x12\
    \x03\x19\0C\n\t\n\x02\x08%\x12\x03\x19\0C\n\x08\n\x01\x08\x12\x03\x1a\0_\
    \n\t\n\x02\x08\x0b\x12\x03\x1a\0_\n\x08\n\x01\x08\x12\x03\x1b\0\"\n\t\n\
    \x02\x08\n\x12\x03\x1b\0\"\n\x08\n\x01\x08\x12\x03\x1c\0,\n\t\n\x02\x08\
    \x08\x12\x03\x1c\0,\n\x08\n\x01\x08\x12\x03\x1d\0=\n\t\n\x02\x08\x01\x12\
    \x03\x1d\0=\n\x08\n\x01\x08\x12\x03\x1e\0E\n\t\n\x02\x08)\x12\x03\x1e\0E\
    \n\x08\n\x01\x08\x12\x03\x1f\0D\n\t\n\x02\x08-\x12\x03\x1f\0D\n3\n\x02\
    \x04\0\x12\x04\"\0}\x01\x1a'\x20A\x20backup\x20of\x20a\x20Cloud\x20Spann\
    er\x20database.\n\n\n\n\x03\x04\0\x01\x12\x03\"\x08\x0e\n\x0b\n\x03\x04\
    \0\x07\x12\x04#\x02&\x04\n\r\n\x05\x04\0\x07\x9d\x08\x12\x04#\x02&\x04\n\
    :\n\x04\x04\0\x04\0\x12\x04)\x023\x03\x1a,\x20Indicates\x20the\x20curren\
    t\x20state\x20of\x20the\x20backup.\n\n\x0c\n\x05\x04\0\x04\0\x01\x12\x03\
    )\x07\x0c\n\x1f\n\x06\x04\0\x04\0\x02\0\x12\x03+\x04\x1a\x1a\x10\x20Not\
    \x20specified.\n\n\x0e\n\x07\x04\0\x04\0\x02\0\x01\x12\x03+\x04\x15\n\
    \x0e\n\x07\x04\0\x04\0\x02\0\x02\x12\x03+\x18\x19\n\x88\x01\n\x06\x04\0\
    \x04\0\x02\x01\x12\x03/\x04\x11\x1ay\x20The\x20pending\x20backup\x20is\
    \x20still\x20being\x20created.\x20Operations\x20on\x20the\n\x20backup\
    \x20may\x20fail\x20with\x20`FAILED_PRECONDITION`\x20in\x20this\x20state.\
    \n\n\x0e\n\x07\x04\0\x04\0\x02\x01\x01\x12\x03/\x04\x0c\n\x0e\n\x07\x04\
    \0\x04\0\x02\x01\x02\x12\x03/\x0f\x10\n:\n\x06\x04\0\x04\0\x02\x02\x12\
    \x032\x04\x0e\x1a+\x20The\x20backup\x20is\x20complete\x20and\x20ready\
    \x20for\x20use.\n\n\x0e\n\x07\x04\0\x04\0\x02\x02\x01\x12\x032\x04\t\n\
    \x0e\n\x07\x04\0\x04\0\x02\x02\x02\x12\x032\x0c\r\n\xc1\x02\n\x04\x04\0\
    \x02\0\x12\x04:\x02<\x05\x1a\xb2\x02\x20Required\x20for\x20the\n\x20[Cre\
    ateBackup][google.spanner.admin.database.v1.DatabaseAdmin.CreateBackup]\
    \n\x20operation.\x20Name\x20of\x20the\x20database\x20from\x20which\x20th\
    is\x20backup\x20was\x20created.\x20This\n\x20needs\x20to\x20be\x20in\x20\
    the\x20same\x20instance\x20as\x20the\x20backup.\x20Values\x20are\x20of\
    \x20the\x20form\n\x20`projects/<project>/instances/<instance>/databases/\
    <database>`.\n\n\r\n\x05\x04\0\x02\0\x04\x12\x04:\x023\x03\n\x0c\n\x05\
    \x04\0\x02\0\x05\x12\x03:\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03:\t\
    \x11\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03:\x14\x15\n\r\n\x05\x04\0\x02\0\
    \x08\x12\x04:\x16<\x04\n\x0f\n\x07\x04\0\x02\0\x08\x9f\x08\x12\x04:\x17<\
    \x03\n\xf1\x01\n\x04\x04\0\x02\x01\x12\x03B\x02-\x1a\xe3\x01\x20The\x20b\
    ackup\x20will\x20contain\x20an\x20externally\x20consistent\x20copy\x20of\
    \x20the\x20database\x20at\n\x20the\x20timestamp\x20specified\x20by\x20`v\
    ersion_time`.\x20If\x20`version_time`\x20is\x20not\n\x20specified,\x20th\
    e\x20system\x20will\x20set\x20`version_time`\x20to\x20the\x20`create_tim\
    e`\x20of\x20the\n\x20backup.\n\n\r\n\x05\x04\0\x02\x01\x04\x12\x04B\x02<\
    \x05\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x03B\x02\x1b\n\x0c\n\x05\x04\0\
    \x02\x01\x01\x12\x03B\x1c(\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03B+,\n\
    \xb7\x03\n\x04\x04\0\x02\x02\x12\x03K\x02,\x1a\xa9\x03\x20Required\x20fo\
    r\x20the\n\x20[CreateBackup][google.spanner.admin.database.v1.DatabaseAd\
    min.CreateBackup]\n\x20operation.\x20The\x20expiration\x20time\x20of\x20\
    the\x20backup,\x20with\x20microseconds\n\x20granularity\x20that\x20must\
    \x20be\x20at\x20least\x206\x20hours\x20and\x20at\x20most\x20366\x20days\
    \n\x20from\x20the\x20time\x20the\x20CreateBackup\x20request\x20is\x20pro\
    cessed.\x20Once\x20the\x20`expire_time`\n\x20has\x20passed,\x20the\x20ba\
    ckup\x20is\x20eligible\x20to\x20be\x20automatically\x20deleted\x20by\x20\
    Cloud\n\x20Spanner\x20to\x20free\x20the\x20resources\x20used\x20by\x20th\
    e\x20backup.\n\n\r\n\x05\x04\0\x02\x02\x04\x12\x04K\x02B-\n\x0c\n\x05\
    \x04\0\x02\x02\x06\x12\x03K\x02\x1b\n\x0c\n\x05\x04\0\x02\x02\x01\x12\
    \x03K\x1c'\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03K*+\n\xc0\x05\n\x04\x04\
    \0\x02\x03\x12\x03]\x02\x12\x1a\xb2\x05\x20Output\x20only\x20for\x20the\
    \n\x20[CreateBackup][google.spanner.admin.database.v1.DatabaseAdmin.Crea\
    teBackup]\n\x20operation.\x20Required\x20for\x20the\n\x20[UpdateBackup][\
    google.spanner.admin.database.v1.DatabaseAdmin.UpdateBackup]\n\x20operat\
    ion.\n\n\x20A\x20globally\x20unique\x20identifier\x20for\x20the\x20backu\
    p\x20which\x20cannot\x20be\n\x20changed.\x20Values\x20are\x20of\x20the\
    \x20form\n\x20`projects/<project>/instances/<instance>/backups/[a-z][a-z\
    0-9_\\-]*[a-z0-9]`\n\x20The\x20final\x20segment\x20of\x20the\x20name\x20\
    must\x20be\x20between\x202\x20and\x2060\x20characters\n\x20in\x20length.\
    \n\n\x20The\x20backup\x20is\x20stored\x20in\x20the\x20location(s)\x20spe\
    cified\x20in\x20the\x20instance\n\x20configuration\x20of\x20the\x20insta\
    nce\x20containing\x20the\x20backup,\x20identified\n\x20by\x20the\x20pref\
    ix\x20of\x20the\x20backup\x20name\x20of\x20the\x20form\n\x20`projects/<p\
    roject>/instances/<instance>`.\n\n\r\n\x05\x04\0\x02\x03\x04\x12\x04]\
    \x02K,\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03]\x02\x08\n\x0c\n\x05\x04\0\
    \x02\x03\x01\x12\x03]\t\r\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03]\x10\x11\
    \n\x88\x02\n\x04\x04\0\x02\x04\x12\x04c\x02d2\x1a\xf9\x01\x20Output\x20o\
    nly.\x20The\x20time\x20the\n\x20[CreateBackup][google.spanner.admin.data\
    base.v1.DatabaseAdmin.CreateBackup]\n\x20request\x20is\x20received.\x20I\
    f\x20the\x20request\x20does\x20not\x20specify\x20`version_time`,\x20the\
    \n\x20`version_time`\x20of\x20the\x20backup\x20will\x20be\x20equivalent\
    \x20to\x20the\x20`create_time`.\n\n\r\n\x05\x04\0\x02\x04\x04\x12\x04c\
    \x02]\x12\n\x0c\n\x05\x04\0\x02\x04\x06\x12\x03c\x02\x1b\n\x0c\n\x05\x04\
    \0\x02\x04\x01\x12\x03c\x1c'\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03c*+\n\
    \x0c\n\x05\x04\0\x02\x04\x08\x12\x03d\x061\n\x0f\n\x08\x04\0\x02\x04\x08\
    \x9c\x08\0\x12\x03d\x070\n8\n\x04\x04\0\x02\x05\x12\x03g\x02C\x1a+\x20Ou\
    tput\x20only.\x20Size\x20of\x20the\x20backup\x20in\x20bytes.\n\n\r\n\x05\
    \x04\0\x02\x05\x04\x12\x04g\x02d2\n\x0c\n\x05\x04\0\x02\x05\x05\x12\x03g\
    \x02\x07\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03g\x08\x12\n\x0c\n\x05\x04\
    \0\x02\x05\x03\x12\x03g\x15\x16\n\x0c\n\x05\x04\0\x02\x05\x08\x12\x03g\
    \x17B\n\x0f\n\x08\x04\0\x02\x05\x08\x9c\x08\0\x12\x03g\x18A\n<\n\x04\x04\
    \0\x02\x06\x12\x03j\x02>\x1a/\x20Output\x20only.\x20The\x20current\x20st\
    ate\x20of\x20the\x20backup.\n\n\r\n\x05\x04\0\x02\x06\x04\x12\x04j\x02gC\
    \n\x0c\n\x05\x04\0\x02\x06\x06\x12\x03j\x02\x07\n\x0c\n\x05\x04\0\x02\
    \x06\x01\x12\x03j\x08\r\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03j\x10\x11\n\
    \x0c\n\x05\x04\0\x02\x06\x08\x12\x03j\x12=\n\x0f\n\x08\x04\0\x02\x06\x08\
    \x9c\x08\0\x12\x03j\x13<\n\xba\x03\n\x04\x04\0\x02\x07\x12\x04s\x02x\x04\
    \x1a\xab\x03\x20Output\x20only.\x20The\x20names\x20of\x20the\x20restored\
    \x20databases\x20that\x20reference\x20the\x20backup.\n\x20The\x20databas\
    e\x20names\x20are\x20of\n\x20the\x20form\x20`projects/<project>/instance\
    s/<instance>/databases/<database>`.\n\x20Referencing\x20databases\x20may\
    \x20exist\x20in\x20different\x20instances.\x20The\x20existence\x20of\n\
    \x20any\x20referencing\x20database\x20prevents\x20the\x20backup\x20from\
    \x20being\x20deleted.\x20When\x20a\n\x20restored\x20database\x20from\x20\
    the\x20backup\x20enters\x20the\x20`READY`\x20state,\x20the\x20reference\
    \n\x20to\x20the\x20backup\x20is\x20removed.\n\n\x0c\n\x05\x04\0\x02\x07\
    \x04\x12\x03s\x02\n\n\x0c\n\x05\x04\0\x02\x07\x05\x12\x03s\x0b\x11\n\x0c\
    \n\x05\x04\0\x02\x07\x01\x12\x03s\x12'\n\x0c\n\x05\x04\0\x02\x07\x03\x12\
    \x03s*+\n\r\n\x05\x04\0\x02\x07\x08\x12\x04s,x\x03\n\x0f\n\x08\x04\0\x02\
    \x07\x08\x9c\x08\0\x12\x03t\x04-\n\x0f\n\x07\x04\0\x02\x07\x08\x9f\x08\
    \x12\x04u\x04w\x05\nG\n\x04\x04\0\x02\x08\x12\x04{\x02|2\x1a9\x20Output\
    \x20only.\x20The\x20encryption\x20information\x20for\x20the\x20backup.\n\
    \n\r\n\x05\x04\0\x02\x08\x04\x12\x04{\x02x\x04\n\x0c\n\x05\x04\0\x02\x08\
    \x06\x12\x03{\x02\x10\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03{\x11\x20\n\
    \x0c\n\x05\x04\0\x02\x08\x03\x12\x03{#$\n\x0c\n\x05\x04\0\x02\x08\x08\
    \x12\x03|\x061\n\x0f\n\x08\x04\0\x02\x08\x08\x9c\x08\0\x12\x03|\x070\nm\
    \n\x02\x04\x01\x12\x06\x81\x01\0\x9e\x01\x01\x1a_\x20The\x20request\x20f\
    or\n\x20[CreateBackup][google.spanner.admin.database.v1.DatabaseAdmin.Cr\
    eateBackup].\n\n\x0b\n\x03\x04\x01\x01\x12\x04\x81\x01\x08\x1b\n\xe3\x02\
    \n\x04\x04\x01\x02\0\x12\x06\x88\x01\x02\x8d\x01\x04\x1a\xd2\x02\x20Requ\
    ired.\x20The\x20name\x20of\x20the\x20instance\x20in\x20which\x20the\x20b\
    ackup\x20will\x20be\n\x20created.\x20This\x20must\x20be\x20the\x20same\
    \x20instance\x20that\x20contains\x20the\x20database\x20the\n\x20backup\
    \x20will\x20be\x20created\x20from.\x20The\x20backup\x20will\x20be\x20sto\
    red\x20in\x20the\n\x20location(s)\x20specified\x20in\x20the\x20instance\
    \x20configuration\x20of\x20this\n\x20instance.\x20Values\x20are\x20of\
    \x20the\x20form\n\x20`projects/<project>/instances/<instance>`.\n\n\x0f\
    \n\x05\x04\x01\x02\0\x04\x12\x06\x88\x01\x02\x81\x01\x1d\n\r\n\x05\x04\
    \x01\x02\0\x05\x12\x04\x88\x01\x02\x08\n\r\n\x05\x04\x01\x02\0\x01\x12\
    \x04\x88\x01\t\x0f\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\x88\x01\x12\x13\n\
    \x0f\n\x05\x04\x01\x02\0\x08\x12\x06\x88\x01\x14\x8d\x01\x03\n\x10\n\x08\
    \x04\x01\x02\0\x08\x9c\x08\0\x12\x04\x89\x01\x04*\n\x11\n\x07\x04\x01\
    \x02\0\x08\x9f\x08\x12\x06\x8a\x01\x04\x8c\x01\x05\n\xcb\x01\n\x04\x04\
    \x01\x02\x01\x12\x04\x92\x01\x02@\x1a\xbc\x01\x20Required.\x20The\x20id\
    \x20of\x20the\x20backup\x20to\x20be\x20created.\x20The\x20`backup_id`\
    \x20appended\x20to\n\x20`parent`\x20forms\x20the\x20full\x20backup\x20na\
    me\x20of\x20the\x20form\n\x20`projects/<project>/instances/<instance>/ba\
    ckups/<backup_id>`.\n\n\x0f\n\x05\x04\x01\x02\x01\x04\x12\x06\x92\x01\
    \x02\x8d\x01\x04\n\r\n\x05\x04\x01\x02\x01\x05\x12\x04\x92\x01\x02\x08\n\
    \r\n\x05\x04\x01\x02\x01\x01\x12\x04\x92\x01\t\x12\n\r\n\x05\x04\x01\x02\
    \x01\x03\x12\x04\x92\x01\x15\x16\n\r\n\x05\x04\x01\x02\x01\x08\x12\x04\
    \x92\x01\x17?\n\x10\n\x08\x04\x01\x02\x01\x08\x9c\x08\0\x12\x04\x92\x01\
    \x18>\n/\n\x04\x04\x01\x02\x02\x12\x04\x95\x01\x02=\x1a!\x20Required.\
    \x20The\x20backup\x20to\x20create.\n\n\x0f\n\x05\x04\x01\x02\x02\x04\x12\
    \x06\x95\x01\x02\x92\x01@\n\r\n\x05\x04\x01\x02\x02\x06\x12\x04\x95\x01\
    \x02\x08\n\r\n\x05\x04\x01\x02\x02\x01\x12\x04\x95\x01\t\x0f\n\r\n\x05\
    \x04\x01\x02\x02\x03\x12\x04\x95\x01\x12\x13\n\r\n\x05\x04\x01\x02\x02\
    \x08\x12\x04\x95\x01\x14<\n\x10\n\x08\x04\x01\x02\x02\x08\x9c\x08\0\x12\
    \x04\x95\x01\x15;\n\xd0\x02\n\x04\x04\x01\x02\x03\x12\x06\x9c\x01\x02\
    \x9d\x01/\x1a\xbf\x02\x20Optional.\x20The\x20encryption\x20configuration\
    \x20used\x20to\x20encrypt\x20the\x20backup.\x20If\x20this\n\x20field\x20\
    is\x20not\x20specified,\x20the\x20backup\x20will\x20use\x20the\x20same\
    \x20encryption\n\x20configuration\x20as\x20the\x20database\x20by\x20defa\
    ult,\x20namely\n\x20[encryption_type][google.spanner.admin.database.v1.C\
    reateBackupEncryptionConfig.encryption_type]\n\x20=\x20`USE_DATABASE_ENC\
    RYPTION`.\n\n\x0f\n\x05\x04\x01\x02\x03\x04\x12\x06\x9c\x01\x02\x95\x01=\
    \n\r\n\x05\x04\x01\x02\x03\x06\x12\x04\x9c\x01\x02\x1e\n\r\n\x05\x04\x01\
    \x02\x03\x01\x12\x04\x9c\x01\x1f0\n\r\n\x05\x04\x01\x02\x03\x03\x12\x04\
    \x9c\x0134\n\r\n\x05\x04\x01\x02\x03\x08\x12\x04\x9d\x01\x06.\n\x10\n\
    \x08\x04\x01\x02\x03\x08\x9c\x08\0\x12\x04\x9d\x01\x07-\n\x89\x01\n\x02\
    \x04\x02\x12\x06\xa2\x01\0\xbf\x01\x01\x1a{\x20Metadata\x20type\x20for\
    \x20the\x20operation\x20returned\x20by\n\x20[CreateBackup][google.spanne\
    r.admin.database.v1.DatabaseAdmin.CreateBackup].\n\n\x0b\n\x03\x04\x02\
    \x01\x12\x04\xa2\x01\x08\x1c\n7\n\x04\x04\x02\x02\0\x12\x06\xa4\x01\x02\
    \xa6\x01\x04\x1a'\x20The\x20name\x20of\x20the\x20backup\x20being\x20crea\
    ted.\n\n\x0f\n\x05\x04\x02\x02\0\x04\x12\x06\xa4\x01\x02\xa2\x01\x1e\n\r\
    \n\x05\x04\x02\x02\0\x05\x12\x04\xa4\x01\x02\x08\n\r\n\x05\x04\x02\x02\0\
    \x01\x12\x04\xa4\x01\t\r\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\xa4\x01\x10\
    \x11\n\x0f\n\x05\x04\x02\x02\0\x08\x12\x06\xa4\x01\x12\xa6\x01\x03\n\x0f\
    \n\x07\x04\x02\x02\0\x08\x9f\x08\x12\x04\xa5\x01\x04O\nF\n\x04\x04\x02\
    \x02\x01\x12\x06\xa9\x01\x02\xab\x01\x05\x1a6\x20The\x20name\x20of\x20th\
    e\x20database\x20the\x20backup\x20is\x20created\x20from.\n\n\x0f\n\x05\
    \x04\x02\x02\x01\x04\x12\x06\xa9\x01\x02\xa6\x01\x04\n\r\n\x05\x04\x02\
    \x02\x01\x05\x12\x04\xa9\x01\x02\x08\n\r\n\x05\x04\x02\x02\x01\x01\x12\
    \x04\xa9\x01\t\x11\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\xa9\x01\x14\x15\
    \n\x0f\n\x05\x04\x02\x02\x01\x08\x12\x06\xa9\x01\x16\xab\x01\x04\n\x11\n\
    \x07\x04\x02\x02\x01\x08\x9f\x08\x12\x06\xa9\x01\x17\xab\x01\x03\n|\n\
    \x04\x04\x02\x02\x02\x12\x04\xb0\x01\x02!\x1an\x20The\x20progress\x20of\
    \x20the\n\x20[CreateBackup][google.spanner.admin.database.v1.DatabaseAdm\
    in.CreateBackup]\n\x20operation.\n\n\x0f\n\x05\x04\x02\x02\x02\x04\x12\
    \x06\xb0\x01\x02\xab\x01\x05\n\r\n\x05\x04\x02\x02\x02\x06\x12\x04\xb0\
    \x01\x02\x13\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\xb0\x01\x14\x1c\n\r\n\
    \x05\x04\x02\x02\x02\x03\x12\x04\xb0\x01\x1f\x20\n\x87\x06\n\x04\x04\x02\
    \x02\x03\x12\x04\xbe\x01\x02,\x1a\xf8\x05\x20The\x20time\x20at\x20which\
    \x20cancellation\x20of\x20this\x20operation\x20was\x20received.\n\x20[Op\
    erations.CancelOperation][google.longrunning.Operations.CancelOperation]\
    \n\x20starts\x20asynchronous\x20cancellation\x20on\x20a\x20long-running\
    \x20operation.\x20The\x20server\n\x20makes\x20a\x20best\x20effort\x20to\
    \x20cancel\x20the\x20operation,\x20but\x20success\x20is\x20not\x20guaran\
    teed.\n\x20Clients\x20can\x20use\n\x20[Operations.GetOperation][google.l\
    ongrunning.Operations.GetOperation]\x20or\n\x20other\x20methods\x20to\
    \x20check\x20whether\x20the\x20cancellation\x20succeeded\x20or\x20whethe\
    r\x20the\n\x20operation\x20completed\x20despite\x20cancellation.\x20On\
    \x20successful\x20cancellation,\n\x20the\x20operation\x20is\x20not\x20de\
    leted;\x20instead,\x20it\x20becomes\x20an\x20operation\x20with\n\x20an\
    \x20[Operation.error][google.longrunning.Operation.error]\x20value\x20wi\
    th\x20a\n\x20[google.rpc.Status.code][google.rpc.Status.code]\x20of\x201\
    ,\n\x20corresponding\x20to\x20`Code.CANCELLED`.\n\n\x0f\n\x05\x04\x02\
    \x02\x03\x04\x12\x06\xbe\x01\x02\xb0\x01!\n\r\n\x05\x04\x02\x02\x03\x06\
    \x12\x04\xbe\x01\x02\x1b\n\r\n\x05\x04\x02\x02\x03\x01\x12\x04\xbe\x01\
    \x1c'\n\r\n\x05\x04\x02\x02\x03\x03\x12\x04\xbe\x01*+\nm\n\x02\x04\x03\
    \x12\x06\xc3\x01\0\xd1\x01\x01\x1a_\x20The\x20request\x20for\n\x20[Updat\
    eBackup][google.spanner.admin.database.v1.DatabaseAdmin.UpdateBackup].\n\
    \n\x0b\n\x03\x04\x03\x01\x12\x04\xc3\x01\x08\x1b\n\xf1\x01\n\x04\x04\x03\
    \x02\0\x12\x04\xc8\x01\x02=\x1a\xe2\x01\x20Required.\x20The\x20backup\
    \x20to\x20update.\x20`backup.name`,\x20and\x20the\x20fields\x20to\x20be\
    \x20updated\n\x20as\x20specified\x20by\x20`update_mask`\x20are\x20requir\
    ed.\x20Other\x20fields\x20are\x20ignored.\n\x20Update\x20is\x20only\x20s\
    upported\x20for\x20the\x20following\x20fields:\n\x20\x20*\x20`backup.exp\
    ire_time`.\n\n\x0f\n\x05\x04\x03\x02\0\x04\x12\x06\xc8\x01\x02\xc3\x01\
    \x1d\n\r\n\x05\x04\x03\x02\0\x06\x12\x04\xc8\x01\x02\x08\n\r\n\x05\x04\
    \x03\x02\0\x01\x12\x04\xc8\x01\t\x0f\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\
    \xc8\x01\x12\x13\n\r\n\x05\x04\x03\x02\0\x08\x12\x04\xc8\x01\x14<\n\x10\
    \n\x08\x04\x03\x02\0\x08\x9c\x08\0\x12\x04\xc8\x01\x15;\n\xd8\x02\n\x04\
    \x04\x03\x02\x01\x12\x06\xcf\x01\x02\xd0\x01/\x1a\xc7\x02\x20Required.\
    \x20A\x20mask\x20specifying\x20which\x20fields\x20(e.g.\x20`expire_time`\
    )\x20in\x20the\n\x20Backup\x20resource\x20should\x20be\x20updated.\x20Th\
    is\x20mask\x20is\x20relative\x20to\x20the\x20Backup\n\x20resource,\x20no\
    t\x20to\x20the\x20request\x20message.\x20The\x20field\x20mask\x20must\
    \x20always\x20be\n\x20specified;\x20this\x20prevents\x20any\x20future\
    \x20fields\x20from\x20being\x20erased\x20accidentally\n\x20by\x20clients\
    \x20that\x20do\x20not\x20know\x20about\x20them.\n\n\x0f\n\x05\x04\x03\
    \x02\x01\x04\x12\x06\xcf\x01\x02\xc8\x01=\n\r\n\x05\x04\x03\x02\x01\x06\
    \x12\x04\xcf\x01\x02\x1b\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\xcf\x01\
    \x1c'\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\xcf\x01*+\n\r\n\x05\x04\x03\
    \x02\x01\x08\x12\x04\xd0\x01\x06.\n\x10\n\x08\x04\x03\x02\x01\x08\x9c\
    \x08\0\x12\x04\xd0\x01\x07-\ng\n\x02\x04\x04\x12\x06\xd5\x01\0\xdd\x01\
    \x01\x1aY\x20The\x20request\x20for\n\x20[GetBackup][google.spanner.admin\
    .database.v1.DatabaseAdmin.GetBackup].\n\n\x0b\n\x03\x04\x04\x01\x12\x04\
    \xd5\x01\x08\x18\n\x84\x01\n\x04\x04\x04\x02\0\x12\x06\xd9\x01\x02\xdc\
    \x01\x04\x1at\x20Required.\x20Name\x20of\x20the\x20backup.\n\x20Values\
    \x20are\x20of\x20the\x20form\n\x20`projects/<project>/instances/<instanc\
    e>/backups/<backup>`.\n\n\x0f\n\x05\x04\x04\x02\0\x04\x12\x06\xd9\x01\
    \x02\xd5\x01\x1a\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\xd9\x01\x02\x08\n\r\
    \n\x05\x04\x04\x02\0\x01\x12\x04\xd9\x01\t\r\n\r\n\x05\x04\x04\x02\0\x03\
    \x12\x04\xd9\x01\x10\x11\n\x0f\n\x05\x04\x04\x02\0\x08\x12\x06\xd9\x01\
    \x12\xdc\x01\x03\n\x10\n\x08\x04\x04\x02\0\x08\x9c\x08\0\x12\x04\xda\x01\
    \x04*\n\x0f\n\x07\x04\x04\x02\0\x08\x9f\x08\x12\x04\xdb\x01\x04O\nm\n\
    \x02\x04\x05\x12\x06\xe1\x01\0\xe9\x01\x01\x1a_\x20The\x20request\x20for\
    \n\x20[DeleteBackup][google.spanner.admin.database.v1.DatabaseAdmin.Dele\
    teBackup].\n\n\x0b\n\x03\x04\x05\x01\x12\x04\xe1\x01\x08\x1b\n\x8e\x01\n\
    \x04\x04\x05\x02\0\x12\x06\xe5\x01\x02\xe8\x01\x04\x1a~\x20Required.\x20\
    Name\x20of\x20the\x20backup\x20to\x20delete.\n\x20Values\x20are\x20of\
    \x20the\x20form\n\x20`projects/<project>/instances/<instance>/backups/<b\
    ackup>`.\n\n\x0f\n\x05\x04\x05\x02\0\x04\x12\x06\xe5\x01\x02\xe1\x01\x1d\
    \n\r\n\x05\x04\x05\x02\0\x05\x12\x04\xe5\x01\x02\x08\n\r\n\x05\x04\x05\
    \x02\0\x01\x12\x04\xe5\x01\t\r\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xe5\
    \x01\x10\x11\n\x0f\n\x05\x04\x05\x02\0\x08\x12\x06\xe5\x01\x12\xe8\x01\
    \x03\n\x10\n\x08\x04\x05\x02\0\x08\x9c\x08\0\x12\x04\xe6\x01\x04*\n\x0f\
    \n\x07\x04\x05\x02\0\x08\x9f\x08\x12\x04\xe7\x01\x04O\nk\n\x02\x04\x06\
    \x12\x06\xed\x01\0\xa8\x02\x01\x1a]\x20The\x20request\x20for\n\x20[ListB\
    ackups][google.spanner.admin.database.v1.DatabaseAdmin.ListBackups].\n\n\
    \x0b\n\x03\x04\x06\x01\x12\x04\xed\x01\x08\x1a\n\x82\x01\n\x04\x04\x06\
    \x02\0\x12\x06\xf0\x01\x02\xf5\x01\x04\x1ar\x20Required.\x20The\x20insta\
    nce\x20to\x20list\x20backups\x20from.\x20\x20Values\x20are\x20of\x20the\
    \n\x20form\x20`projects/<project>/instances/<instance>`.\n\n\x0f\n\x05\
    \x04\x06\x02\0\x04\x12\x06\xf0\x01\x02\xed\x01\x1c\n\r\n\x05\x04\x06\x02\
    \0\x05\x12\x04\xf0\x01\x02\x08\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xf0\
    \x01\t\x0f\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xf0\x01\x12\x13\n\x0f\n\
    \x05\x04\x06\x02\0\x08\x12\x06\xf0\x01\x14\xf5\x01\x03\n\x10\n\x08\x04\
    \x06\x02\0\x08\x9c\x08\0\x12\x04\xf1\x01\x04*\n\x11\n\x07\x04\x06\x02\0\
    \x08\x9f\x08\x12\x06\xf2\x01\x04\xf4\x01\x05\n\xec\x0c\n\x04\x04\x06\x02\
    \x01\x12\x04\x9c\x02\x02\x14\x1a\xdd\x0c\x20An\x20expression\x20that\x20\
    filters\x20the\x20list\x20of\x20returned\x20backups.\n\n\x20A\x20filter\
    \x20expression\x20consists\x20of\x20a\x20field\x20name,\x20a\x20comparis\
    on\x20operator,\x20and\x20a\n\x20value\x20for\x20filtering.\n\x20The\x20\
    value\x20must\x20be\x20a\x20string,\x20a\x20number,\x20or\x20a\x20boolea\
    n.\x20The\x20comparison\x20operator\n\x20must\x20be\x20one\x20of:\x20`<`\
    ,\x20`>`,\x20`<=`,\x20`>=`,\x20`!=`,\x20`=`,\x20or\x20`:`.\n\x20Colon\
    \x20`:`\x20is\x20the\x20contains\x20operator.\x20Filter\x20rules\x20are\
    \x20not\x20case\x20sensitive.\n\n\x20The\x20following\x20fields\x20in\
    \x20the\n\x20[Backup][google.spanner.admin.database.v1.Backup]\x20are\
    \x20eligible\x20for\n\x20filtering:\n\n\x20\x20\x20*\x20`name`\n\x20\x20\
    \x20*\x20`database`\n\x20\x20\x20*\x20`state`\n\x20\x20\x20*\x20`create_\
    time`\x20\x20(and\x20values\x20are\x20of\x20the\x20format\x20YYYY-MM-DDT\
    HH:MM:SSZ)\n\x20\x20\x20*\x20`expire_time`\x20\x20(and\x20values\x20are\
    \x20of\x20the\x20format\x20YYYY-MM-DDTHH:MM:SSZ)\n\x20\x20\x20*\x20`vers\
    ion_time`\x20(and\x20values\x20are\x20of\x20the\x20format\x20YYYY-MM-DDT\
    HH:MM:SSZ)\n\x20\x20\x20*\x20`size_bytes`\n\n\x20You\x20can\x20combine\
    \x20multiple\x20expressions\x20by\x20enclosing\x20each\x20expression\x20\
    in\n\x20parentheses.\x20By\x20default,\x20expressions\x20are\x20combined\
    \x20with\x20AND\x20logic,\x20but\n\x20you\x20can\x20specify\x20AND,\x20O\
    R,\x20and\x20NOT\x20logic\x20explicitly.\n\n\x20Here\x20are\x20a\x20few\
    \x20examples:\n\n\x20\x20\x20*\x20`name:Howl`\x20-\x20The\x20backup's\
    \x20name\x20contains\x20the\x20string\x20\"howl\".\n\x20\x20\x20*\x20`da\
    tabase:prod`\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20-\x20The\x20databa\
    se's\x20name\x20contains\x20the\x20string\x20\"prod\".\n\x20\x20\x20*\
    \x20`state:CREATING`\x20-\x20The\x20backup\x20is\x20pending\x20creation.\
    \n\x20\x20\x20*\x20`state:READY`\x20-\x20The\x20backup\x20is\x20fully\
    \x20created\x20and\x20ready\x20for\x20use.\n\x20\x20\x20*\x20`(name:howl\
    )\x20AND\x20(create_time\x20<\x20\\\"2018-03-28T14:50:00Z\\\")`\n\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20-\x20The\x20backup\x20name\x20contai\
    ns\x20the\x20string\x20\"howl\"\x20and\x20`create_time`\n\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20of\x20the\x20backup\x20is\
    \x20before\x202018-03-28T14:50:00Z.\n\x20\x20\x20*\x20`expire_time\x20<\
    \x20\\\"2018-03-28T14:50:00Z\\\"`\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20-\x20The\x20backup\x20`expire_time`\x20is\x20before\x202018-03-28T14\
    :50:00Z.\n\x20\x20\x20*\x20`size_bytes\x20>\x2010000000000`\x20-\x20The\
    \x20backup's\x20size\x20is\x20greater\x20than\x2010GB\n\n\x0f\n\x05\x04\
    \x06\x02\x01\x04\x12\x06\x9c\x02\x02\xf5\x01\x04\n\r\n\x05\x04\x06\x02\
    \x01\x05\x12\x04\x9c\x02\x02\x08\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\
    \x9c\x02\t\x0f\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\x9c\x02\x12\x13\n\
    \x84\x01\n\x04\x04\x06\x02\x02\x12\x04\xa0\x02\x02\x16\x1av\x20Number\
    \x20of\x20backups\x20to\x20be\x20returned\x20in\x20the\x20response.\x20I\
    f\x200\x20or\n\x20less,\x20defaults\x20to\x20the\x20server's\x20maximum\
    \x20allowed\x20page\x20size.\n\n\x0f\n\x05\x04\x06\x02\x02\x04\x12\x06\
    \xa0\x02\x02\x9c\x02\x14\n\r\n\x05\x04\x06\x02\x02\x05\x12\x04\xa0\x02\
    \x02\x07\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\xa0\x02\x08\x11\n\r\n\x05\
    \x04\x06\x02\x02\x03\x12\x04\xa0\x02\x14\x15\n\xa5\x02\n\x04\x04\x06\x02\
    \x03\x12\x04\xa7\x02\x02\x18\x1a\x96\x02\x20If\x20non-empty,\x20`page_to\
    ken`\x20should\x20contain\x20a\n\x20[next_page_token][google.spanner.adm\
    in.database.v1.ListBackupsResponse.next_page_token]\n\x20from\x20a\x20pr\
    evious\n\x20[ListBackupsResponse][google.spanner.admin.database.v1.ListB\
    ackupsResponse]\n\x20to\x20the\x20same\x20`parent`\x20and\x20with\x20the\
    \x20same\x20`filter`.\n\n\x0f\n\x05\x04\x06\x02\x03\x04\x12\x06\xa7\x02\
    \x02\xa0\x02\x16\n\r\n\x05\x04\x06\x02\x03\x05\x12\x04\xa7\x02\x02\x08\n\
    \r\n\x05\x04\x06\x02\x03\x01\x12\x04\xa7\x02\t\x13\n\r\n\x05\x04\x06\x02\
    \x03\x03\x12\x04\xa7\x02\x16\x17\nl\n\x02\x04\x07\x12\x06\xac\x02\0\xb5\
    \x02\x01\x1a^\x20The\x20response\x20for\n\x20[ListBackups][google.spanne\
    r.admin.database.v1.DatabaseAdmin.ListBackups].\n\n\x0b\n\x03\x04\x07\
    \x01\x12\x04\xac\x02\x08\x1b\n\x9f\x01\n\x04\x04\x07\x02\0\x12\x04\xaf\
    \x02\x02\x1e\x1a\x90\x01\x20The\x20list\x20of\x20matching\x20backups.\
    \x20Backups\x20returned\x20are\x20ordered\x20by\x20`create_time`\n\x20in\
    \x20descending\x20order,\x20starting\x20from\x20the\x20most\x20recent\
    \x20`create_time`.\n\n\r\n\x05\x04\x07\x02\0\x04\x12\x04\xaf\x02\x02\n\n\
    \r\n\x05\x04\x07\x02\0\x06\x12\x04\xaf\x02\x0b\x11\n\r\n\x05\x04\x07\x02\
    \0\x01\x12\x04\xaf\x02\x12\x19\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xaf\
    \x02\x1c\x1d\n\xb6\x01\n\x04\x04\x07\x02\x01\x12\x04\xb4\x02\x02\x1d\x1a\
    \xa7\x01\x20`next_page_token`\x20can\x20be\x20sent\x20in\x20a\x20subsequ\
    ent\n\x20[ListBackups][google.spanner.admin.database.v1.DatabaseAdmin.Li\
    stBackups]\n\x20call\x20to\x20fetch\x20more\x20of\x20the\x20matching\x20\
    backups.\n\n\x0f\n\x05\x04\x07\x02\x01\x04\x12\x06\xb4\x02\x02\xaf\x02\
    \x1e\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\xb4\x02\x02\x08\n\r\n\x05\x04\
    \x07\x02\x01\x01\x12\x04\xb4\x02\t\x18\n\r\n\x05\x04\x07\x02\x01\x03\x12\
    \x04\xb4\x02\x1b\x1c\n}\n\x02\x04\x08\x12\x06\xb9\x02\0\xf8\x02\x01\x1ao\
    \x20The\x20request\x20for\n\x20[ListBackupOperations][google.spanner.adm\
    in.database.v1.DatabaseAdmin.ListBackupOperations].\n\n\x0b\n\x03\x04\
    \x08\x01\x12\x04\xb9\x02\x08#\n\x85\x01\n\x04\x04\x08\x02\0\x12\x06\xbc\
    \x02\x02\xc1\x02\x04\x1au\x20Required.\x20The\x20instance\x20of\x20the\
    \x20backup\x20operations.\x20Values\x20are\x20of\n\x20the\x20form\x20`pr\
    ojects/<project>/instances/<instance>`.\n\n\x0f\n\x05\x04\x08\x02\0\x04\
    \x12\x06\xbc\x02\x02\xb9\x02%\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\xbc\
    \x02\x02\x08\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xbc\x02\t\x0f\n\r\n\x05\
    \x04\x08\x02\0\x03\x12\x04\xbc\x02\x12\x13\n\x0f\n\x05\x04\x08\x02\0\x08\
    \x12\x06\xbc\x02\x14\xc1\x02\x03\n\x10\n\x08\x04\x08\x02\0\x08\x9c\x08\0\
    \x12\x04\xbd\x02\x04*\n\x11\n\x07\x04\x08\x02\0\x08\x9f\x08\x12\x06\xbe\
    \x02\x04\xc0\x02\x05\n\xe2\x0f\n\x04\x04\x08\x02\x01\x12\x04\xec\x02\x02\
    \x14\x1a\xd3\x0f\x20An\x20expression\x20that\x20filters\x20the\x20list\
    \x20of\x20returned\x20backup\x20operations.\n\n\x20A\x20filter\x20expres\
    sion\x20consists\x20of\x20a\x20field\x20name,\x20a\n\x20comparison\x20op\
    erator,\x20and\x20a\x20value\x20for\x20filtering.\n\x20The\x20value\x20m\
    ust\x20be\x20a\x20string,\x20a\x20number,\x20or\x20a\x20boolean.\x20The\
    \x20comparison\x20operator\n\x20must\x20be\x20one\x20of:\x20`<`,\x20`>`,\
    \x20`<=`,\x20`>=`,\x20`!=`,\x20`=`,\x20or\x20`:`.\n\x20Colon\x20`:`\x20i\
    s\x20the\x20contains\x20operator.\x20Filter\x20rules\x20are\x20not\x20ca\
    se\x20sensitive.\n\n\x20The\x20following\x20fields\x20in\x20the\x20[oper\
    ation][google.longrunning.Operation]\n\x20are\x20eligible\x20for\x20filt\
    ering:\n\n\x20\x20\x20*\x20`name`\x20-\x20The\x20name\x20of\x20the\x20lo\
    ng-running\x20operation\n\x20\x20\x20*\x20`done`\x20-\x20False\x20if\x20\
    the\x20operation\x20is\x20in\x20progress,\x20else\x20true.\n\x20\x20\x20\
    *\x20`metadata.@type`\x20-\x20the\x20type\x20of\x20metadata.\x20For\x20e\
    xample,\x20the\x20type\x20string\n\x20\x20\x20\x20\x20\x20for\n\x20\x20\
    \x20\x20\x20\x20[CreateBackupMetadata][google.spanner.admin.database.v1.\
    CreateBackupMetadata]\n\x20\x20\x20\x20\x20\x20is\n\x20\x20\x20\x20\x20\
    \x20`type.googleapis.com/google.spanner.admin.database.v1.CreateBackupMe\
    tadata`.\n\x20\x20\x20*\x20`metadata.<field_name>`\x20-\x20any\x20field\
    \x20in\x20metadata.value.\n\x20\x20\x20*\x20`error`\x20-\x20Error\x20ass\
    ociated\x20with\x20the\x20long-running\x20operation.\n\x20\x20\x20*\x20`\
    response.@type`\x20-\x20the\x20type\x20of\x20response.\n\x20\x20\x20*\
    \x20`response.<field_name>`\x20-\x20any\x20field\x20in\x20response.value\
    .\n\n\x20You\x20can\x20combine\x20multiple\x20expressions\x20by\x20enclo\
    sing\x20each\x20expression\x20in\n\x20parentheses.\x20By\x20default,\x20\
    expressions\x20are\x20combined\x20with\x20AND\x20logic,\x20but\n\x20you\
    \x20can\x20specify\x20AND,\x20OR,\x20and\x20NOT\x20logic\x20explicitly.\
    \n\n\x20Here\x20are\x20a\x20few\x20examples:\n\n\x20\x20\x20*\x20`done:t\
    rue`\x20-\x20The\x20operation\x20is\x20complete.\n\x20\x20\x20*\x20`meta\
    data.database:prod`\x20-\x20The\x20database\x20the\x20backup\x20was\x20t\
    aken\x20from\x20has\n\x20\x20\x20\x20\x20\x20a\x20name\x20containing\x20\
    the\x20string\x20\"prod\".\n\x20\x20\x20*\x20`(metadata.@type=type.googl\
    eapis.com/google.spanner.admin.database.v1.CreateBackupMetadata)\x20AND`\
    \x20\\\n\x20\x20\x20\x20\x20`(metadata.name:howl)\x20AND`\x20\\\n\x20\
    \x20\x20\x20\x20`(metadata.progress.start_time\x20<\x20\\\"2018-03-28T14\
    :50:00Z\\\")\x20AND`\x20\\\n\x20\x20\x20\x20\x20`(error:*)`\x20-\x20Retu\
    rns\x20operations\x20where:\n\x20\x20\x20\x20\x20*\x20The\x20operation's\
    \x20metadata\x20type\x20is\n\x20\x20\x20\x20\x20[CreateBackupMetadata][g\
    oogle.spanner.admin.database.v1.CreateBackupMetadata].\n\x20\x20\x20\x20\
    \x20*\x20The\x20backup\x20name\x20contains\x20the\x20string\x20\"howl\".\
    \n\x20\x20\x20\x20\x20*\x20The\x20operation\x20started\x20before\x202018\
    -03-28T14:50:00Z.\n\x20\x20\x20\x20\x20*\x20The\x20operation\x20resulted\
    \x20in\x20an\x20error.\n\n\x0f\n\x05\x04\x08\x02\x01\x04\x12\x06\xec\x02\
    \x02\xc1\x02\x04\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\xec\x02\x02\x08\n\
    \r\n\x05\x04\x08\x02\x01\x01\x12\x04\xec\x02\t\x0f\n\r\n\x05\x04\x08\x02\
    \x01\x03\x12\x04\xec\x02\x12\x13\n\x87\x01\n\x04\x04\x08\x02\x02\x12\x04\
    \xf0\x02\x02\x16\x1ay\x20Number\x20of\x20operations\x20to\x20be\x20retur\
    ned\x20in\x20the\x20response.\x20If\x200\x20or\n\x20less,\x20defaults\
    \x20to\x20the\x20server's\x20maximum\x20allowed\x20page\x20size.\n\n\x0f\
    \n\x05\x04\x08\x02\x02\x04\x12\x06\xf0\x02\x02\xec\x02\x14\n\r\n\x05\x04\
    \x08\x02\x02\x05\x12\x04\xf0\x02\x02\x07\n\r\n\x05\x04\x08\x02\x02\x01\
    \x12\x04\xf0\x02\x08\x11\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\xf0\x02\
    \x14\x15\n\xc0\x02\n\x04\x04\x08\x02\x03\x12\x04\xf7\x02\x02\x18\x1a\xb1\
    \x02\x20If\x20non-empty,\x20`page_token`\x20should\x20contain\x20a\n\x20\
    [next_page_token][google.spanner.admin.database.v1.ListBackupOperationsR\
    esponse.next_page_token]\n\x20from\x20a\x20previous\n\x20[ListBackupOper\
    ationsResponse][google.spanner.admin.database.v1.ListBackupOperationsRes\
    ponse]\n\x20to\x20the\x20same\x20`parent`\x20and\x20with\x20the\x20same\
    \x20`filter`.\n\n\x0f\n\x05\x04\x08\x02\x03\x04\x12\x06\xf7\x02\x02\xf0\
    \x02\x16\n\r\n\x05\x04\x08\x02\x03\x05\x12\x04\xf7\x02\x02\x08\n\r\n\x05\
    \x04\x08\x02\x03\x01\x12\x04\xf7\x02\t\x13\n\r\n\x05\x04\x08\x02\x03\x03\
    \x12\x04\xf7\x02\x16\x17\n~\n\x02\x04\t\x12\x06\xfc\x02\0\x8c\x03\x01\
    \x1ap\x20The\x20response\x20for\n\x20[ListBackupOperations][google.spann\
    er.admin.database.v1.DatabaseAdmin.ListBackupOperations].\n\n\x0b\n\x03\
    \x04\t\x01\x12\x04\xfc\x02\x08$\n\xd4\x04\n\x04\x04\t\x02\0\x12\x04\x86\
    \x03\x027\x1a\xc5\x04\x20The\x20list\x20of\x20matching\x20backup\x20[lon\
    g-running\n\x20operations][google.longrunning.Operation].\x20Each\x20ope\
    ration's\x20name\x20will\x20be\n\x20prefixed\x20by\x20the\x20backup's\
    \x20name\x20and\x20the\x20operation's\n\x20[metadata][google.longrunning\
    .Operation.metadata]\x20will\x20be\x20of\x20type\n\x20[CreateBackupMetad\
    ata][google.spanner.admin.database.v1.CreateBackupMetadata].\n\x20Operat\
    ions\x20returned\x20include\x20those\x20that\x20are\x20pending\x20or\x20\
    have\n\x20completed/failed/canceled\x20within\x20the\x20last\x207\x20day\
    s.\x20Operations\x20returned\x20are\n\x20ordered\x20by\x20`operation.met\
    adata.value.progress.start_time`\x20in\x20descending\n\x20order\x20start\
    ing\x20from\x20the\x20most\x20recently\x20started\x20operation.\n\n\r\n\
    \x05\x04\t\x02\0\x04\x12\x04\x86\x03\x02\n\n\r\n\x05\x04\t\x02\0\x06\x12\
    \x04\x86\x03\x0b'\n\r\n\x05\x04\t\x02\0\x01\x12\x04\x86\x03(2\n\r\n\x05\
    \x04\t\x02\0\x03\x12\x04\x86\x0356\n\xc9\x01\n\x04\x04\t\x02\x01\x12\x04\
    \x8b\x03\x02\x1d\x1a\xba\x01\x20`next_page_token`\x20can\x20be\x20sent\
    \x20in\x20a\x20subsequent\n\x20[ListBackupOperations][google.spanner.adm\
    in.database.v1.DatabaseAdmin.ListBackupOperations]\n\x20call\x20to\x20fe\
    tch\x20more\x20of\x20the\x20matching\x20metadata.\n\n\x0f\n\x05\x04\t\
    \x02\x01\x04\x12\x06\x8b\x03\x02\x86\x037\n\r\n\x05\x04\t\x02\x01\x05\
    \x12\x04\x8b\x03\x02\x08\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\x8b\x03\t\
    \x18\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\x8b\x03\x1b\x1c\n+\n\x02\x04\n\
    \x12\x06\x8f\x03\0\xa5\x03\x01\x1a\x1d\x20Information\x20about\x20a\x20b\
    ackup.\n\n\x0b\n\x03\x04\n\x01\x12\x04\x8f\x03\x08\x12\n%\n\x04\x04\n\
    \x02\0\x12\x06\x91\x03\x02\x93\x03\x04\x1a\x15\x20Name\x20of\x20the\x20b\
    ackup.\n\n\x0f\n\x05\x04\n\x02\0\x04\x12\x06\x91\x03\x02\x8f\x03\x14\n\r\
    \n\x05\x04\n\x02\0\x05\x12\x04\x91\x03\x02\x08\n\r\n\x05\x04\n\x02\0\x01\
    \x12\x04\x91\x03\t\x0f\n\r\n\x05\x04\n\x02\0\x03\x12\x04\x91\x03\x12\x13\
    \n\x0f\n\x05\x04\n\x02\0\x08\x12\x06\x91\x03\x14\x93\x03\x03\n\x0f\n\x07\
    \x04\n\x02\0\x08\x9f\x08\x12\x04\x92\x03\x04O\n\xc9\x02\n\x04\x04\n\x02\
    \x01\x12\x04\x9a\x03\x02-\x1a\xba\x02\x20The\x20backup\x20contains\x20an\
    \x20externally\x20consistent\x20copy\x20of\x20`source_database`\x20at\n\
    \x20the\x20timestamp\x20specified\x20by\x20`version_time`.\x20If\x20the\
    \n\x20[CreateBackup][google.spanner.admin.database.v1.DatabaseAdmin.Crea\
    teBackup]\n\x20request\x20did\x20not\x20specify\x20`version_time`,\x20th\
    e\x20`version_time`\x20of\x20the\x20backup\x20is\n\x20equivalent\x20to\
    \x20the\x20`create_time`.\n\n\x0f\n\x05\x04\n\x02\x01\x04\x12\x06\x9a\
    \x03\x02\x93\x03\x04\n\r\n\x05\x04\n\x02\x01\x06\x12\x04\x9a\x03\x02\x1b\
    \n\r\n\x05\x04\n\x02\x01\x01\x12\x04\x9a\x03\x1c(\n\r\n\x05\x04\n\x02\
    \x01\x03\x12\x04\x9a\x03+,\n\x80\x01\n\x04\x04\n\x02\x02\x12\x04\x9f\x03\
    \x02,\x1ar\x20The\x20time\x20the\n\x20[CreateBackup][google.spanner.admi\
    n.database.v1.DatabaseAdmin.CreateBackup]\n\x20request\x20was\x20receive\
    d.\n\n\x0f\n\x05\x04\n\x02\x02\x04\x12\x06\x9f\x03\x02\x9a\x03-\n\r\n\
    \x05\x04\n\x02\x02\x06\x12\x04\x9f\x03\x02\x1b\n\r\n\x05\x04\n\x02\x02\
    \x01\x12\x04\x9f\x03\x1c'\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\x9f\x03*+\
    \nC\n\x04\x04\n\x02\x03\x12\x06\xa2\x03\x02\xa4\x03\x05\x1a3\x20Name\x20\
    of\x20the\x20database\x20the\x20backup\x20was\x20created\x20from.\n\n\
    \x0f\n\x05\x04\n\x02\x03\x04\x12\x06\xa2\x03\x02\x9f\x03,\n\r\n\x05\x04\
    \n\x02\x03\x05\x12\x04\xa2\x03\x02\x08\n\r\n\x05\x04\n\x02\x03\x01\x12\
    \x04\xa2\x03\t\x18\n\r\n\x05\x04\n\x02\x03\x03\x12\x04\xa2\x03\x1b\x1c\n\
    \x0f\n\x05\x04\n\x02\x03\x08\x12\x06\xa2\x03\x1d\xa4\x03\x04\n\x11\n\x07\
    \x04\n\x02\x03\x08\x9f\x08\x12\x06\xa2\x03\x1e\xa4\x03\x03\nB\n\x02\x04\
    \x0b\x12\x06\xa8\x03\0\xcc\x03\x01\x1a4\x20Encryption\x20configuration\
    \x20for\x20the\x20backup\x20to\x20create.\n\n\x0b\n\x03\x04\x0b\x01\x12\
    \x04\xa8\x03\x08$\n2\n\x04\x04\x0b\x04\0\x12\x06\xaa\x03\x02\xbc\x03\x03\
    \x1a\"\x20Encryption\x20types\x20for\x20the\x20backup.\n\n\r\n\x05\x04\
    \x0b\x04\0\x01\x12\x04\xaa\x03\x07\x15\n*\n\x06\x04\x0b\x04\0\x02\0\x12\
    \x04\xac\x03\x04$\x1a\x1a\x20Unspecified.\x20Do\x20not\x20use.\n\n\x0f\n\
    \x07\x04\x0b\x04\0\x02\0\x01\x12\x04\xac\x03\x04\x1f\n\x0f\n\x07\x04\x0b\
    \x04\0\x02\0\x02\x12\x04\xac\x03\"#\n\xd1\x02\n\x06\x04\x0b\x04\0\x02\
    \x01\x12\x04\xb4\x03\x04\x20\x1a\xc0\x02\x20Use\x20the\x20same\x20encryp\
    tion\x20configuration\x20as\x20the\x20database.\x20This\x20is\x20the\n\
    \x20default\x20option\x20when\n\x20[encryption_config][google.spanner.ad\
    min.database.v1.CreateBackupEncryptionConfig]\n\x20is\x20empty.\x20For\
    \x20example,\x20if\x20the\x20database\x20is\x20using\n\x20`Customer_Mana\
    ged_Encryption`,\x20the\x20backup\x20will\x20be\x20using\x20the\x20same\
    \x20Cloud\n\x20KMS\x20key\x20as\x20the\x20database.\n\n\x0f\n\x07\x04\
    \x0b\x04\0\x02\x01\x01\x12\x04\xb4\x03\x04\x1b\n\x0f\n\x07\x04\x0b\x04\0\
    \x02\x01\x02\x12\x04\xb4\x03\x1e\x1f\n0\n\x06\x04\x0b\x04\0\x02\x02\x12\
    \x04\xb7\x03\x04\"\x1a\x20\x20Use\x20Google\x20default\x20encryption.\n\
    \n\x0f\n\x07\x04\x0b\x04\0\x02\x02\x01\x12\x04\xb7\x03\x04\x1d\n\x0f\n\
    \x07\x04\x0b\x04\0\x02\x02\x02\x12\x04\xb7\x03\x20!\nt\n\x06\x04\x0b\x04\
    \0\x02\x03\x12\x04\xbb\x03\x04$\x1ad\x20Use\x20customer\x20managed\x20en\
    cryption.\x20If\x20specified,\x20`kms_key_name`\n\x20must\x20contain\x20\
    a\x20valid\x20Cloud\x20KMS\x20key.\n\n\x0f\n\x07\x04\x0b\x04\0\x02\x03\
    \x01\x12\x04\xbb\x03\x04\x1f\n\x0f\n\x07\x04\x0b\x04\0\x02\x03\x02\x12\
    \x04\xbb\x03\"#\n<\n\x04\x04\x0b\x02\0\x12\x04\xbf\x03\x02N\x1a.\x20Requ\
    ired.\x20The\x20encryption\x20type\x20of\x20the\x20backup.\n\n\x0f\n\x05\
    \x04\x0b\x02\0\x04\x12\x06\xbf\x03\x02\xbc\x03\x03\n\r\n\x05\x04\x0b\x02\
    \0\x06\x12\x04\xbf\x03\x02\x10\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xbf\
    \x03\x11\x20\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xbf\x03#$\n\r\n\x05\x04\
    \x0b\x02\0\x08\x12\x04\xbf\x03%M\n\x10\n\x08\x04\x0b\x02\0\x08\x9c\x08\0\
    \x12\x04\xbf\x03&L\n\xf1\x02\n\x04\x04\x0b\x02\x01\x12\x06\xc6\x03\x02\
    \xcb\x03\x04\x1a\xe0\x02\x20Optional.\x20The\x20Cloud\x20KMS\x20key\x20t\
    hat\x20will\x20be\x20used\x20to\x20protect\x20the\x20backup.\n\x20This\
    \x20field\x20should\x20be\x20set\x20only\x20when\n\x20[encryption_type][\
    google.spanner.admin.database.v1.CreateBackupEncryptionConfig.encryption\
    _type]\n\x20is\x20`CUSTOMER_MANAGED_ENCRYPTION`.\x20Values\x20are\x20of\
    \x20the\x20form\n\x20`projects/<project>/locations/<location>/keyRings/<\
    key_ring>/cryptoKeys/<kms_key_name>`.\n\n\x0f\n\x05\x04\x0b\x02\x01\x04\
    \x12\x06\xc6\x03\x02\xbf\x03N\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\xc6\
    \x03\x02\x08\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xc6\x03\t\x15\n\r\n\
    \x05\x04\x0b\x02\x01\x03\x12\x04\xc6\x03\x18\x19\n\x0f\n\x05\x04\x0b\x02\
    \x01\x08\x12\x06\xc6\x03\x1a\xcb\x03\x03\n\x10\n\x08\x04\x0b\x02\x01\x08\
    \x9c\x08\0\x12\x04\xc7\x03\x04*\n\x11\n\x07\x04\x0b\x02\x01\x08\x9f\x08\
    \x12\x06\xc8\x03\x04\xca\x03\x05b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
