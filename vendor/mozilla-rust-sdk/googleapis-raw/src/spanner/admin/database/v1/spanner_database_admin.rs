// This file is generated by rust-protobuf 2.22.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/spanner/admin/database/v1/spanner_database_admin.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_22_0;

#[derive(PartialEq,Clone,Default)]
pub struct RestoreInfo {
    // message fields
    pub source_type: RestoreSourceType,
    // message oneof groups
    pub source_info: ::std::option::Option<RestoreInfo_oneof_source_info>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RestoreInfo {
    fn default() -> &'a RestoreInfo {
        <RestoreInfo as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RestoreInfo_oneof_source_info {
    backup_info(super::backup::BackupInfo),
}

impl RestoreInfo {
    pub fn new() -> RestoreInfo {
        ::std::default::Default::default()
    }

    // .google.spanner.admin.database.v1.RestoreSourceType source_type = 1;


    pub fn get_source_type(&self) -> RestoreSourceType {
        self.source_type
    }
    pub fn clear_source_type(&mut self) {
        self.source_type = RestoreSourceType::TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_source_type(&mut self, v: RestoreSourceType) {
        self.source_type = v;
    }

    // .google.spanner.admin.database.v1.BackupInfo backup_info = 2;


    pub fn get_backup_info(&self) -> &super::backup::BackupInfo {
        match self.source_info {
            ::std::option::Option::Some(RestoreInfo_oneof_source_info::backup_info(ref v)) => v,
            _ => <super::backup::BackupInfo as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_backup_info(&mut self) {
        self.source_info = ::std::option::Option::None;
    }

    pub fn has_backup_info(&self) -> bool {
        match self.source_info {
            ::std::option::Option::Some(RestoreInfo_oneof_source_info::backup_info(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_backup_info(&mut self, v: super::backup::BackupInfo) {
        self.source_info = ::std::option::Option::Some(RestoreInfo_oneof_source_info::backup_info(v))
    }

    // Mutable pointer to the field.
    pub fn mut_backup_info(&mut self) -> &mut super::backup::BackupInfo {
        if let ::std::option::Option::Some(RestoreInfo_oneof_source_info::backup_info(_)) = self.source_info {
        } else {
            self.source_info = ::std::option::Option::Some(RestoreInfo_oneof_source_info::backup_info(super::backup::BackupInfo::new()));
        }
        match self.source_info {
            ::std::option::Option::Some(RestoreInfo_oneof_source_info::backup_info(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_backup_info(&mut self) -> super::backup::BackupInfo {
        if self.has_backup_info() {
            match self.source_info.take() {
                ::std::option::Option::Some(RestoreInfo_oneof_source_info::backup_info(v)) => v,
                _ => panic!(),
            }
        } else {
            super::backup::BackupInfo::new()
        }
    }
}

impl ::protobuf::Message for RestoreInfo {
    fn is_initialized(&self) -> bool {
        if let Some(RestoreInfo_oneof_source_info::backup_info(ref v)) = self.source_info {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.source_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.source_info = ::std::option::Option::Some(RestoreInfo_oneof_source_info::backup_info(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.source_type != RestoreSourceType::TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.source_type);
        }
        if let ::std::option::Option::Some(ref v) = self.source_info {
            match v {
                &RestoreInfo_oneof_source_info::backup_info(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.source_type != RestoreSourceType::TYPE_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.source_type))?;
        }
        if let ::std::option::Option::Some(ref v) = self.source_info {
            match v {
                &RestoreInfo_oneof_source_info::backup_info(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RestoreInfo {
        RestoreInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RestoreSourceType>>(
                "source_type",
                |m: &RestoreInfo| { &m.source_type },
                |m: &mut RestoreInfo| { &mut m.source_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::backup::BackupInfo>(
                "backup_info",
                RestoreInfo::has_backup_info,
                RestoreInfo::get_backup_info,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RestoreInfo>(
                "RestoreInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RestoreInfo {
        static instance: ::protobuf::rt::LazyV2<RestoreInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RestoreInfo::new)
    }
}

impl ::protobuf::Clear for RestoreInfo {
    fn clear(&mut self) {
        self.source_type = RestoreSourceType::TYPE_UNSPECIFIED;
        self.source_info = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RestoreInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Database {
    // message fields
    pub name: ::std::string::String,
    pub state: Database_State,
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub restore_info: ::protobuf::SingularPtrField<RestoreInfo>,
    pub encryption_config: ::protobuf::SingularPtrField<super::common::EncryptionConfig>,
    pub encryption_info: ::protobuf::RepeatedField<super::common::EncryptionInfo>,
    pub version_retention_period: ::std::string::String,
    pub earliest_version_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Database {
    fn default() -> &'a Database {
        <Database as ::protobuf::Message>::default_instance()
    }
}

impl Database {
    pub fn new() -> Database {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.spanner.admin.database.v1.Database.State state = 2;


    pub fn get_state(&self) -> Database_State {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = Database_State::STATE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: Database_State) {
        self.state = v;
    }

    // .google.protobuf.Timestamp create_time = 3;


    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.spanner.admin.database.v1.RestoreInfo restore_info = 4;


    pub fn get_restore_info(&self) -> &RestoreInfo {
        self.restore_info.as_ref().unwrap_or_else(|| <RestoreInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_restore_info(&mut self) {
        self.restore_info.clear();
    }

    pub fn has_restore_info(&self) -> bool {
        self.restore_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_restore_info(&mut self, v: RestoreInfo) {
        self.restore_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_restore_info(&mut self) -> &mut RestoreInfo {
        if self.restore_info.is_none() {
            self.restore_info.set_default();
        }
        self.restore_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_restore_info(&mut self) -> RestoreInfo {
        self.restore_info.take().unwrap_or_else(|| RestoreInfo::new())
    }

    // .google.spanner.admin.database.v1.EncryptionConfig encryption_config = 5;


    pub fn get_encryption_config(&self) -> &super::common::EncryptionConfig {
        self.encryption_config.as_ref().unwrap_or_else(|| <super::common::EncryptionConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_encryption_config(&mut self) {
        self.encryption_config.clear();
    }

    pub fn has_encryption_config(&self) -> bool {
        self.encryption_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_config(&mut self, v: super::common::EncryptionConfig) {
        self.encryption_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_config(&mut self) -> &mut super::common::EncryptionConfig {
        if self.encryption_config.is_none() {
            self.encryption_config.set_default();
        }
        self.encryption_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryption_config(&mut self) -> super::common::EncryptionConfig {
        self.encryption_config.take().unwrap_or_else(|| super::common::EncryptionConfig::new())
    }

    // repeated .google.spanner.admin.database.v1.EncryptionInfo encryption_info = 8;


    pub fn get_encryption_info(&self) -> &[super::common::EncryptionInfo] {
        &self.encryption_info
    }
    pub fn clear_encryption_info(&mut self) {
        self.encryption_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_encryption_info(&mut self, v: ::protobuf::RepeatedField<super::common::EncryptionInfo>) {
        self.encryption_info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_encryption_info(&mut self) -> &mut ::protobuf::RepeatedField<super::common::EncryptionInfo> {
        &mut self.encryption_info
    }

    // Take field
    pub fn take_encryption_info(&mut self) -> ::protobuf::RepeatedField<super::common::EncryptionInfo> {
        ::std::mem::replace(&mut self.encryption_info, ::protobuf::RepeatedField::new())
    }

    // string version_retention_period = 6;


    pub fn get_version_retention_period(&self) -> &str {
        &self.version_retention_period
    }
    pub fn clear_version_retention_period(&mut self) {
        self.version_retention_period.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_retention_period(&mut self, v: ::std::string::String) {
        self.version_retention_period = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_retention_period(&mut self) -> &mut ::std::string::String {
        &mut self.version_retention_period
    }

    // Take field
    pub fn take_version_retention_period(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_retention_period, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp earliest_version_time = 7;


    pub fn get_earliest_version_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.earliest_version_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_earliest_version_time(&mut self) {
        self.earliest_version_time.clear();
    }

    pub fn has_earliest_version_time(&self) -> bool {
        self.earliest_version_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_earliest_version_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.earliest_version_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_earliest_version_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.earliest_version_time.is_none() {
            self.earliest_version_time.set_default();
        }
        self.earliest_version_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_earliest_version_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.earliest_version_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for Database {
    fn is_initialized(&self) -> bool {
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.restore_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.encryption_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.encryption_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.earliest_version_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.restore_info)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.encryption_config)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.encryption_info)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version_retention_period)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.earliest_version_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.state != Database_State::STATE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(2, self.state);
        }
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.restore_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.encryption_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.encryption_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.version_retention_period.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.version_retention_period);
        }
        if let Some(ref v) = self.earliest_version_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.state != Database_State::STATE_UNSPECIFIED {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.restore_info.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.encryption_config.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.encryption_info {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.version_retention_period.is_empty() {
            os.write_string(6, &self.version_retention_period)?;
        }
        if let Some(ref v) = self.earliest_version_time.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Database {
        Database::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Database| { &m.name },
                |m: &mut Database| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Database_State>>(
                "state",
                |m: &Database| { &m.state },
                |m: &mut Database| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "create_time",
                |m: &Database| { &m.create_time },
                |m: &mut Database| { &mut m.create_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RestoreInfo>>(
                "restore_info",
                |m: &Database| { &m.restore_info },
                |m: &mut Database| { &mut m.restore_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::EncryptionConfig>>(
                "encryption_config",
                |m: &Database| { &m.encryption_config },
                |m: &mut Database| { &mut m.encryption_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::EncryptionInfo>>(
                "encryption_info",
                |m: &Database| { &m.encryption_info },
                |m: &mut Database| { &mut m.encryption_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_retention_period",
                |m: &Database| { &m.version_retention_period },
                |m: &mut Database| { &mut m.version_retention_period },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "earliest_version_time",
                |m: &Database| { &m.earliest_version_time },
                |m: &mut Database| { &mut m.earliest_version_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Database>(
                "Database",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Database {
        static instance: ::protobuf::rt::LazyV2<Database> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Database::new)
    }
}

impl ::protobuf::Clear for Database {
    fn clear(&mut self) {
        self.name.clear();
        self.state = Database_State::STATE_UNSPECIFIED;
        self.create_time.clear();
        self.restore_info.clear();
        self.encryption_config.clear();
        self.encryption_info.clear();
        self.version_retention_period.clear();
        self.earliest_version_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Database {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Database {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Database_State {
    STATE_UNSPECIFIED = 0,
    CREATING = 1,
    READY = 2,
    READY_OPTIMIZING = 3,
}

impl ::protobuf::ProtobufEnum for Database_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Database_State> {
        match value {
            0 => ::std::option::Option::Some(Database_State::STATE_UNSPECIFIED),
            1 => ::std::option::Option::Some(Database_State::CREATING),
            2 => ::std::option::Option::Some(Database_State::READY),
            3 => ::std::option::Option::Some(Database_State::READY_OPTIMIZING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Database_State] = &[
            Database_State::STATE_UNSPECIFIED,
            Database_State::CREATING,
            Database_State::READY,
            Database_State::READY_OPTIMIZING,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Database_State>("Database.State", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Database_State {
}

impl ::std::default::Default for Database_State {
    fn default() -> Self {
        Database_State::STATE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Database_State {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListDatabasesRequest {
    // message fields
    pub parent: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListDatabasesRequest {
    fn default() -> &'a ListDatabasesRequest {
        <ListDatabasesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListDatabasesRequest {
    pub fn new() -> ListDatabasesRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // int32 page_size = 3;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 4;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListDatabasesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if self.page_size != 0 {
            os.write_int32(3, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(4, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListDatabasesRequest {
        ListDatabasesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListDatabasesRequest| { &m.parent },
                |m: &mut ListDatabasesRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListDatabasesRequest| { &m.page_size },
                |m: &mut ListDatabasesRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListDatabasesRequest| { &m.page_token },
                |m: &mut ListDatabasesRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListDatabasesRequest>(
                "ListDatabasesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListDatabasesRequest {
        static instance: ::protobuf::rt::LazyV2<ListDatabasesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListDatabasesRequest::new)
    }
}

impl ::protobuf::Clear for ListDatabasesRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListDatabasesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDatabasesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListDatabasesResponse {
    // message fields
    pub databases: ::protobuf::RepeatedField<Database>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListDatabasesResponse {
    fn default() -> &'a ListDatabasesResponse {
        <ListDatabasesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListDatabasesResponse {
    pub fn new() -> ListDatabasesResponse {
        ::std::default::Default::default()
    }

    // repeated .google.spanner.admin.database.v1.Database databases = 1;


    pub fn get_databases(&self) -> &[Database] {
        &self.databases
    }
    pub fn clear_databases(&mut self) {
        self.databases.clear();
    }

    // Param is passed by value, moved
    pub fn set_databases(&mut self, v: ::protobuf::RepeatedField<Database>) {
        self.databases = v;
    }

    // Mutable pointer to the field.
    pub fn mut_databases(&mut self) -> &mut ::protobuf::RepeatedField<Database> {
        &mut self.databases
    }

    // Take field
    pub fn take_databases(&mut self) -> ::protobuf::RepeatedField<Database> {
        ::std::mem::replace(&mut self.databases, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListDatabasesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.databases {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.databases)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.databases {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.databases {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListDatabasesResponse {
        ListDatabasesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Database>>(
                "databases",
                |m: &ListDatabasesResponse| { &m.databases },
                |m: &mut ListDatabasesResponse| { &mut m.databases },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListDatabasesResponse| { &m.next_page_token },
                |m: &mut ListDatabasesResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListDatabasesResponse>(
                "ListDatabasesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListDatabasesResponse {
        static instance: ::protobuf::rt::LazyV2<ListDatabasesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListDatabasesResponse::new)
    }
}

impl ::protobuf::Clear for ListDatabasesResponse {
    fn clear(&mut self) {
        self.databases.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListDatabasesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDatabasesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateDatabaseRequest {
    // message fields
    pub parent: ::std::string::String,
    pub create_statement: ::std::string::String,
    pub extra_statements: ::protobuf::RepeatedField<::std::string::String>,
    pub encryption_config: ::protobuf::SingularPtrField<super::common::EncryptionConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateDatabaseRequest {
    fn default() -> &'a CreateDatabaseRequest {
        <CreateDatabaseRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateDatabaseRequest {
    pub fn new() -> CreateDatabaseRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string create_statement = 2;


    pub fn get_create_statement(&self) -> &str {
        &self.create_statement
    }
    pub fn clear_create_statement(&mut self) {
        self.create_statement.clear();
    }

    // Param is passed by value, moved
    pub fn set_create_statement(&mut self, v: ::std::string::String) {
        self.create_statement = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_statement(&mut self) -> &mut ::std::string::String {
        &mut self.create_statement
    }

    // Take field
    pub fn take_create_statement(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.create_statement, ::std::string::String::new())
    }

    // repeated string extra_statements = 3;


    pub fn get_extra_statements(&self) -> &[::std::string::String] {
        &self.extra_statements
    }
    pub fn clear_extra_statements(&mut self) {
        self.extra_statements.clear();
    }

    // Param is passed by value, moved
    pub fn set_extra_statements(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.extra_statements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extra_statements(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.extra_statements
    }

    // Take field
    pub fn take_extra_statements(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.extra_statements, ::protobuf::RepeatedField::new())
    }

    // .google.spanner.admin.database.v1.EncryptionConfig encryption_config = 4;


    pub fn get_encryption_config(&self) -> &super::common::EncryptionConfig {
        self.encryption_config.as_ref().unwrap_or_else(|| <super::common::EncryptionConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_encryption_config(&mut self) {
        self.encryption_config.clear();
    }

    pub fn has_encryption_config(&self) -> bool {
        self.encryption_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_config(&mut self, v: super::common::EncryptionConfig) {
        self.encryption_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_config(&mut self) -> &mut super::common::EncryptionConfig {
        if self.encryption_config.is_none() {
            self.encryption_config.set_default();
        }
        self.encryption_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryption_config(&mut self) -> super::common::EncryptionConfig {
        self.encryption_config.take().unwrap_or_else(|| super::common::EncryptionConfig::new())
    }
}

impl ::protobuf::Message for CreateDatabaseRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.encryption_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.create_statement)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.extra_statements)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.encryption_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.create_statement.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.create_statement);
        }
        for value in &self.extra_statements {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(ref v) = self.encryption_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.create_statement.is_empty() {
            os.write_string(2, &self.create_statement)?;
        }
        for v in &self.extra_statements {
            os.write_string(3, &v)?;
        };
        if let Some(ref v) = self.encryption_config.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateDatabaseRequest {
        CreateDatabaseRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &CreateDatabaseRequest| { &m.parent },
                |m: &mut CreateDatabaseRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "create_statement",
                |m: &CreateDatabaseRequest| { &m.create_statement },
                |m: &mut CreateDatabaseRequest| { &mut m.create_statement },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "extra_statements",
                |m: &CreateDatabaseRequest| { &m.extra_statements },
                |m: &mut CreateDatabaseRequest| { &mut m.extra_statements },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::EncryptionConfig>>(
                "encryption_config",
                |m: &CreateDatabaseRequest| { &m.encryption_config },
                |m: &mut CreateDatabaseRequest| { &mut m.encryption_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateDatabaseRequest>(
                "CreateDatabaseRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateDatabaseRequest {
        static instance: ::protobuf::rt::LazyV2<CreateDatabaseRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateDatabaseRequest::new)
    }
}

impl ::protobuf::Clear for CreateDatabaseRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.create_statement.clear();
        self.extra_statements.clear();
        self.encryption_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateDatabaseRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateDatabaseRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateDatabaseMetadata {
    // message fields
    pub database: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateDatabaseMetadata {
    fn default() -> &'a CreateDatabaseMetadata {
        <CreateDatabaseMetadata as ::protobuf::Message>::default_instance()
    }
}

impl CreateDatabaseMetadata {
    pub fn new() -> CreateDatabaseMetadata {
        ::std::default::Default::default()
    }

    // string database = 1;


    pub fn get_database(&self) -> &str {
        &self.database
    }
    pub fn clear_database(&mut self) {
        self.database.clear();
    }

    // Param is passed by value, moved
    pub fn set_database(&mut self, v: ::std::string::String) {
        self.database = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_database(&mut self) -> &mut ::std::string::String {
        &mut self.database
    }

    // Take field
    pub fn take_database(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.database, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateDatabaseMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.database)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.database.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.database);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.database.is_empty() {
            os.write_string(1, &self.database)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateDatabaseMetadata {
        CreateDatabaseMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "database",
                |m: &CreateDatabaseMetadata| { &m.database },
                |m: &mut CreateDatabaseMetadata| { &mut m.database },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateDatabaseMetadata>(
                "CreateDatabaseMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateDatabaseMetadata {
        static instance: ::protobuf::rt::LazyV2<CreateDatabaseMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateDatabaseMetadata::new)
    }
}

impl ::protobuf::Clear for CreateDatabaseMetadata {
    fn clear(&mut self) {
        self.database.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateDatabaseMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateDatabaseMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDatabaseRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDatabaseRequest {
    fn default() -> &'a GetDatabaseRequest {
        <GetDatabaseRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDatabaseRequest {
    pub fn new() -> GetDatabaseRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetDatabaseRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDatabaseRequest {
        GetDatabaseRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetDatabaseRequest| { &m.name },
                |m: &mut GetDatabaseRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDatabaseRequest>(
                "GetDatabaseRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetDatabaseRequest {
        static instance: ::protobuf::rt::LazyV2<GetDatabaseRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetDatabaseRequest::new)
    }
}

impl ::protobuf::Clear for GetDatabaseRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDatabaseRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatabaseRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateDatabaseDdlRequest {
    // message fields
    pub database: ::std::string::String,
    pub statements: ::protobuf::RepeatedField<::std::string::String>,
    pub operation_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateDatabaseDdlRequest {
    fn default() -> &'a UpdateDatabaseDdlRequest {
        <UpdateDatabaseDdlRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateDatabaseDdlRequest {
    pub fn new() -> UpdateDatabaseDdlRequest {
        ::std::default::Default::default()
    }

    // string database = 1;


    pub fn get_database(&self) -> &str {
        &self.database
    }
    pub fn clear_database(&mut self) {
        self.database.clear();
    }

    // Param is passed by value, moved
    pub fn set_database(&mut self, v: ::std::string::String) {
        self.database = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_database(&mut self) -> &mut ::std::string::String {
        &mut self.database
    }

    // Take field
    pub fn take_database(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.database, ::std::string::String::new())
    }

    // repeated string statements = 2;


    pub fn get_statements(&self) -> &[::std::string::String] {
        &self.statements
    }
    pub fn clear_statements(&mut self) {
        self.statements.clear();
    }

    // Param is passed by value, moved
    pub fn set_statements(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.statements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statements(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.statements
    }

    // Take field
    pub fn take_statements(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.statements, ::protobuf::RepeatedField::new())
    }

    // string operation_id = 3;


    pub fn get_operation_id(&self) -> &str {
        &self.operation_id
    }
    pub fn clear_operation_id(&mut self) {
        self.operation_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_operation_id(&mut self, v: ::std::string::String) {
        self.operation_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation_id(&mut self) -> &mut ::std::string::String {
        &mut self.operation_id
    }

    // Take field
    pub fn take_operation_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.operation_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UpdateDatabaseDdlRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.database)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.statements)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.operation_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.database.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.database);
        }
        for value in &self.statements {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if !self.operation_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.operation_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.database.is_empty() {
            os.write_string(1, &self.database)?;
        }
        for v in &self.statements {
            os.write_string(2, &v)?;
        };
        if !self.operation_id.is_empty() {
            os.write_string(3, &self.operation_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateDatabaseDdlRequest {
        UpdateDatabaseDdlRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "database",
                |m: &UpdateDatabaseDdlRequest| { &m.database },
                |m: &mut UpdateDatabaseDdlRequest| { &mut m.database },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "statements",
                |m: &UpdateDatabaseDdlRequest| { &m.statements },
                |m: &mut UpdateDatabaseDdlRequest| { &mut m.statements },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "operation_id",
                |m: &UpdateDatabaseDdlRequest| { &m.operation_id },
                |m: &mut UpdateDatabaseDdlRequest| { &mut m.operation_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateDatabaseDdlRequest>(
                "UpdateDatabaseDdlRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateDatabaseDdlRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateDatabaseDdlRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateDatabaseDdlRequest::new)
    }
}

impl ::protobuf::Clear for UpdateDatabaseDdlRequest {
    fn clear(&mut self) {
        self.database.clear();
        self.statements.clear();
        self.operation_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateDatabaseDdlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateDatabaseDdlRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateDatabaseDdlMetadata {
    // message fields
    pub database: ::std::string::String,
    pub statements: ::protobuf::RepeatedField<::std::string::String>,
    pub commit_timestamps: ::protobuf::RepeatedField<::protobuf::well_known_types::Timestamp>,
    pub throttled: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateDatabaseDdlMetadata {
    fn default() -> &'a UpdateDatabaseDdlMetadata {
        <UpdateDatabaseDdlMetadata as ::protobuf::Message>::default_instance()
    }
}

impl UpdateDatabaseDdlMetadata {
    pub fn new() -> UpdateDatabaseDdlMetadata {
        ::std::default::Default::default()
    }

    // string database = 1;


    pub fn get_database(&self) -> &str {
        &self.database
    }
    pub fn clear_database(&mut self) {
        self.database.clear();
    }

    // Param is passed by value, moved
    pub fn set_database(&mut self, v: ::std::string::String) {
        self.database = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_database(&mut self) -> &mut ::std::string::String {
        &mut self.database
    }

    // Take field
    pub fn take_database(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.database, ::std::string::String::new())
    }

    // repeated string statements = 2;


    pub fn get_statements(&self) -> &[::std::string::String] {
        &self.statements
    }
    pub fn clear_statements(&mut self) {
        self.statements.clear();
    }

    // Param is passed by value, moved
    pub fn set_statements(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.statements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statements(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.statements
    }

    // Take field
    pub fn take_statements(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.statements, ::protobuf::RepeatedField::new())
    }

    // repeated .google.protobuf.Timestamp commit_timestamps = 3;


    pub fn get_commit_timestamps(&self) -> &[::protobuf::well_known_types::Timestamp] {
        &self.commit_timestamps
    }
    pub fn clear_commit_timestamps(&mut self) {
        self.commit_timestamps.clear();
    }

    // Param is passed by value, moved
    pub fn set_commit_timestamps(&mut self, v: ::protobuf::RepeatedField<::protobuf::well_known_types::Timestamp>) {
        self.commit_timestamps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_commit_timestamps(&mut self) -> &mut ::protobuf::RepeatedField<::protobuf::well_known_types::Timestamp> {
        &mut self.commit_timestamps
    }

    // Take field
    pub fn take_commit_timestamps(&mut self) -> ::protobuf::RepeatedField<::protobuf::well_known_types::Timestamp> {
        ::std::mem::replace(&mut self.commit_timestamps, ::protobuf::RepeatedField::new())
    }

    // bool throttled = 4;


    pub fn get_throttled(&self) -> bool {
        self.throttled
    }
    pub fn clear_throttled(&mut self) {
        self.throttled = false;
    }

    // Param is passed by value, moved
    pub fn set_throttled(&mut self, v: bool) {
        self.throttled = v;
    }
}

impl ::protobuf::Message for UpdateDatabaseDdlMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.commit_timestamps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.database)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.statements)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.commit_timestamps)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.throttled = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.database.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.database);
        }
        for value in &self.statements {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.commit_timestamps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.throttled != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.database.is_empty() {
            os.write_string(1, &self.database)?;
        }
        for v in &self.statements {
            os.write_string(2, &v)?;
        };
        for v in &self.commit_timestamps {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.throttled != false {
            os.write_bool(4, self.throttled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateDatabaseDdlMetadata {
        UpdateDatabaseDdlMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "database",
                |m: &UpdateDatabaseDdlMetadata| { &m.database },
                |m: &mut UpdateDatabaseDdlMetadata| { &mut m.database },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "statements",
                |m: &UpdateDatabaseDdlMetadata| { &m.statements },
                |m: &mut UpdateDatabaseDdlMetadata| { &mut m.statements },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "commit_timestamps",
                |m: &UpdateDatabaseDdlMetadata| { &m.commit_timestamps },
                |m: &mut UpdateDatabaseDdlMetadata| { &mut m.commit_timestamps },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "throttled",
                |m: &UpdateDatabaseDdlMetadata| { &m.throttled },
                |m: &mut UpdateDatabaseDdlMetadata| { &mut m.throttled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateDatabaseDdlMetadata>(
                "UpdateDatabaseDdlMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateDatabaseDdlMetadata {
        static instance: ::protobuf::rt::LazyV2<UpdateDatabaseDdlMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateDatabaseDdlMetadata::new)
    }
}

impl ::protobuf::Clear for UpdateDatabaseDdlMetadata {
    fn clear(&mut self) {
        self.database.clear();
        self.statements.clear();
        self.commit_timestamps.clear();
        self.throttled = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateDatabaseDdlMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateDatabaseDdlMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DropDatabaseRequest {
    // message fields
    pub database: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DropDatabaseRequest {
    fn default() -> &'a DropDatabaseRequest {
        <DropDatabaseRequest as ::protobuf::Message>::default_instance()
    }
}

impl DropDatabaseRequest {
    pub fn new() -> DropDatabaseRequest {
        ::std::default::Default::default()
    }

    // string database = 1;


    pub fn get_database(&self) -> &str {
        &self.database
    }
    pub fn clear_database(&mut self) {
        self.database.clear();
    }

    // Param is passed by value, moved
    pub fn set_database(&mut self, v: ::std::string::String) {
        self.database = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_database(&mut self) -> &mut ::std::string::String {
        &mut self.database
    }

    // Take field
    pub fn take_database(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.database, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DropDatabaseRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.database)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.database.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.database);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.database.is_empty() {
            os.write_string(1, &self.database)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DropDatabaseRequest {
        DropDatabaseRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "database",
                |m: &DropDatabaseRequest| { &m.database },
                |m: &mut DropDatabaseRequest| { &mut m.database },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DropDatabaseRequest>(
                "DropDatabaseRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DropDatabaseRequest {
        static instance: ::protobuf::rt::LazyV2<DropDatabaseRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DropDatabaseRequest::new)
    }
}

impl ::protobuf::Clear for DropDatabaseRequest {
    fn clear(&mut self) {
        self.database.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DropDatabaseRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DropDatabaseRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDatabaseDdlRequest {
    // message fields
    pub database: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDatabaseDdlRequest {
    fn default() -> &'a GetDatabaseDdlRequest {
        <GetDatabaseDdlRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDatabaseDdlRequest {
    pub fn new() -> GetDatabaseDdlRequest {
        ::std::default::Default::default()
    }

    // string database = 1;


    pub fn get_database(&self) -> &str {
        &self.database
    }
    pub fn clear_database(&mut self) {
        self.database.clear();
    }

    // Param is passed by value, moved
    pub fn set_database(&mut self, v: ::std::string::String) {
        self.database = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_database(&mut self) -> &mut ::std::string::String {
        &mut self.database
    }

    // Take field
    pub fn take_database(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.database, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetDatabaseDdlRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.database)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.database.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.database);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.database.is_empty() {
            os.write_string(1, &self.database)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDatabaseDdlRequest {
        GetDatabaseDdlRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "database",
                |m: &GetDatabaseDdlRequest| { &m.database },
                |m: &mut GetDatabaseDdlRequest| { &mut m.database },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDatabaseDdlRequest>(
                "GetDatabaseDdlRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetDatabaseDdlRequest {
        static instance: ::protobuf::rt::LazyV2<GetDatabaseDdlRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetDatabaseDdlRequest::new)
    }
}

impl ::protobuf::Clear for GetDatabaseDdlRequest {
    fn clear(&mut self) {
        self.database.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDatabaseDdlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatabaseDdlRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDatabaseDdlResponse {
    // message fields
    pub statements: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDatabaseDdlResponse {
    fn default() -> &'a GetDatabaseDdlResponse {
        <GetDatabaseDdlResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetDatabaseDdlResponse {
    pub fn new() -> GetDatabaseDdlResponse {
        ::std::default::Default::default()
    }

    // repeated string statements = 1;


    pub fn get_statements(&self) -> &[::std::string::String] {
        &self.statements
    }
    pub fn clear_statements(&mut self) {
        self.statements.clear();
    }

    // Param is passed by value, moved
    pub fn set_statements(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.statements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statements(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.statements
    }

    // Take field
    pub fn take_statements(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.statements, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetDatabaseDdlResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.statements)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.statements {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.statements {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDatabaseDdlResponse {
        GetDatabaseDdlResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "statements",
                |m: &GetDatabaseDdlResponse| { &m.statements },
                |m: &mut GetDatabaseDdlResponse| { &mut m.statements },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDatabaseDdlResponse>(
                "GetDatabaseDdlResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetDatabaseDdlResponse {
        static instance: ::protobuf::rt::LazyV2<GetDatabaseDdlResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetDatabaseDdlResponse::new)
    }
}

impl ::protobuf::Clear for GetDatabaseDdlResponse {
    fn clear(&mut self) {
        self.statements.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDatabaseDdlResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatabaseDdlResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListDatabaseOperationsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub filter: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListDatabaseOperationsRequest {
    fn default() -> &'a ListDatabaseOperationsRequest {
        <ListDatabaseOperationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListDatabaseOperationsRequest {
    pub fn new() -> ListDatabaseOperationsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string filter = 2;


    pub fn get_filter(&self) -> &str {
        &self.filter
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }

    // int32 page_size = 3;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 4;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListDatabaseOperationsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.filter);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.filter.is_empty() {
            os.write_string(2, &self.filter)?;
        }
        if self.page_size != 0 {
            os.write_int32(3, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(4, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListDatabaseOperationsRequest {
        ListDatabaseOperationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListDatabaseOperationsRequest| { &m.parent },
                |m: &mut ListDatabaseOperationsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &ListDatabaseOperationsRequest| { &m.filter },
                |m: &mut ListDatabaseOperationsRequest| { &mut m.filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListDatabaseOperationsRequest| { &m.page_size },
                |m: &mut ListDatabaseOperationsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListDatabaseOperationsRequest| { &m.page_token },
                |m: &mut ListDatabaseOperationsRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListDatabaseOperationsRequest>(
                "ListDatabaseOperationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListDatabaseOperationsRequest {
        static instance: ::protobuf::rt::LazyV2<ListDatabaseOperationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListDatabaseOperationsRequest::new)
    }
}

impl ::protobuf::Clear for ListDatabaseOperationsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.filter.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListDatabaseOperationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDatabaseOperationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListDatabaseOperationsResponse {
    // message fields
    pub operations: ::protobuf::RepeatedField<super::operations::Operation>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListDatabaseOperationsResponse {
    fn default() -> &'a ListDatabaseOperationsResponse {
        <ListDatabaseOperationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListDatabaseOperationsResponse {
    pub fn new() -> ListDatabaseOperationsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.longrunning.Operation operations = 1;


    pub fn get_operations(&self) -> &[super::operations::Operation] {
        &self.operations
    }
    pub fn clear_operations(&mut self) {
        self.operations.clear();
    }

    // Param is passed by value, moved
    pub fn set_operations(&mut self, v: ::protobuf::RepeatedField<super::operations::Operation>) {
        self.operations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_operations(&mut self) -> &mut ::protobuf::RepeatedField<super::operations::Operation> {
        &mut self.operations
    }

    // Take field
    pub fn take_operations(&mut self) -> ::protobuf::RepeatedField<super::operations::Operation> {
        ::std::mem::replace(&mut self.operations, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListDatabaseOperationsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.operations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.operations)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.operations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.operations {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListDatabaseOperationsResponse {
        ListDatabaseOperationsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::operations::Operation>>(
                "operations",
                |m: &ListDatabaseOperationsResponse| { &m.operations },
                |m: &mut ListDatabaseOperationsResponse| { &mut m.operations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListDatabaseOperationsResponse| { &m.next_page_token },
                |m: &mut ListDatabaseOperationsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListDatabaseOperationsResponse>(
                "ListDatabaseOperationsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListDatabaseOperationsResponse {
        static instance: ::protobuf::rt::LazyV2<ListDatabaseOperationsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListDatabaseOperationsResponse::new)
    }
}

impl ::protobuf::Clear for ListDatabaseOperationsResponse {
    fn clear(&mut self) {
        self.operations.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListDatabaseOperationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDatabaseOperationsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RestoreDatabaseRequest {
    // message fields
    pub parent: ::std::string::String,
    pub database_id: ::std::string::String,
    pub encryption_config: ::protobuf::SingularPtrField<RestoreDatabaseEncryptionConfig>,
    // message oneof groups
    pub source: ::std::option::Option<RestoreDatabaseRequest_oneof_source>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RestoreDatabaseRequest {
    fn default() -> &'a RestoreDatabaseRequest {
        <RestoreDatabaseRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RestoreDatabaseRequest_oneof_source {
    backup(::std::string::String),
}

impl RestoreDatabaseRequest {
    pub fn new() -> RestoreDatabaseRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string database_id = 2;


    pub fn get_database_id(&self) -> &str {
        &self.database_id
    }
    pub fn clear_database_id(&mut self) {
        self.database_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_database_id(&mut self, v: ::std::string::String) {
        self.database_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_database_id(&mut self) -> &mut ::std::string::String {
        &mut self.database_id
    }

    // Take field
    pub fn take_database_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.database_id, ::std::string::String::new())
    }

    // string backup = 3;


    pub fn get_backup(&self) -> &str {
        match self.source {
            ::std::option::Option::Some(RestoreDatabaseRequest_oneof_source::backup(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_backup(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_backup(&self) -> bool {
        match self.source {
            ::std::option::Option::Some(RestoreDatabaseRequest_oneof_source::backup(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_backup(&mut self, v: ::std::string::String) {
        self.source = ::std::option::Option::Some(RestoreDatabaseRequest_oneof_source::backup(v))
    }

    // Mutable pointer to the field.
    pub fn mut_backup(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RestoreDatabaseRequest_oneof_source::backup(_)) = self.source {
        } else {
            self.source = ::std::option::Option::Some(RestoreDatabaseRequest_oneof_source::backup(::std::string::String::new()));
        }
        match self.source {
            ::std::option::Option::Some(RestoreDatabaseRequest_oneof_source::backup(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_backup(&mut self) -> ::std::string::String {
        if self.has_backup() {
            match self.source.take() {
                ::std::option::Option::Some(RestoreDatabaseRequest_oneof_source::backup(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .google.spanner.admin.database.v1.RestoreDatabaseEncryptionConfig encryption_config = 4;


    pub fn get_encryption_config(&self) -> &RestoreDatabaseEncryptionConfig {
        self.encryption_config.as_ref().unwrap_or_else(|| <RestoreDatabaseEncryptionConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_encryption_config(&mut self) {
        self.encryption_config.clear();
    }

    pub fn has_encryption_config(&self) -> bool {
        self.encryption_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_config(&mut self, v: RestoreDatabaseEncryptionConfig) {
        self.encryption_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_config(&mut self) -> &mut RestoreDatabaseEncryptionConfig {
        if self.encryption_config.is_none() {
            self.encryption_config.set_default();
        }
        self.encryption_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryption_config(&mut self) -> RestoreDatabaseEncryptionConfig {
        self.encryption_config.take().unwrap_or_else(|| RestoreDatabaseEncryptionConfig::new())
    }
}

impl ::protobuf::Message for RestoreDatabaseRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.encryption_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.database_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.source = ::std::option::Option::Some(RestoreDatabaseRequest_oneof_source::backup(is.read_string()?));
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.encryption_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.database_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.database_id);
        }
        if let Some(ref v) = self.encryption_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.source {
            match v {
                &RestoreDatabaseRequest_oneof_source::backup(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.database_id.is_empty() {
            os.write_string(2, &self.database_id)?;
        }
        if let Some(ref v) = self.encryption_config.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.source {
            match v {
                &RestoreDatabaseRequest_oneof_source::backup(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RestoreDatabaseRequest {
        RestoreDatabaseRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &RestoreDatabaseRequest| { &m.parent },
                |m: &mut RestoreDatabaseRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "database_id",
                |m: &RestoreDatabaseRequest| { &m.database_id },
                |m: &mut RestoreDatabaseRequest| { &mut m.database_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "backup",
                RestoreDatabaseRequest::has_backup,
                RestoreDatabaseRequest::get_backup,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RestoreDatabaseEncryptionConfig>>(
                "encryption_config",
                |m: &RestoreDatabaseRequest| { &m.encryption_config },
                |m: &mut RestoreDatabaseRequest| { &mut m.encryption_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RestoreDatabaseRequest>(
                "RestoreDatabaseRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RestoreDatabaseRequest {
        static instance: ::protobuf::rt::LazyV2<RestoreDatabaseRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RestoreDatabaseRequest::new)
    }
}

impl ::protobuf::Clear for RestoreDatabaseRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.database_id.clear();
        self.source = ::std::option::Option::None;
        self.encryption_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RestoreDatabaseRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreDatabaseRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RestoreDatabaseEncryptionConfig {
    // message fields
    pub encryption_type: RestoreDatabaseEncryptionConfig_EncryptionType,
    pub kms_key_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RestoreDatabaseEncryptionConfig {
    fn default() -> &'a RestoreDatabaseEncryptionConfig {
        <RestoreDatabaseEncryptionConfig as ::protobuf::Message>::default_instance()
    }
}

impl RestoreDatabaseEncryptionConfig {
    pub fn new() -> RestoreDatabaseEncryptionConfig {
        ::std::default::Default::default()
    }

    // .google.spanner.admin.database.v1.RestoreDatabaseEncryptionConfig.EncryptionType encryption_type = 1;


    pub fn get_encryption_type(&self) -> RestoreDatabaseEncryptionConfig_EncryptionType {
        self.encryption_type
    }
    pub fn clear_encryption_type(&mut self) {
        self.encryption_type = RestoreDatabaseEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_encryption_type(&mut self, v: RestoreDatabaseEncryptionConfig_EncryptionType) {
        self.encryption_type = v;
    }

    // string kms_key_name = 2;


    pub fn get_kms_key_name(&self) -> &str {
        &self.kms_key_name
    }
    pub fn clear_kms_key_name(&mut self) {
        self.kms_key_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_kms_key_name(&mut self, v: ::std::string::String) {
        self.kms_key_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kms_key_name(&mut self) -> &mut ::std::string::String {
        &mut self.kms_key_name
    }

    // Take field
    pub fn take_kms_key_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kms_key_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RestoreDatabaseEncryptionConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.encryption_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kms_key_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.encryption_type != RestoreDatabaseEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.encryption_type);
        }
        if !self.kms_key_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.kms_key_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.encryption_type != RestoreDatabaseEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.encryption_type))?;
        }
        if !self.kms_key_name.is_empty() {
            os.write_string(2, &self.kms_key_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RestoreDatabaseEncryptionConfig {
        RestoreDatabaseEncryptionConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RestoreDatabaseEncryptionConfig_EncryptionType>>(
                "encryption_type",
                |m: &RestoreDatabaseEncryptionConfig| { &m.encryption_type },
                |m: &mut RestoreDatabaseEncryptionConfig| { &mut m.encryption_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kms_key_name",
                |m: &RestoreDatabaseEncryptionConfig| { &m.kms_key_name },
                |m: &mut RestoreDatabaseEncryptionConfig| { &mut m.kms_key_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RestoreDatabaseEncryptionConfig>(
                "RestoreDatabaseEncryptionConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RestoreDatabaseEncryptionConfig {
        static instance: ::protobuf::rt::LazyV2<RestoreDatabaseEncryptionConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RestoreDatabaseEncryptionConfig::new)
    }
}

impl ::protobuf::Clear for RestoreDatabaseEncryptionConfig {
    fn clear(&mut self) {
        self.encryption_type = RestoreDatabaseEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED;
        self.kms_key_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RestoreDatabaseEncryptionConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreDatabaseEncryptionConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RestoreDatabaseEncryptionConfig_EncryptionType {
    ENCRYPTION_TYPE_UNSPECIFIED = 0,
    USE_CONFIG_DEFAULT_OR_BACKUP_ENCRYPTION = 1,
    GOOGLE_DEFAULT_ENCRYPTION = 2,
    CUSTOMER_MANAGED_ENCRYPTION = 3,
}

impl ::protobuf::ProtobufEnum for RestoreDatabaseEncryptionConfig_EncryptionType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RestoreDatabaseEncryptionConfig_EncryptionType> {
        match value {
            0 => ::std::option::Option::Some(RestoreDatabaseEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(RestoreDatabaseEncryptionConfig_EncryptionType::USE_CONFIG_DEFAULT_OR_BACKUP_ENCRYPTION),
            2 => ::std::option::Option::Some(RestoreDatabaseEncryptionConfig_EncryptionType::GOOGLE_DEFAULT_ENCRYPTION),
            3 => ::std::option::Option::Some(RestoreDatabaseEncryptionConfig_EncryptionType::CUSTOMER_MANAGED_ENCRYPTION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RestoreDatabaseEncryptionConfig_EncryptionType] = &[
            RestoreDatabaseEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED,
            RestoreDatabaseEncryptionConfig_EncryptionType::USE_CONFIG_DEFAULT_OR_BACKUP_ENCRYPTION,
            RestoreDatabaseEncryptionConfig_EncryptionType::GOOGLE_DEFAULT_ENCRYPTION,
            RestoreDatabaseEncryptionConfig_EncryptionType::CUSTOMER_MANAGED_ENCRYPTION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RestoreDatabaseEncryptionConfig_EncryptionType>("RestoreDatabaseEncryptionConfig.EncryptionType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RestoreDatabaseEncryptionConfig_EncryptionType {
}

impl ::std::default::Default for RestoreDatabaseEncryptionConfig_EncryptionType {
    fn default() -> Self {
        RestoreDatabaseEncryptionConfig_EncryptionType::ENCRYPTION_TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreDatabaseEncryptionConfig_EncryptionType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RestoreDatabaseMetadata {
    // message fields
    pub name: ::std::string::String,
    pub source_type: RestoreSourceType,
    pub progress: ::protobuf::SingularPtrField<super::common::OperationProgress>,
    pub cancel_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub optimize_database_operation_name: ::std::string::String,
    // message oneof groups
    pub source_info: ::std::option::Option<RestoreDatabaseMetadata_oneof_source_info>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RestoreDatabaseMetadata {
    fn default() -> &'a RestoreDatabaseMetadata {
        <RestoreDatabaseMetadata as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RestoreDatabaseMetadata_oneof_source_info {
    backup_info(super::backup::BackupInfo),
}

impl RestoreDatabaseMetadata {
    pub fn new() -> RestoreDatabaseMetadata {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.spanner.admin.database.v1.RestoreSourceType source_type = 2;


    pub fn get_source_type(&self) -> RestoreSourceType {
        self.source_type
    }
    pub fn clear_source_type(&mut self) {
        self.source_type = RestoreSourceType::TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_source_type(&mut self, v: RestoreSourceType) {
        self.source_type = v;
    }

    // .google.spanner.admin.database.v1.BackupInfo backup_info = 3;


    pub fn get_backup_info(&self) -> &super::backup::BackupInfo {
        match self.source_info {
            ::std::option::Option::Some(RestoreDatabaseMetadata_oneof_source_info::backup_info(ref v)) => v,
            _ => <super::backup::BackupInfo as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_backup_info(&mut self) {
        self.source_info = ::std::option::Option::None;
    }

    pub fn has_backup_info(&self) -> bool {
        match self.source_info {
            ::std::option::Option::Some(RestoreDatabaseMetadata_oneof_source_info::backup_info(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_backup_info(&mut self, v: super::backup::BackupInfo) {
        self.source_info = ::std::option::Option::Some(RestoreDatabaseMetadata_oneof_source_info::backup_info(v))
    }

    // Mutable pointer to the field.
    pub fn mut_backup_info(&mut self) -> &mut super::backup::BackupInfo {
        if let ::std::option::Option::Some(RestoreDatabaseMetadata_oneof_source_info::backup_info(_)) = self.source_info {
        } else {
            self.source_info = ::std::option::Option::Some(RestoreDatabaseMetadata_oneof_source_info::backup_info(super::backup::BackupInfo::new()));
        }
        match self.source_info {
            ::std::option::Option::Some(RestoreDatabaseMetadata_oneof_source_info::backup_info(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_backup_info(&mut self) -> super::backup::BackupInfo {
        if self.has_backup_info() {
            match self.source_info.take() {
                ::std::option::Option::Some(RestoreDatabaseMetadata_oneof_source_info::backup_info(v)) => v,
                _ => panic!(),
            }
        } else {
            super::backup::BackupInfo::new()
        }
    }

    // .google.spanner.admin.database.v1.OperationProgress progress = 4;


    pub fn get_progress(&self) -> &super::common::OperationProgress {
        self.progress.as_ref().unwrap_or_else(|| <super::common::OperationProgress as ::protobuf::Message>::default_instance())
    }
    pub fn clear_progress(&mut self) {
        self.progress.clear();
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: super::common::OperationProgress) {
        self.progress = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_progress(&mut self) -> &mut super::common::OperationProgress {
        if self.progress.is_none() {
            self.progress.set_default();
        }
        self.progress.as_mut().unwrap()
    }

    // Take field
    pub fn take_progress(&mut self) -> super::common::OperationProgress {
        self.progress.take().unwrap_or_else(|| super::common::OperationProgress::new())
    }

    // .google.protobuf.Timestamp cancel_time = 5;


    pub fn get_cancel_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.cancel_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cancel_time(&mut self) {
        self.cancel_time.clear();
    }

    pub fn has_cancel_time(&self) -> bool {
        self.cancel_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cancel_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.cancel_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cancel_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.cancel_time.is_none() {
            self.cancel_time.set_default();
        }
        self.cancel_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_cancel_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.cancel_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string optimize_database_operation_name = 6;


    pub fn get_optimize_database_operation_name(&self) -> &str {
        &self.optimize_database_operation_name
    }
    pub fn clear_optimize_database_operation_name(&mut self) {
        self.optimize_database_operation_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_optimize_database_operation_name(&mut self, v: ::std::string::String) {
        self.optimize_database_operation_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_optimize_database_operation_name(&mut self) -> &mut ::std::string::String {
        &mut self.optimize_database_operation_name
    }

    // Take field
    pub fn take_optimize_database_operation_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.optimize_database_operation_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RestoreDatabaseMetadata {
    fn is_initialized(&self) -> bool {
        if let Some(RestoreDatabaseMetadata_oneof_source_info::backup_info(ref v)) = self.source_info {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.progress {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cancel_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.source_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.source_info = ::std::option::Option::Some(RestoreDatabaseMetadata_oneof_source_info::backup_info(is.read_message()?));
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.progress)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cancel_time)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.optimize_database_operation_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.source_type != RestoreSourceType::TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(2, self.source_type);
        }
        if let Some(ref v) = self.progress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cancel_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.optimize_database_operation_name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.optimize_database_operation_name);
        }
        if let ::std::option::Option::Some(ref v) = self.source_info {
            match v {
                &RestoreDatabaseMetadata_oneof_source_info::backup_info(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.source_type != RestoreSourceType::TYPE_UNSPECIFIED {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.source_type))?;
        }
        if let Some(ref v) = self.progress.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cancel_time.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.optimize_database_operation_name.is_empty() {
            os.write_string(6, &self.optimize_database_operation_name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.source_info {
            match v {
                &RestoreDatabaseMetadata_oneof_source_info::backup_info(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RestoreDatabaseMetadata {
        RestoreDatabaseMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &RestoreDatabaseMetadata| { &m.name },
                |m: &mut RestoreDatabaseMetadata| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RestoreSourceType>>(
                "source_type",
                |m: &RestoreDatabaseMetadata| { &m.source_type },
                |m: &mut RestoreDatabaseMetadata| { &mut m.source_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::backup::BackupInfo>(
                "backup_info",
                RestoreDatabaseMetadata::has_backup_info,
                RestoreDatabaseMetadata::get_backup_info,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::OperationProgress>>(
                "progress",
                |m: &RestoreDatabaseMetadata| { &m.progress },
                |m: &mut RestoreDatabaseMetadata| { &mut m.progress },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "cancel_time",
                |m: &RestoreDatabaseMetadata| { &m.cancel_time },
                |m: &mut RestoreDatabaseMetadata| { &mut m.cancel_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "optimize_database_operation_name",
                |m: &RestoreDatabaseMetadata| { &m.optimize_database_operation_name },
                |m: &mut RestoreDatabaseMetadata| { &mut m.optimize_database_operation_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RestoreDatabaseMetadata>(
                "RestoreDatabaseMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RestoreDatabaseMetadata {
        static instance: ::protobuf::rt::LazyV2<RestoreDatabaseMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RestoreDatabaseMetadata::new)
    }
}

impl ::protobuf::Clear for RestoreDatabaseMetadata {
    fn clear(&mut self) {
        self.name.clear();
        self.source_type = RestoreSourceType::TYPE_UNSPECIFIED;
        self.source_info = ::std::option::Option::None;
        self.progress.clear();
        self.cancel_time.clear();
        self.optimize_database_operation_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RestoreDatabaseMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreDatabaseMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OptimizeRestoredDatabaseMetadata {
    // message fields
    pub name: ::std::string::String,
    pub progress: ::protobuf::SingularPtrField<super::common::OperationProgress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OptimizeRestoredDatabaseMetadata {
    fn default() -> &'a OptimizeRestoredDatabaseMetadata {
        <OptimizeRestoredDatabaseMetadata as ::protobuf::Message>::default_instance()
    }
}

impl OptimizeRestoredDatabaseMetadata {
    pub fn new() -> OptimizeRestoredDatabaseMetadata {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.spanner.admin.database.v1.OperationProgress progress = 2;


    pub fn get_progress(&self) -> &super::common::OperationProgress {
        self.progress.as_ref().unwrap_or_else(|| <super::common::OperationProgress as ::protobuf::Message>::default_instance())
    }
    pub fn clear_progress(&mut self) {
        self.progress.clear();
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: super::common::OperationProgress) {
        self.progress = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_progress(&mut self) -> &mut super::common::OperationProgress {
        if self.progress.is_none() {
            self.progress.set_default();
        }
        self.progress.as_mut().unwrap()
    }

    // Take field
    pub fn take_progress(&mut self) -> super::common::OperationProgress {
        self.progress.take().unwrap_or_else(|| super::common::OperationProgress::new())
    }
}

impl ::protobuf::Message for OptimizeRestoredDatabaseMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.progress {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.progress)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.progress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.progress.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OptimizeRestoredDatabaseMetadata {
        OptimizeRestoredDatabaseMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &OptimizeRestoredDatabaseMetadata| { &m.name },
                |m: &mut OptimizeRestoredDatabaseMetadata| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::OperationProgress>>(
                "progress",
                |m: &OptimizeRestoredDatabaseMetadata| { &m.progress },
                |m: &mut OptimizeRestoredDatabaseMetadata| { &mut m.progress },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OptimizeRestoredDatabaseMetadata>(
                "OptimizeRestoredDatabaseMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OptimizeRestoredDatabaseMetadata {
        static instance: ::protobuf::rt::LazyV2<OptimizeRestoredDatabaseMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OptimizeRestoredDatabaseMetadata::new)
    }
}

impl ::protobuf::Clear for OptimizeRestoredDatabaseMetadata {
    fn clear(&mut self) {
        self.name.clear();
        self.progress.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OptimizeRestoredDatabaseMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OptimizeRestoredDatabaseMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RestoreSourceType {
    TYPE_UNSPECIFIED = 0,
    BACKUP = 1,
}

impl ::protobuf::ProtobufEnum for RestoreSourceType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RestoreSourceType> {
        match value {
            0 => ::std::option::Option::Some(RestoreSourceType::TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(RestoreSourceType::BACKUP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RestoreSourceType] = &[
            RestoreSourceType::TYPE_UNSPECIFIED,
            RestoreSourceType::BACKUP,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RestoreSourceType>("RestoreSourceType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RestoreSourceType {
}

impl ::std::default::Default for RestoreSourceType {
    fn default() -> Self {
        RestoreSourceType::TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreSourceType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n=google/spanner/admin/database/v1/spanner_database_admin.proto\x12\x20\
    google.spanner.admin.database.v1\x1a\x1cgoogle/api/annotations.proto\x1a\
    \x17google/api/client.proto\x1a\x1fgoogle/api/field_behavior.proto\x1a\
    \x19google/api/resource.proto\x1a\x1egoogle/iam/v1/iam_policy.proto\x1a\
    \x1agoogle/iam/v1/policy.proto\x1a#google/longrunning/operations.proto\
    \x1a\x1bgoogle/protobuf/empty.proto\x1a\x1fgoogle/protobuf/timestamp.pro\
    to\x1a-google/spanner/admin/database/v1/backup.proto\x1a-google/spanner/\
    admin/database/v1/common.proto\"\xc3\x01\n\x0bRestoreInfo\x12T\n\x0bsour\
    ce_type\x18\x01\x20\x01(\x0e23.google.spanner.admin.database.v1.RestoreS\
    ourceTypeR\nsourceType\x12O\n\x0bbackup_info\x18\x02\x20\x01(\x0b2,.goog\
    le.spanner.admin.database.v1.BackupInfoH\0R\nbackupInfoB\r\n\x0bsource_i\
    nfo\"\x96\x06\n\x08Database\x12\x17\n\x04name\x18\x01\x20\x01(\tR\x04nam\
    eB\x03\xe0A\x02\x12K\n\x05state\x18\x02\x20\x01(\x0e20.google.spanner.ad\
    min.database.v1.Database.StateR\x05stateB\x03\xe0A\x03\x12@\n\x0bcreate_\
    time\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\ncreateTimeB\
    \x03\xe0A\x03\x12U\n\x0crestore_info\x18\x04\x20\x01(\x0b2-.google.spann\
    er.admin.database.v1.RestoreInfoR\x0brestoreInfoB\x03\xe0A\x03\x12d\n\
    \x11encryption_config\x18\x05\x20\x01(\x0b22.google.spanner.admin.databa\
    se.v1.EncryptionConfigR\x10encryptionConfigB\x03\xe0A\x03\x12^\n\x0fencr\
    yption_info\x18\x08\x20\x03(\x0b20.google.spanner.admin.database.v1.Encr\
    yptionInfoR\x0eencryptionInfoB\x03\xe0A\x03\x12=\n\x18version_retention_\
    period\x18\x06\x20\x01(\tR\x16versionRetentionPeriodB\x03\xe0A\x03\x12S\
    \n\x15earliest_version_time\x18\x07\x20\x01(\x0b2\x1a.google.protobuf.Ti\
    mestampR\x13earliestVersionTimeB\x03\xe0A\x03\"M\n\x05State\x12\x15\n\
    \x11STATE_UNSPECIFIED\x10\0\x12\x0c\n\x08CREATING\x10\x01\x12\t\n\x05REA\
    DY\x10\x02\x12\x14\n\x10READY_OPTIMIZING\x10\x03:b\xeaA_\n\x1fspanner.go\
    ogleapis.com/Database\x12<projects/{project}/instances/{instance}/databa\
    ses/{database}\"\x93\x01\n\x14ListDatabasesRequest\x12?\n\x06parent\x18\
    \x01\x20\x01(\tR\x06parentB'\xe0A\x02\xfaA!\n\x1fspanner.googleapis.com/\
    Instance\x12\x1b\n\tpage_size\x18\x03\x20\x01(\x05R\x08pageSize\x12\x1d\
    \n\npage_token\x18\x04\x20\x01(\tR\tpageToken\"\x89\x01\n\x15ListDatabas\
    esResponse\x12H\n\tdatabases\x18\x01\x20\x03(\x0b2*.google.spanner.admin\
    .database.v1.DatabaseR\tdatabases\x12&\n\x0fnext_page_token\x18\x02\x20\
    \x01(\tR\rnextPageToken\"\x9e\x02\n\x15CreateDatabaseRequest\x12?\n\x06p\
    arent\x18\x01\x20\x01(\tR\x06parentB'\xe0A\x02\xfaA!\n\x1fspanner.google\
    apis.com/Instance\x12.\n\x10create_statement\x18\x02\x20\x01(\tR\x0fcrea\
    teStatementB\x03\xe0A\x02\x12.\n\x10extra_statements\x18\x03\x20\x03(\tR\
    \x0fextraStatementsB\x03\xe0A\x01\x12d\n\x11encryption_config\x18\x04\
    \x20\x01(\x0b22.google.spanner.admin.database.v1.EncryptionConfigR\x10en\
    cryptionConfigB\x03\xe0A\x01\"Z\n\x16CreateDatabaseMetadata\x12@\n\x08da\
    tabase\x18\x01\x20\x01(\tR\x08databaseB$\xfaA!\n\x1fspanner.googleapis.c\
    om/Database\"Q\n\x12GetDatabaseRequest\x12;\n\x04name\x18\x01\x20\x01(\t\
    R\x04nameB'\xe0A\x02\xfaA!\n\x1fspanner.googleapis.com/Database\"\xa7\
    \x01\n\x18UpdateDatabaseDdlRequest\x12C\n\x08database\x18\x01\x20\x01(\t\
    R\x08databaseB'\xe0A\x02\xfaA!\n\x1fspanner.googleapis.com/Database\x12#\
    \n\nstatements\x18\x02\x20\x03(\tR\nstatementsB\x03\xe0A\x02\x12!\n\x0co\
    peration_id\x18\x03\x20\x01(\tR\x0boperationId\"\xe9\x01\n\x19UpdateData\
    baseDdlMetadata\x12@\n\x08database\x18\x01\x20\x01(\tR\x08databaseB$\xfa\
    A!\n\x1fspanner.googleapis.com/Database\x12\x1e\n\nstatements\x18\x02\
    \x20\x03(\tR\nstatements\x12G\n\x11commit_timestamps\x18\x03\x20\x03(\
    \x0b2\x1a.google.protobuf.TimestampR\x10commitTimestamps\x12!\n\tthrottl\
    ed\x18\x04\x20\x01(\x08R\tthrottledB\x03\xe0A\x03\"Z\n\x13DropDatabaseRe\
    quest\x12C\n\x08database\x18\x01\x20\x01(\tR\x08databaseB'\xfaA!\n\x1fsp\
    anner.googleapis.com/Database\xe0A\x02\"\\\n\x15GetDatabaseDdlRequest\
    \x12C\n\x08database\x18\x01\x20\x01(\tR\x08databaseB'\xe0A\x02\xfaA!\n\
    \x1fspanner.googleapis.com/Database\"8\n\x16GetDatabaseDdlResponse\x12\
    \x1e\n\nstatements\x18\x01\x20\x03(\tR\nstatements\"\xb4\x01\n\x1dListDa\
    tabaseOperationsRequest\x12?\n\x06parent\x18\x01\x20\x01(\tR\x06parentB'\
    \xe0A\x02\xfaA!\n\x1fspanner.googleapis.com/Instance\x12\x16\n\x06filter\
    \x18\x02\x20\x01(\tR\x06filter\x12\x1b\n\tpage_size\x18\x03\x20\x01(\x05\
    R\x08pageSize\x12\x1d\n\npage_token\x18\x04\x20\x01(\tR\tpageToken\"\x87\
    \x01\n\x1eListDatabaseOperationsResponse\x12=\n\noperations\x18\x01\x20\
    \x03(\x0b2\x1d.google.longrunning.OperationR\noperations\x12&\n\x0fnext_\
    page_token\x18\x02\x20\x01(\tR\rnextPageToken\"\xbc\x02\n\x16RestoreData\
    baseRequest\x12?\n\x06parent\x18\x01\x20\x01(\tR\x06parentB'\xe0A\x02\
    \xfaA!\n\x1fspanner.googleapis.com/Instance\x12$\n\x0bdatabase_id\x18\
    \x02\x20\x01(\tR\ndatabaseIdB\x03\xe0A\x02\x12<\n\x06backup\x18\x03\x20\
    \x01(\tH\0R\x06backupB\"\xfaA\x1f\n\x1dspanner.googleapis.com/Backup\x12\
    s\n\x11encryption_config\x18\x04\x20\x01(\x0b2A.google.spanner.admin.dat\
    abase.v1.RestoreDatabaseEncryptionConfigR\x10encryptionConfigB\x03\xe0A\
    \x01B\x08\n\x06source\"\x8f\x03\n\x1fRestoreDatabaseEncryptionConfig\x12\
    ~\n\x0fencryption_type\x18\x01\x20\x01(\x0e2P.google.spanner.admin.datab\
    ase.v1.RestoreDatabaseEncryptionConfig.EncryptionTypeR\x0eencryptionType\
    B\x03\xe0A\x02\x12K\n\x0ckms_key_name\x18\x02\x20\x01(\tR\nkmsKeyNameB)\
    \xfaA#\n!cloudkms.googleapis.com/CryptoKey\xe0A\x01\"\x9e\x01\n\x0eEncry\
    ptionType\x12\x1f\n\x1bENCRYPTION_TYPE_UNSPECIFIED\x10\0\x12+\n'USE_CONF\
    IG_DEFAULT_OR_BACKUP_ENCRYPTION\x10\x01\x12\x1d\n\x19GOOGLE_DEFAULT_ENCR\
    YPTION\x10\x02\x12\x1f\n\x1bCUSTOMER_MANAGED_ENCRYPTION\x10\x03\"\xe0\
    \x03\n\x17RestoreDatabaseMetadata\x128\n\x04name\x18\x01\x20\x01(\tR\x04\
    nameB$\xfaA!\n\x1fspanner.googleapis.com/Database\x12T\n\x0bsource_type\
    \x18\x02\x20\x01(\x0e23.google.spanner.admin.database.v1.RestoreSourceTy\
    peR\nsourceType\x12O\n\x0bbackup_info\x18\x03\x20\x01(\x0b2,.google.span\
    ner.admin.database.v1.BackupInfoH\0R\nbackupInfo\x12O\n\x08progress\x18\
    \x04\x20\x01(\x0b23.google.spanner.admin.database.v1.OperationProgressR\
    \x08progress\x12;\n\x0bcancel_time\x18\x05\x20\x01(\x0b2\x1a.google.prot\
    obuf.TimestampR\ncancelTime\x12G\n\x20optimize_database_operation_name\
    \x18\x06\x20\x01(\tR\x1doptimizeDatabaseOperationNameB\r\n\x0bsource_inf\
    o\"\xad\x01\n\x20OptimizeRestoredDatabaseMetadata\x128\n\x04name\x18\x01\
    \x20\x01(\tR\x04nameB$\xfaA!\n\x1fspanner.googleapis.com/Database\x12O\n\
    \x08progress\x18\x02\x20\x01(\x0b23.google.spanner.admin.database.v1.Ope\
    rationProgressR\x08progress*5\n\x11RestoreSourceType\x12\x14\n\x10TYPE_U\
    NSPECIFIED\x10\0\x12\n\n\x06BACKUP\x10\x012\x93\x1f\n\rDatabaseAdmin\x12\
    \xc0\x01\n\rListDatabases\x126.google.spanner.admin.database.v1.ListData\
    basesRequest\x1a7.google.spanner.admin.database.v1.ListDatabasesResponse\
    \">\x82\xd3\xe4\x93\x02/\x12-/v1/{parent=projects/*/instances/*}/databas\
    es\xdaA\x06parent\x12\xa4\x02\n\x0eCreateDatabase\x127.google.spanner.ad\
    min.database.v1.CreateDatabaseRequest\x1a\x1d.google.longrunning.Operati\
    on\"\xb9\x01\xcaAd\n)google.spanner.admin.database.v1.Database\x127googl\
    e.spanner.admin.database.v1.CreateDatabaseMetadata\xdaA\x17parent,create\
    _statement\x82\xd3\xe4\x93\x022\"-/v1/{parent=projects/*/instances/*}/da\
    tabases:\x01*\x12\xad\x01\n\x0bGetDatabase\x124.google.spanner.admin.dat\
    abase.v1.GetDatabaseRequest\x1a*.google.spanner.admin.database.v1.Databa\
    se\"<\xdaA\x04name\x82\xd3\xe4\x93\x02/\x12-/v1/{name=projects/*/instanc\
    es/*/databases/*}\x12\x9d\x02\n\x11UpdateDatabaseDdl\x12:.google.spanner\
    .admin.database.v1.UpdateDatabaseDdlRequest\x1a\x1d.google.longrunning.O\
    peration\"\xac\x01\x82\xd3\xe4\x93\x02:25/v1/{database=projects/*/instan\
    ces/*/databases/*}/ddl:\x01*\xcaAS\n\x15google.protobuf.Empty\x12:google\
    .spanner.admin.database.v1.UpdateDatabaseDdlMetadata\xdaA\x13database,st\
    atements\x12\xa3\x01\n\x0cDropDatabase\x125.google.spanner.admin.databas\
    e.v1.DropDatabaseRequest\x1a\x16.google.protobuf.Empty\"D\xdaA\x08databa\
    se\x82\xd3\xe4\x93\x023*1/v1/{database=projects/*/instances/*/databases/\
    *}\x12\xcd\x01\n\x0eGetDatabaseDdl\x127.google.spanner.admin.database.v1\
    .GetDatabaseDdlRequest\x1a8.google.spanner.admin.database.v1.GetDatabase\
    DdlResponse\"H\x82\xd3\xe4\x93\x027\x125/v1/{database=projects/*/instanc\
    es/*/databases/*}/ddl\xdaA\x08database\x12\xeb\x01\n\x0cSetIamPolicy\x12\
    \".google.iam.v1.SetIamPolicyRequest\x1a\x15.google.iam.v1.Policy\"\x9f\
    \x01\x82\xd3\xe4\x93\x02\x86\x01\">/v1/{resource=projects/*/instances/*/\
    databases/*}:setIamPolicy:\x01*ZA\"</v1/{resource=projects/*/instances/*\
    /backups/*}:setIamPolicy:\x01*\xdaA\x0fresource,policy\x12\xe4\x01\n\x0c\
    GetIamPolicy\x12\".google.iam.v1.GetIamPolicyRequest\x1a\x15.google.iam.\
    v1.Policy\"\x98\x01\x82\xd3\xe4\x93\x02\x86\x01\">/v1/{resource=projects\
    /*/instances/*/databases/*}:getIamPolicy:\x01*ZA\"</v1/{resource=project\
    s/*/instances/*/backups/*}:getIamPolicy:\x01*\xdaA\x08resource\x12\x9c\
    \x02\n\x12TestIamPermissions\x12(.google.iam.v1.TestIamPermissionsReques\
    t\x1a).google.iam.v1.TestIamPermissionsResponse\"\xb0\x01\xdaA\x14resour\
    ce,permissions\x82\xd3\xe4\x93\x02\x92\x01\"D/v1/{resource=projects/*/in\
    stances/*/databases/*}:testIamPermissions:\x01*ZG\"B/v1/{resource=projec\
    ts/*/instances/*/backups/*}:testIamPermissions:\x01*\x12\x9f\x02\n\x0cCr\
    eateBackup\x125.google.spanner.admin.database.v1.CreateBackupRequest\x1a\
    \x1d.google.longrunning.Operation\"\xb8\x01\xdaA\x17parent,backup,backup\
    _id\x82\xd3\xe4\x93\x025\"+/v1/{parent=projects/*/instances/*}/backups:\
    \x06backup\xcaA`\n'google.spanner.admin.database.v1.Backup\x125google.sp\
    anner.admin.database.v1.CreateBackupMetadata\x12\xa5\x01\n\tGetBackup\
    \x122.google.spanner.admin.database.v1.GetBackupRequest\x1a(.google.span\
    ner.admin.database.v1.Backup\":\xdaA\x04name\x82\xd3\xe4\x93\x02-\x12+/v\
    1/{name=projects/*/instances/*/backups/*}\x12\xc8\x01\n\x0cUpdateBackup\
    \x125.google.spanner.admin.database.v1.UpdateBackupRequest\x1a(.google.s\
    panner.admin.database.v1.Backup\"W\x82\xd3\xe4\x93\x02<22/v1/{backup.nam\
    e=projects/*/instances/*/backups/*}:\x06backup\xdaA\x12backup,update_mas\
    k\x12\x99\x01\n\x0cDeleteBackup\x125.google.spanner.admin.database.v1.De\
    leteBackupRequest\x1a\x16.google.protobuf.Empty\":\xdaA\x04name\x82\xd3\
    \xe4\x93\x02-*+/v1/{name=projects/*/instances/*/backups/*}\x12\xb8\x01\n\
    \x0bListBackups\x124.google.spanner.admin.database.v1.ListBackupsRequest\
    \x1a5.google.spanner.admin.database.v1.ListBackupsResponse\"<\xdaA\x06pa\
    rent\x82\xd3\xe4\x93\x02-\x12+/v1/{parent=projects/*/instances/*}/backup\
    s\x12\xb1\x02\n\x0fRestoreDatabase\x128.google.spanner.admin.database.v1\
    .RestoreDatabaseRequest\x1a\x1d.google.longrunning.Operation\"\xc4\x01\
    \x82\xd3\xe4\x93\x02:\"5/v1/{parent=projects/*/instances/*}/databases:re\
    store:\x01*\xdaA\x19parent,database_id,backup\xcaAe\n)google.spanner.adm\
    in.database.v1.Database\x128google.spanner.admin.database.v1.RestoreData\
    baseMetadata\x12\xe4\x01\n\x16ListDatabaseOperations\x12?.google.spanner\
    .admin.database.v1.ListDatabaseOperationsRequest\x1a@.google.spanner.adm\
    in.database.v1.ListDatabaseOperationsResponse\"G\x82\xd3\xe4\x93\x028\
    \x126/v1/{parent=projects/*/instances/*}/databaseOperations\xdaA\x06pare\
    nt\x12\xdc\x01\n\x14ListBackupOperations\x12=.google.spanner.admin.datab\
    ase.v1.ListBackupOperationsRequest\x1a>.google.spanner.admin.database.v1\
    .ListBackupOperationsResponse\"E\x82\xd3\xe4\x93\x026\x124/v1/{parent=pr\
    ojects/*/instances/*}/backupOperations\xdaA\x06parent\x1ax\xd2A\\https:/\
    /www.googleapis.com/auth/cloud-platform,https://www.googleapis.com/auth/\
    spanner.admin\xcaA\x16spanner.googleapis.comB\xda\x02\n$com.google.spann\
    er.admin.database.v1B\x19SpannerDatabaseAdminProtoP\x01ZHgoogle.golang.o\
    rg/genproto/googleapis/spanner/admin/database/v1;database\xaa\x02&Google\
    .Cloud.Spanner.Admin.Database.V1\xca\x02&Google\\Cloud\\Spanner\\Admin\\\
    Database\\V1\xea\x02+Google::Cloud::Spanner::Admin::Database::V1\xeaAJ\n\
    \x1fspanner.googleapis.com/Instance\x12'projects/{project}/instances/{in\
    stance}J\xc0\xff\x01\n\x07\x12\x05\x0e\0\xd4\x06\x01\n\xbc\x04\n\x01\x0c\
    \x12\x03\x0e\0\x122\xb1\x04\x20Copyright\x202021\x20Google\x20LLC\n\n\
    \x20Licensed\x20under\x20the\x20Apache\x20License,\x20Version\x202.0\x20\
    (the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\x20file\x20e\
    xcept\x20in\x20compliance\x20with\x20the\x20License.\n\x20You\x20may\x20\
    obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\x20\
    \x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\x20required\
    \x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\x20s\
    oftware\n\x20distributed\x20under\x20the\x20License\x20is\x20distributed\
    \x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\
    \x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\x20impli\
    ed.\n\x20See\x20the\x20License\x20for\x20the\x20specific\x20language\x20\
    governing\x20permissions\x20and\n\x20limitations\x20under\x20the\x20Lice\
    nse.\n\n\x08\n\x01\x02\x12\x03\x10\0)\n\t\n\x02\x03\0\x12\x03\x12\0&\n\t\
    \n\x02\x03\x01\x12\x03\x13\0!\n\t\n\x02\x03\x02\x12\x03\x14\0)\n\t\n\x02\
    \x03\x03\x12\x03\x15\0#\n\t\n\x02\x03\x04\x12\x03\x16\0(\n\t\n\x02\x03\
    \x05\x12\x03\x17\0$\n\t\n\x02\x03\x06\x12\x03\x18\0-\n\t\n\x02\x03\x07\
    \x12\x03\x19\0%\n\t\n\x02\x03\x08\x12\x03\x1a\0)\n\t\n\x02\x03\t\x12\x03\
    \x1b\07\n\t\n\x02\x03\n\x12\x03\x1c\07\n\x08\n\x01\x08\x12\x03\x1e\0C\n\
    \t\n\x02\x08%\x12\x03\x1e\0C\n\x08\n\x01\x08\x12\x03\x1f\0_\n\t\n\x02\
    \x08\x0b\x12\x03\x1f\0_\n\x08\n\x01\x08\x12\x03\x20\0\"\n\t\n\x02\x08\n\
    \x12\x03\x20\0\"\n\x08\n\x01\x08\x12\x03!\0:\n\t\n\x02\x08\x08\x12\x03!\
    \0:\n\x08\n\x01\x08\x12\x03\"\0=\n\t\n\x02\x08\x01\x12\x03\"\0=\n\x08\n\
    \x01\x08\x12\x03#\0E\n\t\n\x02\x08)\x12\x03#\0E\n\x08\n\x01\x08\x12\x03$\
    \0D\n\t\n\x02\x08-\x12\x03$\0D\n\t\n\x01\x08\x12\x04%\0(\x02\n\x0c\n\x04\
    \x08\x9d\x08\0\x12\x04%\0(\x02\n\xb8\x02\n\x02\x06\0\x12\x050\0\xc1\x02\
    \x01\x1a\xaa\x02\x20Cloud\x20Spanner\x20Database\x20Admin\x20API\n\n\x20\
    The\x20Cloud\x20Spanner\x20Database\x20Admin\x20API\x20can\x20be\x20used\
    \x20to\x20create,\x20drop,\x20and\n\x20list\x20databases.\x20It\x20also\
    \x20enables\x20updating\x20the\x20schema\x20of\x20pre-existing\n\x20data\
    bases.\x20It\x20can\x20be\x20also\x20used\x20to\x20create,\x20delete\x20\
    and\x20list\x20backups\x20for\x20a\n\x20database\x20and\x20to\x20restore\
    \x20from\x20an\x20existing\x20backup.\n\n\n\n\x03\x06\0\x01\x12\x030\x08\
    \x15\n\n\n\x03\x06\0\x03\x12\x031\x02>\n\x0c\n\x05\x06\0\x03\x99\x08\x12\
    \x031\x02>\n\x0b\n\x03\x06\0\x03\x12\x042\x0246\n\r\n\x05\x06\0\x03\x9a\
    \x08\x12\x042\x0246\n.\n\x04\x06\0\x02\0\x12\x047\x02<\x03\x1a\x20\x20Li\
    sts\x20Cloud\x20Spanner\x20databases.\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\
    \x037\x06\x13\n\x0c\n\x05\x06\0\x02\0\x02\x12\x037\x14(\n\x0c\n\x05\x06\
    \0\x02\0\x03\x12\x0373H\n\r\n\x05\x06\0\x02\0\x04\x12\x048\x04:\x06\n\
    \x11\n\t\x06\0\x02\0\x04\xb0\xca\xbc\"\x12\x048\x04:\x06\n\x0c\n\x05\x06\
    \0\x02\0\x04\x12\x03;\x044\n\x0f\n\x08\x06\0\x02\0\x04\x9b\x08\0\x12\x03\
    ;\x044\n\xc8\x04\n\x04\x06\0\x02\x01\x12\x04F\x02Q\x03\x1a\xb9\x04\x20Cr\
    eates\x20a\x20new\x20Cloud\x20Spanner\x20database\x20and\x20starts\x20to\
    \x20prepare\x20it\x20for\x20serving.\n\x20The\x20returned\x20[long-runni\
    ng\x20operation][google.longrunning.Operation]\x20will\n\x20have\x20a\
    \x20name\x20of\x20the\x20format\x20`<database_name>/operations/<operatio\
    n_id>`\x20and\n\x20can\x20be\x20used\x20to\x20track\x20preparation\x20of\
    \x20the\x20database.\x20The\n\x20[metadata][google.longrunning.Operation\
    .metadata]\x20field\x20type\x20is\n\x20[CreateDatabaseMetadata][google.s\
    panner.admin.database.v1.CreateDatabaseMetadata].\n\x20The\x20[response]\
    [google.longrunning.Operation.response]\x20field\x20type\x20is\n\x20[Dat\
    abase][google.spanner.admin.database.v1.Database],\x20if\x20successful.\
    \n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03F\x06\x14\n\x0c\n\x05\x06\0\x02\
    \x01\x02\x12\x03F\x15*\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03G\x0f+\n\r\n\
    \x05\x06\0\x02\x01\x04\x12\x04H\x04K\x06\n\x11\n\t\x06\0\x02\x01\x04\xb0\
    \xca\xbc\"\x12\x04H\x04K\x06\n\x0c\n\x05\x06\0\x02\x01\x04\x12\x03L\x04E\
    \n\x0f\n\x08\x06\0\x02\x01\x04\x9b\x08\0\x12\x03L\x04E\n\r\n\x05\x06\0\
    \x02\x01\x04\x12\x04M\x04P\x06\n\x0f\n\x07\x06\0\x02\x01\x04\x99\x08\x12\
    \x04M\x04P\x06\n;\n\x04\x06\0\x02\x02\x12\x04T\x02Y\x03\x1a-\x20Gets\x20\
    the\x20state\x20of\x20a\x20Cloud\x20Spanner\x20database.\n\n\x0c\n\x05\
    \x06\0\x02\x02\x01\x12\x03T\x06\x11\n\x0c\n\x05\x06\0\x02\x02\x02\x12\
    \x03T\x12$\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03T/7\n\r\n\x05\x06\0\x02\
    \x02\x04\x12\x04U\x04W\x06\n\x11\n\t\x06\0\x02\x02\x04\xb0\xca\xbc\"\x12\
    \x04U\x04W\x06\n\x0c\n\x05\x06\0\x02\x02\x04\x12\x03X\x042\n\x0f\n\x08\
    \x06\0\x02\x02\x04\x9b\x08\0\x12\x03X\x042\n\x8a\x04\n\x04\x06\0\x02\x03\
    \x12\x04c\x02n\x03\x1a\xfb\x03\x20Updates\x20the\x20schema\x20of\x20a\
    \x20Cloud\x20Spanner\x20database\x20by\n\x20creating/altering/dropping\
    \x20tables,\x20columns,\x20indexes,\x20etc.\x20The\x20returned\n\x20[lon\
    g-running\x20operation][google.longrunning.Operation]\x20will\x20have\
    \x20a\x20name\x20of\n\x20the\x20format\x20`<database_name>/operations/<o\
    peration_id>`\x20and\x20can\x20be\x20used\x20to\n\x20track\x20execution\
    \x20of\x20the\x20schema\x20change(s).\x20The\n\x20[metadata][google.long\
    running.Operation.metadata]\x20field\x20type\x20is\n\x20[UpdateDatabaseD\
    dlMetadata][google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata].\
    \n\x20The\x20operation\x20has\x20no\x20response.\n\n\x0c\n\x05\x06\0\x02\
    \x03\x01\x12\x03c\x06\x17\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03c\x180\n\
    \x0c\n\x05\x06\0\x02\x03\x03\x12\x03d\x0f+\n\r\n\x05\x06\0\x02\x03\x04\
    \x12\x04e\x04h\x06\n\x11\n\t\x06\0\x02\x03\x04\xb0\xca\xbc\"\x12\x04e\
    \x04h\x06\n\x0c\n\x05\x06\0\x02\x03\x04\x12\x03i\x04A\n\x0f\n\x08\x06\0\
    \x02\x03\x04\x9b\x08\0\x12\x03i\x04A\n\r\n\x05\x06\0\x02\x03\x04\x12\x04\
    j\x04m\x06\n\x0f\n\x07\x06\0\x02\x03\x04\x99\x08\x12\x04j\x04m\x06\n\x96\
    \x01\n\x04\x06\0\x02\x04\x12\x04s\x02x\x03\x1a\x87\x01\x20Drops\x20(aka\
    \x20deletes)\x20a\x20Cloud\x20Spanner\x20database.\n\x20Completed\x20bac\
    kups\x20for\x20the\x20database\x20will\x20be\x20retained\x20according\
    \x20to\x20their\n\x20`expire_time`.\n\n\x0c\n\x05\x06\0\x02\x04\x01\x12\
    \x03s\x06\x12\n\x0c\n\x05\x06\0\x02\x04\x02\x12\x03s\x13&\n\x0c\n\x05\
    \x06\0\x02\x04\x03\x12\x03s1F\n\r\n\x05\x06\0\x02\x04\x04\x12\x04t\x04v\
    \x06\n\x11\n\t\x06\0\x02\x04\x04\xb0\xca\xbc\"\x12\x04t\x04v\x06\n\x0c\n\
    \x05\x06\0\x02\x04\x04\x12\x03w\x046\n\x0f\n\x08\x06\0\x02\x04\x04\x9b\
    \x08\0\x12\x03w\x046\n\xeb\x01\n\x04\x06\0\x02\x05\x12\x05}\x02\x82\x01\
    \x03\x1a\xdb\x01\x20Returns\x20the\x20schema\x20of\x20a\x20Cloud\x20Span\
    ner\x20database\x20as\x20a\x20list\x20of\x20formatted\n\x20DDL\x20statem\
    ents.\x20This\x20method\x20does\x20not\x20show\x20pending\x20schema\x20u\
    pdates,\x20those\x20may\n\x20be\x20queried\x20using\x20the\x20[Operation\
    s][google.longrunning.Operations]\x20API.\n\n\x0c\n\x05\x06\0\x02\x05\
    \x01\x12\x03}\x06\x14\n\x0c\n\x05\x06\0\x02\x05\x02\x12\x03}\x15*\n\x0c\
    \n\x05\x06\0\x02\x05\x03\x12\x03}5K\n\x0e\n\x05\x06\0\x02\x05\x04\x12\
    \x05~\x04\x80\x01\x06\n\x12\n\t\x06\0\x02\x05\x04\xb0\xca\xbc\"\x12\x05~\
    \x04\x80\x01\x06\n\r\n\x05\x06\0\x02\x05\x04\x12\x04\x81\x01\x046\n\x10\
    \n\x08\x06\0\x02\x05\x04\x9b\x08\0\x12\x04\x81\x01\x046\n\xfe\x02\n\x04\
    \x06\0\x02\x06\x12\x06\x8b\x01\x02\x96\x01\x03\x1a\xed\x02\x20Sets\x20th\
    e\x20access\x20control\x20policy\x20on\x20a\x20database\x20or\x20backup\
    \x20resource.\n\x20Replaces\x20any\x20existing\x20policy.\n\n\x20Authori\
    zation\x20requires\x20`spanner.databases.setIamPolicy`\n\x20permission\
    \x20on\x20[resource][google.iam.v1.SetIamPolicyRequest.resource].\n\x20F\
    or\x20backups,\x20authorization\x20requires\x20`spanner.backups.setIamPo\
    licy`\n\x20permission\x20on\x20[resource][google.iam.v1.SetIamPolicyRequ\
    est.resource].\n\n\r\n\x05\x06\0\x02\x06\x01\x12\x04\x8b\x01\x06\x12\n\r\
    \n\x05\x06\0\x02\x06\x02\x12\x04\x8b\x01\x134\n\r\n\x05\x06\0\x02\x06\
    \x03\x12\x04\x8c\x01\x0f#\n\x0f\n\x05\x06\0\x02\x06\x04\x12\x06\x8d\x01\
    \x04\x94\x01\x06\n\x13\n\t\x06\0\x02\x06\x04\xb0\xca\xbc\"\x12\x06\x8d\
    \x01\x04\x94\x01\x06\n\r\n\x05\x06\0\x02\x06\x04\x12\x04\x95\x01\x04=\n\
    \x10\n\x08\x06\0\x02\x06\x04\x9b\x08\0\x12\x04\x95\x01\x04=\n\xb9\x03\n\
    \x04\x06\0\x02\x07\x12\x06\xa0\x01\x02\xab\x01\x03\x1a\xa8\x03\x20Gets\
    \x20the\x20access\x20control\x20policy\x20for\x20a\x20database\x20or\x20\
    backup\x20resource.\n\x20Returns\x20an\x20empty\x20policy\x20if\x20a\x20\
    database\x20or\x20backup\x20exists\x20but\x20does\x20not\x20have\x20a\n\
    \x20policy\x20set.\n\n\x20Authorization\x20requires\x20`spanner.database\
    s.getIamPolicy`\x20permission\x20on\n\x20[resource][google.iam.v1.GetIam\
    PolicyRequest.resource].\n\x20For\x20backups,\x20authorization\x20requir\
    es\x20`spanner.backups.getIamPolicy`\n\x20permission\x20on\x20[resource]\
    [google.iam.v1.GetIamPolicyRequest.resource].\n\n\r\n\x05\x06\0\x02\x07\
    \x01\x12\x04\xa0\x01\x06\x12\n\r\n\x05\x06\0\x02\x07\x02\x12\x04\xa0\x01\
    \x134\n\r\n\x05\x06\0\x02\x07\x03\x12\x04\xa1\x01\x0f#\n\x0f\n\x05\x06\0\
    \x02\x07\x04\x12\x06\xa2\x01\x04\xa9\x01\x06\n\x13\n\t\x06\0\x02\x07\x04\
    \xb0\xca\xbc\"\x12\x06\xa2\x01\x04\xa9\x01\x06\n\r\n\x05\x06\0\x02\x07\
    \x04\x12\x04\xaa\x01\x046\n\x10\n\x08\x06\0\x02\x07\x04\x9b\x08\0\x12\
    \x04\xaa\x01\x046\n\xff\x03\n\x04\x06\0\x02\x08\x12\x06\xb7\x01\x02\xc2\
    \x01\x03\x1a\xee\x03\x20Returns\x20permissions\x20that\x20the\x20caller\
    \x20has\x20on\x20the\x20specified\x20database\x20or\x20backup\n\x20resou\
    rce.\n\n\x20Attempting\x20this\x20RPC\x20on\x20a\x20non-existent\x20Clou\
    d\x20Spanner\x20database\x20will\n\x20result\x20in\x20a\x20NOT_FOUND\x20\
    error\x20if\x20the\x20user\x20has\n\x20`spanner.databases.list`\x20permi\
    ssion\x20on\x20the\x20containing\x20Cloud\n\x20Spanner\x20instance.\x20O\
    therwise\x20returns\x20an\x20empty\x20set\x20of\x20permissions.\n\x20Cal\
    ling\x20this\x20method\x20on\x20a\x20backup\x20that\x20does\x20not\x20ex\
    ist\x20will\n\x20result\x20in\x20a\x20NOT_FOUND\x20error\x20if\x20the\
    \x20user\x20has\n\x20`spanner.backups.list`\x20permission\x20on\x20the\
    \x20containing\x20instance.\n\n\r\n\x05\x06\0\x02\x08\x01\x12\x04\xb7\
    \x01\x06\x18\n\r\n\x05\x06\0\x02\x08\x02\x12\x04\xb7\x01\x19@\n\r\n\x05\
    \x06\0\x02\x08\x03\x12\x04\xb8\x01\x0f7\n\x0f\n\x05\x06\0\x02\x08\x04\
    \x12\x06\xb9\x01\x04\xc0\x01\x06\n\x13\n\t\x06\0\x02\x08\x04\xb0\xca\xbc\
    \"\x12\x06\xb9\x01\x04\xc0\x01\x06\n\r\n\x05\x06\0\x02\x08\x04\x12\x04\
    \xc1\x01\x04B\n\x10\n\x08\x06\0\x02\x08\x04\x9b\x08\0\x12\x04\xc1\x01\
    \x04B\n\x9b\x06\n\x04\x06\0\x02\t\x12\x06\xd0\x01\x02\xda\x01\x03\x1a\
    \x8a\x06\x20Starts\x20creating\x20a\x20new\x20Cloud\x20Spanner\x20Backup\
    .\n\x20The\x20returned\x20backup\x20[long-running\x20operation][google.l\
    ongrunning.Operation]\n\x20will\x20have\x20a\x20name\x20of\x20the\x20for\
    mat\n\x20`projects/<project>/instances/<instance>/backups/<backup>/opera\
    tions/<operation_id>`\n\x20and\x20can\x20be\x20used\x20to\x20track\x20cr\
    eation\x20of\x20the\x20backup.\x20The\n\x20[metadata][google.longrunning\
    .Operation.metadata]\x20field\x20type\x20is\n\x20[CreateBackupMetadata][\
    google.spanner.admin.database.v1.CreateBackupMetadata].\n\x20The\x20[res\
    ponse][google.longrunning.Operation.response]\x20field\x20type\x20is\n\
    \x20[Backup][google.spanner.admin.database.v1.Backup],\x20if\x20successf\
    ul.\n\x20Cancelling\x20the\x20returned\x20operation\x20will\x20stop\x20t\
    he\x20creation\x20and\x20delete\x20the\n\x20backup.\x20There\x20can\x20b\
    e\x20only\x20one\x20pending\x20backup\x20creation\x20per\x20database.\
    \x20Backup\n\x20creation\x20of\x20different\x20databases\x20can\x20run\
    \x20concurrently.\n\n\r\n\x05\x06\0\x02\t\x01\x12\x04\xd0\x01\x06\x12\n\
    \r\n\x05\x06\0\x02\t\x02\x12\x04\xd0\x01\x13&\n\r\n\x05\x06\0\x02\t\x03\
    \x12\x04\xd0\x011M\n\x0f\n\x05\x06\0\x02\t\x04\x12\x06\xd1\x01\x04\xd4\
    \x01\x06\n\x13\n\t\x06\0\x02\t\x04\xb0\xca\xbc\"\x12\x06\xd1\x01\x04\xd4\
    \x01\x06\n\r\n\x05\x06\0\x02\t\x04\x12\x04\xd5\x01\x04E\n\x10\n\x08\x06\
    \0\x02\t\x04\x9b\x08\0\x12\x04\xd5\x01\x04E\n\x0f\n\x05\x06\0\x02\t\x04\
    \x12\x06\xd6\x01\x04\xd9\x01\x06\n\x11\n\x07\x06\0\x02\t\x04\x99\x08\x12\
    \x06\xd6\x01\x04\xd9\x01\x06\nm\n\x04\x06\0\x02\n\x12\x06\xde\x01\x02\
    \xe3\x01\x03\x1a]\x20Gets\x20metadata\x20on\x20a\x20pending\x20or\x20com\
    pleted\n\x20[Backup][google.spanner.admin.database.v1.Backup].\n\n\r\n\
    \x05\x06\0\x02\n\x01\x12\x04\xde\x01\x06\x0f\n\r\n\x05\x06\0\x02\n\x02\
    \x12\x04\xde\x01\x10\x20\n\r\n\x05\x06\0\x02\n\x03\x12\x04\xde\x01+1\n\
    \x0f\n\x05\x06\0\x02\n\x04\x12\x06\xdf\x01\x04\xe1\x01\x06\n\x13\n\t\x06\
    \0\x02\n\x04\xb0\xca\xbc\"\x12\x06\xdf\x01\x04\xe1\x01\x06\n\r\n\x05\x06\
    \0\x02\n\x04\x12\x04\xe2\x01\x042\n\x10\n\x08\x06\0\x02\n\x04\x9b\x08\0\
    \x12\x04\xe2\x01\x042\nd\n\x04\x06\0\x02\x0b\x12\x06\xe7\x01\x02\xed\x01\
    \x03\x1aT\x20Updates\x20a\x20pending\x20or\x20completed\n\x20[Backup][go\
    ogle.spanner.admin.database.v1.Backup].\n\n\r\n\x05\x06\0\x02\x0b\x01\
    \x12\x04\xe7\x01\x06\x12\n\r\n\x05\x06\0\x02\x0b\x02\x12\x04\xe7\x01\x13\
    &\n\r\n\x05\x06\0\x02\x0b\x03\x12\x04\xe7\x0117\n\x0f\n\x05\x06\0\x02\
    \x0b\x04\x12\x06\xe8\x01\x04\xeb\x01\x06\n\x13\n\t\x06\0\x02\x0b\x04\xb0\
    \xca\xbc\"\x12\x06\xe8\x01\x04\xeb\x01\x06\n\r\n\x05\x06\0\x02\x0b\x04\
    \x12\x04\xec\x01\x04@\n\x10\n\x08\x06\0\x02\x0b\x04\x9b\x08\0\x12\x04\
    \xec\x01\x04@\nd\n\x04\x06\0\x02\x0c\x12\x06\xf1\x01\x02\xf6\x01\x03\x1a\
    T\x20Deletes\x20a\x20pending\x20or\x20completed\n\x20[Backup][google.spa\
    nner.admin.database.v1.Backup].\n\n\r\n\x05\x06\0\x02\x0c\x01\x12\x04\
    \xf1\x01\x06\x12\n\r\n\x05\x06\0\x02\x0c\x02\x12\x04\xf1\x01\x13&\n\r\n\
    \x05\x06\0\x02\x0c\x03\x12\x04\xf1\x011F\n\x0f\n\x05\x06\0\x02\x0c\x04\
    \x12\x06\xf2\x01\x04\xf4\x01\x06\n\x13\n\t\x06\0\x02\x0c\x04\xb0\xca\xbc\
    \"\x12\x06\xf2\x01\x04\xf4\x01\x06\n\r\n\x05\x06\0\x02\x0c\x04\x12\x04\
    \xf5\x01\x042\n\x10\n\x08\x06\0\x02\x0c\x04\x9b\x08\0\x12\x04\xf5\x01\
    \x042\n\xa9\x01\n\x04\x06\0\x02\r\x12\x06\xfb\x01\x02\x80\x02\x03\x1a\
    \x98\x01\x20Lists\x20completed\x20and\x20pending\x20backups.\n\x20Backup\
    s\x20returned\x20are\x20ordered\x20by\x20`create_time`\x20in\x20descendi\
    ng\x20order,\n\x20starting\x20from\x20the\x20most\x20recent\x20`create_t\
    ime`.\n\n\r\n\x05\x06\0\x02\r\x01\x12\x04\xfb\x01\x06\x11\n\r\n\x05\x06\
    \0\x02\r\x02\x12\x04\xfb\x01\x12$\n\r\n\x05\x06\0\x02\r\x03\x12\x04\xfb\
    \x01/B\n\x0f\n\x05\x06\0\x02\r\x04\x12\x06\xfc\x01\x04\xfe\x01\x06\n\x13\
    \n\t\x06\0\x02\r\x04\xb0\xca\xbc\"\x12\x06\xfc\x01\x04\xfe\x01\x06\n\r\n\
    \x05\x06\0\x02\r\x04\x12\x04\xff\x01\x044\n\x10\n\x08\x06\0\x02\r\x04\
    \x9b\x08\0\x12\x04\xff\x01\x044\n\xd6\x08\n\x04\x06\0\x02\x0e\x12\x06\
    \x93\x02\x02\x9e\x02\x03\x1a\xc5\x08\x20Create\x20a\x20new\x20database\
    \x20by\x20restoring\x20from\x20a\x20completed\x20backup.\x20The\x20new\n\
    \x20database\x20must\x20be\x20in\x20the\x20same\x20project\x20and\x20in\
    \x20an\x20instance\x20with\x20the\x20same\n\x20instance\x20configuration\
    \x20as\x20the\x20instance\x20containing\n\x20the\x20backup.\x20The\x20re\
    turned\x20database\x20[long-running\n\x20operation][google.longrunning.O\
    peration]\x20has\x20a\x20name\x20of\x20the\x20format\n\x20`projects/<pro\
    ject>/instances/<instance>/databases/<database>/operations/<operation_id\
    >`,\n\x20and\x20can\x20be\x20used\x20to\x20track\x20the\x20progress\x20o\
    f\x20the\x20operation,\x20and\x20to\x20cancel\x20it.\n\x20The\x20[metada\
    ta][google.longrunning.Operation.metadata]\x20field\x20type\x20is\n\x20[\
    RestoreDatabaseMetadata][google.spanner.admin.database.v1.RestoreDatabas\
    eMetadata].\n\x20The\x20[response][google.longrunning.Operation.response\
    ]\x20type\n\x20is\x20[Database][google.spanner.admin.database.v1.Databas\
    e],\x20if\n\x20successful.\x20Cancelling\x20the\x20returned\x20operation\
    \x20will\x20stop\x20the\x20restore\x20and\n\x20delete\x20the\x20database\
    .\n\x20There\x20can\x20be\x20only\x20one\x20database\x20being\x20restore\
    d\x20into\x20an\x20instance\x20at\x20a\x20time.\n\x20Once\x20the\x20rest\
    ore\x20operation\x20completes,\x20a\x20new\x20restore\x20operation\x20ca\
    n\x20be\n\x20initiated,\x20without\x20waiting\x20for\x20the\x20optimize\
    \x20operation\x20associated\x20with\x20the\n\x20first\x20restore\x20to\
    \x20complete.\n\n\r\n\x05\x06\0\x02\x0e\x01\x12\x04\x93\x02\x06\x15\n\r\
    \n\x05\x06\0\x02\x0e\x02\x12\x04\x93\x02\x16,\n\r\n\x05\x06\0\x02\x0e\
    \x03\x12\x04\x94\x02\x0f+\n\x0f\n\x05\x06\0\x02\x0e\x04\x12\x06\x95\x02\
    \x04\x98\x02\x06\n\x13\n\t\x06\0\x02\x0e\x04\xb0\xca\xbc\"\x12\x06\x95\
    \x02\x04\x98\x02\x06\n\r\n\x05\x06\0\x02\x0e\x04\x12\x04\x99\x02\x04G\n\
    \x10\n\x08\x06\0\x02\x0e\x04\x9b\x08\0\x12\x04\x99\x02\x04G\n\x0f\n\x05\
    \x06\0\x02\x0e\x04\x12\x06\x9a\x02\x04\x9d\x02\x06\n\x11\n\x07\x06\0\x02\
    \x0e\x04\x99\x08\x12\x06\x9a\x02\x04\x9d\x02\x06\n\xe9\x03\n\x04\x06\0\
    \x02\x0f\x12\x06\xa8\x02\x02\xae\x02\x03\x1a\xd8\x03\x20Lists\x20databas\
    e\x20[longrunning-operations][google.longrunning.Operation].\n\x20A\x20d\
    atabase\x20operation\x20has\x20a\x20name\x20of\x20the\x20form\n\x20`proj\
    ects/<project>/instances/<instance>/databases/<database>/operations/<ope\
    ration>`.\n\x20The\x20long-running\x20operation\n\x20[metadata][google.l\
    ongrunning.Operation.metadata]\x20field\x20type\n\x20`metadata.type_url`\
    \x20describes\x20the\x20type\x20of\x20the\x20metadata.\x20Operations\x20\
    returned\n\x20include\x20those\x20that\x20have\x20completed/failed/cance\
    led\x20within\x20the\x20last\x207\x20days,\n\x20and\x20pending\x20operat\
    ions.\n\n\r\n\x05\x06\0\x02\x0f\x01\x12\x04\xa8\x02\x06\x1c\n\r\n\x05\
    \x06\0\x02\x0f\x02\x12\x04\xa8\x02\x1d:\n\r\n\x05\x06\0\x02\x0f\x03\x12\
    \x04\xa9\x02\x0f-\n\x0f\n\x05\x06\0\x02\x0f\x04\x12\x06\xaa\x02\x04\xac\
    \x02\x06\n\x13\n\t\x06\0\x02\x0f\x04\xb0\xca\xbc\"\x12\x06\xaa\x02\x04\
    \xac\x02\x06\n\r\n\x05\x06\0\x02\x0f\x04\x12\x04\xad\x02\x044\n\x10\n\
    \x08\x06\0\x02\x0f\x04\x9b\x08\0\x12\x04\xad\x02\x044\n\x97\x05\n\x04\
    \x06\0\x02\x10\x12\x06\xba\x02\x02\xc0\x02\x03\x1a\x86\x05\x20Lists\x20t\
    he\x20backup\x20[long-running\x20operations][google.longrunning.Operatio\
    n]\x20in\n\x20the\x20given\x20instance.\x20A\x20backup\x20operation\x20h\
    as\x20a\x20name\x20of\x20the\x20form\n\x20`projects/<project>/instances/\
    <instance>/backups/<backup>/operations/<operation>`.\n\x20The\x20long-ru\
    nning\x20operation\n\x20[metadata][google.longrunning.Operation.metadata\
    ]\x20field\x20type\n\x20`metadata.type_url`\x20describes\x20the\x20type\
    \x20of\x20the\x20metadata.\x20Operations\x20returned\n\x20include\x20tho\
    se\x20that\x20have\x20completed/failed/canceled\x20within\x20the\x20last\
    \x207\x20days,\n\x20and\x20pending\x20operations.\x20Operations\x20retur\
    ned\x20are\x20ordered\x20by\n\x20`operation.metadata.value.progress.star\
    t_time`\x20in\x20descending\x20order\x20starting\n\x20from\x20the\x20mos\
    t\x20recently\x20started\x20operation.\n\n\r\n\x05\x06\0\x02\x10\x01\x12\
    \x04\xba\x02\x06\x1a\n\r\n\x05\x06\0\x02\x10\x02\x12\x04\xba\x02\x1b6\n\
    \r\n\x05\x06\0\x02\x10\x03\x12\x04\xbb\x02\x0f+\n\x0f\n\x05\x06\0\x02\
    \x10\x04\x12\x06\xbc\x02\x04\xbe\x02\x06\n\x13\n\t\x06\0\x02\x10\x04\xb0\
    \xca\xbc\"\x12\x06\xbc\x02\x04\xbe\x02\x06\n\r\n\x05\x06\0\x02\x10\x04\
    \x12\x04\xbf\x02\x044\n\x10\n\x08\x06\0\x02\x10\x04\x9b\x08\0\x12\x04\
    \xbf\x02\x044\n7\n\x02\x04\0\x12\x06\xc4\x02\0\xce\x02\x01\x1a)\x20Infor\
    mation\x20about\x20the\x20database\x20restore.\n\n\x0b\n\x03\x04\0\x01\
    \x12\x04\xc4\x02\x08\x13\n/\n\x04\x04\0\x02\0\x12\x04\xc6\x02\x02$\x1a!\
    \x20The\x20type\x20of\x20the\x20restore\x20source.\n\n\x0f\n\x05\x04\0\
    \x02\0\x04\x12\x06\xc6\x02\x02\xc4\x02\x15\n\r\n\x05\x04\0\x02\0\x06\x12\
    \x04\xc6\x02\x02\x13\n\r\n\x05\x04\0\x02\0\x01\x12\x04\xc6\x02\x14\x1f\n\
    \r\n\x05\x04\0\x02\0\x03\x12\x04\xc6\x02\"#\nL\n\x04\x04\0\x08\0\x12\x06\
    \xc9\x02\x02\xcd\x02\x03\x1a<\x20Information\x20about\x20the\x20source\
    \x20used\x20to\x20restore\x20the\x20database.\n\n\r\n\x05\x04\0\x08\0\
    \x01\x12\x04\xc9\x02\x08\x13\nk\n\x04\x04\0\x02\x01\x12\x04\xcc\x02\x04\
    \x1f\x1a]\x20Information\x20about\x20the\x20backup\x20used\x20to\x20rest\
    ore\x20the\x20database.\x20The\x20backup\n\x20may\x20no\x20longer\x20exi\
    st.\n\n\r\n\x05\x04\0\x02\x01\x06\x12\x04\xcc\x02\x04\x0e\n\r\n\x05\x04\
    \0\x02\x01\x01\x12\x04\xcc\x02\x0f\x1a\n\r\n\x05\x04\0\x02\x01\x03\x12\
    \x04\xcc\x02\x1d\x1e\n)\n\x02\x04\x01\x12\x06\xd1\x02\0\xa2\x03\x01\x1a\
    \x1b\x20A\x20Cloud\x20Spanner\x20database.\n\n\x0b\n\x03\x04\x01\x01\x12\
    \x04\xd1\x02\x08\x10\n\r\n\x03\x04\x01\x07\x12\x06\xd2\x02\x02\xd5\x02\
    \x04\n\x0f\n\x05\x04\x01\x07\x9d\x08\x12\x06\xd2\x02\x02\xd5\x02\x04\n>\
    \n\x04\x04\x01\x04\0\x12\x06\xd8\x02\x02\xec\x02\x03\x1a.\x20Indicates\
    \x20the\x20current\x20state\x20of\x20the\x20database.\n\n\r\n\x05\x04\
    \x01\x04\0\x01\x12\x04\xd8\x02\x07\x0c\n\x20\n\x06\x04\x01\x04\0\x02\0\
    \x12\x04\xda\x02\x04\x1a\x1a\x10\x20Not\x20specified.\n\n\x0f\n\x07\x04\
    \x01\x04\0\x02\0\x01\x12\x04\xda\x02\x04\x15\n\x0f\n\x07\x04\x01\x04\0\
    \x02\0\x02\x12\x04\xda\x02\x18\x19\n\x85\x01\n\x06\x04\x01\x04\0\x02\x01\
    \x12\x04\xde\x02\x04\x11\x1au\x20The\x20database\x20is\x20still\x20being\
    \x20created.\x20Operations\x20on\x20the\x20database\x20may\x20fail\n\x20\
    with\x20`FAILED_PRECONDITION`\x20in\x20this\x20state.\n\n\x0f\n\x07\x04\
    \x01\x04\0\x02\x01\x01\x12\x04\xde\x02\x04\x0c\n\x0f\n\x07\x04\x01\x04\0\
    \x02\x01\x02\x12\x04\xde\x02\x0f\x10\nB\n\x06\x04\x01\x04\0\x02\x02\x12\
    \x04\xe1\x02\x04\x0e\x1a2\x20The\x20database\x20is\x20fully\x20created\
    \x20and\x20ready\x20for\x20use.\n\n\x0f\n\x07\x04\x01\x04\0\x02\x02\x01\
    \x12\x04\xe1\x02\x04\t\n\x0f\n\x07\x04\x01\x04\0\x02\x02\x02\x12\x04\xe1\
    \x02\x0c\r\n\x96\x03\n\x06\x04\x01\x04\0\x02\x03\x12\x04\xeb\x02\x04\x19\
    \x1a\x85\x03\x20The\x20database\x20is\x20fully\x20created\x20and\x20read\
    y\x20for\x20use,\x20but\x20is\x20still\n\x20being\x20optimized\x20for\
    \x20performance\x20and\x20cannot\x20handle\x20full\x20load.\n\n\x20In\
    \x20this\x20state,\x20the\x20database\x20still\x20references\x20the\x20b\
    ackup\n\x20it\x20was\x20restore\x20from,\x20preventing\x20the\x20backup\
    \n\x20from\x20being\x20deleted.\x20When\x20optimizations\x20are\x20compl\
    ete,\x20the\x20full\x20performance\n\x20of\x20the\x20database\x20will\
    \x20be\x20restored,\x20and\x20the\x20database\x20will\x20transition\x20t\
    o\n\x20`READY`\x20state.\n\n\x0f\n\x07\x04\x01\x04\0\x02\x03\x01\x12\x04\
    \xeb\x02\x04\x14\n\x0f\n\x07\x04\x01\x04\0\x02\x03\x02\x12\x04\xeb\x02\
    \x17\x18\n\x9d\x02\n\x04\x04\x01\x02\0\x12\x04\xf3\x02\x02;\x1a\x8e\x02\
    \x20Required.\x20The\x20name\x20of\x20the\x20database.\x20Values\x20are\
    \x20of\x20the\x20form\n\x20`projects/<project>/instances/<instance>/data\
    bases/<database>`,\n\x20where\x20`<database>`\x20is\x20as\x20specified\
    \x20in\x20the\x20`CREATE\x20DATABASE`\n\x20statement.\x20This\x20name\
    \x20can\x20be\x20passed\x20to\x20other\x20API\x20methods\x20to\n\x20iden\
    tify\x20the\x20database.\n\n\x0f\n\x05\x04\x01\x02\0\x04\x12\x06\xf3\x02\
    \x02\xec\x02\x03\n\r\n\x05\x04\x01\x02\0\x05\x12\x04\xf3\x02\x02\x08\n\r\
    \n\x05\x04\x01\x02\0\x01\x12\x04\xf3\x02\t\r\n\r\n\x05\x04\x01\x02\0\x03\
    \x12\x04\xf3\x02\x10\x11\n\r\n\x05\x04\x01\x02\0\x08\x12\x04\xf3\x02\x12\
    :\n\x10\n\x08\x04\x01\x02\0\x08\x9c\x08\0\x12\x04\xf3\x02\x139\n8\n\x04\
    \x04\x01\x02\x01\x12\x04\xf6\x02\x02>\x1a*\x20Output\x20only.\x20The\x20\
    current\x20database\x20state.\n\n\x0f\n\x05\x04\x01\x02\x01\x04\x12\x06\
    \xf6\x02\x02\xf3\x02;\n\r\n\x05\x04\x01\x02\x01\x06\x12\x04\xf6\x02\x02\
    \x07\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\xf6\x02\x08\r\n\r\n\x05\x04\
    \x01\x02\x01\x03\x12\x04\xf6\x02\x10\x11\n\r\n\x05\x04\x01\x02\x01\x08\
    \x12\x04\xf6\x02\x12=\n\x10\n\x08\x04\x01\x02\x01\x08\x9c\x08\0\x12\x04\
    \xf6\x02\x13<\nZ\n\x04\x04\x01\x02\x02\x12\x06\xf9\x02\x02\xfa\x022\x1aJ\
    \x20Output\x20only.\x20If\x20exists,\x20the\x20time\x20at\x20which\x20th\
    e\x20database\x20creation\x20started.\n\n\x0f\n\x05\x04\x01\x02\x02\x04\
    \x12\x06\xf9\x02\x02\xf6\x02>\n\r\n\x05\x04\x01\x02\x02\x06\x12\x04\xf9\
    \x02\x02\x1b\n\r\n\x05\x04\x01\x02\x02\x01\x12\x04\xf9\x02\x1c'\n\r\n\
    \x05\x04\x01\x02\x02\x03\x12\x04\xf9\x02*+\n\r\n\x05\x04\x01\x02\x02\x08\
    \x12\x04\xfa\x02\x061\n\x10\n\x08\x04\x01\x02\x02\x08\x9c\x08\0\x12\x04\
    \xfa\x02\x070\nt\n\x04\x04\x01\x02\x03\x12\x04\xfe\x02\x02K\x1af\x20Outp\
    ut\x20only.\x20Applicable\x20only\x20for\x20restored\x20databases.\x20Co\
    ntains\x20information\n\x20about\x20the\x20restore\x20source.\n\n\x0f\n\
    \x05\x04\x01\x02\x03\x04\x12\x06\xfe\x02\x02\xfa\x022\n\r\n\x05\x04\x01\
    \x02\x03\x06\x12\x04\xfe\x02\x02\r\n\r\n\x05\x04\x01\x02\x03\x01\x12\x04\
    \xfe\x02\x0e\x1a\n\r\n\x05\x04\x01\x02\x03\x03\x12\x04\xfe\x02\x1d\x1e\n\
    \r\n\x05\x04\x01\x02\x03\x08\x12\x04\xfe\x02\x1fJ\n\x10\n\x08\x04\x01\
    \x02\x03\x08\x9c\x08\0\x12\x04\xfe\x02\x20I\n\xfe\x01\n\x04\x04\x01\x02\
    \x04\x12\x06\x84\x03\x02\x85\x032\x1a\xed\x01\x20Output\x20only.\x20For\
    \x20databases\x20that\x20are\x20using\x20customer\x20managed\x20encrypti\
    on,\x20this\n\x20field\x20contains\x20the\x20encryption\x20configuration\
    \x20for\x20the\x20database.\n\x20For\x20databases\x20that\x20are\x20usin\
    g\x20Google\x20default\x20or\x20other\x20types\x20of\x20encryption,\n\
    \x20this\x20field\x20is\x20empty.\n\n\x0f\n\x05\x04\x01\x02\x04\x04\x12\
    \x06\x84\x03\x02\xfe\x02K\n\r\n\x05\x04\x01\x02\x04\x06\x12\x04\x84\x03\
    \x02\x12\n\r\n\x05\x04\x01\x02\x04\x01\x12\x04\x84\x03\x13$\n\r\n\x05\
    \x04\x01\x02\x04\x03\x12\x04\x84\x03'(\n\r\n\x05\x04\x01\x02\x04\x08\x12\
    \x04\x85\x03\x061\n\x10\n\x08\x04\x01\x02\x04\x08\x9c\x08\0\x12\x04\x85\
    \x03\x070\n\xdc\x03\n\x04\x04\x01\x02\x05\x12\x06\x90\x03\x02\x91\x032\
    \x1a\xcb\x03\x20Output\x20only.\x20For\x20databases\x20that\x20are\x20us\
    ing\x20customer\x20managed\x20encryption,\x20this\n\x20field\x20contains\
    \x20the\x20encryption\x20information\x20for\x20the\x20database,\x20such\
    \x20as\n\x20encryption\x20state\x20and\x20the\x20Cloud\x20KMS\x20key\x20\
    versions\x20that\x20are\x20in\x20use.\n\n\x20For\x20databases\x20that\
    \x20are\x20using\x20Google\x20default\x20or\x20other\x20types\x20of\x20e\
    ncryption,\n\x20this\x20field\x20is\x20empty.\n\n\x20This\x20field\x20is\
    \x20propagated\x20lazily\x20from\x20the\x20backend.\x20There\x20might\
    \x20be\x20a\x20delay\n\x20from\x20when\x20a\x20key\x20version\x20is\x20b\
    eing\x20used\x20and\x20when\x20it\x20appears\x20in\x20this\x20field.\n\n\
    \r\n\x05\x04\x01\x02\x05\x04\x12\x04\x90\x03\x02\n\n\r\n\x05\x04\x01\x02\
    \x05\x06\x12\x04\x90\x03\x0b\x19\n\r\n\x05\x04\x01\x02\x05\x01\x12\x04\
    \x90\x03\x1a)\n\r\n\x05\x04\x01\x02\x05\x03\x12\x04\x90\x03,-\n\r\n\x05\
    \x04\x01\x02\x05\x08\x12\x04\x91\x03\x061\n\x10\n\x08\x04\x01\x02\x05\
    \x08\x9c\x08\0\x12\x04\x91\x03\x070\n\xbf\x02\n\x04\x04\x01\x02\x06\x12\
    \x06\x98\x03\x02\x99\x032\x1a\xae\x02\x20Output\x20only.\x20The\x20perio\
    d\x20in\x20which\x20Cloud\x20Spanner\x20retains\x20all\x20versions\x20of\
    \x20data\n\x20for\x20the\x20database.\x20This\x20is\x20the\x20same\x20as\
    \x20the\x20value\x20of\x20version_retention_period\n\x20database\x20opti\
    on\x20set\x20using\n\x20[UpdateDatabaseDdl][google.spanner.admin.databas\
    e.v1.DatabaseAdmin.UpdateDatabaseDdl].\n\x20Defaults\x20to\x201\x20hour,\
    \x20if\x20not\x20set.\n\n\x0f\n\x05\x04\x01\x02\x06\x04\x12\x06\x98\x03\
    \x02\x91\x032\n\r\n\x05\x04\x01\x02\x06\x05\x12\x04\x98\x03\x02\x08\n\r\
    \n\x05\x04\x01\x02\x06\x01\x12\x04\x98\x03\t!\n\r\n\x05\x04\x01\x02\x06\
    \x03\x12\x04\x98\x03$%\n\r\n\x05\x04\x01\x02\x06\x08\x12\x04\x99\x03\x06\
    1\n\x10\n\x08\x04\x01\x02\x06\x08\x9c\x08\0\x12\x04\x99\x03\x070\n\xee\
    \x02\n\x04\x04\x01\x02\x07\x12\x06\xa0\x03\x02\xa1\x032\x1a\xdd\x02\x20O\
    utput\x20only.\x20Earliest\x20timestamp\x20at\x20which\x20older\x20versi\
    ons\x20of\x20the\x20data\x20can\x20be\n\x20read.\x20This\x20value\x20is\
    \x20continuously\x20updated\x20by\x20Cloud\x20Spanner\x20and\x20becomes\
    \x20stale\n\x20the\x20moment\x20it\x20is\x20queried.\x20If\x20you\x20are\
    \x20using\x20this\x20value\x20to\x20recover\x20data,\x20make\n\x20sure\
    \x20to\x20account\x20for\x20the\x20time\x20from\x20the\x20moment\x20when\
    \x20the\x20value\x20is\x20queried\x20to\n\x20the\x20moment\x20when\x20yo\
    u\x20initiate\x20the\x20recovery.\n\n\x0f\n\x05\x04\x01\x02\x07\x04\x12\
    \x06\xa0\x03\x02\x99\x032\n\r\n\x05\x04\x01\x02\x07\x06\x12\x04\xa0\x03\
    \x02\x1b\n\r\n\x05\x04\x01\x02\x07\x01\x12\x04\xa0\x03\x1c1\n\r\n\x05\
    \x04\x01\x02\x07\x03\x12\x04\xa0\x0345\n\r\n\x05\x04\x01\x02\x07\x08\x12\
    \x04\xa1\x03\x061\n\x10\n\x08\x04\x01\x02\x07\x08\x9c\x08\0\x12\x04\xa1\
    \x03\x070\no\n\x02\x04\x02\x12\x06\xa6\x03\0\xb9\x03\x01\x1aa\x20The\x20\
    request\x20for\n\x20[ListDatabases][google.spanner.admin.database.v1.Dat\
    abaseAdmin.ListDatabases].\n\n\x0b\n\x03\x04\x02\x01\x12\x04\xa6\x03\x08\
    \x1c\n\x8d\x01\n\x04\x04\x02\x02\0\x12\x06\xa9\x03\x02\xae\x03\x04\x1a}\
    \x20Required.\x20The\x20instance\x20whose\x20databases\x20should\x20be\
    \x20listed.\n\x20Values\x20are\x20of\x20the\x20form\x20`projects/<projec\
    t>/instances/<instance>`.\n\n\x0f\n\x05\x04\x02\x02\0\x04\x12\x06\xa9\
    \x03\x02\xa6\x03\x1e\n\r\n\x05\x04\x02\x02\0\x05\x12\x04\xa9\x03\x02\x08\
    \n\r\n\x05\x04\x02\x02\0\x01\x12\x04\xa9\x03\t\x0f\n\r\n\x05\x04\x02\x02\
    \0\x03\x12\x04\xa9\x03\x12\x13\n\x0f\n\x05\x04\x02\x02\0\x08\x12\x06\xa9\
    \x03\x14\xae\x03\x03\n\x10\n\x08\x04\x02\x02\0\x08\x9c\x08\0\x12\x04\xaa\
    \x03\x04*\n\x11\n\x07\x04\x02\x02\0\x08\x9f\x08\x12\x06\xab\x03\x04\xad\
    \x03\x05\n\x86\x01\n\x04\x04\x02\x02\x01\x12\x04\xb2\x03\x02\x16\x1ax\
    \x20Number\x20of\x20databases\x20to\x20be\x20returned\x20in\x20the\x20re\
    sponse.\x20If\x200\x20or\x20less,\n\x20defaults\x20to\x20the\x20server's\
    \x20maximum\x20allowed\x20page\x20size.\n\n\x0f\n\x05\x04\x02\x02\x01\
    \x04\x12\x06\xb2\x03\x02\xae\x03\x04\n\r\n\x05\x04\x02\x02\x01\x05\x12\
    \x04\xb2\x03\x02\x07\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\xb2\x03\x08\
    \x11\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\xb2\x03\x14\x15\n\xfa\x01\n\
    \x04\x04\x02\x02\x02\x12\x04\xb8\x03\x02\x18\x1a\xeb\x01\x20If\x20non-em\
    pty,\x20`page_token`\x20should\x20contain\x20a\n\x20[next_page_token][go\
    ogle.spanner.admin.database.v1.ListDatabasesResponse.next_page_token]\n\
    \x20from\x20a\x20previous\n\x20[ListDatabasesResponse][google.spanner.ad\
    min.database.v1.ListDatabasesResponse].\n\n\x0f\n\x05\x04\x02\x02\x02\
    \x04\x12\x06\xb8\x03\x02\xb2\x03\x16\n\r\n\x05\x04\x02\x02\x02\x05\x12\
    \x04\xb8\x03\x02\x08\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\xb8\x03\t\x13\
    \n\r\n\x05\x04\x02\x02\x02\x03\x12\x04\xb8\x03\x16\x17\np\n\x02\x04\x03\
    \x12\x06\xbd\x03\0\xc5\x03\x01\x1ab\x20The\x20response\x20for\n\x20[List\
    Databases][google.spanner.admin.database.v1.DatabaseAdmin.ListDatabases]\
    .\n\n\x0b\n\x03\x04\x03\x01\x12\x04\xbd\x03\x08\x1d\n3\n\x04\x04\x03\x02\
    \0\x12\x04\xbf\x03\x02\"\x1a%\x20Databases\x20that\x20matched\x20the\x20\
    request.\n\n\r\n\x05\x04\x03\x02\0\x04\x12\x04\xbf\x03\x02\n\n\r\n\x05\
    \x04\x03\x02\0\x06\x12\x04\xbf\x03\x0b\x13\n\r\n\x05\x04\x03\x02\0\x01\
    \x12\x04\xbf\x03\x14\x1d\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\xbf\x03\x20\
    !\n\xbc\x01\n\x04\x04\x03\x02\x01\x12\x04\xc4\x03\x02\x1d\x1a\xad\x01\
    \x20`next_page_token`\x20can\x20be\x20sent\x20in\x20a\x20subsequent\n\
    \x20[ListDatabases][google.spanner.admin.database.v1.DatabaseAdmin.ListD\
    atabases]\n\x20call\x20to\x20fetch\x20more\x20of\x20the\x20matching\x20d\
    atabases.\n\n\x0f\n\x05\x04\x03\x02\x01\x04\x12\x06\xc4\x03\x02\xbf\x03\
    \"\n\r\n\x05\x04\x03\x02\x01\x05\x12\x04\xc4\x03\x02\x08\n\r\n\x05\x04\
    \x03\x02\x01\x01\x12\x04\xc4\x03\t\x18\n\r\n\x05\x04\x03\x02\x01\x03\x12\
    \x04\xc4\x03\x1b\x1c\nq\n\x02\x04\x04\x12\x06\xc9\x03\0\xe5\x03\x01\x1ac\
    \x20The\x20request\x20for\n\x20[CreateDatabase][google.spanner.admin.dat\
    abase.v1.DatabaseAdmin.CreateDatabase].\n\n\x0b\n\x03\x04\x04\x01\x12\
    \x04\xc9\x03\x08\x1d\n\x9a\x01\n\x04\x04\x04\x02\0\x12\x06\xcc\x03\x02\
    \xd1\x03\x04\x1a\x89\x01\x20Required.\x20The\x20name\x20of\x20the\x20ins\
    tance\x20that\x20will\x20serve\x20the\x20new\x20database.\n\x20Values\
    \x20are\x20of\x20the\x20form\x20`projects/<project>/instances/<instance>\
    `.\n\n\x0f\n\x05\x04\x04\x02\0\x04\x12\x06\xcc\x03\x02\xc9\x03\x1f\n\r\n\
    \x05\x04\x04\x02\0\x05\x12\x04\xcc\x03\x02\x08\n\r\n\x05\x04\x04\x02\0\
    \x01\x12\x04\xcc\x03\t\x0f\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\xcc\x03\
    \x12\x13\n\x0f\n\x05\x04\x04\x02\0\x08\x12\x06\xcc\x03\x14\xd1\x03\x03\n\
    \x10\n\x08\x04\x04\x02\0\x08\x9c\x08\0\x12\x04\xcd\x03\x04*\n\x11\n\x07\
    \x04\x04\x02\0\x08\x9f\x08\x12\x06\xce\x03\x04\xd0\x03\x05\n\xe6\x02\n\
    \x04\x04\x04\x02\x01\x12\x04\xd8\x03\x02G\x1a\xd7\x02\x20Required.\x20A\
    \x20`CREATE\x20DATABASE`\x20statement,\x20which\x20specifies\x20the\x20I\
    D\x20of\x20the\n\x20new\x20database.\x20\x20The\x20database\x20ID\x20mus\
    t\x20conform\x20to\x20the\x20regular\x20expression\n\x20`[a-z][a-z0-9_\\\
    -]*[a-z0-9]`\x20and\x20be\x20between\x202\x20and\x2030\x20characters\x20\
    in\x20length.\n\x20If\x20the\x20database\x20ID\x20is\x20a\x20reserved\
    \x20word\x20or\x20if\x20it\x20contains\x20a\x20hyphen,\x20the\n\x20datab\
    ase\x20ID\x20must\x20be\x20enclosed\x20in\x20backticks\x20(``\x20`\x20``\
    ).\n\n\x0f\n\x05\x04\x04\x02\x01\x04\x12\x06\xd8\x03\x02\xd1\x03\x04\n\r\
    \n\x05\x04\x04\x02\x01\x05\x12\x04\xd8\x03\x02\x08\n\r\n\x05\x04\x04\x02\
    \x01\x01\x12\x04\xd8\x03\t\x19\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\xd8\
    \x03\x1c\x1d\n\r\n\x05\x04\x04\x02\x01\x08\x12\x04\xd8\x03\x1eF\n\x10\n\
    \x08\x04\x04\x02\x01\x08\x9c\x08\0\x12\x04\xd8\x03\x1fE\n\x97\x02\n\x04\
    \x04\x04\x02\x02\x12\x04\xde\x03\x02P\x1a\x88\x02\x20Optional.\x20A\x20l\
    ist\x20of\x20DDL\x20statements\x20to\x20run\x20inside\x20the\x20newly\
    \x20created\n\x20database.\x20Statements\x20can\x20create\x20tables,\x20\
    indexes,\x20etc.\x20These\n\x20statements\x20execute\x20atomically\x20wi\
    th\x20the\x20creation\x20of\x20the\x20database:\n\x20if\x20there\x20is\
    \x20an\x20error\x20in\x20any\x20statement,\x20the\x20database\x20is\x20n\
    ot\x20created.\n\n\r\n\x05\x04\x04\x02\x02\x04\x12\x04\xde\x03\x02\n\n\r\
    \n\x05\x04\x04\x02\x02\x05\x12\x04\xde\x03\x0b\x11\n\r\n\x05\x04\x04\x02\
    \x02\x01\x12\x04\xde\x03\x12\"\n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\xde\
    \x03%&\n\r\n\x05\x04\x04\x02\x02\x08\x12\x04\xde\x03'O\n\x10\n\x08\x04\
    \x04\x02\x02\x08\x9c\x08\0\x12\x04\xde\x03(N\n\xc2\x01\n\x04\x04\x04\x02\
    \x03\x12\x06\xe3\x03\x02\xe4\x03/\x1a\xb1\x01\x20Optional.\x20The\x20enc\
    ryption\x20configuration\x20for\x20the\x20database.\x20If\x20this\x20fie\
    ld\x20is\n\x20not\x20specified,\x20Cloud\x20Spanner\x20will\x20encrypt/d\
    ecrypt\x20all\x20data\x20at\x20rest\x20using\n\x20Google\x20default\x20e\
    ncryption.\n\n\x0f\n\x05\x04\x04\x02\x03\x04\x12\x06\xe3\x03\x02\xde\x03\
    P\n\r\n\x05\x04\x04\x02\x03\x06\x12\x04\xe3\x03\x02\x12\n\r\n\x05\x04\
    \x04\x02\x03\x01\x12\x04\xe3\x03\x13$\n\r\n\x05\x04\x04\x02\x03\x03\x12\
    \x04\xe3\x03'(\n\r\n\x05\x04\x04\x02\x03\x08\x12\x04\xe4\x03\x06.\n\x10\
    \n\x08\x04\x04\x02\x03\x08\x9c\x08\0\x12\x04\xe4\x03\x07-\n\x8d\x01\n\
    \x02\x04\x05\x12\x06\xe9\x03\0\xee\x03\x01\x1a\x7f\x20Metadata\x20type\
    \x20for\x20the\x20operation\x20returned\x20by\n\x20[CreateDatabase][goog\
    le.spanner.admin.database.v1.DatabaseAdmin.CreateDatabase].\n\n\x0b\n\
    \x03\x04\x05\x01\x12\x04\xe9\x03\x08\x1e\n-\n\x04\x04\x05\x02\0\x12\x06\
    \xeb\x03\x02\xed\x03\x05\x1a\x1d\x20The\x20database\x20being\x20created.\
    \n\n\x0f\n\x05\x04\x05\x02\0\x04\x12\x06\xeb\x03\x02\xe9\x03\x20\n\r\n\
    \x05\x04\x05\x02\0\x05\x12\x04\xeb\x03\x02\x08\n\r\n\x05\x04\x05\x02\0\
    \x01\x12\x04\xeb\x03\t\x11\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xeb\x03\
    \x14\x15\n\x0f\n\x05\x04\x05\x02\0\x08\x12\x06\xeb\x03\x16\xed\x03\x04\n\
    \x11\n\x07\x04\x05\x02\0\x08\x9f\x08\x12\x06\xeb\x03\x17\xed\x03\x03\nk\
    \n\x02\x04\x06\x12\x06\xf2\x03\0\xfb\x03\x01\x1a]\x20The\x20request\x20f\
    or\n\x20[GetDatabase][google.spanner.admin.database.v1.DatabaseAdmin.Get\
    Database].\n\n\x0b\n\x03\x04\x06\x01\x12\x04\xf2\x03\x08\x1a\n\x98\x01\n\
    \x04\x04\x06\x02\0\x12\x06\xf5\x03\x02\xfa\x03\x04\x1a\x87\x01\x20Requir\
    ed.\x20The\x20name\x20of\x20the\x20requested\x20database.\x20Values\x20a\
    re\x20of\x20the\x20form\n\x20`projects/<project>/instances/<instance>/da\
    tabases/<database>`.\n\n\x0f\n\x05\x04\x06\x02\0\x04\x12\x06\xf5\x03\x02\
    \xf2\x03\x1c\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\xf5\x03\x02\x08\n\r\n\
    \x05\x04\x06\x02\0\x01\x12\x04\xf5\x03\t\r\n\r\n\x05\x04\x06\x02\0\x03\
    \x12\x04\xf5\x03\x10\x11\n\x0f\n\x05\x04\x06\x02\0\x08\x12\x06\xf5\x03\
    \x12\xfa\x03\x03\n\x10\n\x08\x04\x06\x02\0\x08\x9c\x08\0\x12\x04\xf6\x03\
    \x04*\n\x11\n\x07\x04\x06\x02\0\x08\x9f\x08\x12\x06\xf7\x03\x04\xf9\x03\
    \x05\n\x99\x07\n\x02\x04\x07\x12\x06\x8d\x04\0\xaf\x04\x01\x1a\x8a\x07\
    \x20Enqueues\x20the\x20given\x20DDL\x20statements\x20to\x20be\x20applied\
    ,\x20in\x20order\x20but\x20not\n\x20necessarily\x20all\x20at\x20once,\
    \x20to\x20the\x20database\x20schema\x20at\x20some\x20point\x20(or\n\x20p\
    oints)\x20in\x20the\x20future.\x20The\x20server\x20checks\x20that\x20the\
    \x20statements\n\x20are\x20executable\x20(syntactically\x20valid,\x20nam\
    e\x20tables\x20that\x20exist,\x20etc.)\n\x20before\x20enqueueing\x20them\
    ,\x20but\x20they\x20may\x20still\x20fail\x20upon\n\x20later\x20execution\
    \x20(e.g.,\x20if\x20a\x20statement\x20from\x20another\x20batch\x20of\n\
    \x20statements\x20is\x20applied\x20first\x20and\x20it\x20conflicts\x20in\
    \x20some\x20way,\x20or\x20if\n\x20there\x20is\x20some\x20data-related\
    \x20problem\x20like\x20a\x20`NULL`\x20value\x20in\x20a\x20column\x20to\n\
    \x20which\x20`NOT\x20NULL`\x20would\x20be\x20added).\x20If\x20a\x20state\
    ment\x20fails,\x20all\n\x20subsequent\x20statements\x20in\x20the\x20batc\
    h\x20are\x20automatically\x20cancelled.\n\n\x20Each\x20batch\x20of\x20st\
    atements\x20is\x20assigned\x20a\x20name\x20which\x20can\x20be\x20used\
    \x20with\n\x20the\x20[Operations][google.longrunning.Operations]\x20API\
    \x20to\x20monitor\n\x20progress.\x20See\x20the\n\x20[operation_id][googl\
    e.spanner.admin.database.v1.UpdateDatabaseDdlRequest.operation_id]\n\x20\
    field\x20for\x20more\x20details.\n\n\x0b\n\x03\x04\x07\x01\x12\x04\x8d\
    \x04\x08\x20\n3\n\x04\x04\x07\x02\0\x12\x06\x8f\x04\x02\x94\x04\x04\x1a#\
    \x20Required.\x20The\x20database\x20to\x20update.\n\n\x0f\n\x05\x04\x07\
    \x02\0\x04\x12\x06\x8f\x04\x02\x8d\x04\"\n\r\n\x05\x04\x07\x02\0\x05\x12\
    \x04\x8f\x04\x02\x08\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\x8f\x04\t\x11\n\
    \r\n\x05\x04\x07\x02\0\x03\x12\x04\x8f\x04\x14\x15\n\x0f\n\x05\x04\x07\
    \x02\0\x08\x12\x06\x8f\x04\x16\x94\x04\x03\n\x10\n\x08\x04\x07\x02\0\x08\
    \x9c\x08\0\x12\x04\x90\x04\x04*\n\x11\n\x07\x04\x07\x02\0\x08\x9f\x08\
    \x12\x06\x91\x04\x04\x93\x04\x05\nG\n\x04\x04\x07\x02\x01\x12\x04\x97\
    \x04\x02J\x1a9\x20Required.\x20DDL\x20statements\x20to\x20be\x20applied\
    \x20to\x20the\x20database.\n\n\r\n\x05\x04\x07\x02\x01\x04\x12\x04\x97\
    \x04\x02\n\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\x97\x04\x0b\x11\n\r\n\
    \x05\x04\x07\x02\x01\x01\x12\x04\x97\x04\x12\x1c\n\r\n\x05\x04\x07\x02\
    \x01\x03\x12\x04\x97\x04\x1f\x20\n\r\n\x05\x04\x07\x02\x01\x08\x12\x04\
    \x97\x04!I\n\x10\n\x08\x04\x07\x02\x01\x08\x9c\x08\0\x12\x04\x97\x04\"H\
    \n\xe6\x08\n\x04\x04\x07\x02\x02\x12\x04\xae\x04\x02\x1a\x1a\xd7\x08\x20\
    If\x20empty,\x20the\x20new\x20update\x20request\x20is\x20assigned\x20an\
    \n\x20automatically-generated\x20operation\x20ID.\x20Otherwise,\x20`oper\
    ation_id`\n\x20is\x20used\x20to\x20construct\x20the\x20name\x20of\x20the\
    \x20resulting\n\x20[Operation][google.longrunning.Operation].\n\n\x20Spe\
    cifying\x20an\x20explicit\x20operation\x20ID\x20simplifies\x20determinin\
    g\n\x20whether\x20the\x20statements\x20were\x20executed\x20in\x20the\x20\
    event\x20that\x20the\n\x20[UpdateDatabaseDdl][google.spanner.admin.datab\
    ase.v1.DatabaseAdmin.UpdateDatabaseDdl]\n\x20call\x20is\x20replayed,\x20\
    or\x20the\x20return\x20value\x20is\x20otherwise\x20lost:\x20the\n\x20[da\
    tabase][google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.databa\
    se]\n\x20and\x20`operation_id`\x20fields\x20can\x20be\x20combined\x20to\
    \x20form\x20the\n\x20[name][google.longrunning.Operation.name]\x20of\x20\
    the\x20resulting\n\x20[longrunning.Operation][google.longrunning.Operati\
    on]:\n\x20`<database>/operations/<operation_id>`.\n\n\x20`operation_id`\
    \x20should\x20be\x20unique\x20within\x20the\x20database,\x20and\x20must\
    \x20be\n\x20a\x20valid\x20identifier:\x20`[a-z][a-z0-9_]*`.\x20Note\x20t\
    hat\n\x20automatically-generated\x20operation\x20IDs\x20always\x20begin\
    \x20with\x20an\n\x20underscore.\x20If\x20the\x20named\x20operation\x20al\
    ready\x20exists,\n\x20[UpdateDatabaseDdl][google.spanner.admin.database.\
    v1.DatabaseAdmin.UpdateDatabaseDdl]\n\x20returns\x20`ALREADY_EXISTS`.\n\
    \n\x0f\n\x05\x04\x07\x02\x02\x04\x12\x06\xae\x04\x02\x97\x04J\n\r\n\x05\
    \x04\x07\x02\x02\x05\x12\x04\xae\x04\x02\x08\n\r\n\x05\x04\x07\x02\x02\
    \x01\x12\x04\xae\x04\t\x15\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\xae\x04\
    \x18\x19\n\x94\x01\n\x02\x04\x08\x12\x06\xb3\x04\0\xc6\x04\x01\x1a\x85\
    \x01\x20Metadata\x20type\x20for\x20the\x20operation\x20returned\x20by\n\
    \x20[UpdateDatabaseDdl][google.spanner.admin.database.v1.DatabaseAdmin.U\
    pdateDatabaseDdl].\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xb3\x04\x08!\n.\n\
    \x04\x04\x08\x02\0\x12\x06\xb5\x04\x02\xb7\x04\x05\x1a\x1e\x20The\x20dat\
    abase\x20being\x20modified.\n\n\x0f\n\x05\x04\x08\x02\0\x04\x12\x06\xb5\
    \x04\x02\xb3\x04#\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\xb5\x04\x02\x08\n\
    \r\n\x05\x04\x08\x02\0\x01\x12\x04\xb5\x04\t\x11\n\r\n\x05\x04\x08\x02\0\
    \x03\x12\x04\xb5\x04\x14\x15\n\x0f\n\x05\x04\x08\x02\0\x08\x12\x06\xb5\
    \x04\x16\xb7\x04\x04\n\x11\n\x07\x04\x08\x02\0\x08\x9f\x08\x12\x06\xb5\
    \x04\x17\xb7\x04\x03\n\x8a\x01\n\x04\x04\x08\x02\x01\x12\x04\xbb\x04\x02\
    !\x1a|\x20For\x20an\x20update\x20this\x20list\x20contains\x20all\x20the\
    \x20statements.\x20For\x20an\n\x20individual\x20statement,\x20this\x20li\
    st\x20contains\x20only\x20that\x20statement.\n\n\r\n\x05\x04\x08\x02\x01\
    \x04\x12\x04\xbb\x04\x02\n\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\xbb\x04\
    \x0b\x11\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xbb\x04\x12\x1c\n\r\n\x05\
    \x04\x08\x02\x01\x03\x12\x04\xbb\x04\x1f\x20\n\xb6\x01\n\x04\x04\x08\x02\
    \x02\x12\x04\xc0\x04\x02;\x1a\xa7\x01\x20Reports\x20the\x20commit\x20tim\
    estamps\x20of\x20all\x20statements\x20that\x20have\n\x20succeeded\x20so\
    \x20far,\x20where\x20`commit_timestamps[i]`\x20is\x20the\x20commit\n\x20\
    timestamp\x20for\x20the\x20statement\x20`statements[i]`.\n\n\r\n\x05\x04\
    \x08\x02\x02\x04\x12\x04\xc0\x04\x02\n\n\r\n\x05\x04\x08\x02\x02\x06\x12\
    \x04\xc0\x04\x0b$\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\xc0\x04%6\n\r\n\
    \x05\x04\x08\x02\x02\x03\x12\x04\xc0\x049:\n\xd3\x01\n\x04\x04\x08\x02\
    \x03\x12\x04\xc5\x04\x02A\x1a\xc4\x01\x20Output\x20only.\x20When\x20true\
    ,\x20indicates\x20that\x20the\x20operation\x20is\x20throttled\x20e.g\n\
    \x20due\x20to\x20resource\x20constraints.\x20When\x20resources\x20become\
    \x20available\x20the\x20operation\n\x20will\x20resume\x20and\x20this\x20\
    field\x20will\x20be\x20false\x20again.\n\n\x0f\n\x05\x04\x08\x02\x03\x04\
    \x12\x06\xc5\x04\x02\xc0\x04;\n\r\n\x05\x04\x08\x02\x03\x05\x12\x04\xc5\
    \x04\x02\x06\n\r\n\x05\x04\x08\x02\x03\x01\x12\x04\xc5\x04\x07\x10\n\r\n\
    \x05\x04\x08\x02\x03\x03\x12\x04\xc5\x04\x13\x14\n\r\n\x05\x04\x08\x02\
    \x03\x08\x12\x04\xc5\x04\x15@\n\x10\n\x08\x04\x08\x02\x03\x08\x9c\x08\0\
    \x12\x04\xc5\x04\x16?\nm\n\x02\x04\t\x12\x06\xca\x04\0\xd2\x04\x01\x1a_\
    \x20The\x20request\x20for\n\x20[DropDatabase][google.spanner.admin.datab\
    ase.v1.DatabaseAdmin.DropDatabase].\n\n\x0b\n\x03\x04\t\x01\x12\x04\xca\
    \x04\x08\x1b\n7\n\x04\x04\t\x02\0\x12\x06\xcc\x04\x02\xd1\x04\x04\x1a'\
    \x20Required.\x20The\x20database\x20to\x20be\x20dropped.\n\n\x0f\n\x05\
    \x04\t\x02\0\x04\x12\x06\xcc\x04\x02\xca\x04\x1d\n\r\n\x05\x04\t\x02\0\
    \x05\x12\x04\xcc\x04\x02\x08\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xcc\x04\t\
    \x11\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xcc\x04\x14\x15\n\x0f\n\x05\x04\t\
    \x02\0\x08\x12\x06\xcc\x04\x16\xd1\x04\x03\n\x10\n\x08\x04\t\x02\0\x08\
    \x9c\x08\0\x12\x04\xcd\x04\x04*\n\x11\n\x07\x04\t\x02\0\x08\x9f\x08\x12\
    \x06\xce\x04\x04\xd0\x04\x05\nq\n\x02\x04\n\x12\x06\xd6\x04\0\xe0\x04\
    \x01\x1ac\x20The\x20request\x20for\n\x20[GetDatabaseDdl][google.spanner.\
    admin.database.v1.DatabaseAdmin.GetDatabaseDdl].\n\n\x0b\n\x03\x04\n\x01\
    \x12\x04\xd6\x04\x08\x1d\n\x9e\x01\n\x04\x04\n\x02\0\x12\x06\xda\x04\x02\
    \xdf\x04\x04\x1a\x8d\x01\x20Required.\x20The\x20database\x20whose\x20sch\
    ema\x20we\x20wish\x20to\x20get.\n\x20Values\x20are\x20of\x20the\x20form\
    \n\x20`projects/<project>/instances/<instance>/databases/<database>`\n\n\
    \x0f\n\x05\x04\n\x02\0\x04\x12\x06\xda\x04\x02\xd6\x04\x1f\n\r\n\x05\x04\
    \n\x02\0\x05\x12\x04\xda\x04\x02\x08\n\r\n\x05\x04\n\x02\0\x01\x12\x04\
    \xda\x04\t\x11\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xda\x04\x14\x15\n\x0f\n\
    \x05\x04\n\x02\0\x08\x12\x06\xda\x04\x16\xdf\x04\x03\n\x10\n\x08\x04\n\
    \x02\0\x08\x9c\x08\0\x12\x04\xdb\x04\x04*\n\x11\n\x07\x04\n\x02\0\x08\
    \x9f\x08\x12\x06\xdc\x04\x04\xde\x04\x05\nr\n\x02\x04\x0b\x12\x06\xe4\
    \x04\0\xe8\x04\x01\x1ad\x20The\x20response\x20for\n\x20[GetDatabaseDdl][\
    google.spanner.admin.database.v1.DatabaseAdmin.GetDatabaseDdl].\n\n\x0b\
    \n\x03\x04\x0b\x01\x12\x04\xe4\x04\x08\x1e\nq\n\x04\x04\x0b\x02\0\x12\
    \x04\xe7\x04\x02!\x1ac\x20A\x20list\x20of\x20formatted\x20DDL\x20stateme\
    nts\x20defining\x20the\x20schema\x20of\x20the\x20database\n\x20specified\
    \x20in\x20the\x20request.\n\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\xe7\x04\
    \x02\n\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\xe7\x04\x0b\x11\n\r\n\x05\x04\
    \x0b\x02\0\x01\x12\x04\xe7\x04\x12\x1c\n\r\n\x05\x04\x0b\x02\0\x03\x12\
    \x04\xe7\x04\x1f\x20\n\x81\x01\n\x02\x04\x0c\x12\x06\xec\x04\0\xad\x05\
    \x01\x1as\x20The\x20request\x20for\n\x20[ListDatabaseOperations][google.\
    spanner.admin.database.v1.DatabaseAdmin.ListDatabaseOperations].\n\n\x0b\
    \n\x03\x04\x0c\x01\x12\x04\xec\x04\x08%\n\x87\x01\n\x04\x04\x0c\x02\0\
    \x12\x06\xef\x04\x02\xf4\x04\x04\x1aw\x20Required.\x20The\x20instance\
    \x20of\x20the\x20database\x20operations.\n\x20Values\x20are\x20of\x20the\
    \x20form\x20`projects/<project>/instances/<instance>`.\n\n\x0f\n\x05\x04\
    \x0c\x02\0\x04\x12\x06\xef\x04\x02\xec\x04'\n\r\n\x05\x04\x0c\x02\0\x05\
    \x12\x04\xef\x04\x02\x08\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xef\x04\t\
    \x0f\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xef\x04\x12\x13\n\x0f\n\x05\x04\
    \x0c\x02\0\x08\x12\x06\xef\x04\x14\xf4\x04\x03\n\x10\n\x08\x04\x0c\x02\0\
    \x08\x9c\x08\0\x12\x04\xf0\x04\x04*\n\x11\n\x07\x04\x0c\x02\0\x08\x9f\
    \x08\x12\x06\xf1\x04\x04\xf3\x04\x05\n\xcf\x10\n\x04\x04\x0c\x02\x01\x12\
    \x04\xa1\x05\x02\x14\x1a\xc0\x10\x20An\x20expression\x20that\x20filters\
    \x20the\x20list\x20of\x20returned\x20operations.\n\n\x20A\x20filter\x20e\
    xpression\x20consists\x20of\x20a\x20field\x20name,\x20a\n\x20comparison\
    \x20operator,\x20and\x20a\x20value\x20for\x20filtering.\n\x20The\x20valu\
    e\x20must\x20be\x20a\x20string,\x20a\x20number,\x20or\x20a\x20boolean.\
    \x20The\x20comparison\x20operator\n\x20must\x20be\x20one\x20of:\x20`<`,\
    \x20`>`,\x20`<=`,\x20`>=`,\x20`!=`,\x20`=`,\x20or\x20`:`.\n\x20Colon\x20\
    `:`\x20is\x20the\x20contains\x20operator.\x20Filter\x20rules\x20are\x20n\
    ot\x20case\x20sensitive.\n\n\x20The\x20following\x20fields\x20in\x20the\
    \x20[Operation][google.longrunning.Operation]\n\x20are\x20eligible\x20fo\
    r\x20filtering:\n\n\x20\x20\x20*\x20`name`\x20-\x20The\x20name\x20of\x20\
    the\x20long-running\x20operation\n\x20\x20\x20*\x20`done`\x20-\x20False\
    \x20if\x20the\x20operation\x20is\x20in\x20progress,\x20else\x20true.\n\
    \x20\x20\x20*\x20`metadata.@type`\x20-\x20the\x20type\x20of\x20metadata.\
    \x20For\x20example,\x20the\x20type\x20string\n\x20\x20\x20\x20\x20\x20fo\
    r\n\x20\x20\x20\x20\x20\x20[RestoreDatabaseMetadata][google.spanner.admi\
    n.database.v1.RestoreDatabaseMetadata]\n\x20\x20\x20\x20\x20\x20is\n\x20\
    \x20\x20\x20\x20\x20`type.googleapis.com/google.spanner.admin.database.v\
    1.RestoreDatabaseMetadata`.\n\x20\x20\x20*\x20`metadata.<field_name>`\
    \x20-\x20any\x20field\x20in\x20metadata.value.\n\x20\x20\x20*\x20`error`\
    \x20-\x20Error\x20associated\x20with\x20the\x20long-running\x20operation\
    .\n\x20\x20\x20*\x20`response.@type`\x20-\x20the\x20type\x20of\x20respon\
    se.\n\x20\x20\x20*\x20`response.<field_name>`\x20-\x20any\x20field\x20in\
    \x20response.value.\n\n\x20You\x20can\x20combine\x20multiple\x20expressi\
    ons\x20by\x20enclosing\x20each\x20expression\x20in\n\x20parentheses.\x20\
    By\x20default,\x20expressions\x20are\x20combined\x20with\x20AND\x20logic\
    .\x20However,\n\x20you\x20can\x20specify\x20AND,\x20OR,\x20and\x20NOT\
    \x20logic\x20explicitly.\n\n\x20Here\x20are\x20a\x20few\x20examples:\n\n\
    \x20\x20\x20*\x20`done:true`\x20-\x20The\x20operation\x20is\x20complete.\
    \n\x20\x20\x20*\x20`(metadata.@type=type.googleapis.com/google.spanner.a\
    dmin.database.v1.RestoreDatabaseMetadata)\x20AND`\x20\\\n\x20\x20\x20\
    \x20\x20`(metadata.source_type:BACKUP)\x20AND`\x20\\\n\x20\x20\x20\x20\
    \x20`(metadata.backup_info.backup:backup_howl)\x20AND`\x20\\\n\x20\x20\
    \x20\x20\x20`(metadata.name:restored_howl)\x20AND`\x20\\\n\x20\x20\x20\
    \x20\x20`(metadata.progress.start_time\x20<\x20\\\"2018-03-28T14:50:00Z\
    \\\")\x20AND`\x20\\\n\x20\x20\x20\x20\x20`(error:*)`\x20-\x20Return\x20o\
    perations\x20where:\n\x20\x20\x20\x20\x20*\x20The\x20operation's\x20meta\
    data\x20type\x20is\n\x20\x20\x20\x20\x20[RestoreDatabaseMetadata][google\
    .spanner.admin.database.v1.RestoreDatabaseMetadata].\n\x20\x20\x20\x20\
    \x20*\x20The\x20database\x20is\x20restored\x20from\x20a\x20backup.\n\x20\
    \x20\x20\x20\x20*\x20The\x20backup\x20name\x20contains\x20\"backup_howl\
    \".\n\x20\x20\x20\x20\x20*\x20The\x20restored\x20database's\x20name\x20c\
    ontains\x20\"restored_howl\".\n\x20\x20\x20\x20\x20*\x20The\x20operation\
    \x20started\x20before\x202018-03-28T14:50:00Z.\n\x20\x20\x20\x20\x20*\
    \x20The\x20operation\x20resulted\x20in\x20an\x20error.\n\n\x0f\n\x05\x04\
    \x0c\x02\x01\x04\x12\x06\xa1\x05\x02\xf4\x04\x04\n\r\n\x05\x04\x0c\x02\
    \x01\x05\x12\x04\xa1\x05\x02\x08\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\
    \xa1\x05\t\x0f\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\xa1\x05\x12\x13\n\
    \x87\x01\n\x04\x04\x0c\x02\x02\x12\x04\xa5\x05\x02\x16\x1ay\x20Number\
    \x20of\x20operations\x20to\x20be\x20returned\x20in\x20the\x20response.\
    \x20If\x200\x20or\n\x20less,\x20defaults\x20to\x20the\x20server's\x20max\
    imum\x20allowed\x20page\x20size.\n\n\x0f\n\x05\x04\x0c\x02\x02\x04\x12\
    \x06\xa5\x05\x02\xa1\x05\x14\n\r\n\x05\x04\x0c\x02\x02\x05\x12\x04\xa5\
    \x05\x02\x07\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\xa5\x05\x08\x11\n\r\n\
    \x05\x04\x0c\x02\x02\x03\x12\x04\xa5\x05\x14\x15\n\xc6\x02\n\x04\x04\x0c\
    \x02\x03\x12\x04\xac\x05\x02\x18\x1a\xb7\x02\x20If\x20non-empty,\x20`pag\
    e_token`\x20should\x20contain\x20a\n\x20[next_page_token][google.spanner\
    .admin.database.v1.ListDatabaseOperationsResponse.next_page_token]\n\x20\
    from\x20a\x20previous\n\x20[ListDatabaseOperationsResponse][google.spann\
    er.admin.database.v1.ListDatabaseOperationsResponse]\n\x20to\x20the\x20s\
    ame\x20`parent`\x20and\x20with\x20the\x20same\x20`filter`.\n\n\x0f\n\x05\
    \x04\x0c\x02\x03\x04\x12\x06\xac\x05\x02\xa5\x05\x16\n\r\n\x05\x04\x0c\
    \x02\x03\x05\x12\x04\xac\x05\x02\x08\n\r\n\x05\x04\x0c\x02\x03\x01\x12\
    \x04\xac\x05\t\x13\n\r\n\x05\x04\x0c\x02\x03\x03\x12\x04\xac\x05\x16\x17\
    \n\x82\x01\n\x02\x04\r\x12\x06\xb1\x05\0\xbd\x05\x01\x1at\x20The\x20resp\
    onse\x20for\n\x20[ListDatabaseOperations][google.spanner.admin.database.\
    v1.DatabaseAdmin.ListDatabaseOperations].\n\n\x0b\n\x03\x04\r\x01\x12\
    \x04\xb1\x05\x08&\n\xaf\x02\n\x04\x04\r\x02\0\x12\x04\xb7\x05\x027\x1a\
    \xa0\x02\x20The\x20list\x20of\x20matching\x20database\x20[long-running\n\
    \x20operations][google.longrunning.Operation].\x20Each\x20operation's\
    \x20name\x20will\x20be\n\x20prefixed\x20by\x20the\x20database's\x20name.\
    \x20The\x20operation's\n\x20[metadata][google.longrunning.Operation.meta\
    data]\x20field\x20type\n\x20`metadata.type_url`\x20describes\x20the\x20t\
    ype\x20of\x20the\x20metadata.\n\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xb7\
    \x05\x02\n\n\r\n\x05\x04\r\x02\0\x06\x12\x04\xb7\x05\x0b'\n\r\n\x05\x04\
    \r\x02\0\x01\x12\x04\xb7\x05(2\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xb7\x05\
    56\n\xcd\x01\n\x04\x04\r\x02\x01\x12\x04\xbc\x05\x02\x1d\x1a\xbe\x01\x20\
    `next_page_token`\x20can\x20be\x20sent\x20in\x20a\x20subsequent\n\x20[Li\
    stDatabaseOperations][google.spanner.admin.database.v1.DatabaseAdmin.Lis\
    tDatabaseOperations]\n\x20call\x20to\x20fetch\x20more\x20of\x20the\x20ma\
    tching\x20metadata.\n\n\x0f\n\x05\x04\r\x02\x01\x04\x12\x06\xbc\x05\x02\
    \xb7\x057\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\xbc\x05\x02\x08\n\r\n\x05\
    \x04\r\x02\x01\x01\x12\x04\xbc\x05\t\x18\n\r\n\x05\x04\r\x02\x01\x03\x12\
    \x04\xbc\x05\x1b\x1c\ns\n\x02\x04\x0e\x12\x06\xc1\x05\0\xe5\x05\x01\x1ae\
    \x20The\x20request\x20for\n\x20[RestoreDatabase][google.spanner.admin.da\
    tabase.v1.DatabaseAdmin.RestoreDatabase].\n\n\x0b\n\x03\x04\x0e\x01\x12\
    \x04\xc1\x05\x08\x1e\n\xa6\x02\n\x04\x04\x0e\x02\0\x12\x06\xc7\x05\x02\
    \xcc\x05\x04\x1a\x95\x02\x20Required.\x20The\x20name\x20of\x20the\x20ins\
    tance\x20in\x20which\x20to\x20create\x20the\n\x20restored\x20database.\
    \x20This\x20instance\x20must\x20be\x20in\x20the\x20same\x20project\x20an\
    d\n\x20have\x20the\x20same\x20instance\x20configuration\x20as\x20the\x20\
    instance\x20containing\n\x20the\x20source\x20backup.\x20Values\x20are\
    \x20of\x20the\x20form\n\x20`projects/<project>/instances/<instance>`.\n\
    \n\x0f\n\x05\x04\x0e\x02\0\x04\x12\x06\xc7\x05\x02\xc1\x05\x20\n\r\n\x05\
    \x04\x0e\x02\0\x05\x12\x04\xc7\x05\x02\x08\n\r\n\x05\x04\x0e\x02\0\x01\
    \x12\x04\xc7\x05\t\x0f\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xc7\x05\x12\
    \x13\n\x0f\n\x05\x04\x0e\x02\0\x08\x12\x06\xc7\x05\x14\xcc\x05\x03\n\x10\
    \n\x08\x04\x0e\x02\0\x08\x9c\x08\0\x12\x04\xc8\x05\x04*\n\x11\n\x07\x04\
    \x0e\x02\0\x08\x9f\x08\x12\x06\xc9\x05\x04\xcb\x05\x05\n\x87\x02\n\x04\
    \x04\x0e\x02\x01\x12\x04\xd2\x05\x02B\x1a\xf8\x01\x20Required.\x20The\
    \x20id\x20of\x20the\x20database\x20to\x20create\x20and\x20restore\x20to.\
    \x20This\n\x20database\x20must\x20not\x20already\x20exist.\x20The\x20`da\
    tabase_id`\x20appended\x20to\n\x20`parent`\x20forms\x20the\x20full\x20da\
    tabase\x20name\x20of\x20the\x20form\n\x20`projects/<project>/instances/<\
    instance>/databases/<database_id>`.\n\n\x0f\n\x05\x04\x0e\x02\x01\x04\
    \x12\x06\xd2\x05\x02\xcc\x05\x04\n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\
    \xd2\x05\x02\x08\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xd2\x05\t\x14\n\r\
    \n\x05\x04\x0e\x02\x01\x03\x12\x04\xd2\x05\x17\x18\n\r\n\x05\x04\x0e\x02\
    \x01\x08\x12\x04\xd2\x05\x19A\n\x10\n\x08\x04\x0e\x02\x01\x08\x9c\x08\0\
    \x12\x04\xd2\x05\x1a@\n=\n\x04\x04\x0e\x08\0\x12\x06\xd5\x05\x02\xdb\x05\
    \x03\x1a-\x20Required.\x20The\x20source\x20from\x20which\x20to\x20restor\
    e.\n\n\r\n\x05\x04\x0e\x08\0\x01\x12\x04\xd5\x05\x08\x0e\n\x91\x01\n\x04\
    \x04\x0e\x02\x02\x12\x06\xd8\x05\x04\xda\x05\x07\x1a\x80\x01\x20Name\x20\
    of\x20the\x20backup\x20from\x20which\x20to\x20restore.\x20\x20Values\x20\
    are\x20of\x20the\x20form\n\x20`projects/<project>/instances/<instance>/b\
    ackups/<backup>`.\n\n\r\n\x05\x04\x0e\x02\x02\x05\x12\x04\xd8\x05\x04\n\
    \n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xd8\x05\x0b\x11\n\r\n\x05\x04\x0e\
    \x02\x02\x03\x12\x04\xd8\x05\x14\x15\n\x0f\n\x05\x04\x0e\x02\x02\x08\x12\
    \x06\xd8\x05\x16\xda\x05\x06\n\x11\n\x07\x04\x0e\x02\x02\x08\x9f\x08\x12\
    \x06\xd8\x05\x17\xda\x05\x05\n\xc4\x03\n\x04\x04\x0e\x02\x03\x12\x06\xe3\
    \x05\x02\xe4\x05/\x1a\xb3\x03\x20Optional.\x20An\x20encryption\x20config\
    uration\x20describing\x20the\x20encryption\x20type\x20and\n\x20key\x20re\
    sources\x20in\x20Cloud\x20KMS\x20used\x20to\x20encrypt/decrypt\x20the\
    \x20database\x20to\x20restore\n\x20to.\x20If\x20this\x20field\x20is\x20n\
    ot\x20specified,\x20the\x20restored\x20database\x20will\x20use\x20the\
    \x20same\n\x20encryption\x20configuration\x20as\x20the\x20backup\x20by\
    \x20default,\x20namely\n\x20[encryption_type][google.spanner.admin.datab\
    ase.v1.RestoreDatabaseEncryptionConfig.encryption_type]\n\x20=\x20`USE_C\
    ONFIG_DEFAULT_OR_DATABASE_ENCRYPTION`.\n\n\x0f\n\x05\x04\x0e\x02\x03\x04\
    \x12\x06\xe3\x05\x02\xdb\x05\x03\n\r\n\x05\x04\x0e\x02\x03\x06\x12\x04\
    \xe3\x05\x02!\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\xe3\x05\"3\n\r\n\x05\
    \x04\x0e\x02\x03\x03\x12\x04\xe3\x0567\n\r\n\x05\x04\x0e\x02\x03\x08\x12\
    \x04\xe4\x05\x06.\n\x10\n\x08\x04\x0e\x02\x03\x08\x9c\x08\0\x12\x04\xe4\
    \x05\x07-\nC\n\x02\x04\x0f\x12\x06\xe8\x05\0\x89\x06\x01\x1a5\x20Encrypt\
    ion\x20configuration\x20for\x20the\x20restored\x20database.\n\n\x0b\n\
    \x03\x04\x0f\x01\x12\x04\xe8\x05\x08'\nC\n\x04\x04\x0f\x04\0\x12\x06\xea\
    \x05\x02\xf9\x05\x03\x1a3\x20Encryption\x20types\x20for\x20the\x20databa\
    se\x20to\x20be\x20restored.\n\n\r\n\x05\x04\x0f\x04\0\x01\x12\x04\xea\
    \x05\x07\x15\n*\n\x06\x04\x0f\x04\0\x02\0\x12\x04\xec\x05\x04$\x1a\x1a\
    \x20Unspecified.\x20Do\x20not\x20use.\n\n\x0f\n\x07\x04\x0f\x04\0\x02\0\
    \x01\x12\x04\xec\x05\x04\x1f\n\x0f\n\x07\x04\x0f\x04\0\x02\0\x02\x12\x04\
    \xec\x05\"#\n\x9c\x01\n\x06\x04\x0f\x04\0\x02\x01\x12\x04\xf1\x05\x040\
    \x1a\x8b\x01\x20This\x20is\x20the\x20default\x20option\x20when\n\x20[enc\
    ryption_config][google.spanner.admin.database.v1.RestoreDatabaseEncrypti\
    onConfig]\n\x20is\x20not\x20specified.\n\n\x0f\n\x07\x04\x0f\x04\0\x02\
    \x01\x01\x12\x04\xf1\x05\x04+\n\x0f\n\x07\x04\x0f\x04\0\x02\x01\x02\x12\
    \x04\xf1\x05./\n0\n\x06\x04\x0f\x04\0\x02\x02\x12\x04\xf4\x05\x04\"\x1a\
    \x20\x20Use\x20Google\x20default\x20encryption.\n\n\x0f\n\x07\x04\x0f\
    \x04\0\x02\x02\x01\x12\x04\xf4\x05\x04\x1d\n\x0f\n\x07\x04\x0f\x04\0\x02\
    \x02\x02\x12\x04\xf4\x05\x20!\ny\n\x06\x04\x0f\x04\0\x02\x03\x12\x04\xf8\
    \x05\x04$\x1ai\x20Use\x20customer\x20managed\x20encryption.\x20If\x20spe\
    cified,\x20`kms_key_name`\x20must\n\x20must\x20contain\x20a\x20valid\x20\
    Cloud\x20KMS\x20key.\n\n\x0f\n\x07\x04\x0f\x04\0\x02\x03\x01\x12\x04\xf8\
    \x05\x04\x1f\n\x0f\n\x07\x04\x0f\x04\0\x02\x03\x02\x12\x04\xf8\x05\"#\nG\
    \n\x04\x04\x0f\x02\0\x12\x04\xfc\x05\x02N\x1a9\x20Required.\x20The\x20en\
    cryption\x20type\x20of\x20the\x20restored\x20database.\n\n\x0f\n\x05\x04\
    \x0f\x02\0\x04\x12\x06\xfc\x05\x02\xf9\x05\x03\n\r\n\x05\x04\x0f\x02\0\
    \x06\x12\x04\xfc\x05\x02\x10\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xfc\x05\
    \x11\x20\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xfc\x05#$\n\r\n\x05\x04\x0f\
    \x02\0\x08\x12\x04\xfc\x05%M\n\x10\n\x08\x04\x0f\x02\0\x08\x9c\x08\0\x12\
    \x04\xfc\x05&L\n\x87\x03\n\x04\x04\x0f\x02\x01\x12\x06\x83\x06\x02\x88\
    \x06\x04\x1a\xf6\x02\x20Optional.\x20The\x20Cloud\x20KMS\x20key\x20that\
    \x20will\x20be\x20used\x20to\x20encrypt/decrypt\x20the\n\x20restored\x20\
    database.\x20This\x20field\x20should\x20be\x20set\x20only\x20when\n\x20[\
    encryption_type][google.spanner.admin.database.v1.RestoreDatabaseEncrypt\
    ionConfig.encryption_type]\n\x20is\x20`CUSTOMER_MANAGED_ENCRYPTION`.\x20\
    Values\x20are\x20of\x20the\x20form\n\x20`projects/<project>/locations/<l\
    ocation>/keyRings/<key_ring>/cryptoKeys/<kms_key_name>`.\n\n\x0f\n\x05\
    \x04\x0f\x02\x01\x04\x12\x06\x83\x06\x02\xfc\x05N\n\r\n\x05\x04\x0f\x02\
    \x01\x05\x12\x04\x83\x06\x02\x08\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\
    \x83\x06\t\x15\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\x83\x06\x18\x19\n\
    \x0f\n\x05\x04\x0f\x02\x01\x08\x12\x06\x83\x06\x1a\x88\x06\x03\n\x10\n\
    \x08\x04\x0f\x02\x01\x08\x9c\x08\0\x12\x04\x84\x06\x04*\n\x11\n\x07\x04\
    \x0f\x02\x01\x08\x9f\x08\x12\x06\x85\x06\x04\x87\x06\x05\n\x9d\x01\n\x02\
    \x04\x10\x12\x06\x8d\x06\0\xbd\x06\x01\x1a\x8e\x01\x20Metadata\x20type\
    \x20for\x20the\x20long-running\x20operation\x20returned\x20by\n\x20[Rest\
    oreDatabase][google.spanner.admin.database.v1.DatabaseAdmin.RestoreDatab\
    ase].\n\n\x0b\n\x03\x04\x10\x01\x12\x04\x8d\x06\x08\x1f\nE\n\x04\x04\x10\
    \x02\0\x12\x06\x8f\x06\x02\x91\x06\x05\x1a5\x20Name\x20of\x20the\x20data\
    base\x20being\x20created\x20and\x20restored\x20to.\n\n\x0f\n\x05\x04\x10\
    \x02\0\x04\x12\x06\x8f\x06\x02\x8d\x06!\n\r\n\x05\x04\x10\x02\0\x05\x12\
    \x04\x8f\x06\x02\x08\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\x8f\x06\t\r\n\r\
    \n\x05\x04\x10\x02\0\x03\x12\x04\x8f\x06\x10\x11\n\x0f\n\x05\x04\x10\x02\
    \0\x08\x12\x06\x8f\x06\x12\x91\x06\x04\n\x11\n\x07\x04\x10\x02\0\x08\x9f\
    \x08\x12\x06\x8f\x06\x13\x91\x06\x03\n/\n\x04\x04\x10\x02\x01\x12\x04\
    \x94\x06\x02$\x1a!\x20The\x20type\x20of\x20the\x20restore\x20source.\n\n\
    \x0f\n\x05\x04\x10\x02\x01\x04\x12\x06\x94\x06\x02\x91\x06\x05\n\r\n\x05\
    \x04\x10\x02\x01\x06\x12\x04\x94\x06\x02\x13\n\r\n\x05\x04\x10\x02\x01\
    \x01\x12\x04\x94\x06\x14\x1f\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\x94\
    \x06\"#\n\xbe\x01\n\x04\x04\x10\x08\0\x12\x06\x99\x06\x02\x9c\x06\x03\
    \x1a\xad\x01\x20Information\x20about\x20the\x20source\x20used\x20to\x20r\
    estore\x20the\x20database,\x20as\x20specified\x20by\n\x20`source`\x20in\
    \n\x20[RestoreDatabaseRequest][google.spanner.admin.database.v1.RestoreD\
    atabaseRequest].\n\n\r\n\x05\x04\x10\x08\0\x01\x12\x04\x99\x06\x08\x13\n\
    J\n\x04\x04\x10\x02\x02\x12\x04\x9b\x06\x04\x1f\x1a<\x20Information\x20a\
    bout\x20the\x20backup\x20used\x20to\x20restore\x20the\x20database.\n\n\r\
    \n\x05\x04\x10\x02\x02\x06\x12\x04\x9b\x06\x04\x0e\n\r\n\x05\x04\x10\x02\
    \x02\x01\x12\x04\x9b\x06\x0f\x1a\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\
    \x9b\x06\x1d\x1e\n\x82\x01\n\x04\x04\x10\x02\x03\x12\x04\xa1\x06\x02!\
    \x1at\x20The\x20progress\x20of\x20the\n\x20[RestoreDatabase][google.span\
    ner.admin.database.v1.DatabaseAdmin.RestoreDatabase]\n\x20operation.\n\n\
    \x0f\n\x05\x04\x10\x02\x03\x04\x12\x06\xa1\x06\x02\x9c\x06\x03\n\r\n\x05\
    \x04\x10\x02\x03\x06\x12\x04\xa1\x06\x02\x13\n\r\n\x05\x04\x10\x02\x03\
    \x01\x12\x04\xa1\x06\x14\x1c\n\r\n\x05\x04\x10\x02\x03\x03\x12\x04\xa1\
    \x06\x1f\x20\n\x87\x06\n\x04\x04\x10\x02\x04\x12\x04\xaf\x06\x02,\x1a\
    \xf8\x05\x20The\x20time\x20at\x20which\x20cancellation\x20of\x20this\x20\
    operation\x20was\x20received.\n\x20[Operations.CancelOperation][google.l\
    ongrunning.Operations.CancelOperation]\n\x20starts\x20asynchronous\x20ca\
    ncellation\x20on\x20a\x20long-running\x20operation.\x20The\x20server\n\
    \x20makes\x20a\x20best\x20effort\x20to\x20cancel\x20the\x20operation,\
    \x20but\x20success\x20is\x20not\x20guaranteed.\n\x20Clients\x20can\x20us\
    e\n\x20[Operations.GetOperation][google.longrunning.Operations.GetOperat\
    ion]\x20or\n\x20other\x20methods\x20to\x20check\x20whether\x20the\x20can\
    cellation\x20succeeded\x20or\x20whether\x20the\n\x20operation\x20complet\
    ed\x20despite\x20cancellation.\x20On\x20successful\x20cancellation,\n\
    \x20the\x20operation\x20is\x20not\x20deleted;\x20instead,\x20it\x20becom\
    es\x20an\x20operation\x20with\n\x20an\x20[Operation.error][google.longru\
    nning.Operation.error]\x20value\x20with\x20a\n\x20[google.rpc.Status.cod\
    e][google.rpc.Status.code]\x20of\x201,\x20corresponding\x20to\n\x20`Code\
    .CANCELLED`.\n\n\x0f\n\x05\x04\x10\x02\x04\x04\x12\x06\xaf\x06\x02\xa1\
    \x06!\n\r\n\x05\x04\x10\x02\x04\x06\x12\x04\xaf\x06\x02\x1b\n\r\n\x05\
    \x04\x10\x02\x04\x01\x12\x04\xaf\x06\x1c'\n\r\n\x05\x04\x10\x02\x04\x03\
    \x12\x04\xaf\x06*+\n\xa0\x06\n\x04\x04\x10\x02\x05\x12\x04\xbc\x06\x02.\
    \x1a\x91\x06\x20If\x20exists,\x20the\x20name\x20of\x20the\x20long-runnin\
    g\x20operation\x20that\x20will\x20be\x20used\x20to\n\x20track\x20the\x20\
    post-restore\x20optimization\x20process\x20to\x20optimize\x20the\x20perf\
    ormance\x20of\n\x20the\x20restored\x20database,\x20and\x20remove\x20the\
    \x20dependency\x20on\x20the\x20restore\x20source.\n\x20The\x20name\x20is\
    \x20of\x20the\x20form\n\x20`projects/<project>/instances/<instance>/data\
    bases/<database>/operations/<operation>`\n\x20where\x20the\x20<database>\
    \x20is\x20the\x20name\x20of\x20database\x20being\x20created\x20and\x20re\
    stored\x20to.\n\x20The\x20metadata\x20type\x20of\x20the\x20\x20long-runn\
    ing\x20operation\x20is\n\x20[OptimizeRestoredDatabaseMetadata][google.sp\
    anner.admin.database.v1.OptimizeRestoredDatabaseMetadata].\n\x20This\x20\
    long-running\x20operation\x20will\x20be\x20automatically\x20created\x20b\
    y\x20the\x20system\n\x20after\x20the\x20RestoreDatabase\x20long-running\
    \x20operation\x20completes\x20successfully.\n\x20This\x20operation\x20wi\
    ll\x20not\x20be\x20created\x20if\x20the\x20restore\x20was\x20not\x20succ\
    essful.\n\n\x0f\n\x05\x04\x10\x02\x05\x04\x12\x06\xbc\x06\x02\xaf\x06,\n\
    \r\n\x05\x04\x10\x02\x05\x05\x12\x04\xbc\x06\x02\x08\n\r\n\x05\x04\x10\
    \x02\x05\x01\x12\x04\xbc\x06\t)\n\r\n\x05\x04\x10\x02\x05\x03\x12\x04\
    \xbc\x06,-\n\xa7\x02\n\x02\x04\x11\x12\x06\xc3\x06\0\xcb\x06\x01\x1a\x98\
    \x02\x20Metadata\x20type\x20for\x20the\x20long-running\x20operation\x20u\
    sed\x20to\x20track\x20the\x20progress\n\x20of\x20optimizations\x20perfor\
    med\x20on\x20a\x20newly\x20restored\x20database.\x20This\x20long-running\
    \n\x20operation\x20is\x20automatically\x20created\x20by\x20the\x20system\
    \x20after\x20the\x20successful\n\x20completion\x20of\x20a\x20database\
    \x20restore,\x20and\x20cannot\x20be\x20cancelled.\n\n\x0b\n\x03\x04\x11\
    \x01\x12\x04\xc3\x06\x08(\n@\n\x04\x04\x11\x02\0\x12\x06\xc5\x06\x02\xc7\
    \x06\x05\x1a0\x20Name\x20of\x20the\x20restored\x20database\x20being\x20o\
    ptimized.\n\n\x0f\n\x05\x04\x11\x02\0\x04\x12\x06\xc5\x06\x02\xc3\x06*\n\
    \r\n\x05\x04\x11\x02\0\x05\x12\x04\xc5\x06\x02\x08\n\r\n\x05\x04\x11\x02\
    \0\x01\x12\x04\xc5\x06\t\r\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xc5\x06\
    \x10\x11\n\x0f\n\x05\x04\x11\x02\0\x08\x12\x06\xc5\x06\x12\xc7\x06\x04\n\
    \x11\n\x07\x04\x11\x02\0\x08\x9f\x08\x12\x06\xc5\x06\x13\xc7\x06\x03\n?\
    \n\x04\x04\x11\x02\x01\x12\x04\xca\x06\x02!\x1a1\x20The\x20progress\x20o\
    f\x20the\x20post-restore\x20optimizations.\n\n\x0f\n\x05\x04\x11\x02\x01\
    \x04\x12\x06\xca\x06\x02\xc7\x06\x05\n\r\n\x05\x04\x11\x02\x01\x06\x12\
    \x04\xca\x06\x02\x13\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xca\x06\x14\
    \x1c\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xca\x06\x1f\x20\n9\n\x02\x05\
    \0\x12\x06\xce\x06\0\xd4\x06\x01\x1a+\x20Indicates\x20the\x20type\x20of\
    \x20the\x20restore\x20source.\n\n\x0b\n\x03\x05\0\x01\x12\x04\xce\x06\
    \x05\x16\n&\n\x04\x05\0\x02\0\x12\x04\xd0\x06\x02\x17\x1a\x18\x20No\x20r\
    estore\x20associated.\n\n\r\n\x05\x05\0\x02\0\x01\x12\x04\xd0\x06\x02\
    \x12\n\r\n\x05\x05\0\x02\0\x02\x12\x04\xd0\x06\x15\x16\n?\n\x04\x05\0\
    \x02\x01\x12\x04\xd3\x06\x02\r\x1a1\x20A\x20backup\x20was\x20used\x20as\
    \x20the\x20source\x20of\x20the\x20restore.\n\n\r\n\x05\x05\0\x02\x01\x01\
    \x12\x04\xd3\x06\x02\x08\n\r\n\x05\x05\0\x02\x01\x02\x12\x04\xd3\x06\x0b\
    \x0cb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
