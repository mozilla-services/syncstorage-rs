// This file is generated by rust-protobuf 2.12.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/spanner/v1/transaction.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_12_0;

#[derive(PartialEq,Clone,Default)]
pub struct TransactionOptions {
    // message oneof groups
    pub mode: ::std::option::Option<TransactionOptions_oneof_mode>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionOptions {
    fn default() -> &'a TransactionOptions {
        <TransactionOptions as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum TransactionOptions_oneof_mode {
    read_write(TransactionOptions_ReadWrite),
    partitioned_dml(TransactionOptions_PartitionedDml),
    read_only(TransactionOptions_ReadOnly),
}

impl TransactionOptions {
    pub fn new() -> TransactionOptions {
        ::std::default::Default::default()
    }

    // .google.spanner.v1.TransactionOptions.ReadWrite read_write = 1;


    pub fn get_read_write(&self) -> &TransactionOptions_ReadWrite {
        match self.mode {
            ::std::option::Option::Some(TransactionOptions_oneof_mode::read_write(ref v)) => v,
            _ => TransactionOptions_ReadWrite::default_instance(),
        }
    }
    pub fn clear_read_write(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_read_write(&self) -> bool {
        match self.mode {
            ::std::option::Option::Some(TransactionOptions_oneof_mode::read_write(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read_write(&mut self, v: TransactionOptions_ReadWrite) {
        self.mode = ::std::option::Option::Some(TransactionOptions_oneof_mode::read_write(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read_write(&mut self) -> &mut TransactionOptions_ReadWrite {
        if let ::std::option::Option::Some(TransactionOptions_oneof_mode::read_write(_)) = self.mode {
        } else {
            self.mode = ::std::option::Option::Some(TransactionOptions_oneof_mode::read_write(TransactionOptions_ReadWrite::new()));
        }
        match self.mode {
            ::std::option::Option::Some(TransactionOptions_oneof_mode::read_write(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read_write(&mut self) -> TransactionOptions_ReadWrite {
        if self.has_read_write() {
            match self.mode.take() {
                ::std::option::Option::Some(TransactionOptions_oneof_mode::read_write(v)) => v,
                _ => panic!(),
            }
        } else {
            TransactionOptions_ReadWrite::new()
        }
    }

    // .google.spanner.v1.TransactionOptions.PartitionedDml partitioned_dml = 3;


    pub fn get_partitioned_dml(&self) -> &TransactionOptions_PartitionedDml {
        match self.mode {
            ::std::option::Option::Some(TransactionOptions_oneof_mode::partitioned_dml(ref v)) => v,
            _ => TransactionOptions_PartitionedDml::default_instance(),
        }
    }
    pub fn clear_partitioned_dml(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_partitioned_dml(&self) -> bool {
        match self.mode {
            ::std::option::Option::Some(TransactionOptions_oneof_mode::partitioned_dml(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_partitioned_dml(&mut self, v: TransactionOptions_PartitionedDml) {
        self.mode = ::std::option::Option::Some(TransactionOptions_oneof_mode::partitioned_dml(v))
    }

    // Mutable pointer to the field.
    pub fn mut_partitioned_dml(&mut self) -> &mut TransactionOptions_PartitionedDml {
        if let ::std::option::Option::Some(TransactionOptions_oneof_mode::partitioned_dml(_)) = self.mode {
        } else {
            self.mode = ::std::option::Option::Some(TransactionOptions_oneof_mode::partitioned_dml(TransactionOptions_PartitionedDml::new()));
        }
        match self.mode {
            ::std::option::Option::Some(TransactionOptions_oneof_mode::partitioned_dml(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_partitioned_dml(&mut self) -> TransactionOptions_PartitionedDml {
        if self.has_partitioned_dml() {
            match self.mode.take() {
                ::std::option::Option::Some(TransactionOptions_oneof_mode::partitioned_dml(v)) => v,
                _ => panic!(),
            }
        } else {
            TransactionOptions_PartitionedDml::new()
        }
    }

    // .google.spanner.v1.TransactionOptions.ReadOnly read_only = 2;


    pub fn get_read_only(&self) -> &TransactionOptions_ReadOnly {
        match self.mode {
            ::std::option::Option::Some(TransactionOptions_oneof_mode::read_only(ref v)) => v,
            _ => TransactionOptions_ReadOnly::default_instance(),
        }
    }
    pub fn clear_read_only(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_read_only(&self) -> bool {
        match self.mode {
            ::std::option::Option::Some(TransactionOptions_oneof_mode::read_only(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read_only(&mut self, v: TransactionOptions_ReadOnly) {
        self.mode = ::std::option::Option::Some(TransactionOptions_oneof_mode::read_only(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read_only(&mut self) -> &mut TransactionOptions_ReadOnly {
        if let ::std::option::Option::Some(TransactionOptions_oneof_mode::read_only(_)) = self.mode {
        } else {
            self.mode = ::std::option::Option::Some(TransactionOptions_oneof_mode::read_only(TransactionOptions_ReadOnly::new()));
        }
        match self.mode {
            ::std::option::Option::Some(TransactionOptions_oneof_mode::read_only(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read_only(&mut self) -> TransactionOptions_ReadOnly {
        if self.has_read_only() {
            match self.mode.take() {
                ::std::option::Option::Some(TransactionOptions_oneof_mode::read_only(v)) => v,
                _ => panic!(),
            }
        } else {
            TransactionOptions_ReadOnly::new()
        }
    }
}

impl ::protobuf::Message for TransactionOptions {
    fn is_initialized(&self) -> bool {
        if let Some(TransactionOptions_oneof_mode::read_write(ref v)) = self.mode {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TransactionOptions_oneof_mode::partitioned_dml(ref v)) = self.mode {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TransactionOptions_oneof_mode::read_only(ref v)) = self.mode {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mode = ::std::option::Option::Some(TransactionOptions_oneof_mode::read_write(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mode = ::std::option::Option::Some(TransactionOptions_oneof_mode::partitioned_dml(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mode = ::std::option::Option::Some(TransactionOptions_oneof_mode::read_only(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.mode {
            match v {
                &TransactionOptions_oneof_mode::read_write(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TransactionOptions_oneof_mode::partitioned_dml(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TransactionOptions_oneof_mode::read_only(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.mode {
            match v {
                &TransactionOptions_oneof_mode::read_write(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TransactionOptions_oneof_mode::partitioned_dml(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TransactionOptions_oneof_mode::read_only(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionOptions {
        TransactionOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TransactionOptions_ReadWrite>(
                    "read_write",
                    TransactionOptions::has_read_write,
                    TransactionOptions::get_read_write,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TransactionOptions_PartitionedDml>(
                    "partitioned_dml",
                    TransactionOptions::has_partitioned_dml,
                    TransactionOptions::get_partitioned_dml,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TransactionOptions_ReadOnly>(
                    "read_only",
                    TransactionOptions::has_read_only,
                    TransactionOptions::get_read_only,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransactionOptions>(
                    "TransactionOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionOptions {
        static mut instance: ::protobuf::lazy::Lazy<TransactionOptions> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(TransactionOptions::new)
        }
    }
}

impl ::protobuf::Clear for TransactionOptions {
    fn clear(&mut self) {
        self.mode = ::std::option::Option::None;
        self.mode = ::std::option::Option::None;
        self.mode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionOptions_ReadWrite {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionOptions_ReadWrite {
    fn default() -> &'a TransactionOptions_ReadWrite {
        <TransactionOptions_ReadWrite as ::protobuf::Message>::default_instance()
    }
}

impl TransactionOptions_ReadWrite {
    pub fn new() -> TransactionOptions_ReadWrite {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TransactionOptions_ReadWrite {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionOptions_ReadWrite {
        TransactionOptions_ReadWrite::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransactionOptions_ReadWrite>(
                    "TransactionOptions.ReadWrite",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionOptions_ReadWrite {
        static mut instance: ::protobuf::lazy::Lazy<TransactionOptions_ReadWrite> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(TransactionOptions_ReadWrite::new)
        }
    }
}

impl ::protobuf::Clear for TransactionOptions_ReadWrite {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionOptions_ReadWrite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionOptions_ReadWrite {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionOptions_PartitionedDml {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionOptions_PartitionedDml {
    fn default() -> &'a TransactionOptions_PartitionedDml {
        <TransactionOptions_PartitionedDml as ::protobuf::Message>::default_instance()
    }
}

impl TransactionOptions_PartitionedDml {
    pub fn new() -> TransactionOptions_PartitionedDml {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TransactionOptions_PartitionedDml {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionOptions_PartitionedDml {
        TransactionOptions_PartitionedDml::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransactionOptions_PartitionedDml>(
                    "TransactionOptions.PartitionedDml",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionOptions_PartitionedDml {
        static mut instance: ::protobuf::lazy::Lazy<TransactionOptions_PartitionedDml> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(TransactionOptions_PartitionedDml::new)
        }
    }
}

impl ::protobuf::Clear for TransactionOptions_PartitionedDml {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionOptions_PartitionedDml {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionOptions_PartitionedDml {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionOptions_ReadOnly {
    // message fields
    pub return_read_timestamp: bool,
    // message oneof groups
    pub timestamp_bound: ::std::option::Option<TransactionOptions_ReadOnly_oneof_timestamp_bound>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionOptions_ReadOnly {
    fn default() -> &'a TransactionOptions_ReadOnly {
        <TransactionOptions_ReadOnly as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum TransactionOptions_ReadOnly_oneof_timestamp_bound {
    strong(bool),
    min_read_timestamp(::protobuf::well_known_types::Timestamp),
    max_staleness(::protobuf::well_known_types::Duration),
    read_timestamp(::protobuf::well_known_types::Timestamp),
    exact_staleness(::protobuf::well_known_types::Duration),
}

impl TransactionOptions_ReadOnly {
    pub fn new() -> TransactionOptions_ReadOnly {
        ::std::default::Default::default()
    }

    // bool strong = 1;


    pub fn get_strong(&self) -> bool {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::strong(v)) => v,
            _ => false,
        }
    }
    pub fn clear_strong(&mut self) {
        self.timestamp_bound = ::std::option::Option::None;
    }

    pub fn has_strong(&self) -> bool {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::strong(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_strong(&mut self, v: bool) {
        self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::strong(v))
    }

    // .google.protobuf.Timestamp min_read_timestamp = 2;


    pub fn get_min_read_timestamp(&self) -> &::protobuf::well_known_types::Timestamp {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(ref v)) => v,
            _ => ::protobuf::well_known_types::Timestamp::default_instance(),
        }
    }
    pub fn clear_min_read_timestamp(&mut self) {
        self.timestamp_bound = ::std::option::Option::None;
    }

    pub fn has_min_read_timestamp(&self) -> bool {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_min_read_timestamp(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_min_read_timestamp(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if let ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(_)) = self.timestamp_bound {
        } else {
            self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(::protobuf::well_known_types::Timestamp::new()));
        }
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_min_read_timestamp(&mut self) -> ::protobuf::well_known_types::Timestamp {
        if self.has_min_read_timestamp() {
            match self.timestamp_bound.take() {
                ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Timestamp::new()
        }
    }

    // .google.protobuf.Duration max_staleness = 3;


    pub fn get_max_staleness(&self) -> &::protobuf::well_known_types::Duration {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(ref v)) => v,
            _ => ::protobuf::well_known_types::Duration::default_instance(),
        }
    }
    pub fn clear_max_staleness(&mut self) {
        self.timestamp_bound = ::std::option::Option::None;
    }

    pub fn has_max_staleness(&self) -> bool {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_max_staleness(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(v))
    }

    // Mutable pointer to the field.
    pub fn mut_max_staleness(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if let ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(_)) = self.timestamp_bound {
        } else {
            self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(::protobuf::well_known_types::Duration::new()));
        }
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_max_staleness(&mut self) -> ::protobuf::well_known_types::Duration {
        if self.has_max_staleness() {
            match self.timestamp_bound.take() {
                ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Duration::new()
        }
    }

    // .google.protobuf.Timestamp read_timestamp = 4;


    pub fn get_read_timestamp(&self) -> &::protobuf::well_known_types::Timestamp {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(ref v)) => v,
            _ => ::protobuf::well_known_types::Timestamp::default_instance(),
        }
    }
    pub fn clear_read_timestamp(&mut self) {
        self.timestamp_bound = ::std::option::Option::None;
    }

    pub fn has_read_timestamp(&self) -> bool {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read_timestamp(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read_timestamp(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if let ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(_)) = self.timestamp_bound {
        } else {
            self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(::protobuf::well_known_types::Timestamp::new()));
        }
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read_timestamp(&mut self) -> ::protobuf::well_known_types::Timestamp {
        if self.has_read_timestamp() {
            match self.timestamp_bound.take() {
                ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Timestamp::new()
        }
    }

    // .google.protobuf.Duration exact_staleness = 5;


    pub fn get_exact_staleness(&self) -> &::protobuf::well_known_types::Duration {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(ref v)) => v,
            _ => ::protobuf::well_known_types::Duration::default_instance(),
        }
    }
    pub fn clear_exact_staleness(&mut self) {
        self.timestamp_bound = ::std::option::Option::None;
    }

    pub fn has_exact_staleness(&self) -> bool {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_exact_staleness(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(v))
    }

    // Mutable pointer to the field.
    pub fn mut_exact_staleness(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if let ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(_)) = self.timestamp_bound {
        } else {
            self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(::protobuf::well_known_types::Duration::new()));
        }
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_exact_staleness(&mut self) -> ::protobuf::well_known_types::Duration {
        if self.has_exact_staleness() {
            match self.timestamp_bound.take() {
                ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Duration::new()
        }
    }

    // bool return_read_timestamp = 6;


    pub fn get_return_read_timestamp(&self) -> bool {
        self.return_read_timestamp
    }
    pub fn clear_return_read_timestamp(&mut self) {
        self.return_read_timestamp = false;
    }

    // Param is passed by value, moved
    pub fn set_return_read_timestamp(&mut self, v: bool) {
        self.return_read_timestamp = v;
    }
}

impl ::protobuf::Message for TransactionOptions_ReadOnly {
    fn is_initialized(&self) -> bool {
        if let Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(ref v)) = self.timestamp_bound {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(ref v)) = self.timestamp_bound {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(ref v)) = self.timestamp_bound {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(ref v)) = self.timestamp_bound {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::strong(is.read_bool()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.return_read_timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.return_read_timestamp != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.timestamp_bound {
            match v {
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::strong(v) => {
                    my_size += 2;
                },
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.return_read_timestamp != false {
            os.write_bool(6, self.return_read_timestamp)?;
        }
        if let ::std::option::Option::Some(ref v) = self.timestamp_bound {
            match v {
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::strong(v) => {
                    os.write_bool(1, v)?;
                },
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionOptions_ReadOnly {
        TransactionOptions_ReadOnly::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                    "strong",
                    TransactionOptions_ReadOnly::has_strong,
                    TransactionOptions_ReadOnly::get_strong,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Timestamp>(
                    "min_read_timestamp",
                    TransactionOptions_ReadOnly::has_min_read_timestamp,
                    TransactionOptions_ReadOnly::get_min_read_timestamp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Duration>(
                    "max_staleness",
                    TransactionOptions_ReadOnly::has_max_staleness,
                    TransactionOptions_ReadOnly::get_max_staleness,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Timestamp>(
                    "read_timestamp",
                    TransactionOptions_ReadOnly::has_read_timestamp,
                    TransactionOptions_ReadOnly::get_read_timestamp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Duration>(
                    "exact_staleness",
                    TransactionOptions_ReadOnly::has_exact_staleness,
                    TransactionOptions_ReadOnly::get_exact_staleness,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "return_read_timestamp",
                    |m: &TransactionOptions_ReadOnly| { &m.return_read_timestamp },
                    |m: &mut TransactionOptions_ReadOnly| { &mut m.return_read_timestamp },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransactionOptions_ReadOnly>(
                    "TransactionOptions.ReadOnly",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionOptions_ReadOnly {
        static mut instance: ::protobuf::lazy::Lazy<TransactionOptions_ReadOnly> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(TransactionOptions_ReadOnly::new)
        }
    }
}

impl ::protobuf::Clear for TransactionOptions_ReadOnly {
    fn clear(&mut self) {
        self.timestamp_bound = ::std::option::Option::None;
        self.timestamp_bound = ::std::option::Option::None;
        self.timestamp_bound = ::std::option::Option::None;
        self.timestamp_bound = ::std::option::Option::None;
        self.timestamp_bound = ::std::option::Option::None;
        self.return_read_timestamp = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionOptions_ReadOnly {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionOptions_ReadOnly {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction {
    // message fields
    pub id: ::std::vec::Vec<u8>,
    pub read_timestamp: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction {
    fn default() -> &'a Transaction {
        <Transaction as ::protobuf::Message>::default_instance()
    }
}

impl Transaction {
    pub fn new() -> Transaction {
        ::std::default::Default::default()
    }

    // bytes id = 1;


    pub fn get_id(&self) -> &[u8] {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.id, ::std::vec::Vec::new())
    }

    // .google.protobuf.Timestamp read_timestamp = 2;


    pub fn get_read_timestamp(&self) -> &::protobuf::well_known_types::Timestamp {
        self.read_timestamp.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_read_timestamp(&mut self) {
        self.read_timestamp.clear();
    }

    pub fn has_read_timestamp(&self) -> bool {
        self.read_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read_timestamp(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.read_timestamp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_read_timestamp(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.read_timestamp.is_none() {
            self.read_timestamp.set_default();
        }
        self.read_timestamp.as_mut().unwrap()
    }

    // Take field
    pub fn take_read_timestamp(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.read_timestamp.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for Transaction {
    fn is_initialized(&self) -> bool {
        for v in &self.read_timestamp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.read_timestamp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.id);
        }
        if let Some(ref v) = self.read_timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_bytes(1, &self.id)?;
        }
        if let Some(ref v) = self.read_timestamp.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction {
        Transaction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "id",
                    |m: &Transaction| { &m.id },
                    |m: &mut Transaction| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "read_timestamp",
                    |m: &Transaction| { &m.read_timestamp },
                    |m: &mut Transaction| { &mut m.read_timestamp },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transaction>(
                    "Transaction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Transaction {
        static mut instance: ::protobuf::lazy::Lazy<Transaction> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Transaction::new)
        }
    }
}

impl ::protobuf::Clear for Transaction {
    fn clear(&mut self) {
        self.id.clear();
        self.read_timestamp.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionSelector {
    // message oneof groups
    pub selector: ::std::option::Option<TransactionSelector_oneof_selector>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionSelector {
    fn default() -> &'a TransactionSelector {
        <TransactionSelector as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum TransactionSelector_oneof_selector {
    single_use(TransactionOptions),
    id(::std::vec::Vec<u8>),
    begin(TransactionOptions),
}

impl TransactionSelector {
    pub fn new() -> TransactionSelector {
        ::std::default::Default::default()
    }

    // .google.spanner.v1.TransactionOptions single_use = 1;


    pub fn get_single_use(&self) -> &TransactionOptions {
        match self.selector {
            ::std::option::Option::Some(TransactionSelector_oneof_selector::single_use(ref v)) => v,
            _ => TransactionOptions::default_instance(),
        }
    }
    pub fn clear_single_use(&mut self) {
        self.selector = ::std::option::Option::None;
    }

    pub fn has_single_use(&self) -> bool {
        match self.selector {
            ::std::option::Option::Some(TransactionSelector_oneof_selector::single_use(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_single_use(&mut self, v: TransactionOptions) {
        self.selector = ::std::option::Option::Some(TransactionSelector_oneof_selector::single_use(v))
    }

    // Mutable pointer to the field.
    pub fn mut_single_use(&mut self) -> &mut TransactionOptions {
        if let ::std::option::Option::Some(TransactionSelector_oneof_selector::single_use(_)) = self.selector {
        } else {
            self.selector = ::std::option::Option::Some(TransactionSelector_oneof_selector::single_use(TransactionOptions::new()));
        }
        match self.selector {
            ::std::option::Option::Some(TransactionSelector_oneof_selector::single_use(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_single_use(&mut self) -> TransactionOptions {
        if self.has_single_use() {
            match self.selector.take() {
                ::std::option::Option::Some(TransactionSelector_oneof_selector::single_use(v)) => v,
                _ => panic!(),
            }
        } else {
            TransactionOptions::new()
        }
    }

    // bytes id = 2;


    pub fn get_id(&self) -> &[u8] {
        match self.selector {
            ::std::option::Option::Some(TransactionSelector_oneof_selector::id(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_id(&mut self) {
        self.selector = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        match self.selector {
            ::std::option::Option::Some(TransactionSelector_oneof_selector::id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.selector = ::std::option::Option::Some(TransactionSelector_oneof_selector::id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(TransactionSelector_oneof_selector::id(_)) = self.selector {
        } else {
            self.selector = ::std::option::Option::Some(TransactionSelector_oneof_selector::id(::std::vec::Vec::new()));
        }
        match self.selector {
            ::std::option::Option::Some(TransactionSelector_oneof_selector::id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_id() {
            match self.selector.take() {
                ::std::option::Option::Some(TransactionSelector_oneof_selector::id(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // .google.spanner.v1.TransactionOptions begin = 3;


    pub fn get_begin(&self) -> &TransactionOptions {
        match self.selector {
            ::std::option::Option::Some(TransactionSelector_oneof_selector::begin(ref v)) => v,
            _ => TransactionOptions::default_instance(),
        }
    }
    pub fn clear_begin(&mut self) {
        self.selector = ::std::option::Option::None;
    }

    pub fn has_begin(&self) -> bool {
        match self.selector {
            ::std::option::Option::Some(TransactionSelector_oneof_selector::begin(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_begin(&mut self, v: TransactionOptions) {
        self.selector = ::std::option::Option::Some(TransactionSelector_oneof_selector::begin(v))
    }

    // Mutable pointer to the field.
    pub fn mut_begin(&mut self) -> &mut TransactionOptions {
        if let ::std::option::Option::Some(TransactionSelector_oneof_selector::begin(_)) = self.selector {
        } else {
            self.selector = ::std::option::Option::Some(TransactionSelector_oneof_selector::begin(TransactionOptions::new()));
        }
        match self.selector {
            ::std::option::Option::Some(TransactionSelector_oneof_selector::begin(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_begin(&mut self) -> TransactionOptions {
        if self.has_begin() {
            match self.selector.take() {
                ::std::option::Option::Some(TransactionSelector_oneof_selector::begin(v)) => v,
                _ => panic!(),
            }
        } else {
            TransactionOptions::new()
        }
    }
}

impl ::protobuf::Message for TransactionSelector {
    fn is_initialized(&self) -> bool {
        if let Some(TransactionSelector_oneof_selector::single_use(ref v)) = self.selector {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TransactionSelector_oneof_selector::begin(ref v)) = self.selector {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.selector = ::std::option::Option::Some(TransactionSelector_oneof_selector::single_use(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.selector = ::std::option::Option::Some(TransactionSelector_oneof_selector::id(is.read_bytes()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.selector = ::std::option::Option::Some(TransactionSelector_oneof_selector::begin(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.selector {
            match v {
                &TransactionSelector_oneof_selector::single_use(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TransactionSelector_oneof_selector::id(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
                &TransactionSelector_oneof_selector::begin(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.selector {
            match v {
                &TransactionSelector_oneof_selector::single_use(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TransactionSelector_oneof_selector::id(ref v) => {
                    os.write_bytes(2, v)?;
                },
                &TransactionSelector_oneof_selector::begin(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionSelector {
        TransactionSelector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TransactionOptions>(
                    "single_use",
                    TransactionSelector::has_single_use,
                    TransactionSelector::get_single_use,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                    "id",
                    TransactionSelector::has_id,
                    TransactionSelector::get_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TransactionOptions>(
                    "begin",
                    TransactionSelector::has_begin,
                    TransactionSelector::get_begin,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransactionSelector>(
                    "TransactionSelector",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionSelector {
        static mut instance: ::protobuf::lazy::Lazy<TransactionSelector> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(TransactionSelector::new)
        }
    }
}

impl ::protobuf::Clear for TransactionSelector {
    fn clear(&mut self) {
        self.selector = ::std::option::Option::None;
        self.selector = ::std::option::Option::None;
        self.selector = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionSelector {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n#google/spanner/v1/transaction.proto\x12\x11google.spanner.v1\x1a\x1cg\
    oogle/api/annotations.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\
    \x1fgoogle/protobuf/timestamp.proto\"\xc4\x05\n\x12TransactionOptions\
    \x12P\n\nread_write\x18\x01\x20\x01(\x0b2/.google.spanner.v1.Transaction\
    Options.ReadWriteH\0R\treadWrite\x12_\n\x0fpartitioned_dml\x18\x03\x20\
    \x01(\x0b24.google.spanner.v1.TransactionOptions.PartitionedDmlH\0R\x0ep\
    artitionedDml\x12M\n\tread_only\x18\x02\x20\x01(\x0b2..google.spanner.v1\
    .TransactionOptions.ReadOnlyH\0R\x08readOnly\x1a\x0b\n\tReadWrite\x1a\
    \x10\n\x0ePartitionedDml\x1a\x84\x03\n\x08ReadOnly\x12\x18\n\x06strong\
    \x18\x01\x20\x01(\x08H\0R\x06strong\x12J\n\x12min_read_timestamp\x18\x02\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampH\0R\x10minReadTimestamp\x12\
    @\n\rmax_staleness\x18\x03\x20\x01(\x0b2\x19.google.protobuf.DurationH\0\
    R\x0cmaxStaleness\x12C\n\x0eread_timestamp\x18\x04\x20\x01(\x0b2\x1a.goo\
    gle.protobuf.TimestampH\0R\rreadTimestamp\x12D\n\x0fexact_staleness\x18\
    \x05\x20\x01(\x0b2\x19.google.protobuf.DurationH\0R\x0eexactStaleness\
    \x122\n\x15return_read_timestamp\x18\x06\x20\x01(\x08R\x13returnReadTime\
    stampB\x11\n\x0ftimestamp_boundB\x06\n\x04mode\"`\n\x0bTransaction\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\x0cR\x02id\x12A\n\x0eread_timestamp\x18\
    \x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\rreadTimestamp\"\xba\
    \x01\n\x13TransactionSelector\x12F\n\nsingle_use\x18\x01\x20\x01(\x0b2%.\
    google.spanner.v1.TransactionOptionsH\0R\tsingleUse\x12\x10\n\x02id\x18\
    \x02\x20\x01(\x0cH\0R\x02id\x12=\n\x05begin\x18\x03\x20\x01(\x0b2%.googl\
    e.spanner.v1.TransactionOptionsH\0R\x05beginB\n\n\x08selectorB\x99\x01\n\
    \x15com.google.spanner.v1B\x10TransactionProtoP\x01Z8google.golang.org/g\
    enproto/googleapis/spanner/v1;spanner\xaa\x02\x17Google.Cloud.Spanner.V1\
    \xca\x02\x17Google\\Cloud\\Spanner\\V1J\xbc\x9c\x01\n\x07\x12\x05\x0e\0\
    \xc7\x03\x01\n\xbc\x04\n\x01\x0c\x12\x03\x0e\0\x122\xb1\x04\x20Copyright\
    \x202018\x20Google\x20LLC\n\n\x20Licensed\x20under\x20the\x20Apache\x20L\
    icense,\x20Version\x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20no\
    t\x20use\x20this\x20file\x20except\x20in\x20compliance\x20with\x20the\
    \x20License.\n\x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20Lice\
    nse\x20at\n\n\x20\x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-\
    2.0\n\n\x20Unless\x20required\x20by\x20applicable\x20law\x20or\x20agreed\
    \x20to\x20in\x20writing,\x20software\n\x20distributed\x20under\x20the\
    \x20License\x20is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\
    \x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20e\
    ither\x20express\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20\
    the\x20specific\x20language\x20governing\x20permissions\x20and\n\x20limi\
    tations\x20under\x20the\x20License.\n\n\x08\n\x01\x02\x12\x03\x10\x08\
    \x19\n\t\n\x02\x03\0\x12\x03\x12\x07%\n\t\n\x02\x03\x01\x12\x03\x13\x07'\
    \n\t\n\x02\x03\x02\x12\x03\x14\x07(\n\x08\n\x01\x08\x12\x03\x16\04\n\x0b\
    \n\x04\x08\xe7\x07\0\x12\x03\x16\04\n\x0c\n\x05\x08\xe7\x07\0\x02\x12\
    \x03\x16\x07\x17\n\r\n\x06\x08\xe7\x07\0\x02\0\x12\x03\x16\x07\x17\n\x0e\
    \n\x07\x08\xe7\x07\0\x02\0\x01\x12\x03\x16\x07\x17\n\x0c\n\x05\x08\xe7\
    \x07\0\x07\x12\x03\x16\x1a3\n\x08\n\x01\x08\x12\x03\x17\0O\n\x0b\n\x04\
    \x08\xe7\x07\x01\x12\x03\x17\0O\n\x0c\n\x05\x08\xe7\x07\x01\x02\x12\x03\
    \x17\x07\x11\n\r\n\x06\x08\xe7\x07\x01\x02\0\x12\x03\x17\x07\x11\n\x0e\n\
    \x07\x08\xe7\x07\x01\x02\0\x01\x12\x03\x17\x07\x11\n\x0c\n\x05\x08\xe7\
    \x07\x01\x07\x12\x03\x17\x14N\n\x08\n\x01\x08\x12\x03\x18\0\"\n\x0b\n\
    \x04\x08\xe7\x07\x02\x12\x03\x18\0\"\n\x0c\n\x05\x08\xe7\x07\x02\x02\x12\
    \x03\x18\x07\x1a\n\r\n\x06\x08\xe7\x07\x02\x02\0\x12\x03\x18\x07\x1a\n\
    \x0e\n\x07\x08\xe7\x07\x02\x02\0\x01\x12\x03\x18\x07\x1a\n\x0c\n\x05\x08\
    \xe7\x07\x02\x03\x12\x03\x18\x1d!\n\x08\n\x01\x08\x12\x03\x19\01\n\x0b\n\
    \x04\x08\xe7\x07\x03\x12\x03\x19\01\n\x0c\n\x05\x08\xe7\x07\x03\x02\x12\
    \x03\x19\x07\x1b\n\r\n\x06\x08\xe7\x07\x03\x02\0\x12\x03\x19\x07\x1b\n\
    \x0e\n\x07\x08\xe7\x07\x03\x02\0\x01\x12\x03\x19\x07\x1b\n\x0c\n\x05\x08\
    \xe7\x07\x03\x07\x12\x03\x19\x1e0\n\x08\n\x01\x08\x12\x03\x1a\0.\n\x0b\n\
    \x04\x08\xe7\x07\x04\x12\x03\x1a\0.\n\x0c\n\x05\x08\xe7\x07\x04\x02\x12\
    \x03\x1a\x07\x13\n\r\n\x06\x08\xe7\x07\x04\x02\0\x12\x03\x1a\x07\x13\n\
    \x0e\n\x07\x08\xe7\x07\x04\x02\0\x01\x12\x03\x1a\x07\x13\n\x0c\n\x05\x08\
    \xe7\x07\x04\x07\x12\x03\x1a\x16-\n\x08\n\x01\x08\x12\x03\x1b\04\n\x0b\n\
    \x04\x08\xe7\x07\x05\x12\x03\x1b\04\n\x0c\n\x05\x08\xe7\x07\x05\x02\x12\
    \x03\x1b\x07\x14\n\r\n\x06\x08\xe7\x07\x05\x02\0\x12\x03\x1b\x07\x14\n\
    \x0e\n\x07\x08\xe7\x07\x05\x02\0\x01\x12\x03\x1b\x07\x14\n\x0c\n\x05\x08\
    \xe7\x07\x05\x07\x12\x03\x1b\x173\n\x80e\n\x02\x04\0\x12\x06\xb3\x02\0\
    \x9a\x03\x01\x1a\xf1d\x20#\x20Transactions\n\n\n\x20Each\x20session\x20c\
    an\x20have\x20at\x20most\x20one\x20active\x20transaction\x20at\x20a\x20t\
    ime.\x20After\x20the\n\x20active\x20transaction\x20is\x20completed,\x20t\
    he\x20session\x20can\x20immediately\x20be\n\x20re-used\x20for\x20the\x20\
    next\x20transaction.\x20It\x20is\x20not\x20necessary\x20to\x20create\x20\
    a\n\x20new\x20session\x20for\x20each\x20transaction.\n\n\x20#\x20Transac\
    tion\x20Modes\n\n\x20Cloud\x20Spanner\x20supports\x20three\x20transactio\
    n\x20modes:\n\n\x20\x20\x201.\x20Locking\x20read-write.\x20This\x20type\
    \x20of\x20transaction\x20is\x20the\x20only\x20way\n\x20\x20\x20\x20\x20\
    \x20to\x20write\x20data\x20into\x20Cloud\x20Spanner.\x20These\x20transac\
    tions\x20rely\x20on\n\x20\x20\x20\x20\x20\x20pessimistic\x20locking\x20a\
    nd,\x20if\x20necessary,\x20two-phase\x20commit.\n\x20\x20\x20\x20\x20\
    \x20Locking\x20read-write\x20transactions\x20may\x20abort,\x20requiring\
    \x20the\n\x20\x20\x20\x20\x20\x20application\x20to\x20retry.\n\n\x20\x20\
    \x202.\x20Snapshot\x20read-only.\x20This\x20transaction\x20type\x20provi\
    des\x20guaranteed\n\x20\x20\x20\x20\x20\x20consistency\x20across\x20seve\
    ral\x20reads,\x20but\x20does\x20not\x20allow\n\x20\x20\x20\x20\x20\x20wr\
    ites.\x20Snapshot\x20read-only\x20transactions\x20can\x20be\x20configure\
    d\x20to\n\x20\x20\x20\x20\x20\x20read\x20at\x20timestamps\x20in\x20the\
    \x20past.\x20Snapshot\x20read-only\n\x20\x20\x20\x20\x20\x20transactions\
    \x20do\x20not\x20need\x20to\x20be\x20committed.\n\n\x20\x20\x203.\x20Par\
    titioned\x20DML.\x20This\x20type\x20of\x20transaction\x20is\x20used\x20t\
    o\x20execute\n\x20\x20\x20\x20\x20\x20a\x20single\x20Partitioned\x20DML\
    \x20statement.\x20Partitioned\x20DML\x20partitions\n\x20\x20\x20\x20\x20\
    \x20the\x20key\x20space\x20and\x20runs\x20the\x20DML\x20statement\x20ove\
    r\x20each\x20partition\n\x20\x20\x20\x20\x20\x20in\x20parallel\x20using\
    \x20separate,\x20internal\x20transactions\x20that\x20commit\n\x20\x20\
    \x20\x20\x20\x20independently.\x20Partitioned\x20DML\x20transactions\x20\
    do\x20not\x20need\x20to\x20be\n\x20\x20\x20\x20\x20\x20committed.\n\n\
    \x20For\x20transactions\x20that\x20only\x20read,\x20snapshot\x20read-onl\
    y\x20transactions\n\x20provide\x20simpler\x20semantics\x20and\x20are\x20\
    almost\x20always\x20faster.\x20In\n\x20particular,\x20read-only\x20trans\
    actions\x20do\x20not\x20take\x20locks,\x20so\x20they\x20do\n\x20not\x20c\
    onflict\x20with\x20read-write\x20transactions.\x20As\x20a\x20consequence\
    \x20of\x20not\n\x20taking\x20locks,\x20they\x20also\x20do\x20not\x20abor\
    t,\x20so\x20retry\x20loops\x20are\x20not\x20needed.\n\n\x20Transactions\
    \x20may\x20only\x20read/write\x20data\x20in\x20a\x20single\x20database.\
    \x20They\n\x20may,\x20however,\x20read/write\x20data\x20in\x20different\
    \x20tables\x20within\x20that\n\x20database.\n\n\x20##\x20Locking\x20Read\
    -Write\x20Transactions\n\n\x20Locking\x20transactions\x20may\x20be\x20us\
    ed\x20to\x20atomically\x20read-modify-write\n\x20data\x20anywhere\x20in\
    \x20a\x20database.\x20This\x20type\x20of\x20transaction\x20is\x20externa\
    lly\n\x20consistent.\n\n\x20Clients\x20should\x20attempt\x20to\x20minimi\
    ze\x20the\x20amount\x20of\x20time\x20a\x20transaction\n\x20is\x20active.\
    \x20Faster\x20transactions\x20commit\x20with\x20higher\x20probability\n\
    \x20and\x20cause\x20less\x20contention.\x20Cloud\x20Spanner\x20attempts\
    \x20to\x20keep\x20read\x20locks\n\x20active\x20as\x20long\x20as\x20the\
    \x20transaction\x20continues\x20to\x20do\x20reads,\x20and\x20the\n\x20tr\
    ansaction\x20has\x20not\x20been\x20terminated\x20by\n\x20[Commit][google\
    .spanner.v1.Spanner.Commit]\x20or\n\x20[Rollback][google.spanner.v1.Span\
    ner.Rollback].\x20\x20Long\x20periods\x20of\n\x20inactivity\x20at\x20the\
    \x20client\x20may\x20cause\x20Cloud\x20Spanner\x20to\x20release\x20a\n\
    \x20transaction's\x20locks\x20and\x20abort\x20it.\n\n\x20Conceptually,\
    \x20a\x20read-write\x20transaction\x20consists\x20of\x20zero\x20or\x20mo\
    re\n\x20reads\x20or\x20SQL\x20statements\x20followed\x20by\n\x20[Commit]\
    [google.spanner.v1.Spanner.Commit].\x20At\x20any\x20time\x20before\n\x20\
    [Commit][google.spanner.v1.Spanner.Commit],\x20the\x20client\x20can\x20s\
    end\x20a\n\x20[Rollback][google.spanner.v1.Spanner.Rollback]\x20request\
    \x20to\x20abort\x20the\n\x20transaction.\n\n\x20###\x20Semantics\n\n\x20\
    Cloud\x20Spanner\x20can\x20commit\x20the\x20transaction\x20if\x20all\x20\
    read\x20locks\x20it\x20acquired\n\x20are\x20still\x20valid\x20at\x20comm\
    it\x20time,\x20and\x20it\x20is\x20able\x20to\x20acquire\x20write\n\x20lo\
    cks\x20for\x20all\x20writes.\x20Cloud\x20Spanner\x20can\x20abort\x20the\
    \x20transaction\x20for\x20any\n\x20reason.\x20If\x20a\x20commit\x20attem\
    pt\x20returns\x20`ABORTED`,\x20Cloud\x20Spanner\x20guarantees\n\x20that\
    \x20the\x20transaction\x20has\x20not\x20modified\x20any\x20user\x20data\
    \x20in\x20Cloud\x20Spanner.\n\n\x20Unless\x20the\x20transaction\x20commi\
    ts,\x20Cloud\x20Spanner\x20makes\x20no\x20guarantees\x20about\n\x20how\
    \x20long\x20the\x20transaction's\x20locks\x20were\x20held\x20for.\x20It\
    \x20is\x20an\x20error\x20to\n\x20use\x20Cloud\x20Spanner\x20locks\x20for\
    \x20any\x20sort\x20of\x20mutual\x20exclusion\x20other\x20than\n\x20betwe\
    en\x20Cloud\x20Spanner\x20transactions\x20themselves.\n\n\x20###\x20Retr\
    ying\x20Aborted\x20Transactions\n\n\x20When\x20a\x20transaction\x20abort\
    s,\x20the\x20application\x20can\x20choose\x20to\x20retry\x20the\n\x20who\
    le\x20transaction\x20again.\x20To\x20maximize\x20the\x20chances\x20of\
    \x20successfully\n\x20committing\x20the\x20retry,\x20the\x20client\x20sh\
    ould\x20execute\x20the\x20retry\x20in\x20the\n\x20same\x20session\x20as\
    \x20the\x20original\x20attempt.\x20The\x20original\x20session's\x20lock\
    \n\x20priority\x20increases\x20with\x20each\x20consecutive\x20abort,\x20\
    meaning\x20that\x20each\n\x20attempt\x20has\x20a\x20slightly\x20better\
    \x20chance\x20of\x20success\x20than\x20the\x20previous.\n\n\x20Under\x20\
    some\x20circumstances\x20(e.g.,\x20many\x20transactions\x20attempting\
    \x20to\n\x20modify\x20the\x20same\x20row(s)),\x20a\x20transaction\x20can\
    \x20abort\x20many\x20times\x20in\x20a\n\x20short\x20period\x20before\x20\
    successfully\x20committing.\x20Thus,\x20it\x20is\x20not\x20a\x20good\n\
    \x20idea\x20to\x20cap\x20the\x20number\x20of\x20retries\x20a\x20transact\
    ion\x20can\x20attempt;\n\x20instead,\x20it\x20is\x20better\x20to\x20limi\
    t\x20the\x20total\x20amount\x20of\x20wall\x20time\x20spent\n\x20retrying\
    .\n\n\x20###\x20Idle\x20Transactions\n\n\x20A\x20transaction\x20is\x20co\
    nsidered\x20idle\x20if\x20it\x20has\x20no\x20outstanding\x20reads\x20or\
    \n\x20SQL\x20queries\x20and\x20has\x20not\x20started\x20a\x20read\x20or\
    \x20SQL\x20query\x20within\x20the\x20last\x2010\n\x20seconds.\x20Idle\
    \x20transactions\x20can\x20be\x20aborted\x20by\x20Cloud\x20Spanner\x20so\
    \x20that\x20they\n\x20don't\x20hold\x20on\x20to\x20locks\x20indefinitely\
    .\x20In\x20that\x20case,\x20the\x20commit\x20will\n\x20fail\x20with\x20e\
    rror\x20`ABORTED`.\n\n\x20If\x20this\x20behavior\x20is\x20undesirable,\
    \x20periodically\x20executing\x20a\x20simple\n\x20SQL\x20query\x20in\x20\
    the\x20transaction\x20(e.g.,\x20`SELECT\x201`)\x20prevents\x20the\n\x20t\
    ransaction\x20from\x20becoming\x20idle.\n\n\x20##\x20Snapshot\x20Read-On\
    ly\x20Transactions\n\n\x20Snapshot\x20read-only\x20transactions\x20provi\
    des\x20a\x20simpler\x20method\x20than\n\x20locking\x20read-write\x20tran\
    sactions\x20for\x20doing\x20several\x20consistent\n\x20reads.\x20However\
    ,\x20this\x20type\x20of\x20transaction\x20does\x20not\x20support\x20writ\
    es.\n\n\x20Snapshot\x20transactions\x20do\x20not\x20take\x20locks.\x20In\
    stead,\x20they\x20work\x20by\n\x20choosing\x20a\x20Cloud\x20Spanner\x20t\
    imestamp,\x20then\x20executing\x20all\x20reads\x20at\x20that\n\x20timest\
    amp.\x20Since\x20they\x20do\x20not\x20acquire\x20locks,\x20they\x20do\
    \x20not\x20block\n\x20concurrent\x20read-write\x20transactions.\n\n\x20U\
    nlike\x20locking\x20read-write\x20transactions,\x20snapshot\x20read-only\
    \n\x20transactions\x20never\x20abort.\x20They\x20can\x20fail\x20if\x20th\
    e\x20chosen\x20read\n\x20timestamp\x20is\x20garbage\x20collected;\x20how\
    ever,\x20the\x20default\x20garbage\n\x20collection\x20policy\x20is\x20ge\
    nerous\x20enough\x20that\x20most\x20applications\x20do\x20not\n\x20need\
    \x20to\x20worry\x20about\x20this\x20in\x20practice.\n\n\x20Snapshot\x20r\
    ead-only\x20transactions\x20do\x20not\x20need\x20to\x20call\n\x20[Commit\
    ][google.spanner.v1.Spanner.Commit]\x20or\n\x20[Rollback][google.spanner\
    .v1.Spanner.Rollback]\x20(and\x20in\x20fact\x20are\x20not\n\x20permitted\
    \x20to\x20do\x20so).\n\n\x20To\x20execute\x20a\x20snapshot\x20transactio\
    n,\x20the\x20client\x20specifies\x20a\x20timestamp\n\x20bound,\x20which\
    \x20tells\x20Cloud\x20Spanner\x20how\x20to\x20choose\x20a\x20read\x20tim\
    estamp.\n\n\x20The\x20types\x20of\x20timestamp\x20bound\x20are:\n\n\x20\
    \x20\x20-\x20Strong\x20(the\x20default).\n\x20\x20\x20-\x20Bounded\x20st\
    aleness.\n\x20\x20\x20-\x20Exact\x20staleness.\n\n\x20If\x20the\x20Cloud\
    \x20Spanner\x20database\x20to\x20be\x20read\x20is\x20geographically\x20d\
    istributed,\n\x20stale\x20read-only\x20transactions\x20can\x20execute\
    \x20more\x20quickly\x20than\x20strong\n\x20or\x20read-write\x20transacti\
    on,\x20because\x20they\x20are\x20able\x20to\x20execute\x20far\n\x20from\
    \x20the\x20leader\x20replica.\n\n\x20Each\x20type\x20of\x20timestamp\x20\
    bound\x20is\x20discussed\x20in\x20detail\x20below.\n\n\x20###\x20Strong\
    \n\n\x20Strong\x20reads\x20are\x20guaranteed\x20to\x20see\x20the\x20effe\
    cts\x20of\x20all\x20transactions\n\x20that\x20have\x20committed\x20befor\
    e\x20the\x20start\x20of\x20the\x20read.\x20Furthermore,\x20all\n\x20rows\
    \x20yielded\x20by\x20a\x20single\x20read\x20are\x20consistent\x20with\
    \x20each\x20other\x20--\x20if\n\x20any\x20part\x20of\x20the\x20read\x20o\
    bserves\x20a\x20transaction,\x20all\x20parts\x20of\x20the\x20read\n\x20s\
    ee\x20the\x20transaction.\n\n\x20Strong\x20reads\x20are\x20not\x20repeat\
    able:\x20two\x20consecutive\x20strong\x20read-only\n\x20transactions\x20\
    might\x20return\x20inconsistent\x20results\x20if\x20there\x20are\n\x20co\
    ncurrent\x20writes.\x20If\x20consistency\x20across\x20reads\x20is\x20req\
    uired,\x20the\n\x20reads\x20should\x20be\x20executed\x20within\x20a\x20t\
    ransaction\x20or\x20at\x20an\x20exact\x20read\n\x20timestamp.\n\n\x20See\
    \x20[TransactionOptions.ReadOnly.strong][google.spanner.v1.TransactionOp\
    tions.ReadOnly.strong].\n\n\x20###\x20Exact\x20Staleness\n\n\x20These\
    \x20timestamp\x20bounds\x20execute\x20reads\x20at\x20a\x20user-specified\
    \n\x20timestamp.\x20Reads\x20at\x20a\x20timestamp\x20are\x20guaranteed\
    \x20to\x20see\x20a\x20consistent\n\x20prefix\x20of\x20the\x20global\x20t\
    ransaction\x20history:\x20they\x20observe\n\x20modifications\x20done\x20\
    by\x20all\x20transactions\x20with\x20a\x20commit\x20timestamp\x20<=\n\
    \x20the\x20read\x20timestamp,\x20and\x20observe\x20none\x20of\x20the\x20\
    modifications\x20done\x20by\n\x20transactions\x20with\x20a\x20larger\x20\
    commit\x20timestamp.\x20They\x20will\x20block\x20until\n\x20all\x20confl\
    icting\x20transactions\x20that\x20may\x20be\x20assigned\x20commit\x20tim\
    estamps\n\x20<=\x20the\x20read\x20timestamp\x20have\x20finished.\n\n\x20\
    The\x20timestamp\x20can\x20either\x20be\x20expressed\x20as\x20an\x20abso\
    lute\x20Cloud\x20Spanner\x20commit\n\x20timestamp\x20or\x20a\x20stalenes\
    s\x20relative\x20to\x20the\x20current\x20time.\n\n\x20These\x20modes\x20\
    do\x20not\x20require\x20a\x20\"negotiation\x20phase\"\x20to\x20pick\x20a\
    \n\x20timestamp.\x20As\x20a\x20result,\x20they\x20execute\x20slightly\
    \x20faster\x20than\x20the\n\x20equivalent\x20boundedly\x20stale\x20concu\
    rrency\x20modes.\x20On\x20the\x20other\x20hand,\n\x20boundedly\x20stale\
    \x20reads\x20usually\x20return\x20fresher\x20results.\n\n\x20See\x20[Tra\
    nsactionOptions.ReadOnly.read_timestamp][google.spanner.v1.TransactionOp\
    tions.ReadOnly.read_timestamp]\x20and\n\x20[TransactionOptions.ReadOnly.\
    exact_staleness][google.spanner.v1.TransactionOptions.ReadOnly.exact_sta\
    leness].\n\n\x20###\x20Bounded\x20Staleness\n\n\x20Bounded\x20staleness\
    \x20modes\x20allow\x20Cloud\x20Spanner\x20to\x20pick\x20the\x20read\x20t\
    imestamp,\n\x20subject\x20to\x20a\x20user-provided\x20staleness\x20bound\
    .\x20Cloud\x20Spanner\x20chooses\x20the\n\x20newest\x20timestamp\x20with\
    in\x20the\x20staleness\x20bound\x20that\x20allows\x20execution\n\x20of\
    \x20the\x20reads\x20at\x20the\x20closest\x20available\x20replica\x20with\
    out\x20blocking.\n\n\x20All\x20rows\x20yielded\x20are\x20consistent\x20w\
    ith\x20each\x20other\x20--\x20if\x20any\x20part\x20of\n\x20the\x20read\
    \x20observes\x20a\x20transaction,\x20all\x20parts\x20of\x20the\x20read\
    \x20see\x20the\n\x20transaction.\x20Boundedly\x20stale\x20reads\x20are\
    \x20not\x20repeatable:\x20two\x20stale\n\x20reads,\x20even\x20if\x20they\
    \x20use\x20the\x20same\x20staleness\x20bound,\x20can\x20execute\x20at\n\
    \x20different\x20timestamps\x20and\x20thus\x20return\x20inconsistent\x20\
    results.\n\n\x20Boundedly\x20stale\x20reads\x20execute\x20in\x20two\x20p\
    hases:\x20the\x20first\x20phase\n\x20negotiates\x20a\x20timestamp\x20amo\
    ng\x20all\x20replicas\x20needed\x20to\x20serve\x20the\n\x20read.\x20In\
    \x20the\x20second\x20phase,\x20reads\x20are\x20executed\x20at\x20the\x20\
    negotiated\n\x20timestamp.\n\n\x20As\x20a\x20result\x20of\x20the\x20two\
    \x20phase\x20execution,\x20bounded\x20staleness\x20reads\x20are\n\x20usu\
    ally\x20a\x20little\x20slower\x20than\x20comparable\x20exact\x20stalenes\
    s\n\x20reads.\x20However,\x20they\x20are\x20typically\x20able\x20to\x20r\
    eturn\x20fresher\n\x20results,\x20and\x20are\x20more\x20likely\x20to\x20\
    execute\x20at\x20the\x20closest\x20replica.\n\n\x20Because\x20the\x20tim\
    estamp\x20negotiation\x20requires\x20up-front\x20knowledge\x20of\n\x20wh\
    ich\x20rows\x20will\x20be\x20read,\x20it\x20can\x20only\x20be\x20used\
    \x20with\x20single-use\n\x20read-only\x20transactions.\n\n\x20See\x20[Tr\
    ansactionOptions.ReadOnly.max_staleness][google.spanner.v1.TransactionOp\
    tions.ReadOnly.max_staleness]\x20and\n\x20[TransactionOptions.ReadOnly.m\
    in_read_timestamp][google.spanner.v1.TransactionOptions.ReadOnly.min_rea\
    d_timestamp].\n\n\x20###\x20Old\x20Read\x20Timestamps\x20and\x20Garbage\
    \x20Collection\n\n\x20Cloud\x20Spanner\x20continuously\x20garbage\x20col\
    lects\x20deleted\x20and\x20overwritten\x20data\n\x20in\x20the\x20backgro\
    und\x20to\x20reclaim\x20storage\x20space.\x20This\x20process\x20is\x20kn\
    own\n\x20as\x20\"version\x20GC\".\x20By\x20default,\x20version\x20GC\x20\
    reclaims\x20versions\x20after\x20they\n\x20are\x20one\x20hour\x20old.\
    \x20Because\x20of\x20this,\x20Cloud\x20Spanner\x20cannot\x20perform\x20r\
    eads\n\x20at\x20read\x20timestamps\x20more\x20than\x20one\x20hour\x20in\
    \x20the\x20past.\x20This\n\x20restriction\x20also\x20applies\x20to\x20in\
    -progress\x20reads\x20and/or\x20SQL\x20queries\x20whose\n\x20timestamp\
    \x20become\x20too\x20old\x20while\x20executing.\x20Reads\x20and\x20SQL\
    \x20queries\x20with\n\x20too-old\x20read\x20timestamps\x20fail\x20with\
    \x20the\x20error\x20`FAILED_PRECONDITION`.\n\n\x20##\x20Partitioned\x20D\
    ML\x20Transactions\n\n\x20Partitioned\x20DML\x20transactions\x20are\x20u\
    sed\x20to\x20execute\x20DML\x20statements\x20with\x20a\n\x20different\
    \x20execution\x20strategy\x20that\x20provides\x20different,\x20and\x20of\
    ten\x20better,\n\x20scalability\x20properties\x20for\x20large,\x20table-\
    wide\x20operations\x20than\x20DML\x20in\x20a\n\x20ReadWrite\x20transacti\
    on.\x20Smaller\x20scoped\x20statements,\x20such\x20as\x20an\x20OLTP\x20w\
    orkload,\n\x20should\x20prefer\x20using\x20ReadWrite\x20transactions.\n\
    \n\x20Partitioned\x20DML\x20partitions\x20the\x20keyspace\x20and\x20runs\
    \x20the\x20DML\x20statement\x20on\x20each\n\x20partition\x20in\x20separa\
    te,\x20internal\x20transactions.\x20These\x20transactions\x20commit\n\
    \x20automatically\x20when\x20complete,\x20and\x20run\x20independently\
    \x20from\x20one\x20another.\n\n\x20To\x20reduce\x20lock\x20contention,\
    \x20this\x20execution\x20strategy\x20only\x20acquires\x20read\x20locks\n\
    \x20on\x20rows\x20that\x20match\x20the\x20WHERE\x20clause\x20of\x20the\
    \x20statement.\x20Additionally,\x20the\n\x20smaller\x20per-partition\x20\
    transactions\x20hold\x20locks\x20for\x20less\x20time.\n\n\x20That\x20sai\
    d,\x20Partitioned\x20DML\x20is\x20not\x20a\x20drop-in\x20replacement\x20\
    for\x20standard\x20DML\x20used\n\x20in\x20ReadWrite\x20transactions.\n\n\
    \x20\x20-\x20The\x20DML\x20statement\x20must\x20be\x20fully-partitionabl\
    e.\x20Specifically,\x20the\x20statement\n\x20\x20\x20\x20must\x20be\x20e\
    xpressible\x20as\x20the\x20union\x20of\x20many\x20statements\x20which\
    \x20each\x20access\x20only\n\x20\x20\x20\x20a\x20single\x20row\x20of\x20\
    the\x20table.\n\n\x20\x20-\x20The\x20statement\x20is\x20not\x20applied\
    \x20atomically\x20to\x20all\x20rows\x20of\x20the\x20table.\x20Rather,\n\
    \x20\x20\x20\x20the\x20statement\x20is\x20applied\x20atomically\x20to\
    \x20partitions\x20of\x20the\x20table,\x20in\n\x20\x20\x20\x20independent\
    \x20transactions.\x20Secondary\x20index\x20rows\x20are\x20updated\x20ato\
    mically\n\x20\x20\x20\x20with\x20the\x20base\x20table\x20rows.\n\n\x20\
    \x20-\x20Partitioned\x20DML\x20does\x20not\x20guarantee\x20exactly-once\
    \x20execution\x20semantics\n\x20\x20\x20\x20against\x20a\x20partition.\
    \x20The\x20statement\x20will\x20be\x20applied\x20at\x20least\x20once\x20\
    to\x20each\n\x20\x20\x20\x20partition.\x20It\x20is\x20strongly\x20recomm\
    ended\x20that\x20the\x20DML\x20statement\x20should\x20be\n\x20\x20\x20\
    \x20idempotent\x20to\x20avoid\x20unexpected\x20results.\x20For\x20instan\
    ce,\x20it\x20is\x20potentially\n\x20\x20\x20\x20dangerous\x20to\x20run\
    \x20a\x20statement\x20such\x20as\n\x20\x20\x20\x20`UPDATE\x20table\x20SE\
    T\x20column\x20=\x20column\x20+\x201`\x20as\x20it\x20could\x20be\x20run\
    \x20multiple\x20times\n\x20\x20\x20\x20against\x20some\x20rows.\n\n\x20\
    \x20-\x20The\x20partitions\x20are\x20committed\x20automatically\x20-\x20\
    there\x20is\x20no\x20support\x20for\n\x20\x20\x20\x20Commit\x20or\x20Rol\
    lback.\x20If\x20the\x20call\x20returns\x20an\x20error,\x20or\x20if\x20th\
    e\x20client\x20issuing\n\x20\x20\x20\x20the\x20ExecuteSql\x20call\x20die\
    s,\x20it\x20is\x20possible\x20that\x20some\x20rows\x20had\x20the\x20stat\
    ement\n\x20\x20\x20\x20executed\x20on\x20them\x20successfully.\x20It\x20\
    is\x20also\x20possible\x20that\x20statement\x20was\n\x20\x20\x20\x20neve\
    r\x20executed\x20against\x20other\x20rows.\n\n\x20\x20-\x20Partitioned\
    \x20DML\x20transactions\x20may\x20only\x20contain\x20the\x20execution\
    \x20of\x20a\x20single\n\x20\x20\x20\x20DML\x20statement\x20via\x20Execut\
    eSql\x20or\x20ExecuteStreamingSql.\n\n\x20\x20-\x20If\x20any\x20error\
    \x20is\x20encountered\x20during\x20the\x20execution\x20of\x20the\x20part\
    itioned\x20DML\n\x20\x20\x20\x20operation\x20(for\x20instance,\x20a\x20U\
    NIQUE\x20INDEX\x20violation,\x20division\x20by\x20zero,\x20or\x20a\n\x20\
    \x20\x20\x20value\x20that\x20cannot\x20be\x20stored\x20due\x20to\x20sche\
    ma\x20constraints),\x20then\x20the\n\x20\x20\x20\x20operation\x20is\x20s\
    topped\x20at\x20that\x20point\x20and\x20an\x20error\x20is\x20returned.\
    \x20It\x20is\n\x20\x20\x20\x20possible\x20that\x20at\x20this\x20point,\
    \x20some\x20partitions\x20have\x20been\x20committed\x20(or\x20even\n\x20\
    \x20\x20\x20committed\x20multiple\x20times),\x20and\x20other\x20partitio\
    ns\x20have\x20not\x20been\x20run\x20at\x20all.\n\n\x20Given\x20the\x20ab\
    ove,\x20Partitioned\x20DML\x20is\x20good\x20fit\x20for\x20large,\x20data\
    base-wide,\n\x20operations\x20that\x20are\x20idempotent,\x20such\x20as\
    \x20deleting\x20old\x20rows\x20from\x20a\x20very\x20large\n\x20table.\n\
    \n\x0b\n\x03\x04\0\x01\x12\x04\xb3\x02\x08\x1a\nu\n\x04\x04\0\x03\0\x12\
    \x06\xb6\x02\x02\xb8\x02\x03\x1ae\x20Message\x20type\x20to\x20initiate\
    \x20a\x20read-write\x20transaction.\x20Currently\x20this\n\x20transactio\
    n\x20type\x20has\x20no\x20options.\n\n\r\n\x05\x04\0\x03\0\x01\x12\x04\
    \xb6\x02\n\x13\nI\n\x04\x04\0\x03\x01\x12\x06\xbb\x02\x02\xbd\x02\x03\
    \x1a9\x20Message\x20type\x20to\x20initiate\x20a\x20Partitioned\x20DML\
    \x20transaction.\n\n\r\n\x05\x04\0\x03\x01\x01\x12\x04\xbb\x02\n\x18\nC\
    \n\x04\x04\0\x03\x02\x12\x06\xc0\x02\x02\x81\x03\x03\x1a3\x20Message\x20\
    type\x20to\x20initiate\x20a\x20read-only\x20transaction.\n\n\r\n\x05\x04\
    \0\x03\x02\x01\x12\x04\xc0\x02\n\x12\nN\n\x06\x04\0\x03\x02\x08\0\x12\
    \x06\xc2\x02\x04\xfc\x02\x05\x1a<\x20How\x20to\x20choose\x20the\x20times\
    tamp\x20for\x20the\x20read-only\x20transaction.\n\n\x0f\n\x07\x04\0\x03\
    \x02\x08\0\x01\x12\x04\xc2\x02\n\x19\n_\n\x06\x04\0\x03\x02\x02\0\x12\
    \x04\xc5\x02\x06\x16\x1aO\x20Read\x20at\x20a\x20timestamp\x20where\x20al\
    l\x20previously\x20committed\x20transactions\n\x20are\x20visible.\n\n\
    \x0f\n\x07\x04\0\x03\x02\x02\0\x05\x12\x04\xc5\x02\x06\n\n\x0f\n\x07\x04\
    \0\x03\x02\x02\0\x01\x12\x04\xc5\x02\x0b\x11\n\x0f\n\x07\x04\0\x03\x02\
    \x02\0\x03\x12\x04\xc5\x02\x14\x15\n\xc6\x03\n\x06\x04\0\x03\x02\x02\x01\
    \x12\x04\xd1\x02\x067\x1a\xb5\x03\x20Executes\x20all\x20reads\x20at\x20a\
    \x20timestamp\x20>=\x20`min_read_timestamp`.\n\n\x20This\x20is\x20useful\
    \x20for\x20requesting\x20fresher\x20data\x20than\x20some\x20previous\n\
    \x20read,\x20or\x20data\x20that\x20is\x20fresh\x20enough\x20to\x20observ\
    e\x20the\x20effects\x20of\x20some\n\x20previously\x20committed\x20transa\
    ction\x20whose\x20timestamp\x20is\x20known.\n\n\x20Note\x20that\x20this\
    \x20option\x20can\x20only\x20be\x20used\x20in\x20single-use\x20transacti\
    ons.\n\n\x20A\x20timestamp\x20in\x20RFC3339\x20UTC\x20\\\"Zulu\\\"\x20fo\
    rmat,\x20accurate\x20to\x20nanoseconds.\n\x20Example:\x20`\"2014-10-02T1\
    5:01:23.045123456Z\"`.\n\n\x0f\n\x07\x04\0\x03\x02\x02\x01\x06\x12\x04\
    \xd1\x02\x06\x1f\n\x0f\n\x07\x04\0\x03\x02\x02\x01\x01\x12\x04\xd1\x02\
    \x202\n\x0f\n\x07\x04\0\x03\x02\x02\x01\x03\x12\x04\xd1\x0256\n\xba\x04\
    \n\x06\x04\0\x03\x02\x02\x02\x12\x04\xe0\x02\x061\x1a\xa9\x04\x20Read\
    \x20data\x20at\x20a\x20timestamp\x20>=\x20`NOW\x20-\x20max_staleness`\n\
    \x20seconds.\x20Guarantees\x20that\x20all\x20writes\x20that\x20have\x20c\
    ommitted\x20more\n\x20than\x20the\x20specified\x20number\x20of\x20second\
    s\x20ago\x20are\x20visible.\x20Because\n\x20Cloud\x20Spanner\x20chooses\
    \x20the\x20exact\x20timestamp,\x20this\x20mode\x20works\x20even\x20if\n\
    \x20the\x20client's\x20local\x20clock\x20is\x20substantially\x20skewed\
    \x20from\x20Cloud\x20Spanner\n\x20commit\x20timestamps.\n\n\x20Useful\
    \x20for\x20reading\x20the\x20freshest\x20data\x20available\x20at\x20a\
    \x20nearby\n\x20replica,\x20while\x20bounding\x20the\x20possible\x20stal\
    eness\x20if\x20the\x20local\n\x20replica\x20has\x20fallen\x20behind.\n\n\
    \x20Note\x20that\x20this\x20option\x20can\x20only\x20be\x20used\x20in\
    \x20single-use\n\x20transactions.\n\n\x0f\n\x07\x04\0\x03\x02\x02\x02\
    \x06\x12\x04\xe0\x02\x06\x1e\n\x0f\n\x07\x04\0\x03\x02\x02\x02\x01\x12\
    \x04\xe0\x02\x1f,\n\x0f\n\x07\x04\0\x03\x02\x02\x02\x03\x12\x04\xe0\x02/\
    0\n\xb6\x04\n\x06\x04\0\x03\x02\x02\x03\x12\x04\xee\x02\x063\x1a\xa5\x04\
    \x20Executes\x20all\x20reads\x20at\x20the\x20given\x20timestamp.\x20Unli\
    ke\x20other\x20modes,\n\x20reads\x20at\x20a\x20specific\x20timestamp\x20\
    are\x20repeatable;\x20the\x20same\x20read\x20at\n\x20the\x20same\x20time\
    stamp\x20always\x20returns\x20the\x20same\x20data.\x20If\x20the\n\x20tim\
    estamp\x20is\x20in\x20the\x20future,\x20the\x20read\x20will\x20block\x20\
    until\x20the\n\x20specified\x20timestamp,\x20modulo\x20the\x20read's\x20\
    deadline.\n\n\x20Useful\x20for\x20large\x20scale\x20consistent\x20reads\
    \x20such\x20as\x20mapreduces,\x20or\n\x20for\x20coordinating\x20many\x20\
    reads\x20against\x20a\x20consistent\x20snapshot\x20of\x20the\n\x20data.\
    \n\n\x20A\x20timestamp\x20in\x20RFC3339\x20UTC\x20\\\"Zulu\\\"\x20format\
    ,\x20accurate\x20to\x20nanoseconds.\n\x20Example:\x20`\"2014-10-02T15:01\
    :23.045123456Z\"`.\n\n\x0f\n\x07\x04\0\x03\x02\x02\x03\x06\x12\x04\xee\
    \x02\x06\x1f\n\x0f\n\x07\x04\0\x03\x02\x02\x03\x01\x12\x04\xee\x02\x20.\
    \n\x0f\n\x07\x04\0\x03\x02\x02\x03\x03\x12\x04\xee\x0212\n\x92\x04\n\x06\
    \x04\0\x03\x02\x02\x04\x12\x04\xfb\x02\x063\x1a\x81\x04\x20Executes\x20a\
    ll\x20reads\x20at\x20a\x20timestamp\x20that\x20is\x20`exact_staleness`\n\
    \x20old.\x20The\x20timestamp\x20is\x20chosen\x20soon\x20after\x20the\x20\
    read\x20is\x20started.\n\n\x20Guarantees\x20that\x20all\x20writes\x20tha\
    t\x20have\x20committed\x20more\x20than\x20the\n\x20specified\x20number\
    \x20of\x20seconds\x20ago\x20are\x20visible.\x20Because\x20Cloud\x20Spann\
    er\n\x20chooses\x20the\x20exact\x20timestamp,\x20this\x20mode\x20works\
    \x20even\x20if\x20the\x20client's\n\x20local\x20clock\x20is\x20substanti\
    ally\x20skewed\x20from\x20Cloud\x20Spanner\x20commit\n\x20timestamps.\n\
    \n\x20Useful\x20for\x20reading\x20at\x20nearby\x20replicas\x20without\
    \x20the\x20distributed\n\x20timestamp\x20negotiation\x20overhead\x20of\
    \x20`max_staleness`.\n\n\x0f\n\x07\x04\0\x03\x02\x02\x04\x06\x12\x04\xfb\
    \x02\x06\x1e\n\x0f\n\x07\x04\0\x03\x02\x02\x04\x01\x12\x04\xfb\x02\x1f.\
    \n\x0f\n\x07\x04\0\x03\x02\x02\x04\x03\x12\x04\xfb\x0212\n\xae\x01\n\x06\
    \x04\0\x03\x02\x02\x05\x12\x04\x80\x03\x04#\x1a\x9d\x01\x20If\x20true,\
    \x20the\x20Cloud\x20Spanner-selected\x20read\x20timestamp\x20is\x20inclu\
    ded\x20in\n\x20the\x20[Transaction][google.spanner.v1.Transaction]\x20me\
    ssage\x20that\x20describes\x20the\x20transaction.\n\n\x11\n\x07\x04\0\
    \x03\x02\x02\x05\x04\x12\x06\x80\x03\x04\xfc\x02\x05\n\x0f\n\x07\x04\0\
    \x03\x02\x02\x05\x05\x12\x04\x80\x03\x04\x08\n\x0f\n\x07\x04\0\x03\x02\
    \x02\x05\x01\x12\x04\x80\x03\t\x1e\n\x0f\n\x07\x04\0\x03\x02\x02\x05\x03\
    \x12\x04\x80\x03!\"\n4\n\x04\x04\0\x08\0\x12\x06\x84\x03\x02\x99\x03\x03\
    \x1a$\x20Required.\x20The\x20type\x20of\x20transaction.\n\n\r\n\x05\x04\
    \0\x08\0\x01\x12\x04\x84\x03\x08\x0c\n\xc2\x01\n\x04\x04\0\x02\0\x12\x04\
    \x8a\x03\x04\x1d\x1a\xb3\x01\x20Transaction\x20may\x20write.\n\n\x20Auth\
    orization\x20to\x20begin\x20a\x20read-write\x20transaction\x20requires\n\
    \x20`spanner.databases.beginOrRollbackReadWriteTransaction`\x20permissio\
    n\n\x20on\x20the\x20`session`\x20resource.\n\n\r\n\x05\x04\0\x02\0\x06\
    \x12\x04\x8a\x03\x04\r\n\r\n\x05\x04\0\x02\0\x01\x12\x04\x8a\x03\x0e\x18\
    \n\r\n\x05\x04\0\x02\0\x03\x12\x04\x8a\x03\x1b\x1c\n\xc8\x01\n\x04\x04\0\
    \x02\x01\x12\x04\x91\x03\x04'\x1a\xb9\x01\x20Partitioned\x20DML\x20trans\
    action.\n\n\x20Authorization\x20to\x20begin\x20a\x20Partitioned\x20DML\
    \x20transaction\x20requires\n\x20`spanner.databases.beginPartitionedDmlT\
    ransaction`\x20permission\n\x20on\x20the\x20`session`\x20resource.\n\n\r\
    \n\x05\x04\0\x02\x01\x06\x12\x04\x91\x03\x04\x12\n\r\n\x05\x04\0\x02\x01\
    \x01\x12\x04\x91\x03\x13\"\n\r\n\x05\x04\0\x02\x01\x03\x12\x04\x91\x03%&\
    \n\xbb\x01\n\x04\x04\0\x02\x02\x12\x04\x98\x03\x04\x1b\x1a\xac\x01\x20Tr\
    ansaction\x20will\x20not\x20write.\n\n\x20Authorization\x20to\x20begin\
    \x20a\x20read-only\x20transaction\x20requires\n\x20`spanner.databases.be\
    ginReadOnlyTransaction`\x20permission\n\x20on\x20the\x20`session`\x20res\
    ource.\n\n\r\n\x05\x04\0\x02\x02\x06\x12\x04\x98\x03\x04\x0c\n\r\n\x05\
    \x04\0\x02\x02\x01\x12\x04\x98\x03\r\x16\n\r\n\x05\x04\0\x02\x02\x03\x12\
    \x04\x98\x03\x19\x1a\n\x1e\n\x02\x04\x01\x12\x06\x9d\x03\0\xaf\x03\x01\
    \x1a\x10\x20A\x20transaction.\n\n\x0b\n\x03\x04\x01\x01\x12\x04\x9d\x03\
    \x08\x13\n\x88\x03\n\x04\x04\x01\x02\0\x12\x04\xa6\x03\x02\x0f\x1a\xf9\
    \x02\x20`id`\x20may\x20be\x20used\x20to\x20identify\x20the\x20transactio\
    n\x20in\x20subsequent\n\x20[Read][google.spanner.v1.Spanner.Read],\n\x20\
    [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql],\n\x20[Commit][google\
    .spanner.v1.Spanner.Commit],\x20or\n\x20[Rollback][google.spanner.v1.Spa\
    nner.Rollback]\x20calls.\n\n\x20Single-use\x20read-only\x20transactions\
    \x20do\x20not\x20have\x20IDs,\x20because\n\x20single-use\x20transactions\
    \x20do\x20not\x20support\x20multiple\x20requests.\n\n\x0f\n\x05\x04\x01\
    \x02\0\x04\x12\x06\xa6\x03\x02\x9d\x03\x15\n\r\n\x05\x04\x01\x02\0\x05\
    \x12\x04\xa6\x03\x02\x07\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\xa6\x03\x08\
    \n\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\xa6\x03\r\x0e\n\xf2\x02\n\x04\x04\
    \x01\x02\x01\x12\x04\xae\x03\x02/\x1a\xe3\x02\x20For\x20snapshot\x20read\
    -only\x20transactions,\x20the\x20read\x20timestamp\x20chosen\n\x20for\
    \x20the\x20transaction.\x20Not\x20returned\x20by\x20default:\x20see\n\
    \x20[TransactionOptions.ReadOnly.return_read_timestamp][google.spanner.v\
    1.TransactionOptions.ReadOnly.return_read_timestamp].\n\n\x20A\x20timest\
    amp\x20in\x20RFC3339\x20UTC\x20\\\"Zulu\\\"\x20format,\x20accurate\x20to\
    \x20nanoseconds.\n\x20Example:\x20`\"2014-10-02T15:01:23.045123456Z\"`.\
    \n\n\x0f\n\x05\x04\x01\x02\x01\x04\x12\x06\xae\x03\x02\xa6\x03\x0f\n\r\n\
    \x05\x04\x01\x02\x01\x06\x12\x04\xae\x03\x02\x1b\n\r\n\x05\x04\x01\x02\
    \x01\x01\x12\x04\xae\x03\x1c*\n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\xae\
    \x03-.\n\x9e\x02\n\x02\x04\x02\x12\x06\xb6\x03\0\xc7\x03\x01\x1a\x8f\x02\
    \x20This\x20message\x20is\x20used\x20to\x20select\x20the\x20transaction\
    \x20in\x20which\x20a\n\x20[Read][google.spanner.v1.Spanner.Read]\x20or\n\
    \x20[ExecuteSql][google.spanner.v1.Spanner.ExecuteSql]\x20call\x20runs.\
    \n\n\x20See\x20[TransactionOptions][google.spanner.v1.TransactionOptions\
    ]\x20for\x20more\x20information\x20about\x20transactions.\n\n\x0b\n\x03\
    \x04\x02\x01\x12\x04\xb6\x03\x08\x1b\ni\n\x04\x04\x02\x08\0\x12\x06\xb9\
    \x03\x02\xc6\x03\x03\x1aY\x20If\x20no\x20fields\x20are\x20set,\x20the\
    \x20default\x20is\x20a\x20single\x20use\x20transaction\n\x20with\x20stro\
    ng\x20concurrency.\n\n\r\n\x05\x04\x02\x08\0\x01\x12\x04\xb9\x03\x08\x10\
    \n\xa9\x01\n\x04\x04\x02\x02\0\x12\x04\xbd\x03\x04&\x1a\x9a\x01\x20Execu\
    te\x20the\x20read\x20or\x20SQL\x20query\x20in\x20a\x20temporary\x20trans\
    action.\n\x20This\x20is\x20the\x20most\x20efficient\x20way\x20to\x20exec\
    ute\x20a\x20transaction\x20that\n\x20consists\x20of\x20a\x20single\x20SQ\
    L\x20query.\n\n\r\n\x05\x04\x02\x02\0\x06\x12\x04\xbd\x03\x04\x16\n\r\n\
    \x05\x04\x02\x02\0\x01\x12\x04\xbd\x03\x17!\n\r\n\x05\x04\x02\x02\0\x03\
    \x12\x04\xbd\x03$%\nR\n\x04\x04\x02\x02\x01\x12\x04\xc0\x03\x04\x11\x1aD\
    \x20Execute\x20the\x20read\x20or\x20SQL\x20query\x20in\x20a\x20previousl\
    y-started\x20transaction.\n\n\r\n\x05\x04\x02\x02\x01\x05\x12\x04\xc0\
    \x03\x04\t\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\xc0\x03\n\x0c\n\r\n\x05\
    \x04\x02\x02\x01\x03\x12\x04\xc0\x03\x0f\x10\n\x98\x02\n\x04\x04\x02\x02\
    \x02\x12\x04\xc5\x03\x04!\x1a\x89\x02\x20Begin\x20a\x20new\x20transactio\
    n\x20and\x20execute\x20this\x20read\x20or\x20SQL\x20query\x20in\n\x20it.\
    \x20The\x20transaction\x20ID\x20of\x20the\x20new\x20transaction\x20is\
    \x20returned\x20in\n\x20[ResultSetMetadata.transaction][google.spanner.v\
    1.ResultSetMetadata.transaction],\x20which\x20is\x20a\x20[Transaction][g\
    oogle.spanner.v1.Transaction].\n\n\r\n\x05\x04\x02\x02\x02\x06\x12\x04\
    \xc5\x03\x04\x16\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\xc5\x03\x17\x1c\n\
    \r\n\x05\x04\x02\x02\x02\x03\x12\x04\xc5\x03\x1f\x20b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
