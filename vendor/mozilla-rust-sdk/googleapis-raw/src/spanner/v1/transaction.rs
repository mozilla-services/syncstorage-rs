// This file is generated by rust-protobuf 2.16.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/spanner/v1/transaction.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_16_2;

#[derive(PartialEq,Clone,Default)]
pub struct TransactionOptions {
    // message oneof groups
    pub mode: ::std::option::Option<TransactionOptions_oneof_mode>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionOptions {
    fn default() -> &'a TransactionOptions {
        <TransactionOptions as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum TransactionOptions_oneof_mode {
    read_write(TransactionOptions_ReadWrite),
    partitioned_dml(TransactionOptions_PartitionedDml),
    read_only(TransactionOptions_ReadOnly),
}

impl TransactionOptions {
    pub fn new() -> TransactionOptions {
        ::std::default::Default::default()
    }

    // .google.spanner.v1.TransactionOptions.ReadWrite read_write = 1;


    pub fn get_read_write(&self) -> &TransactionOptions_ReadWrite {
        match self.mode {
            ::std::option::Option::Some(TransactionOptions_oneof_mode::read_write(ref v)) => v,
            _ => <TransactionOptions_ReadWrite as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_read_write(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_read_write(&self) -> bool {
        match self.mode {
            ::std::option::Option::Some(TransactionOptions_oneof_mode::read_write(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read_write(&mut self, v: TransactionOptions_ReadWrite) {
        self.mode = ::std::option::Option::Some(TransactionOptions_oneof_mode::read_write(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read_write(&mut self) -> &mut TransactionOptions_ReadWrite {
        if let ::std::option::Option::Some(TransactionOptions_oneof_mode::read_write(_)) = self.mode {
        } else {
            self.mode = ::std::option::Option::Some(TransactionOptions_oneof_mode::read_write(TransactionOptions_ReadWrite::new()));
        }
        match self.mode {
            ::std::option::Option::Some(TransactionOptions_oneof_mode::read_write(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read_write(&mut self) -> TransactionOptions_ReadWrite {
        if self.has_read_write() {
            match self.mode.take() {
                ::std::option::Option::Some(TransactionOptions_oneof_mode::read_write(v)) => v,
                _ => panic!(),
            }
        } else {
            TransactionOptions_ReadWrite::new()
        }
    }

    // .google.spanner.v1.TransactionOptions.PartitionedDml partitioned_dml = 3;


    pub fn get_partitioned_dml(&self) -> &TransactionOptions_PartitionedDml {
        match self.mode {
            ::std::option::Option::Some(TransactionOptions_oneof_mode::partitioned_dml(ref v)) => v,
            _ => <TransactionOptions_PartitionedDml as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_partitioned_dml(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_partitioned_dml(&self) -> bool {
        match self.mode {
            ::std::option::Option::Some(TransactionOptions_oneof_mode::partitioned_dml(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_partitioned_dml(&mut self, v: TransactionOptions_PartitionedDml) {
        self.mode = ::std::option::Option::Some(TransactionOptions_oneof_mode::partitioned_dml(v))
    }

    // Mutable pointer to the field.
    pub fn mut_partitioned_dml(&mut self) -> &mut TransactionOptions_PartitionedDml {
        if let ::std::option::Option::Some(TransactionOptions_oneof_mode::partitioned_dml(_)) = self.mode {
        } else {
            self.mode = ::std::option::Option::Some(TransactionOptions_oneof_mode::partitioned_dml(TransactionOptions_PartitionedDml::new()));
        }
        match self.mode {
            ::std::option::Option::Some(TransactionOptions_oneof_mode::partitioned_dml(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_partitioned_dml(&mut self) -> TransactionOptions_PartitionedDml {
        if self.has_partitioned_dml() {
            match self.mode.take() {
                ::std::option::Option::Some(TransactionOptions_oneof_mode::partitioned_dml(v)) => v,
                _ => panic!(),
            }
        } else {
            TransactionOptions_PartitionedDml::new()
        }
    }

    // .google.spanner.v1.TransactionOptions.ReadOnly read_only = 2;


    pub fn get_read_only(&self) -> &TransactionOptions_ReadOnly {
        match self.mode {
            ::std::option::Option::Some(TransactionOptions_oneof_mode::read_only(ref v)) => v,
            _ => <TransactionOptions_ReadOnly as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_read_only(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_read_only(&self) -> bool {
        match self.mode {
            ::std::option::Option::Some(TransactionOptions_oneof_mode::read_only(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read_only(&mut self, v: TransactionOptions_ReadOnly) {
        self.mode = ::std::option::Option::Some(TransactionOptions_oneof_mode::read_only(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read_only(&mut self) -> &mut TransactionOptions_ReadOnly {
        if let ::std::option::Option::Some(TransactionOptions_oneof_mode::read_only(_)) = self.mode {
        } else {
            self.mode = ::std::option::Option::Some(TransactionOptions_oneof_mode::read_only(TransactionOptions_ReadOnly::new()));
        }
        match self.mode {
            ::std::option::Option::Some(TransactionOptions_oneof_mode::read_only(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read_only(&mut self) -> TransactionOptions_ReadOnly {
        if self.has_read_only() {
            match self.mode.take() {
                ::std::option::Option::Some(TransactionOptions_oneof_mode::read_only(v)) => v,
                _ => panic!(),
            }
        } else {
            TransactionOptions_ReadOnly::new()
        }
    }
}

impl ::protobuf::Message for TransactionOptions {
    fn is_initialized(&self) -> bool {
        if let Some(TransactionOptions_oneof_mode::read_write(ref v)) = self.mode {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TransactionOptions_oneof_mode::partitioned_dml(ref v)) = self.mode {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TransactionOptions_oneof_mode::read_only(ref v)) = self.mode {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mode = ::std::option::Option::Some(TransactionOptions_oneof_mode::read_write(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mode = ::std::option::Option::Some(TransactionOptions_oneof_mode::partitioned_dml(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mode = ::std::option::Option::Some(TransactionOptions_oneof_mode::read_only(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.mode {
            match v {
                &TransactionOptions_oneof_mode::read_write(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TransactionOptions_oneof_mode::partitioned_dml(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TransactionOptions_oneof_mode::read_only(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.mode {
            match v {
                &TransactionOptions_oneof_mode::read_write(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TransactionOptions_oneof_mode::partitioned_dml(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TransactionOptions_oneof_mode::read_only(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionOptions {
        TransactionOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TransactionOptions_ReadWrite>(
                "read_write",
                TransactionOptions::has_read_write,
                TransactionOptions::get_read_write,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TransactionOptions_PartitionedDml>(
                "partitioned_dml",
                TransactionOptions::has_partitioned_dml,
                TransactionOptions::get_partitioned_dml,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TransactionOptions_ReadOnly>(
                "read_only",
                TransactionOptions::has_read_only,
                TransactionOptions::get_read_only,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransactionOptions>(
                "TransactionOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransactionOptions {
        static instance: ::protobuf::rt::LazyV2<TransactionOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransactionOptions::new)
    }
}

impl ::protobuf::Clear for TransactionOptions {
    fn clear(&mut self) {
        self.mode = ::std::option::Option::None;
        self.mode = ::std::option::Option::None;
        self.mode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionOptions_ReadWrite {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionOptions_ReadWrite {
    fn default() -> &'a TransactionOptions_ReadWrite {
        <TransactionOptions_ReadWrite as ::protobuf::Message>::default_instance()
    }
}

impl TransactionOptions_ReadWrite {
    pub fn new() -> TransactionOptions_ReadWrite {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TransactionOptions_ReadWrite {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionOptions_ReadWrite {
        TransactionOptions_ReadWrite::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransactionOptions_ReadWrite>(
                "TransactionOptions.ReadWrite",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransactionOptions_ReadWrite {
        static instance: ::protobuf::rt::LazyV2<TransactionOptions_ReadWrite> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransactionOptions_ReadWrite::new)
    }
}

impl ::protobuf::Clear for TransactionOptions_ReadWrite {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionOptions_ReadWrite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionOptions_ReadWrite {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionOptions_PartitionedDml {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionOptions_PartitionedDml {
    fn default() -> &'a TransactionOptions_PartitionedDml {
        <TransactionOptions_PartitionedDml as ::protobuf::Message>::default_instance()
    }
}

impl TransactionOptions_PartitionedDml {
    pub fn new() -> TransactionOptions_PartitionedDml {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TransactionOptions_PartitionedDml {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionOptions_PartitionedDml {
        TransactionOptions_PartitionedDml::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransactionOptions_PartitionedDml>(
                "TransactionOptions.PartitionedDml",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransactionOptions_PartitionedDml {
        static instance: ::protobuf::rt::LazyV2<TransactionOptions_PartitionedDml> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransactionOptions_PartitionedDml::new)
    }
}

impl ::protobuf::Clear for TransactionOptions_PartitionedDml {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionOptions_PartitionedDml {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionOptions_PartitionedDml {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionOptions_ReadOnly {
    // message fields
    pub return_read_timestamp: bool,
    // message oneof groups
    pub timestamp_bound: ::std::option::Option<TransactionOptions_ReadOnly_oneof_timestamp_bound>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionOptions_ReadOnly {
    fn default() -> &'a TransactionOptions_ReadOnly {
        <TransactionOptions_ReadOnly as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum TransactionOptions_ReadOnly_oneof_timestamp_bound {
    strong(bool),
    min_read_timestamp(::protobuf::well_known_types::Timestamp),
    max_staleness(::protobuf::well_known_types::Duration),
    read_timestamp(::protobuf::well_known_types::Timestamp),
    exact_staleness(::protobuf::well_known_types::Duration),
}

impl TransactionOptions_ReadOnly {
    pub fn new() -> TransactionOptions_ReadOnly {
        ::std::default::Default::default()
    }

    // bool strong = 1;


    pub fn get_strong(&self) -> bool {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::strong(v)) => v,
            _ => false,
        }
    }
    pub fn clear_strong(&mut self) {
        self.timestamp_bound = ::std::option::Option::None;
    }

    pub fn has_strong(&self) -> bool {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::strong(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_strong(&mut self, v: bool) {
        self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::strong(v))
    }

    // .google.protobuf.Timestamp min_read_timestamp = 2;


    pub fn get_min_read_timestamp(&self) -> &::protobuf::well_known_types::Timestamp {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(ref v)) => v,
            _ => <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_min_read_timestamp(&mut self) {
        self.timestamp_bound = ::std::option::Option::None;
    }

    pub fn has_min_read_timestamp(&self) -> bool {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_min_read_timestamp(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_min_read_timestamp(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if let ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(_)) = self.timestamp_bound {
        } else {
            self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(::protobuf::well_known_types::Timestamp::new()));
        }
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_min_read_timestamp(&mut self) -> ::protobuf::well_known_types::Timestamp {
        if self.has_min_read_timestamp() {
            match self.timestamp_bound.take() {
                ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Timestamp::new()
        }
    }

    // .google.protobuf.Duration max_staleness = 3;


    pub fn get_max_staleness(&self) -> &::protobuf::well_known_types::Duration {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(ref v)) => v,
            _ => <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_max_staleness(&mut self) {
        self.timestamp_bound = ::std::option::Option::None;
    }

    pub fn has_max_staleness(&self) -> bool {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_max_staleness(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(v))
    }

    // Mutable pointer to the field.
    pub fn mut_max_staleness(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if let ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(_)) = self.timestamp_bound {
        } else {
            self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(::protobuf::well_known_types::Duration::new()));
        }
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_max_staleness(&mut self) -> ::protobuf::well_known_types::Duration {
        if self.has_max_staleness() {
            match self.timestamp_bound.take() {
                ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Duration::new()
        }
    }

    // .google.protobuf.Timestamp read_timestamp = 4;


    pub fn get_read_timestamp(&self) -> &::protobuf::well_known_types::Timestamp {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(ref v)) => v,
            _ => <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_read_timestamp(&mut self) {
        self.timestamp_bound = ::std::option::Option::None;
    }

    pub fn has_read_timestamp(&self) -> bool {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read_timestamp(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read_timestamp(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if let ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(_)) = self.timestamp_bound {
        } else {
            self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(::protobuf::well_known_types::Timestamp::new()));
        }
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read_timestamp(&mut self) -> ::protobuf::well_known_types::Timestamp {
        if self.has_read_timestamp() {
            match self.timestamp_bound.take() {
                ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Timestamp::new()
        }
    }

    // .google.protobuf.Duration exact_staleness = 5;


    pub fn get_exact_staleness(&self) -> &::protobuf::well_known_types::Duration {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(ref v)) => v,
            _ => <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_exact_staleness(&mut self) {
        self.timestamp_bound = ::std::option::Option::None;
    }

    pub fn has_exact_staleness(&self) -> bool {
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_exact_staleness(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(v))
    }

    // Mutable pointer to the field.
    pub fn mut_exact_staleness(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if let ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(_)) = self.timestamp_bound {
        } else {
            self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(::protobuf::well_known_types::Duration::new()));
        }
        match self.timestamp_bound {
            ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_exact_staleness(&mut self) -> ::protobuf::well_known_types::Duration {
        if self.has_exact_staleness() {
            match self.timestamp_bound.take() {
                ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Duration::new()
        }
    }

    // bool return_read_timestamp = 6;


    pub fn get_return_read_timestamp(&self) -> bool {
        self.return_read_timestamp
    }
    pub fn clear_return_read_timestamp(&mut self) {
        self.return_read_timestamp = false;
    }

    // Param is passed by value, moved
    pub fn set_return_read_timestamp(&mut self, v: bool) {
        self.return_read_timestamp = v;
    }
}

impl ::protobuf::Message for TransactionOptions_ReadOnly {
    fn is_initialized(&self) -> bool {
        if let Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(ref v)) = self.timestamp_bound {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(ref v)) = self.timestamp_bound {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(ref v)) = self.timestamp_bound {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(ref v)) = self.timestamp_bound {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::strong(is.read_bool()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.timestamp_bound = ::std::option::Option::Some(TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.return_read_timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.return_read_timestamp != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.timestamp_bound {
            match v {
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::strong(v) => {
                    my_size += 2;
                },
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.return_read_timestamp != false {
            os.write_bool(6, self.return_read_timestamp)?;
        }
        if let ::std::option::Option::Some(ref v) = self.timestamp_bound {
            match v {
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::strong(v) => {
                    os.write_bool(1, v)?;
                },
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::min_read_timestamp(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::max_staleness(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::read_timestamp(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TransactionOptions_ReadOnly_oneof_timestamp_bound::exact_staleness(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionOptions_ReadOnly {
        TransactionOptions_ReadOnly::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "strong",
                TransactionOptions_ReadOnly::has_strong,
                TransactionOptions_ReadOnly::get_strong,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Timestamp>(
                "min_read_timestamp",
                TransactionOptions_ReadOnly::has_min_read_timestamp,
                TransactionOptions_ReadOnly::get_min_read_timestamp,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Duration>(
                "max_staleness",
                TransactionOptions_ReadOnly::has_max_staleness,
                TransactionOptions_ReadOnly::get_max_staleness,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Timestamp>(
                "read_timestamp",
                TransactionOptions_ReadOnly::has_read_timestamp,
                TransactionOptions_ReadOnly::get_read_timestamp,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Duration>(
                "exact_staleness",
                TransactionOptions_ReadOnly::has_exact_staleness,
                TransactionOptions_ReadOnly::get_exact_staleness,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "return_read_timestamp",
                |m: &TransactionOptions_ReadOnly| { &m.return_read_timestamp },
                |m: &mut TransactionOptions_ReadOnly| { &mut m.return_read_timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransactionOptions_ReadOnly>(
                "TransactionOptions.ReadOnly",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransactionOptions_ReadOnly {
        static instance: ::protobuf::rt::LazyV2<TransactionOptions_ReadOnly> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransactionOptions_ReadOnly::new)
    }
}

impl ::protobuf::Clear for TransactionOptions_ReadOnly {
    fn clear(&mut self) {
        self.timestamp_bound = ::std::option::Option::None;
        self.timestamp_bound = ::std::option::Option::None;
        self.timestamp_bound = ::std::option::Option::None;
        self.timestamp_bound = ::std::option::Option::None;
        self.timestamp_bound = ::std::option::Option::None;
        self.return_read_timestamp = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionOptions_ReadOnly {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionOptions_ReadOnly {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction {
    // message fields
    pub id: ::std::vec::Vec<u8>,
    pub read_timestamp: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction {
    fn default() -> &'a Transaction {
        <Transaction as ::protobuf::Message>::default_instance()
    }
}

impl Transaction {
    pub fn new() -> Transaction {
        ::std::default::Default::default()
    }

    // bytes id = 1;


    pub fn get_id(&self) -> &[u8] {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.id, ::std::vec::Vec::new())
    }

    // .google.protobuf.Timestamp read_timestamp = 2;


    pub fn get_read_timestamp(&self) -> &::protobuf::well_known_types::Timestamp {
        self.read_timestamp.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_read_timestamp(&mut self) {
        self.read_timestamp.clear();
    }

    pub fn has_read_timestamp(&self) -> bool {
        self.read_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read_timestamp(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.read_timestamp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_read_timestamp(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.read_timestamp.is_none() {
            self.read_timestamp.set_default();
        }
        self.read_timestamp.as_mut().unwrap()
    }

    // Take field
    pub fn take_read_timestamp(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.read_timestamp.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for Transaction {
    fn is_initialized(&self) -> bool {
        for v in &self.read_timestamp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.read_timestamp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.id);
        }
        if let Some(ref v) = self.read_timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_bytes(1, &self.id)?;
        }
        if let Some(ref v) = self.read_timestamp.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction {
        Transaction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "id",
                |m: &Transaction| { &m.id },
                |m: &mut Transaction| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "read_timestamp",
                |m: &Transaction| { &m.read_timestamp },
                |m: &mut Transaction| { &mut m.read_timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transaction>(
                "Transaction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Transaction {
        static instance: ::protobuf::rt::LazyV2<Transaction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Transaction::new)
    }
}

impl ::protobuf::Clear for Transaction {
    fn clear(&mut self) {
        self.id.clear();
        self.read_timestamp.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionSelector {
    // message oneof groups
    pub selector: ::std::option::Option<TransactionSelector_oneof_selector>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionSelector {
    fn default() -> &'a TransactionSelector {
        <TransactionSelector as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum TransactionSelector_oneof_selector {
    single_use(TransactionOptions),
    id(::std::vec::Vec<u8>),
    begin(TransactionOptions),
}

impl TransactionSelector {
    pub fn new() -> TransactionSelector {
        ::std::default::Default::default()
    }

    // .google.spanner.v1.TransactionOptions single_use = 1;


    pub fn get_single_use(&self) -> &TransactionOptions {
        match self.selector {
            ::std::option::Option::Some(TransactionSelector_oneof_selector::single_use(ref v)) => v,
            _ => <TransactionOptions as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_single_use(&mut self) {
        self.selector = ::std::option::Option::None;
    }

    pub fn has_single_use(&self) -> bool {
        match self.selector {
            ::std::option::Option::Some(TransactionSelector_oneof_selector::single_use(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_single_use(&mut self, v: TransactionOptions) {
        self.selector = ::std::option::Option::Some(TransactionSelector_oneof_selector::single_use(v))
    }

    // Mutable pointer to the field.
    pub fn mut_single_use(&mut self) -> &mut TransactionOptions {
        if let ::std::option::Option::Some(TransactionSelector_oneof_selector::single_use(_)) = self.selector {
        } else {
            self.selector = ::std::option::Option::Some(TransactionSelector_oneof_selector::single_use(TransactionOptions::new()));
        }
        match self.selector {
            ::std::option::Option::Some(TransactionSelector_oneof_selector::single_use(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_single_use(&mut self) -> TransactionOptions {
        if self.has_single_use() {
            match self.selector.take() {
                ::std::option::Option::Some(TransactionSelector_oneof_selector::single_use(v)) => v,
                _ => panic!(),
            }
        } else {
            TransactionOptions::new()
        }
    }

    // bytes id = 2;


    pub fn get_id(&self) -> &[u8] {
        match self.selector {
            ::std::option::Option::Some(TransactionSelector_oneof_selector::id(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_id(&mut self) {
        self.selector = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        match self.selector {
            ::std::option::Option::Some(TransactionSelector_oneof_selector::id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.selector = ::std::option::Option::Some(TransactionSelector_oneof_selector::id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(TransactionSelector_oneof_selector::id(_)) = self.selector {
        } else {
            self.selector = ::std::option::Option::Some(TransactionSelector_oneof_selector::id(::std::vec::Vec::new()));
        }
        match self.selector {
            ::std::option::Option::Some(TransactionSelector_oneof_selector::id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_id() {
            match self.selector.take() {
                ::std::option::Option::Some(TransactionSelector_oneof_selector::id(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // .google.spanner.v1.TransactionOptions begin = 3;


    pub fn get_begin(&self) -> &TransactionOptions {
        match self.selector {
            ::std::option::Option::Some(TransactionSelector_oneof_selector::begin(ref v)) => v,
            _ => <TransactionOptions as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_begin(&mut self) {
        self.selector = ::std::option::Option::None;
    }

    pub fn has_begin(&self) -> bool {
        match self.selector {
            ::std::option::Option::Some(TransactionSelector_oneof_selector::begin(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_begin(&mut self, v: TransactionOptions) {
        self.selector = ::std::option::Option::Some(TransactionSelector_oneof_selector::begin(v))
    }

    // Mutable pointer to the field.
    pub fn mut_begin(&mut self) -> &mut TransactionOptions {
        if let ::std::option::Option::Some(TransactionSelector_oneof_selector::begin(_)) = self.selector {
        } else {
            self.selector = ::std::option::Option::Some(TransactionSelector_oneof_selector::begin(TransactionOptions::new()));
        }
        match self.selector {
            ::std::option::Option::Some(TransactionSelector_oneof_selector::begin(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_begin(&mut self) -> TransactionOptions {
        if self.has_begin() {
            match self.selector.take() {
                ::std::option::Option::Some(TransactionSelector_oneof_selector::begin(v)) => v,
                _ => panic!(),
            }
        } else {
            TransactionOptions::new()
        }
    }
}

impl ::protobuf::Message for TransactionSelector {
    fn is_initialized(&self) -> bool {
        if let Some(TransactionSelector_oneof_selector::single_use(ref v)) = self.selector {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(TransactionSelector_oneof_selector::begin(ref v)) = self.selector {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.selector = ::std::option::Option::Some(TransactionSelector_oneof_selector::single_use(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.selector = ::std::option::Option::Some(TransactionSelector_oneof_selector::id(is.read_bytes()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.selector = ::std::option::Option::Some(TransactionSelector_oneof_selector::begin(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.selector {
            match v {
                &TransactionSelector_oneof_selector::single_use(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &TransactionSelector_oneof_selector::id(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
                &TransactionSelector_oneof_selector::begin(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.selector {
            match v {
                &TransactionSelector_oneof_selector::single_use(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &TransactionSelector_oneof_selector::id(ref v) => {
                    os.write_bytes(2, v)?;
                },
                &TransactionSelector_oneof_selector::begin(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionSelector {
        TransactionSelector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TransactionOptions>(
                "single_use",
                TransactionSelector::has_single_use,
                TransactionSelector::get_single_use,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "id",
                TransactionSelector::has_id,
                TransactionSelector::get_id,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TransactionOptions>(
                "begin",
                TransactionSelector::has_begin,
                TransactionSelector::get_begin,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransactionSelector>(
                "TransactionSelector",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransactionSelector {
        static instance: ::protobuf::rt::LazyV2<TransactionSelector> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransactionSelector::new)
    }
}

impl ::protobuf::Clear for TransactionSelector {
    fn clear(&mut self) {
        self.selector = ::std::option::Option::None;
        self.selector = ::std::option::Option::None;
        self.selector = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionSelector {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n#google/spanner/v1/transaction.proto\x12\x11google.spanner.v1\x1a\x1cg\
    oogle/api/annotations.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\
    \x1fgoogle/protobuf/timestamp.proto\"\xc4\x05\n\x12TransactionOptions\
    \x12P\n\nread_write\x18\x01\x20\x01(\x0b2/.google.spanner.v1.Transaction\
    Options.ReadWriteH\0R\treadWrite\x12_\n\x0fpartitioned_dml\x18\x03\x20\
    \x01(\x0b24.google.spanner.v1.TransactionOptions.PartitionedDmlH\0R\x0ep\
    artitionedDml\x12M\n\tread_only\x18\x02\x20\x01(\x0b2..google.spanner.v1\
    .TransactionOptions.ReadOnlyH\0R\x08readOnly\x1a\x0b\n\tReadWrite\x1a\
    \x10\n\x0ePartitionedDml\x1a\x84\x03\n\x08ReadOnly\x12\x18\n\x06strong\
    \x18\x01\x20\x01(\x08H\0R\x06strong\x12J\n\x12min_read_timestamp\x18\x02\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampH\0R\x10minReadTimestamp\x12\
    @\n\rmax_staleness\x18\x03\x20\x01(\x0b2\x19.google.protobuf.DurationH\0\
    R\x0cmaxStaleness\x12C\n\x0eread_timestamp\x18\x04\x20\x01(\x0b2\x1a.goo\
    gle.protobuf.TimestampH\0R\rreadTimestamp\x12D\n\x0fexact_staleness\x18\
    \x05\x20\x01(\x0b2\x19.google.protobuf.DurationH\0R\x0eexactStaleness\
    \x122\n\x15return_read_timestamp\x18\x06\x20\x01(\x08R\x13returnReadTime\
    stampB\x11\n\x0ftimestamp_boundB\x06\n\x04mode\"`\n\x0bTransaction\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\x0cR\x02id\x12A\n\x0eread_timestamp\x18\
    \x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\rreadTimestamp\"\xba\
    \x01\n\x13TransactionSelector\x12F\n\nsingle_use\x18\x01\x20\x01(\x0b2%.\
    google.spanner.v1.TransactionOptionsH\0R\tsingleUse\x12\x10\n\x02id\x18\
    \x02\x20\x01(\x0cH\0R\x02id\x12=\n\x05begin\x18\x03\x20\x01(\x0b2%.googl\
    e.spanner.v1.TransactionOptionsH\0R\x05beginB\n\n\x08selectorB\x99\x01\n\
    \x15com.google.spanner.v1B\x10TransactionProtoP\x01Z8google.golang.org/g\
    enproto/googleapis/spanner/v1;spanner\xaa\x02\x17Google.Cloud.Spanner.V1\
    \xca\x02\x17Google\\Cloud\\Spanner\\V1J\x99\x99\x01\n\x07\x12\x05\x0e\0\
    \xc7\x03\x01\n\xbc\x04\n\x01\x0c\x12\x03\x0e\0\x122\xb1\x04\x20Copyright\
    \x202018\x20Google\x20LLC\n\n\x20Licensed\x20under\x20the\x20Apache\x20L\
    icense,\x20Version\x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20no\
    t\x20use\x20this\x20file\x20except\x20in\x20compliance\x20with\x20the\
    \x20License.\n\x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20Lice\
    nse\x20at\n\n\x20\x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-\
    2.0\n\n\x20Unless\x20required\x20by\x20applicable\x20law\x20or\x20agreed\
    \x20to\x20in\x20writing,\x20software\n\x20distributed\x20under\x20the\
    \x20License\x20is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\
    \x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20e\
    ither\x20express\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20\
    the\x20specific\x20language\x20governing\x20permissions\x20and\n\x20limi\
    tations\x20under\x20the\x20License.\n\n\x08\n\x01\x02\x12\x03\x10\0\x1a\
    \n\t\n\x02\x03\0\x12\x03\x12\0&\n\t\n\x02\x03\x01\x12\x03\x13\0(\n\t\n\
    \x02\x03\x02\x12\x03\x14\0)\n\x08\n\x01\x08\x12\x03\x16\04\n\t\n\x02\x08\
    %\x12\x03\x16\04\n\x08\n\x01\x08\x12\x03\x17\0O\n\t\n\x02\x08\x0b\x12\
    \x03\x17\0O\n\x08\n\x01\x08\x12\x03\x18\0\"\n\t\n\x02\x08\n\x12\x03\x18\
    \0\"\n\x08\n\x01\x08\x12\x03\x19\01\n\t\n\x02\x08\x08\x12\x03\x19\01\n\
    \x08\n\x01\x08\x12\x03\x1a\0.\n\t\n\x02\x08\x01\x12\x03\x1a\0.\n\x08\n\
    \x01\x08\x12\x03\x1b\04\n\t\n\x02\x08)\x12\x03\x1b\04\n\x80e\n\x02\x04\0\
    \x12\x06\xb3\x02\0\x9a\x03\x01\x1a\xf1d\x20#\x20Transactions\n\n\n\x20Ea\
    ch\x20session\x20can\x20have\x20at\x20most\x20one\x20active\x20transacti\
    on\x20at\x20a\x20time.\x20After\x20the\n\x20active\x20transaction\x20is\
    \x20completed,\x20the\x20session\x20can\x20immediately\x20be\n\x20re-use\
    d\x20for\x20the\x20next\x20transaction.\x20It\x20is\x20not\x20necessary\
    \x20to\x20create\x20a\n\x20new\x20session\x20for\x20each\x20transaction.\
    \n\n\x20#\x20Transaction\x20Modes\n\n\x20Cloud\x20Spanner\x20supports\
    \x20three\x20transaction\x20modes:\n\n\x20\x20\x201.\x20Locking\x20read-\
    write.\x20This\x20type\x20of\x20transaction\x20is\x20the\x20only\x20way\
    \n\x20\x20\x20\x20\x20\x20to\x20write\x20data\x20into\x20Cloud\x20Spanne\
    r.\x20These\x20transactions\x20rely\x20on\n\x20\x20\x20\x20\x20\x20pessi\
    mistic\x20locking\x20and,\x20if\x20necessary,\x20two-phase\x20commit.\n\
    \x20\x20\x20\x20\x20\x20Locking\x20read-write\x20transactions\x20may\x20\
    abort,\x20requiring\x20the\n\x20\x20\x20\x20\x20\x20application\x20to\
    \x20retry.\n\n\x20\x20\x202.\x20Snapshot\x20read-only.\x20This\x20transa\
    ction\x20type\x20provides\x20guaranteed\n\x20\x20\x20\x20\x20\x20consist\
    ency\x20across\x20several\x20reads,\x20but\x20does\x20not\x20allow\n\x20\
    \x20\x20\x20\x20\x20writes.\x20Snapshot\x20read-only\x20transactions\x20\
    can\x20be\x20configured\x20to\n\x20\x20\x20\x20\x20\x20read\x20at\x20tim\
    estamps\x20in\x20the\x20past.\x20Snapshot\x20read-only\n\x20\x20\x20\x20\
    \x20\x20transactions\x20do\x20not\x20need\x20to\x20be\x20committed.\n\n\
    \x20\x20\x203.\x20Partitioned\x20DML.\x20This\x20type\x20of\x20transacti\
    on\x20is\x20used\x20to\x20execute\n\x20\x20\x20\x20\x20\x20a\x20single\
    \x20Partitioned\x20DML\x20statement.\x20Partitioned\x20DML\x20partitions\
    \n\x20\x20\x20\x20\x20\x20the\x20key\x20space\x20and\x20runs\x20the\x20D\
    ML\x20statement\x20over\x20each\x20partition\n\x20\x20\x20\x20\x20\x20in\
    \x20parallel\x20using\x20separate,\x20internal\x20transactions\x20that\
    \x20commit\n\x20\x20\x20\x20\x20\x20independently.\x20Partitioned\x20DML\
    \x20transactions\x20do\x20not\x20need\x20to\x20be\n\x20\x20\x20\x20\x20\
    \x20committed.\n\n\x20For\x20transactions\x20that\x20only\x20read,\x20sn\
    apshot\x20read-only\x20transactions\n\x20provide\x20simpler\x20semantics\
    \x20and\x20are\x20almost\x20always\x20faster.\x20In\n\x20particular,\x20\
    read-only\x20transactions\x20do\x20not\x20take\x20locks,\x20so\x20they\
    \x20do\n\x20not\x20conflict\x20with\x20read-write\x20transactions.\x20As\
    \x20a\x20consequence\x20of\x20not\n\x20taking\x20locks,\x20they\x20also\
    \x20do\x20not\x20abort,\x20so\x20retry\x20loops\x20are\x20not\x20needed.\
    \n\n\x20Transactions\x20may\x20only\x20read/write\x20data\x20in\x20a\x20\
    single\x20database.\x20They\n\x20may,\x20however,\x20read/write\x20data\
    \x20in\x20different\x20tables\x20within\x20that\n\x20database.\n\n\x20##\
    \x20Locking\x20Read-Write\x20Transactions\n\n\x20Locking\x20transactions\
    \x20may\x20be\x20used\x20to\x20atomically\x20read-modify-write\n\x20data\
    \x20anywhere\x20in\x20a\x20database.\x20This\x20type\x20of\x20transactio\
    n\x20is\x20externally\n\x20consistent.\n\n\x20Clients\x20should\x20attem\
    pt\x20to\x20minimize\x20the\x20amount\x20of\x20time\x20a\x20transaction\
    \n\x20is\x20active.\x20Faster\x20transactions\x20commit\x20with\x20highe\
    r\x20probability\n\x20and\x20cause\x20less\x20contention.\x20Cloud\x20Sp\
    anner\x20attempts\x20to\x20keep\x20read\x20locks\n\x20active\x20as\x20lo\
    ng\x20as\x20the\x20transaction\x20continues\x20to\x20do\x20reads,\x20and\
    \x20the\n\x20transaction\x20has\x20not\x20been\x20terminated\x20by\n\x20\
    [Commit][google.spanner.v1.Spanner.Commit]\x20or\n\x20[Rollback][google.\
    spanner.v1.Spanner.Rollback].\x20\x20Long\x20periods\x20of\n\x20inactivi\
    ty\x20at\x20the\x20client\x20may\x20cause\x20Cloud\x20Spanner\x20to\x20r\
    elease\x20a\n\x20transaction's\x20locks\x20and\x20abort\x20it.\n\n\x20Co\
    nceptually,\x20a\x20read-write\x20transaction\x20consists\x20of\x20zero\
    \x20or\x20more\n\x20reads\x20or\x20SQL\x20statements\x20followed\x20by\n\
    \x20[Commit][google.spanner.v1.Spanner.Commit].\x20At\x20any\x20time\x20\
    before\n\x20[Commit][google.spanner.v1.Spanner.Commit],\x20the\x20client\
    \x20can\x20send\x20a\n\x20[Rollback][google.spanner.v1.Spanner.Rollback]\
    \x20request\x20to\x20abort\x20the\n\x20transaction.\n\n\x20###\x20Semant\
    ics\n\n\x20Cloud\x20Spanner\x20can\x20commit\x20the\x20transaction\x20if\
    \x20all\x20read\x20locks\x20it\x20acquired\n\x20are\x20still\x20valid\
    \x20at\x20commit\x20time,\x20and\x20it\x20is\x20able\x20to\x20acquire\
    \x20write\n\x20locks\x20for\x20all\x20writes.\x20Cloud\x20Spanner\x20can\
    \x20abort\x20the\x20transaction\x20for\x20any\n\x20reason.\x20If\x20a\
    \x20commit\x20attempt\x20returns\x20`ABORTED`,\x20Cloud\x20Spanner\x20gu\
    arantees\n\x20that\x20the\x20transaction\x20has\x20not\x20modified\x20an\
    y\x20user\x20data\x20in\x20Cloud\x20Spanner.\n\n\x20Unless\x20the\x20tra\
    nsaction\x20commits,\x20Cloud\x20Spanner\x20makes\x20no\x20guarantees\
    \x20about\n\x20how\x20long\x20the\x20transaction's\x20locks\x20were\x20h\
    eld\x20for.\x20It\x20is\x20an\x20error\x20to\n\x20use\x20Cloud\x20Spanne\
    r\x20locks\x20for\x20any\x20sort\x20of\x20mutual\x20exclusion\x20other\
    \x20than\n\x20between\x20Cloud\x20Spanner\x20transactions\x20themselves.\
    \n\n\x20###\x20Retrying\x20Aborted\x20Transactions\n\n\x20When\x20a\x20t\
    ransaction\x20aborts,\x20the\x20application\x20can\x20choose\x20to\x20re\
    try\x20the\n\x20whole\x20transaction\x20again.\x20To\x20maximize\x20the\
    \x20chances\x20of\x20successfully\n\x20committing\x20the\x20retry,\x20th\
    e\x20client\x20should\x20execute\x20the\x20retry\x20in\x20the\n\x20same\
    \x20session\x20as\x20the\x20original\x20attempt.\x20The\x20original\x20s\
    ession's\x20lock\n\x20priority\x20increases\x20with\x20each\x20consecuti\
    ve\x20abort,\x20meaning\x20that\x20each\n\x20attempt\x20has\x20a\x20slig\
    htly\x20better\x20chance\x20of\x20success\x20than\x20the\x20previous.\n\
    \n\x20Under\x20some\x20circumstances\x20(e.g.,\x20many\x20transactions\
    \x20attempting\x20to\n\x20modify\x20the\x20same\x20row(s)),\x20a\x20tran\
    saction\x20can\x20abort\x20many\x20times\x20in\x20a\n\x20short\x20period\
    \x20before\x20successfully\x20committing.\x20Thus,\x20it\x20is\x20not\
    \x20a\x20good\n\x20idea\x20to\x20cap\x20the\x20number\x20of\x20retries\
    \x20a\x20transaction\x20can\x20attempt;\n\x20instead,\x20it\x20is\x20bet\
    ter\x20to\x20limit\x20the\x20total\x20amount\x20of\x20wall\x20time\x20sp\
    ent\n\x20retrying.\n\n\x20###\x20Idle\x20Transactions\n\n\x20A\x20transa\
    ction\x20is\x20considered\x20idle\x20if\x20it\x20has\x20no\x20outstandin\
    g\x20reads\x20or\n\x20SQL\x20queries\x20and\x20has\x20not\x20started\x20\
    a\x20read\x20or\x20SQL\x20query\x20within\x20the\x20last\x2010\n\x20seco\
    nds.\x20Idle\x20transactions\x20can\x20be\x20aborted\x20by\x20Cloud\x20S\
    panner\x20so\x20that\x20they\n\x20don't\x20hold\x20on\x20to\x20locks\x20\
    indefinitely.\x20In\x20that\x20case,\x20the\x20commit\x20will\n\x20fail\
    \x20with\x20error\x20`ABORTED`.\n\n\x20If\x20this\x20behavior\x20is\x20u\
    ndesirable,\x20periodically\x20executing\x20a\x20simple\n\x20SQL\x20quer\
    y\x20in\x20the\x20transaction\x20(e.g.,\x20`SELECT\x201`)\x20prevents\
    \x20the\n\x20transaction\x20from\x20becoming\x20idle.\n\n\x20##\x20Snaps\
    hot\x20Read-Only\x20Transactions\n\n\x20Snapshot\x20read-only\x20transac\
    tions\x20provides\x20a\x20simpler\x20method\x20than\n\x20locking\x20read\
    -write\x20transactions\x20for\x20doing\x20several\x20consistent\n\x20rea\
    ds.\x20However,\x20this\x20type\x20of\x20transaction\x20does\x20not\x20s\
    upport\x20writes.\n\n\x20Snapshot\x20transactions\x20do\x20not\x20take\
    \x20locks.\x20Instead,\x20they\x20work\x20by\n\x20choosing\x20a\x20Cloud\
    \x20Spanner\x20timestamp,\x20then\x20executing\x20all\x20reads\x20at\x20\
    that\n\x20timestamp.\x20Since\x20they\x20do\x20not\x20acquire\x20locks,\
    \x20they\x20do\x20not\x20block\n\x20concurrent\x20read-write\x20transact\
    ions.\n\n\x20Unlike\x20locking\x20read-write\x20transactions,\x20snapsho\
    t\x20read-only\n\x20transactions\x20never\x20abort.\x20They\x20can\x20fa\
    il\x20if\x20the\x20chosen\x20read\n\x20timestamp\x20is\x20garbage\x20col\
    lected;\x20however,\x20the\x20default\x20garbage\n\x20collection\x20poli\
    cy\x20is\x20generous\x20enough\x20that\x20most\x20applications\x20do\x20\
    not\n\x20need\x20to\x20worry\x20about\x20this\x20in\x20practice.\n\n\x20\
    Snapshot\x20read-only\x20transactions\x20do\x20not\x20need\x20to\x20call\
    \n\x20[Commit][google.spanner.v1.Spanner.Commit]\x20or\n\x20[Rollback][g\
    oogle.spanner.v1.Spanner.Rollback]\x20(and\x20in\x20fact\x20are\x20not\n\
    \x20permitted\x20to\x20do\x20so).\n\n\x20To\x20execute\x20a\x20snapshot\
    \x20transaction,\x20the\x20client\x20specifies\x20a\x20timestamp\n\x20bo\
    und,\x20which\x20tells\x20Cloud\x20Spanner\x20how\x20to\x20choose\x20a\
    \x20read\x20timestamp.\n\n\x20The\x20types\x20of\x20timestamp\x20bound\
    \x20are:\n\n\x20\x20\x20-\x20Strong\x20(the\x20default).\n\x20\x20\x20-\
    \x20Bounded\x20staleness.\n\x20\x20\x20-\x20Exact\x20staleness.\n\n\x20I\
    f\x20the\x20Cloud\x20Spanner\x20database\x20to\x20be\x20read\x20is\x20ge\
    ographically\x20distributed,\n\x20stale\x20read-only\x20transactions\x20\
    can\x20execute\x20more\x20quickly\x20than\x20strong\n\x20or\x20read-writ\
    e\x20transaction,\x20because\x20they\x20are\x20able\x20to\x20execute\x20\
    far\n\x20from\x20the\x20leader\x20replica.\n\n\x20Each\x20type\x20of\x20\
    timestamp\x20bound\x20is\x20discussed\x20in\x20detail\x20below.\n\n\x20#\
    ##\x20Strong\n\n\x20Strong\x20reads\x20are\x20guaranteed\x20to\x20see\
    \x20the\x20effects\x20of\x20all\x20transactions\n\x20that\x20have\x20com\
    mitted\x20before\x20the\x20start\x20of\x20the\x20read.\x20Furthermore,\
    \x20all\n\x20rows\x20yielded\x20by\x20a\x20single\x20read\x20are\x20cons\
    istent\x20with\x20each\x20other\x20--\x20if\n\x20any\x20part\x20of\x20th\
    e\x20read\x20observes\x20a\x20transaction,\x20all\x20parts\x20of\x20the\
    \x20read\n\x20see\x20the\x20transaction.\n\n\x20Strong\x20reads\x20are\
    \x20not\x20repeatable:\x20two\x20consecutive\x20strong\x20read-only\n\
    \x20transactions\x20might\x20return\x20inconsistent\x20results\x20if\x20\
    there\x20are\n\x20concurrent\x20writes.\x20If\x20consistency\x20across\
    \x20reads\x20is\x20required,\x20the\n\x20reads\x20should\x20be\x20execut\
    ed\x20within\x20a\x20transaction\x20or\x20at\x20an\x20exact\x20read\n\
    \x20timestamp.\n\n\x20See\x20[TransactionOptions.ReadOnly.strong][google\
    .spanner.v1.TransactionOptions.ReadOnly.strong].\n\n\x20###\x20Exact\x20\
    Staleness\n\n\x20These\x20timestamp\x20bounds\x20execute\x20reads\x20at\
    \x20a\x20user-specified\n\x20timestamp.\x20Reads\x20at\x20a\x20timestamp\
    \x20are\x20guaranteed\x20to\x20see\x20a\x20consistent\n\x20prefix\x20of\
    \x20the\x20global\x20transaction\x20history:\x20they\x20observe\n\x20mod\
    ifications\x20done\x20by\x20all\x20transactions\x20with\x20a\x20commit\
    \x20timestamp\x20<=\n\x20the\x20read\x20timestamp,\x20and\x20observe\x20\
    none\x20of\x20the\x20modifications\x20done\x20by\n\x20transactions\x20wi\
    th\x20a\x20larger\x20commit\x20timestamp.\x20They\x20will\x20block\x20un\
    til\n\x20all\x20conflicting\x20transactions\x20that\x20may\x20be\x20assi\
    gned\x20commit\x20timestamps\n\x20<=\x20the\x20read\x20timestamp\x20have\
    \x20finished.\n\n\x20The\x20timestamp\x20can\x20either\x20be\x20expresse\
    d\x20as\x20an\x20absolute\x20Cloud\x20Spanner\x20commit\n\x20timestamp\
    \x20or\x20a\x20staleness\x20relative\x20to\x20the\x20current\x20time.\n\
    \n\x20These\x20modes\x20do\x20not\x20require\x20a\x20\"negotiation\x20ph\
    ase\"\x20to\x20pick\x20a\n\x20timestamp.\x20As\x20a\x20result,\x20they\
    \x20execute\x20slightly\x20faster\x20than\x20the\n\x20equivalent\x20boun\
    dedly\x20stale\x20concurrency\x20modes.\x20On\x20the\x20other\x20hand,\n\
    \x20boundedly\x20stale\x20reads\x20usually\x20return\x20fresher\x20resul\
    ts.\n\n\x20See\x20[TransactionOptions.ReadOnly.read_timestamp][google.sp\
    anner.v1.TransactionOptions.ReadOnly.read_timestamp]\x20and\n\x20[Transa\
    ctionOptions.ReadOnly.exact_staleness][google.spanner.v1.TransactionOpti\
    ons.ReadOnly.exact_staleness].\n\n\x20###\x20Bounded\x20Staleness\n\n\
    \x20Bounded\x20staleness\x20modes\x20allow\x20Cloud\x20Spanner\x20to\x20\
    pick\x20the\x20read\x20timestamp,\n\x20subject\x20to\x20a\x20user-provid\
    ed\x20staleness\x20bound.\x20Cloud\x20Spanner\x20chooses\x20the\n\x20new\
    est\x20timestamp\x20within\x20the\x20staleness\x20bound\x20that\x20allow\
    s\x20execution\n\x20of\x20the\x20reads\x20at\x20the\x20closest\x20availa\
    ble\x20replica\x20without\x20blocking.\n\n\x20All\x20rows\x20yielded\x20\
    are\x20consistent\x20with\x20each\x20other\x20--\x20if\x20any\x20part\
    \x20of\n\x20the\x20read\x20observes\x20a\x20transaction,\x20all\x20parts\
    \x20of\x20the\x20read\x20see\x20the\n\x20transaction.\x20Boundedly\x20st\
    ale\x20reads\x20are\x20not\x20repeatable:\x20two\x20stale\n\x20reads,\
    \x20even\x20if\x20they\x20use\x20the\x20same\x20staleness\x20bound,\x20c\
    an\x20execute\x20at\n\x20different\x20timestamps\x20and\x20thus\x20retur\
    n\x20inconsistent\x20results.\n\n\x20Boundedly\x20stale\x20reads\x20exec\
    ute\x20in\x20two\x20phases:\x20the\x20first\x20phase\n\x20negotiates\x20\
    a\x20timestamp\x20among\x20all\x20replicas\x20needed\x20to\x20serve\x20t\
    he\n\x20read.\x20In\x20the\x20second\x20phase,\x20reads\x20are\x20execut\
    ed\x20at\x20the\x20negotiated\n\x20timestamp.\n\n\x20As\x20a\x20result\
    \x20of\x20the\x20two\x20phase\x20execution,\x20bounded\x20staleness\x20r\
    eads\x20are\n\x20usually\x20a\x20little\x20slower\x20than\x20comparable\
    \x20exact\x20staleness\n\x20reads.\x20However,\x20they\x20are\x20typical\
    ly\x20able\x20to\x20return\x20fresher\n\x20results,\x20and\x20are\x20mor\
    e\x20likely\x20to\x20execute\x20at\x20the\x20closest\x20replica.\n\n\x20\
    Because\x20the\x20timestamp\x20negotiation\x20requires\x20up-front\x20kn\
    owledge\x20of\n\x20which\x20rows\x20will\x20be\x20read,\x20it\x20can\x20\
    only\x20be\x20used\x20with\x20single-use\n\x20read-only\x20transactions.\
    \n\n\x20See\x20[TransactionOptions.ReadOnly.max_staleness][google.spanne\
    r.v1.TransactionOptions.ReadOnly.max_staleness]\x20and\n\x20[Transaction\
    Options.ReadOnly.min_read_timestamp][google.spanner.v1.TransactionOption\
    s.ReadOnly.min_read_timestamp].\n\n\x20###\x20Old\x20Read\x20Timestamps\
    \x20and\x20Garbage\x20Collection\n\n\x20Cloud\x20Spanner\x20continuously\
    \x20garbage\x20collects\x20deleted\x20and\x20overwritten\x20data\n\x20in\
    \x20the\x20background\x20to\x20reclaim\x20storage\x20space.\x20This\x20p\
    rocess\x20is\x20known\n\x20as\x20\"version\x20GC\".\x20By\x20default,\
    \x20version\x20GC\x20reclaims\x20versions\x20after\x20they\n\x20are\x20o\
    ne\x20hour\x20old.\x20Because\x20of\x20this,\x20Cloud\x20Spanner\x20cann\
    ot\x20perform\x20reads\n\x20at\x20read\x20timestamps\x20more\x20than\x20\
    one\x20hour\x20in\x20the\x20past.\x20This\n\x20restriction\x20also\x20ap\
    plies\x20to\x20in-progress\x20reads\x20and/or\x20SQL\x20queries\x20whose\
    \n\x20timestamp\x20become\x20too\x20old\x20while\x20executing.\x20Reads\
    \x20and\x20SQL\x20queries\x20with\n\x20too-old\x20read\x20timestamps\x20\
    fail\x20with\x20the\x20error\x20`FAILED_PRECONDITION`.\n\n\x20##\x20Part\
    itioned\x20DML\x20Transactions\n\n\x20Partitioned\x20DML\x20transactions\
    \x20are\x20used\x20to\x20execute\x20DML\x20statements\x20with\x20a\n\x20\
    different\x20execution\x20strategy\x20that\x20provides\x20different,\x20\
    and\x20often\x20better,\n\x20scalability\x20properties\x20for\x20large,\
    \x20table-wide\x20operations\x20than\x20DML\x20in\x20a\n\x20ReadWrite\
    \x20transaction.\x20Smaller\x20scoped\x20statements,\x20such\x20as\x20an\
    \x20OLTP\x20workload,\n\x20should\x20prefer\x20using\x20ReadWrite\x20tra\
    nsactions.\n\n\x20Partitioned\x20DML\x20partitions\x20the\x20keyspace\
    \x20and\x20runs\x20the\x20DML\x20statement\x20on\x20each\n\x20partition\
    \x20in\x20separate,\x20internal\x20transactions.\x20These\x20transaction\
    s\x20commit\n\x20automatically\x20when\x20complete,\x20and\x20run\x20ind\
    ependently\x20from\x20one\x20another.\n\n\x20To\x20reduce\x20lock\x20con\
    tention,\x20this\x20execution\x20strategy\x20only\x20acquires\x20read\
    \x20locks\n\x20on\x20rows\x20that\x20match\x20the\x20WHERE\x20clause\x20\
    of\x20the\x20statement.\x20Additionally,\x20the\n\x20smaller\x20per-part\
    ition\x20transactions\x20hold\x20locks\x20for\x20less\x20time.\n\n\x20Th\
    at\x20said,\x20Partitioned\x20DML\x20is\x20not\x20a\x20drop-in\x20replac\
    ement\x20for\x20standard\x20DML\x20used\n\x20in\x20ReadWrite\x20transact\
    ions.\n\n\x20\x20-\x20The\x20DML\x20statement\x20must\x20be\x20fully-par\
    titionable.\x20Specifically,\x20the\x20statement\n\x20\x20\x20\x20must\
    \x20be\x20expressible\x20as\x20the\x20union\x20of\x20many\x20statements\
    \x20which\x20each\x20access\x20only\n\x20\x20\x20\x20a\x20single\x20row\
    \x20of\x20the\x20table.\n\n\x20\x20-\x20The\x20statement\x20is\x20not\
    \x20applied\x20atomically\x20to\x20all\x20rows\x20of\x20the\x20table.\
    \x20Rather,\n\x20\x20\x20\x20the\x20statement\x20is\x20applied\x20atomic\
    ally\x20to\x20partitions\x20of\x20the\x20table,\x20in\n\x20\x20\x20\x20i\
    ndependent\x20transactions.\x20Secondary\x20index\x20rows\x20are\x20upda\
    ted\x20atomically\n\x20\x20\x20\x20with\x20the\x20base\x20table\x20rows.\
    \n\n\x20\x20-\x20Partitioned\x20DML\x20does\x20not\x20guarantee\x20exact\
    ly-once\x20execution\x20semantics\n\x20\x20\x20\x20against\x20a\x20parti\
    tion.\x20The\x20statement\x20will\x20be\x20applied\x20at\x20least\x20onc\
    e\x20to\x20each\n\x20\x20\x20\x20partition.\x20It\x20is\x20strongly\x20r\
    ecommended\x20that\x20the\x20DML\x20statement\x20should\x20be\n\x20\x20\
    \x20\x20idempotent\x20to\x20avoid\x20unexpected\x20results.\x20For\x20in\
    stance,\x20it\x20is\x20potentially\n\x20\x20\x20\x20dangerous\x20to\x20r\
    un\x20a\x20statement\x20such\x20as\n\x20\x20\x20\x20`UPDATE\x20table\x20\
    SET\x20column\x20=\x20column\x20+\x201`\x20as\x20it\x20could\x20be\x20ru\
    n\x20multiple\x20times\n\x20\x20\x20\x20against\x20some\x20rows.\n\n\x20\
    \x20-\x20The\x20partitions\x20are\x20committed\x20automatically\x20-\x20\
    there\x20is\x20no\x20support\x20for\n\x20\x20\x20\x20Commit\x20or\x20Rol\
    lback.\x20If\x20the\x20call\x20returns\x20an\x20error,\x20or\x20if\x20th\
    e\x20client\x20issuing\n\x20\x20\x20\x20the\x20ExecuteSql\x20call\x20die\
    s,\x20it\x20is\x20possible\x20that\x20some\x20rows\x20had\x20the\x20stat\
    ement\n\x20\x20\x20\x20executed\x20on\x20them\x20successfully.\x20It\x20\
    is\x20also\x20possible\x20that\x20statement\x20was\n\x20\x20\x20\x20neve\
    r\x20executed\x20against\x20other\x20rows.\n\n\x20\x20-\x20Partitioned\
    \x20DML\x20transactions\x20may\x20only\x20contain\x20the\x20execution\
    \x20of\x20a\x20single\n\x20\x20\x20\x20DML\x20statement\x20via\x20Execut\
    eSql\x20or\x20ExecuteStreamingSql.\n\n\x20\x20-\x20If\x20any\x20error\
    \x20is\x20encountered\x20during\x20the\x20execution\x20of\x20the\x20part\
    itioned\x20DML\n\x20\x20\x20\x20operation\x20(for\x20instance,\x20a\x20U\
    NIQUE\x20INDEX\x20violation,\x20division\x20by\x20zero,\x20or\x20a\n\x20\
    \x20\x20\x20value\x20that\x20cannot\x20be\x20stored\x20due\x20to\x20sche\
    ma\x20constraints),\x20then\x20the\n\x20\x20\x20\x20operation\x20is\x20s\
    topped\x20at\x20that\x20point\x20and\x20an\x20error\x20is\x20returned.\
    \x20It\x20is\n\x20\x20\x20\x20possible\x20that\x20at\x20this\x20point,\
    \x20some\x20partitions\x20have\x20been\x20committed\x20(or\x20even\n\x20\
    \x20\x20\x20committed\x20multiple\x20times),\x20and\x20other\x20partitio\
    ns\x20have\x20not\x20been\x20run\x20at\x20all.\n\n\x20Given\x20the\x20ab\
    ove,\x20Partitioned\x20DML\x20is\x20good\x20fit\x20for\x20large,\x20data\
    base-wide,\n\x20operations\x20that\x20are\x20idempotent,\x20such\x20as\
    \x20deleting\x20old\x20rows\x20from\x20a\x20very\x20large\n\x20table.\n\
    \n\x0b\n\x03\x04\0\x01\x12\x04\xb3\x02\x08\x1a\nu\n\x04\x04\0\x03\0\x12\
    \x06\xb6\x02\x02\xb8\x02\x03\x1ae\x20Message\x20type\x20to\x20initiate\
    \x20a\x20read-write\x20transaction.\x20Currently\x20this\n\x20transactio\
    n\x20type\x20has\x20no\x20options.\n\n\r\n\x05\x04\0\x03\0\x01\x12\x04\
    \xb6\x02\n\x13\nI\n\x04\x04\0\x03\x01\x12\x06\xbb\x02\x02\xbd\x02\x03\
    \x1a9\x20Message\x20type\x20to\x20initiate\x20a\x20Partitioned\x20DML\
    \x20transaction.\n\n\r\n\x05\x04\0\x03\x01\x01\x12\x04\xbb\x02\n\x18\nC\
    \n\x04\x04\0\x03\x02\x12\x06\xc0\x02\x02\x81\x03\x03\x1a3\x20Message\x20\
    type\x20to\x20initiate\x20a\x20read-only\x20transaction.\n\n\r\n\x05\x04\
    \0\x03\x02\x01\x12\x04\xc0\x02\n\x12\nN\n\x06\x04\0\x03\x02\x08\0\x12\
    \x06\xc2\x02\x04\xfc\x02\x05\x1a<\x20How\x20to\x20choose\x20the\x20times\
    tamp\x20for\x20the\x20read-only\x20transaction.\n\n\x0f\n\x07\x04\0\x03\
    \x02\x08\0\x01\x12\x04\xc2\x02\n\x19\n_\n\x06\x04\0\x03\x02\x02\0\x12\
    \x04\xc5\x02\x06\x16\x1aO\x20Read\x20at\x20a\x20timestamp\x20where\x20al\
    l\x20previously\x20committed\x20transactions\n\x20are\x20visible.\n\n\
    \x0f\n\x07\x04\0\x03\x02\x02\0\x05\x12\x04\xc5\x02\x06\n\n\x0f\n\x07\x04\
    \0\x03\x02\x02\0\x01\x12\x04\xc5\x02\x0b\x11\n\x0f\n\x07\x04\0\x03\x02\
    \x02\0\x03\x12\x04\xc5\x02\x14\x15\n\xc6\x03\n\x06\x04\0\x03\x02\x02\x01\
    \x12\x04\xd1\x02\x067\x1a\xb5\x03\x20Executes\x20all\x20reads\x20at\x20a\
    \x20timestamp\x20>=\x20`min_read_timestamp`.\n\n\x20This\x20is\x20useful\
    \x20for\x20requesting\x20fresher\x20data\x20than\x20some\x20previous\n\
    \x20read,\x20or\x20data\x20that\x20is\x20fresh\x20enough\x20to\x20observ\
    e\x20the\x20effects\x20of\x20some\n\x20previously\x20committed\x20transa\
    ction\x20whose\x20timestamp\x20is\x20known.\n\n\x20Note\x20that\x20this\
    \x20option\x20can\x20only\x20be\x20used\x20in\x20single-use\x20transacti\
    ons.\n\n\x20A\x20timestamp\x20in\x20RFC3339\x20UTC\x20\\\"Zulu\\\"\x20fo\
    rmat,\x20accurate\x20to\x20nanoseconds.\n\x20Example:\x20`\"2014-10-02T1\
    5:01:23.045123456Z\"`.\n\n\x0f\n\x07\x04\0\x03\x02\x02\x01\x06\x12\x04\
    \xd1\x02\x06\x1f\n\x0f\n\x07\x04\0\x03\x02\x02\x01\x01\x12\x04\xd1\x02\
    \x202\n\x0f\n\x07\x04\0\x03\x02\x02\x01\x03\x12\x04\xd1\x0256\n\xba\x04\
    \n\x06\x04\0\x03\x02\x02\x02\x12\x04\xe0\x02\x061\x1a\xa9\x04\x20Read\
    \x20data\x20at\x20a\x20timestamp\x20>=\x20`NOW\x20-\x20max_staleness`\n\
    \x20seconds.\x20Guarantees\x20that\x20all\x20writes\x20that\x20have\x20c\
    ommitted\x20more\n\x20than\x20the\x20specified\x20number\x20of\x20second\
    s\x20ago\x20are\x20visible.\x20Because\n\x20Cloud\x20Spanner\x20chooses\
    \x20the\x20exact\x20timestamp,\x20this\x20mode\x20works\x20even\x20if\n\
    \x20the\x20client's\x20local\x20clock\x20is\x20substantially\x20skewed\
    \x20from\x20Cloud\x20Spanner\n\x20commit\x20timestamps.\n\n\x20Useful\
    \x20for\x20reading\x20the\x20freshest\x20data\x20available\x20at\x20a\
    \x20nearby\n\x20replica,\x20while\x20bounding\x20the\x20possible\x20stal\
    eness\x20if\x20the\x20local\n\x20replica\x20has\x20fallen\x20behind.\n\n\
    \x20Note\x20that\x20this\x20option\x20can\x20only\x20be\x20used\x20in\
    \x20single-use\n\x20transactions.\n\n\x0f\n\x07\x04\0\x03\x02\x02\x02\
    \x06\x12\x04\xe0\x02\x06\x1e\n\x0f\n\x07\x04\0\x03\x02\x02\x02\x01\x12\
    \x04\xe0\x02\x1f,\n\x0f\n\x07\x04\0\x03\x02\x02\x02\x03\x12\x04\xe0\x02/\
    0\n\xb6\x04\n\x06\x04\0\x03\x02\x02\x03\x12\x04\xee\x02\x063\x1a\xa5\x04\
    \x20Executes\x20all\x20reads\x20at\x20the\x20given\x20timestamp.\x20Unli\
    ke\x20other\x20modes,\n\x20reads\x20at\x20a\x20specific\x20timestamp\x20\
    are\x20repeatable;\x20the\x20same\x20read\x20at\n\x20the\x20same\x20time\
    stamp\x20always\x20returns\x20the\x20same\x20data.\x20If\x20the\n\x20tim\
    estamp\x20is\x20in\x20the\x20future,\x20the\x20read\x20will\x20block\x20\
    until\x20the\n\x20specified\x20timestamp,\x20modulo\x20the\x20read's\x20\
    deadline.\n\n\x20Useful\x20for\x20large\x20scale\x20consistent\x20reads\
    \x20such\x20as\x20mapreduces,\x20or\n\x20for\x20coordinating\x20many\x20\
    reads\x20against\x20a\x20consistent\x20snapshot\x20of\x20the\n\x20data.\
    \n\n\x20A\x20timestamp\x20in\x20RFC3339\x20UTC\x20\\\"Zulu\\\"\x20format\
    ,\x20accurate\x20to\x20nanoseconds.\n\x20Example:\x20`\"2014-10-02T15:01\
    :23.045123456Z\"`.\n\n\x0f\n\x07\x04\0\x03\x02\x02\x03\x06\x12\x04\xee\
    \x02\x06\x1f\n\x0f\n\x07\x04\0\x03\x02\x02\x03\x01\x12\x04\xee\x02\x20.\
    \n\x0f\n\x07\x04\0\x03\x02\x02\x03\x03\x12\x04\xee\x0212\n\x92\x04\n\x06\
    \x04\0\x03\x02\x02\x04\x12\x04\xfb\x02\x063\x1a\x81\x04\x20Executes\x20a\
    ll\x20reads\x20at\x20a\x20timestamp\x20that\x20is\x20`exact_staleness`\n\
    \x20old.\x20The\x20timestamp\x20is\x20chosen\x20soon\x20after\x20the\x20\
    read\x20is\x20started.\n\n\x20Guarantees\x20that\x20all\x20writes\x20tha\
    t\x20have\x20committed\x20more\x20than\x20the\n\x20specified\x20number\
    \x20of\x20seconds\x20ago\x20are\x20visible.\x20Because\x20Cloud\x20Spann\
    er\n\x20chooses\x20the\x20exact\x20timestamp,\x20this\x20mode\x20works\
    \x20even\x20if\x20the\x20client's\n\x20local\x20clock\x20is\x20substanti\
    ally\x20skewed\x20from\x20Cloud\x20Spanner\x20commit\n\x20timestamps.\n\
    \n\x20Useful\x20for\x20reading\x20at\x20nearby\x20replicas\x20without\
    \x20the\x20distributed\n\x20timestamp\x20negotiation\x20overhead\x20of\
    \x20`max_staleness`.\n\n\x0f\n\x07\x04\0\x03\x02\x02\x04\x06\x12\x04\xfb\
    \x02\x06\x1e\n\x0f\n\x07\x04\0\x03\x02\x02\x04\x01\x12\x04\xfb\x02\x1f.\
    \n\x0f\n\x07\x04\0\x03\x02\x02\x04\x03\x12\x04\xfb\x0212\n\xae\x01\n\x06\
    \x04\0\x03\x02\x02\x05\x12\x04\x80\x03\x04#\x1a\x9d\x01\x20If\x20true,\
    \x20the\x20Cloud\x20Spanner-selected\x20read\x20timestamp\x20is\x20inclu\
    ded\x20in\n\x20the\x20[Transaction][google.spanner.v1.Transaction]\x20me\
    ssage\x20that\x20describes\x20the\x20transaction.\n\n\x0f\n\x07\x04\0\
    \x03\x02\x02\x05\x05\x12\x04\x80\x03\x04\x08\n\x0f\n\x07\x04\0\x03\x02\
    \x02\x05\x01\x12\x04\x80\x03\t\x1e\n\x0f\n\x07\x04\0\x03\x02\x02\x05\x03\
    \x12\x04\x80\x03!\"\n4\n\x04\x04\0\x08\0\x12\x06\x84\x03\x02\x99\x03\x03\
    \x1a$\x20Required.\x20The\x20type\x20of\x20transaction.\n\n\r\n\x05\x04\
    \0\x08\0\x01\x12\x04\x84\x03\x08\x0c\n\xc2\x01\n\x04\x04\0\x02\0\x12\x04\
    \x8a\x03\x04\x1d\x1a\xb3\x01\x20Transaction\x20may\x20write.\n\n\x20Auth\
    orization\x20to\x20begin\x20a\x20read-write\x20transaction\x20requires\n\
    \x20`spanner.databases.beginOrRollbackReadWriteTransaction`\x20permissio\
    n\n\x20on\x20the\x20`session`\x20resource.\n\n\r\n\x05\x04\0\x02\0\x06\
    \x12\x04\x8a\x03\x04\r\n\r\n\x05\x04\0\x02\0\x01\x12\x04\x8a\x03\x0e\x18\
    \n\r\n\x05\x04\0\x02\0\x03\x12\x04\x8a\x03\x1b\x1c\n\xc8\x01\n\x04\x04\0\
    \x02\x01\x12\x04\x91\x03\x04'\x1a\xb9\x01\x20Partitioned\x20DML\x20trans\
    action.\n\n\x20Authorization\x20to\x20begin\x20a\x20Partitioned\x20DML\
    \x20transaction\x20requires\n\x20`spanner.databases.beginPartitionedDmlT\
    ransaction`\x20permission\n\x20on\x20the\x20`session`\x20resource.\n\n\r\
    \n\x05\x04\0\x02\x01\x06\x12\x04\x91\x03\x04\x12\n\r\n\x05\x04\0\x02\x01\
    \x01\x12\x04\x91\x03\x13\"\n\r\n\x05\x04\0\x02\x01\x03\x12\x04\x91\x03%&\
    \n\xbb\x01\n\x04\x04\0\x02\x02\x12\x04\x98\x03\x04\x1b\x1a\xac\x01\x20Tr\
    ansaction\x20will\x20not\x20write.\n\n\x20Authorization\x20to\x20begin\
    \x20a\x20read-only\x20transaction\x20requires\n\x20`spanner.databases.be\
    ginReadOnlyTransaction`\x20permission\n\x20on\x20the\x20`session`\x20res\
    ource.\n\n\r\n\x05\x04\0\x02\x02\x06\x12\x04\x98\x03\x04\x0c\n\r\n\x05\
    \x04\0\x02\x02\x01\x12\x04\x98\x03\r\x16\n\r\n\x05\x04\0\x02\x02\x03\x12\
    \x04\x98\x03\x19\x1a\n\x1e\n\x02\x04\x01\x12\x06\x9d\x03\0\xaf\x03\x01\
    \x1a\x10\x20A\x20transaction.\n\n\x0b\n\x03\x04\x01\x01\x12\x04\x9d\x03\
    \x08\x13\n\x88\x03\n\x04\x04\x01\x02\0\x12\x04\xa6\x03\x02\x0f\x1a\xf9\
    \x02\x20`id`\x20may\x20be\x20used\x20to\x20identify\x20the\x20transactio\
    n\x20in\x20subsequent\n\x20[Read][google.spanner.v1.Spanner.Read],\n\x20\
    [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql],\n\x20[Commit][google\
    .spanner.v1.Spanner.Commit],\x20or\n\x20[Rollback][google.spanner.v1.Spa\
    nner.Rollback]\x20calls.\n\n\x20Single-use\x20read-only\x20transactions\
    \x20do\x20not\x20have\x20IDs,\x20because\n\x20single-use\x20transactions\
    \x20do\x20not\x20support\x20multiple\x20requests.\n\n\r\n\x05\x04\x01\
    \x02\0\x05\x12\x04\xa6\x03\x02\x07\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\
    \xa6\x03\x08\n\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\xa6\x03\r\x0e\n\xf2\
    \x02\n\x04\x04\x01\x02\x01\x12\x04\xae\x03\x02/\x1a\xe3\x02\x20For\x20sn\
    apshot\x20read-only\x20transactions,\x20the\x20read\x20timestamp\x20chos\
    en\n\x20for\x20the\x20transaction.\x20Not\x20returned\x20by\x20default:\
    \x20see\n\x20[TransactionOptions.ReadOnly.return_read_timestamp][google.\
    spanner.v1.TransactionOptions.ReadOnly.return_read_timestamp].\n\n\x20A\
    \x20timestamp\x20in\x20RFC3339\x20UTC\x20\\\"Zulu\\\"\x20format,\x20accu\
    rate\x20to\x20nanoseconds.\n\x20Example:\x20`\"2014-10-02T15:01:23.04512\
    3456Z\"`.\n\n\r\n\x05\x04\x01\x02\x01\x06\x12\x04\xae\x03\x02\x1b\n\r\n\
    \x05\x04\x01\x02\x01\x01\x12\x04\xae\x03\x1c*\n\r\n\x05\x04\x01\x02\x01\
    \x03\x12\x04\xae\x03-.\n\x9e\x02\n\x02\x04\x02\x12\x06\xb6\x03\0\xc7\x03\
    \x01\x1a\x8f\x02\x20This\x20message\x20is\x20used\x20to\x20select\x20the\
    \x20transaction\x20in\x20which\x20a\n\x20[Read][google.spanner.v1.Spanne\
    r.Read]\x20or\n\x20[ExecuteSql][google.spanner.v1.Spanner.ExecuteSql]\
    \x20call\x20runs.\n\n\x20See\x20[TransactionOptions][google.spanner.v1.T\
    ransactionOptions]\x20for\x20more\x20information\x20about\x20transaction\
    s.\n\n\x0b\n\x03\x04\x02\x01\x12\x04\xb6\x03\x08\x1b\ni\n\x04\x04\x02\
    \x08\0\x12\x06\xb9\x03\x02\xc6\x03\x03\x1aY\x20If\x20no\x20fields\x20are\
    \x20set,\x20the\x20default\x20is\x20a\x20single\x20use\x20transaction\n\
    \x20with\x20strong\x20concurrency.\n\n\r\n\x05\x04\x02\x08\0\x01\x12\x04\
    \xb9\x03\x08\x10\n\xa9\x01\n\x04\x04\x02\x02\0\x12\x04\xbd\x03\x04&\x1a\
    \x9a\x01\x20Execute\x20the\x20read\x20or\x20SQL\x20query\x20in\x20a\x20t\
    emporary\x20transaction.\n\x20This\x20is\x20the\x20most\x20efficient\x20\
    way\x20to\x20execute\x20a\x20transaction\x20that\n\x20consists\x20of\x20\
    a\x20single\x20SQL\x20query.\n\n\r\n\x05\x04\x02\x02\0\x06\x12\x04\xbd\
    \x03\x04\x16\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\xbd\x03\x17!\n\r\n\x05\
    \x04\x02\x02\0\x03\x12\x04\xbd\x03$%\nR\n\x04\x04\x02\x02\x01\x12\x04\
    \xc0\x03\x04\x11\x1aD\x20Execute\x20the\x20read\x20or\x20SQL\x20query\
    \x20in\x20a\x20previously-started\x20transaction.\n\n\r\n\x05\x04\x02\
    \x02\x01\x05\x12\x04\xc0\x03\x04\t\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\
    \xc0\x03\n\x0c\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\xc0\x03\x0f\x10\n\
    \x98\x02\n\x04\x04\x02\x02\x02\x12\x04\xc5\x03\x04!\x1a\x89\x02\x20Begin\
    \x20a\x20new\x20transaction\x20and\x20execute\x20this\x20read\x20or\x20S\
    QL\x20query\x20in\n\x20it.\x20The\x20transaction\x20ID\x20of\x20the\x20n\
    ew\x20transaction\x20is\x20returned\x20in\n\x20[ResultSetMetadata.transa\
    ction][google.spanner.v1.ResultSetMetadata.transaction],\x20which\x20is\
    \x20a\x20[Transaction][google.spanner.v1.Transaction].\n\n\r\n\x05\x04\
    \x02\x02\x02\x06\x12\x04\xc5\x03\x04\x16\n\r\n\x05\x04\x02\x02\x02\x01\
    \x12\x04\xc5\x03\x17\x1c\n\r\n\x05\x04\x02\x02\x02\x03\x12\x04\xc5\x03\
    \x1f\x20b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
