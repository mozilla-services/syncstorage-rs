// This file is generated by rust-protobuf 2.22.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/api/servicemanagement/v1/servicemanager.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_22_0;

#[derive(PartialEq,Clone,Default)]
pub struct ListServicesRequest {
    // message fields
    pub producer_project_id: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    pub consumer_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListServicesRequest {
    fn default() -> &'a ListServicesRequest {
        <ListServicesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListServicesRequest {
    pub fn new() -> ListServicesRequest {
        ::std::default::Default::default()
    }

    // string producer_project_id = 1;


    pub fn get_producer_project_id(&self) -> &str {
        &self.producer_project_id
    }
    pub fn clear_producer_project_id(&mut self) {
        self.producer_project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_producer_project_id(&mut self, v: ::std::string::String) {
        self.producer_project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_producer_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.producer_project_id
    }

    // Take field
    pub fn take_producer_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.producer_project_id, ::std::string::String::new())
    }

    // int32 page_size = 5;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 6;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    // string consumer_id = 7;


    pub fn get_consumer_id(&self) -> &str {
        &self.consumer_id
    }
    pub fn clear_consumer_id(&mut self) {
        self.consumer_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: ::std::string::String) {
        self.consumer_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consumer_id(&mut self) -> &mut ::std::string::String {
        &mut self.consumer_id
    }

    // Take field
    pub fn take_consumer_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.consumer_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListServicesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.producer_project_id)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.consumer_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.producer_project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.producer_project_id);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(5, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.page_token);
        }
        if !self.consumer_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.consumer_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.producer_project_id.is_empty() {
            os.write_string(1, &self.producer_project_id)?;
        }
        if self.page_size != 0 {
            os.write_int32(5, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(6, &self.page_token)?;
        }
        if !self.consumer_id.is_empty() {
            os.write_string(7, &self.consumer_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListServicesRequest {
        ListServicesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "producer_project_id",
                |m: &ListServicesRequest| { &m.producer_project_id },
                |m: &mut ListServicesRequest| { &mut m.producer_project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListServicesRequest| { &m.page_size },
                |m: &mut ListServicesRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListServicesRequest| { &m.page_token },
                |m: &mut ListServicesRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "consumer_id",
                |m: &ListServicesRequest| { &m.consumer_id },
                |m: &mut ListServicesRequest| { &mut m.consumer_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListServicesRequest>(
                "ListServicesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListServicesRequest {
        static instance: ::protobuf::rt::LazyV2<ListServicesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListServicesRequest::new)
    }
}

impl ::protobuf::Clear for ListServicesRequest {
    fn clear(&mut self) {
        self.producer_project_id.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.consumer_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListServicesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListServicesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListServicesResponse {
    // message fields
    pub services: ::protobuf::RepeatedField<super::resources::ManagedService>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListServicesResponse {
    fn default() -> &'a ListServicesResponse {
        <ListServicesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListServicesResponse {
    pub fn new() -> ListServicesResponse {
        ::std::default::Default::default()
    }

    // repeated .google.api.servicemanagement.v1.ManagedService services = 1;


    pub fn get_services(&self) -> &[super::resources::ManagedService] {
        &self.services
    }
    pub fn clear_services(&mut self) {
        self.services.clear();
    }

    // Param is passed by value, moved
    pub fn set_services(&mut self, v: ::protobuf::RepeatedField<super::resources::ManagedService>) {
        self.services = v;
    }

    // Mutable pointer to the field.
    pub fn mut_services(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ManagedService> {
        &mut self.services
    }

    // Take field
    pub fn take_services(&mut self) -> ::protobuf::RepeatedField<super::resources::ManagedService> {
        ::std::mem::replace(&mut self.services, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListServicesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.services {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.services)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.services {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.services {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListServicesResponse {
        ListServicesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ManagedService>>(
                "services",
                |m: &ListServicesResponse| { &m.services },
                |m: &mut ListServicesResponse| { &mut m.services },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListServicesResponse| { &m.next_page_token },
                |m: &mut ListServicesResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListServicesResponse>(
                "ListServicesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListServicesResponse {
        static instance: ::protobuf::rt::LazyV2<ListServicesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListServicesResponse::new)
    }
}

impl ::protobuf::Clear for ListServicesResponse {
    fn clear(&mut self) {
        self.services.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListServicesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListServicesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetServiceRequest {
    // message fields
    pub service_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetServiceRequest {
    fn default() -> &'a GetServiceRequest {
        <GetServiceRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetServiceRequest {
    pub fn new() -> GetServiceRequest {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetServiceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetServiceRequest {
        GetServiceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &GetServiceRequest| { &m.service_name },
                |m: &mut GetServiceRequest| { &mut m.service_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetServiceRequest>(
                "GetServiceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetServiceRequest {
        static instance: ::protobuf::rt::LazyV2<GetServiceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetServiceRequest::new)
    }
}

impl ::protobuf::Clear for GetServiceRequest {
    fn clear(&mut self) {
        self.service_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetServiceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetServiceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateServiceRequest {
    // message fields
    pub service: ::protobuf::SingularPtrField<super::resources::ManagedService>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateServiceRequest {
    fn default() -> &'a CreateServiceRequest {
        <CreateServiceRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateServiceRequest {
    pub fn new() -> CreateServiceRequest {
        ::std::default::Default::default()
    }

    // .google.api.servicemanagement.v1.ManagedService service = 1;


    pub fn get_service(&self) -> &super::resources::ManagedService {
        self.service.as_ref().unwrap_or_else(|| <super::resources::ManagedService as ::protobuf::Message>::default_instance())
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    pub fn has_service(&self) -> bool {
        self.service.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: super::resources::ManagedService) {
        self.service = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut super::resources::ManagedService {
        if self.service.is_none() {
            self.service.set_default();
        }
        self.service.as_mut().unwrap()
    }

    // Take field
    pub fn take_service(&mut self) -> super::resources::ManagedService {
        self.service.take().unwrap_or_else(|| super::resources::ManagedService::new())
    }
}

impl ::protobuf::Message for CreateServiceRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.service {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.service)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.service.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateServiceRequest {
        CreateServiceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ManagedService>>(
                "service",
                |m: &CreateServiceRequest| { &m.service },
                |m: &mut CreateServiceRequest| { &mut m.service },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateServiceRequest>(
                "CreateServiceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateServiceRequest {
        static instance: ::protobuf::rt::LazyV2<CreateServiceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateServiceRequest::new)
    }
}

impl ::protobuf::Clear for CreateServiceRequest {
    fn clear(&mut self) {
        self.service.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateServiceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateServiceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteServiceRequest {
    // message fields
    pub service_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteServiceRequest {
    fn default() -> &'a DeleteServiceRequest {
        <DeleteServiceRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteServiceRequest {
    pub fn new() -> DeleteServiceRequest {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteServiceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteServiceRequest {
        DeleteServiceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &DeleteServiceRequest| { &m.service_name },
                |m: &mut DeleteServiceRequest| { &mut m.service_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteServiceRequest>(
                "DeleteServiceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteServiceRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteServiceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteServiceRequest::new)
    }
}

impl ::protobuf::Clear for DeleteServiceRequest {
    fn clear(&mut self) {
        self.service_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteServiceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteServiceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UndeleteServiceRequest {
    // message fields
    pub service_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UndeleteServiceRequest {
    fn default() -> &'a UndeleteServiceRequest {
        <UndeleteServiceRequest as ::protobuf::Message>::default_instance()
    }
}

impl UndeleteServiceRequest {
    pub fn new() -> UndeleteServiceRequest {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UndeleteServiceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UndeleteServiceRequest {
        UndeleteServiceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &UndeleteServiceRequest| { &m.service_name },
                |m: &mut UndeleteServiceRequest| { &mut m.service_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UndeleteServiceRequest>(
                "UndeleteServiceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UndeleteServiceRequest {
        static instance: ::protobuf::rt::LazyV2<UndeleteServiceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UndeleteServiceRequest::new)
    }
}

impl ::protobuf::Clear for UndeleteServiceRequest {
    fn clear(&mut self) {
        self.service_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UndeleteServiceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UndeleteServiceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UndeleteServiceResponse {
    // message fields
    pub service: ::protobuf::SingularPtrField<super::resources::ManagedService>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UndeleteServiceResponse {
    fn default() -> &'a UndeleteServiceResponse {
        <UndeleteServiceResponse as ::protobuf::Message>::default_instance()
    }
}

impl UndeleteServiceResponse {
    pub fn new() -> UndeleteServiceResponse {
        ::std::default::Default::default()
    }

    // .google.api.servicemanagement.v1.ManagedService service = 1;


    pub fn get_service(&self) -> &super::resources::ManagedService {
        self.service.as_ref().unwrap_or_else(|| <super::resources::ManagedService as ::protobuf::Message>::default_instance())
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    pub fn has_service(&self) -> bool {
        self.service.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: super::resources::ManagedService) {
        self.service = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut super::resources::ManagedService {
        if self.service.is_none() {
            self.service.set_default();
        }
        self.service.as_mut().unwrap()
    }

    // Take field
    pub fn take_service(&mut self) -> super::resources::ManagedService {
        self.service.take().unwrap_or_else(|| super::resources::ManagedService::new())
    }
}

impl ::protobuf::Message for UndeleteServiceResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.service {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.service)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.service.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UndeleteServiceResponse {
        UndeleteServiceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ManagedService>>(
                "service",
                |m: &UndeleteServiceResponse| { &m.service },
                |m: &mut UndeleteServiceResponse| { &mut m.service },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UndeleteServiceResponse>(
                "UndeleteServiceResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UndeleteServiceResponse {
        static instance: ::protobuf::rt::LazyV2<UndeleteServiceResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UndeleteServiceResponse::new)
    }
}

impl ::protobuf::Clear for UndeleteServiceResponse {
    fn clear(&mut self) {
        self.service.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UndeleteServiceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UndeleteServiceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetServiceConfigRequest {
    // message fields
    pub service_name: ::std::string::String,
    pub config_id: ::std::string::String,
    pub view: GetServiceConfigRequest_ConfigView,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetServiceConfigRequest {
    fn default() -> &'a GetServiceConfigRequest {
        <GetServiceConfigRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetServiceConfigRequest {
    pub fn new() -> GetServiceConfigRequest {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }

    // string config_id = 2;


    pub fn get_config_id(&self) -> &str {
        &self.config_id
    }
    pub fn clear_config_id(&mut self) {
        self.config_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_config_id(&mut self, v: ::std::string::String) {
        self.config_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config_id(&mut self) -> &mut ::std::string::String {
        &mut self.config_id
    }

    // Take field
    pub fn take_config_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.config_id, ::std::string::String::new())
    }

    // .google.api.servicemanagement.v1.GetServiceConfigRequest.ConfigView view = 3;


    pub fn get_view(&self) -> GetServiceConfigRequest_ConfigView {
        self.view
    }
    pub fn clear_view(&mut self) {
        self.view = GetServiceConfigRequest_ConfigView::BASIC;
    }

    // Param is passed by value, moved
    pub fn set_view(&mut self, v: GetServiceConfigRequest_ConfigView) {
        self.view = v;
    }
}

impl ::protobuf::Message for GetServiceConfigRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.config_id)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.view, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        if !self.config_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.config_id);
        }
        if self.view != GetServiceConfigRequest_ConfigView::BASIC {
            my_size += ::protobuf::rt::enum_size(3, self.view);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        if !self.config_id.is_empty() {
            os.write_string(2, &self.config_id)?;
        }
        if self.view != GetServiceConfigRequest_ConfigView::BASIC {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.view))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetServiceConfigRequest {
        GetServiceConfigRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &GetServiceConfigRequest| { &m.service_name },
                |m: &mut GetServiceConfigRequest| { &mut m.service_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "config_id",
                |m: &GetServiceConfigRequest| { &m.config_id },
                |m: &mut GetServiceConfigRequest| { &mut m.config_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GetServiceConfigRequest_ConfigView>>(
                "view",
                |m: &GetServiceConfigRequest| { &m.view },
                |m: &mut GetServiceConfigRequest| { &mut m.view },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetServiceConfigRequest>(
                "GetServiceConfigRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetServiceConfigRequest {
        static instance: ::protobuf::rt::LazyV2<GetServiceConfigRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetServiceConfigRequest::new)
    }
}

impl ::protobuf::Clear for GetServiceConfigRequest {
    fn clear(&mut self) {
        self.service_name.clear();
        self.config_id.clear();
        self.view = GetServiceConfigRequest_ConfigView::BASIC;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetServiceConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetServiceConfigRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GetServiceConfigRequest_ConfigView {
    BASIC = 0,
    FULL = 1,
}

impl ::protobuf::ProtobufEnum for GetServiceConfigRequest_ConfigView {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GetServiceConfigRequest_ConfigView> {
        match value {
            0 => ::std::option::Option::Some(GetServiceConfigRequest_ConfigView::BASIC),
            1 => ::std::option::Option::Some(GetServiceConfigRequest_ConfigView::FULL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GetServiceConfigRequest_ConfigView] = &[
            GetServiceConfigRequest_ConfigView::BASIC,
            GetServiceConfigRequest_ConfigView::FULL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<GetServiceConfigRequest_ConfigView>("GetServiceConfigRequest.ConfigView", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for GetServiceConfigRequest_ConfigView {
}

impl ::std::default::Default for GetServiceConfigRequest_ConfigView {
    fn default() -> Self {
        GetServiceConfigRequest_ConfigView::BASIC
    }
}

impl ::protobuf::reflect::ProtobufValue for GetServiceConfigRequest_ConfigView {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListServiceConfigsRequest {
    // message fields
    pub service_name: ::std::string::String,
    pub page_token: ::std::string::String,
    pub page_size: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListServiceConfigsRequest {
    fn default() -> &'a ListServiceConfigsRequest {
        <ListServiceConfigsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListServiceConfigsRequest {
    pub fn new() -> ListServiceConfigsRequest {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }

    // string page_token = 2;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    // int32 page_size = 3;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }
}

impl ::protobuf::Message for ListServiceConfigsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.page_token);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(2, &self.page_token)?;
        }
        if self.page_size != 0 {
            os.write_int32(3, self.page_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListServiceConfigsRequest {
        ListServiceConfigsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &ListServiceConfigsRequest| { &m.service_name },
                |m: &mut ListServiceConfigsRequest| { &mut m.service_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListServiceConfigsRequest| { &m.page_token },
                |m: &mut ListServiceConfigsRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListServiceConfigsRequest| { &m.page_size },
                |m: &mut ListServiceConfigsRequest| { &mut m.page_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListServiceConfigsRequest>(
                "ListServiceConfigsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListServiceConfigsRequest {
        static instance: ::protobuf::rt::LazyV2<ListServiceConfigsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListServiceConfigsRequest::new)
    }
}

impl ::protobuf::Clear for ListServiceConfigsRequest {
    fn clear(&mut self) {
        self.service_name.clear();
        self.page_token.clear();
        self.page_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListServiceConfigsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListServiceConfigsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListServiceConfigsResponse {
    // message fields
    pub service_configs: ::protobuf::RepeatedField<super::service::Service>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListServiceConfigsResponse {
    fn default() -> &'a ListServiceConfigsResponse {
        <ListServiceConfigsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListServiceConfigsResponse {
    pub fn new() -> ListServiceConfigsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.api.Service service_configs = 1;


    pub fn get_service_configs(&self) -> &[super::service::Service] {
        &self.service_configs
    }
    pub fn clear_service_configs(&mut self) {
        self.service_configs.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_configs(&mut self, v: ::protobuf::RepeatedField<super::service::Service>) {
        self.service_configs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_service_configs(&mut self) -> &mut ::protobuf::RepeatedField<super::service::Service> {
        &mut self.service_configs
    }

    // Take field
    pub fn take_service_configs(&mut self) -> ::protobuf::RepeatedField<super::service::Service> {
        ::std::mem::replace(&mut self.service_configs, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListServiceConfigsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.service_configs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.service_configs)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.service_configs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.service_configs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListServiceConfigsResponse {
        ListServiceConfigsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::service::Service>>(
                "service_configs",
                |m: &ListServiceConfigsResponse| { &m.service_configs },
                |m: &mut ListServiceConfigsResponse| { &mut m.service_configs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListServiceConfigsResponse| { &m.next_page_token },
                |m: &mut ListServiceConfigsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListServiceConfigsResponse>(
                "ListServiceConfigsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListServiceConfigsResponse {
        static instance: ::protobuf::rt::LazyV2<ListServiceConfigsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListServiceConfigsResponse::new)
    }
}

impl ::protobuf::Clear for ListServiceConfigsResponse {
    fn clear(&mut self) {
        self.service_configs.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListServiceConfigsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListServiceConfigsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateServiceConfigRequest {
    // message fields
    pub service_name: ::std::string::String,
    pub service_config: ::protobuf::SingularPtrField<super::service::Service>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateServiceConfigRequest {
    fn default() -> &'a CreateServiceConfigRequest {
        <CreateServiceConfigRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateServiceConfigRequest {
    pub fn new() -> CreateServiceConfigRequest {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }

    // .google.api.Service service_config = 2;


    pub fn get_service_config(&self) -> &super::service::Service {
        self.service_config.as_ref().unwrap_or_else(|| <super::service::Service as ::protobuf::Message>::default_instance())
    }
    pub fn clear_service_config(&mut self) {
        self.service_config.clear();
    }

    pub fn has_service_config(&self) -> bool {
        self.service_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_config(&mut self, v: super::service::Service) {
        self.service_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_config(&mut self) -> &mut super::service::Service {
        if self.service_config.is_none() {
            self.service_config.set_default();
        }
        self.service_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_service_config(&mut self) -> super::service::Service {
        self.service_config.take().unwrap_or_else(|| super::service::Service::new())
    }
}

impl ::protobuf::Message for CreateServiceConfigRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.service_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.service_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        if let Some(ref v) = self.service_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        if let Some(ref v) = self.service_config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateServiceConfigRequest {
        CreateServiceConfigRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &CreateServiceConfigRequest| { &m.service_name },
                |m: &mut CreateServiceConfigRequest| { &mut m.service_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::service::Service>>(
                "service_config",
                |m: &CreateServiceConfigRequest| { &m.service_config },
                |m: &mut CreateServiceConfigRequest| { &mut m.service_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateServiceConfigRequest>(
                "CreateServiceConfigRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateServiceConfigRequest {
        static instance: ::protobuf::rt::LazyV2<CreateServiceConfigRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateServiceConfigRequest::new)
    }
}

impl ::protobuf::Clear for CreateServiceConfigRequest {
    fn clear(&mut self) {
        self.service_name.clear();
        self.service_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateServiceConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateServiceConfigRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubmitConfigSourceRequest {
    // message fields
    pub service_name: ::std::string::String,
    pub config_source: ::protobuf::SingularPtrField<super::resources::ConfigSource>,
    pub validate_only: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubmitConfigSourceRequest {
    fn default() -> &'a SubmitConfigSourceRequest {
        <SubmitConfigSourceRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubmitConfigSourceRequest {
    pub fn new() -> SubmitConfigSourceRequest {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }

    // .google.api.servicemanagement.v1.ConfigSource config_source = 2;


    pub fn get_config_source(&self) -> &super::resources::ConfigSource {
        self.config_source.as_ref().unwrap_or_else(|| <super::resources::ConfigSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config_source(&mut self) {
        self.config_source.clear();
    }

    pub fn has_config_source(&self) -> bool {
        self.config_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config_source(&mut self, v: super::resources::ConfigSource) {
        self.config_source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config_source(&mut self) -> &mut super::resources::ConfigSource {
        if self.config_source.is_none() {
            self.config_source.set_default();
        }
        self.config_source.as_mut().unwrap()
    }

    // Take field
    pub fn take_config_source(&mut self) -> super::resources::ConfigSource {
        self.config_source.take().unwrap_or_else(|| super::resources::ConfigSource::new())
    }

    // bool validate_only = 3;


    pub fn get_validate_only(&self) -> bool {
        self.validate_only
    }
    pub fn clear_validate_only(&mut self) {
        self.validate_only = false;
    }

    // Param is passed by value, moved
    pub fn set_validate_only(&mut self, v: bool) {
        self.validate_only = v;
    }
}

impl ::protobuf::Message for SubmitConfigSourceRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.config_source {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config_source)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.validate_only = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        if let Some(ref v) = self.config_source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.validate_only != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        if let Some(ref v) = self.config_source.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.validate_only != false {
            os.write_bool(3, self.validate_only)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubmitConfigSourceRequest {
        SubmitConfigSourceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &SubmitConfigSourceRequest| { &m.service_name },
                |m: &mut SubmitConfigSourceRequest| { &mut m.service_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ConfigSource>>(
                "config_source",
                |m: &SubmitConfigSourceRequest| { &m.config_source },
                |m: &mut SubmitConfigSourceRequest| { &mut m.config_source },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "validate_only",
                |m: &SubmitConfigSourceRequest| { &m.validate_only },
                |m: &mut SubmitConfigSourceRequest| { &mut m.validate_only },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubmitConfigSourceRequest>(
                "SubmitConfigSourceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubmitConfigSourceRequest {
        static instance: ::protobuf::rt::LazyV2<SubmitConfigSourceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubmitConfigSourceRequest::new)
    }
}

impl ::protobuf::Clear for SubmitConfigSourceRequest {
    fn clear(&mut self) {
        self.service_name.clear();
        self.config_source.clear();
        self.validate_only = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubmitConfigSourceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubmitConfigSourceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubmitConfigSourceResponse {
    // message fields
    pub service_config: ::protobuf::SingularPtrField<super::service::Service>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubmitConfigSourceResponse {
    fn default() -> &'a SubmitConfigSourceResponse {
        <SubmitConfigSourceResponse as ::protobuf::Message>::default_instance()
    }
}

impl SubmitConfigSourceResponse {
    pub fn new() -> SubmitConfigSourceResponse {
        ::std::default::Default::default()
    }

    // .google.api.Service service_config = 1;


    pub fn get_service_config(&self) -> &super::service::Service {
        self.service_config.as_ref().unwrap_or_else(|| <super::service::Service as ::protobuf::Message>::default_instance())
    }
    pub fn clear_service_config(&mut self) {
        self.service_config.clear();
    }

    pub fn has_service_config(&self) -> bool {
        self.service_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_config(&mut self, v: super::service::Service) {
        self.service_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_config(&mut self) -> &mut super::service::Service {
        if self.service_config.is_none() {
            self.service_config.set_default();
        }
        self.service_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_service_config(&mut self) -> super::service::Service {
        self.service_config.take().unwrap_or_else(|| super::service::Service::new())
    }
}

impl ::protobuf::Message for SubmitConfigSourceResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.service_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.service_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.service_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.service_config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubmitConfigSourceResponse {
        SubmitConfigSourceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::service::Service>>(
                "service_config",
                |m: &SubmitConfigSourceResponse| { &m.service_config },
                |m: &mut SubmitConfigSourceResponse| { &mut m.service_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubmitConfigSourceResponse>(
                "SubmitConfigSourceResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubmitConfigSourceResponse {
        static instance: ::protobuf::rt::LazyV2<SubmitConfigSourceResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubmitConfigSourceResponse::new)
    }
}

impl ::protobuf::Clear for SubmitConfigSourceResponse {
    fn clear(&mut self) {
        self.service_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubmitConfigSourceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubmitConfigSourceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateServiceRolloutRequest {
    // message fields
    pub service_name: ::std::string::String,
    pub rollout: ::protobuf::SingularPtrField<super::resources::Rollout>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateServiceRolloutRequest {
    fn default() -> &'a CreateServiceRolloutRequest {
        <CreateServiceRolloutRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateServiceRolloutRequest {
    pub fn new() -> CreateServiceRolloutRequest {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }

    // .google.api.servicemanagement.v1.Rollout rollout = 2;


    pub fn get_rollout(&self) -> &super::resources::Rollout {
        self.rollout.as_ref().unwrap_or_else(|| <super::resources::Rollout as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rollout(&mut self) {
        self.rollout.clear();
    }

    pub fn has_rollout(&self) -> bool {
        self.rollout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollout(&mut self, v: super::resources::Rollout) {
        self.rollout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollout(&mut self) -> &mut super::resources::Rollout {
        if self.rollout.is_none() {
            self.rollout.set_default();
        }
        self.rollout.as_mut().unwrap()
    }

    // Take field
    pub fn take_rollout(&mut self) -> super::resources::Rollout {
        self.rollout.take().unwrap_or_else(|| super::resources::Rollout::new())
    }
}

impl ::protobuf::Message for CreateServiceRolloutRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.rollout {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rollout)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        if let Some(ref v) = self.rollout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        if let Some(ref v) = self.rollout.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateServiceRolloutRequest {
        CreateServiceRolloutRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &CreateServiceRolloutRequest| { &m.service_name },
                |m: &mut CreateServiceRolloutRequest| { &mut m.service_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Rollout>>(
                "rollout",
                |m: &CreateServiceRolloutRequest| { &m.rollout },
                |m: &mut CreateServiceRolloutRequest| { &mut m.rollout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateServiceRolloutRequest>(
                "CreateServiceRolloutRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateServiceRolloutRequest {
        static instance: ::protobuf::rt::LazyV2<CreateServiceRolloutRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateServiceRolloutRequest::new)
    }
}

impl ::protobuf::Clear for CreateServiceRolloutRequest {
    fn clear(&mut self) {
        self.service_name.clear();
        self.rollout.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateServiceRolloutRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateServiceRolloutRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListServiceRolloutsRequest {
    // message fields
    pub service_name: ::std::string::String,
    pub page_token: ::std::string::String,
    pub page_size: i32,
    pub filter: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListServiceRolloutsRequest {
    fn default() -> &'a ListServiceRolloutsRequest {
        <ListServiceRolloutsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListServiceRolloutsRequest {
    pub fn new() -> ListServiceRolloutsRequest {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }

    // string page_token = 2;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    // int32 page_size = 3;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string filter = 4;


    pub fn get_filter(&self) -> &str {
        &self.filter
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListServiceRolloutsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.page_token);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.filter);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(2, &self.page_token)?;
        }
        if self.page_size != 0 {
            os.write_int32(3, self.page_size)?;
        }
        if !self.filter.is_empty() {
            os.write_string(4, &self.filter)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListServiceRolloutsRequest {
        ListServiceRolloutsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &ListServiceRolloutsRequest| { &m.service_name },
                |m: &mut ListServiceRolloutsRequest| { &mut m.service_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListServiceRolloutsRequest| { &m.page_token },
                |m: &mut ListServiceRolloutsRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListServiceRolloutsRequest| { &m.page_size },
                |m: &mut ListServiceRolloutsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &ListServiceRolloutsRequest| { &m.filter },
                |m: &mut ListServiceRolloutsRequest| { &mut m.filter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListServiceRolloutsRequest>(
                "ListServiceRolloutsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListServiceRolloutsRequest {
        static instance: ::protobuf::rt::LazyV2<ListServiceRolloutsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListServiceRolloutsRequest::new)
    }
}

impl ::protobuf::Clear for ListServiceRolloutsRequest {
    fn clear(&mut self) {
        self.service_name.clear();
        self.page_token.clear();
        self.page_size = 0;
        self.filter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListServiceRolloutsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListServiceRolloutsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListServiceRolloutsResponse {
    // message fields
    pub rollouts: ::protobuf::RepeatedField<super::resources::Rollout>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListServiceRolloutsResponse {
    fn default() -> &'a ListServiceRolloutsResponse {
        <ListServiceRolloutsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListServiceRolloutsResponse {
    pub fn new() -> ListServiceRolloutsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.api.servicemanagement.v1.Rollout rollouts = 1;


    pub fn get_rollouts(&self) -> &[super::resources::Rollout] {
        &self.rollouts
    }
    pub fn clear_rollouts(&mut self) {
        self.rollouts.clear();
    }

    // Param is passed by value, moved
    pub fn set_rollouts(&mut self, v: ::protobuf::RepeatedField<super::resources::Rollout>) {
        self.rollouts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rollouts(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Rollout> {
        &mut self.rollouts
    }

    // Take field
    pub fn take_rollouts(&mut self) -> ::protobuf::RepeatedField<super::resources::Rollout> {
        ::std::mem::replace(&mut self.rollouts, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListServiceRolloutsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.rollouts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rollouts)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.rollouts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.rollouts {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListServiceRolloutsResponse {
        ListServiceRolloutsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Rollout>>(
                "rollouts",
                |m: &ListServiceRolloutsResponse| { &m.rollouts },
                |m: &mut ListServiceRolloutsResponse| { &mut m.rollouts },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListServiceRolloutsResponse| { &m.next_page_token },
                |m: &mut ListServiceRolloutsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListServiceRolloutsResponse>(
                "ListServiceRolloutsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListServiceRolloutsResponse {
        static instance: ::protobuf::rt::LazyV2<ListServiceRolloutsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListServiceRolloutsResponse::new)
    }
}

impl ::protobuf::Clear for ListServiceRolloutsResponse {
    fn clear(&mut self) {
        self.rollouts.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListServiceRolloutsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListServiceRolloutsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetServiceRolloutRequest {
    // message fields
    pub service_name: ::std::string::String,
    pub rollout_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetServiceRolloutRequest {
    fn default() -> &'a GetServiceRolloutRequest {
        <GetServiceRolloutRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetServiceRolloutRequest {
    pub fn new() -> GetServiceRolloutRequest {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }

    // string rollout_id = 2;


    pub fn get_rollout_id(&self) -> &str {
        &self.rollout_id
    }
    pub fn clear_rollout_id(&mut self) {
        self.rollout_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_rollout_id(&mut self, v: ::std::string::String) {
        self.rollout_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollout_id(&mut self) -> &mut ::std::string::String {
        &mut self.rollout_id
    }

    // Take field
    pub fn take_rollout_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rollout_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetServiceRolloutRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rollout_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        if !self.rollout_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.rollout_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        if !self.rollout_id.is_empty() {
            os.write_string(2, &self.rollout_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetServiceRolloutRequest {
        GetServiceRolloutRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &GetServiceRolloutRequest| { &m.service_name },
                |m: &mut GetServiceRolloutRequest| { &mut m.service_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rollout_id",
                |m: &GetServiceRolloutRequest| { &m.rollout_id },
                |m: &mut GetServiceRolloutRequest| { &mut m.rollout_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetServiceRolloutRequest>(
                "GetServiceRolloutRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetServiceRolloutRequest {
        static instance: ::protobuf::rt::LazyV2<GetServiceRolloutRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetServiceRolloutRequest::new)
    }
}

impl ::protobuf::Clear for GetServiceRolloutRequest {
    fn clear(&mut self) {
        self.service_name.clear();
        self.rollout_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetServiceRolloutRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetServiceRolloutRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EnableServiceRequest {
    // message fields
    pub service_name: ::std::string::String,
    pub consumer_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EnableServiceRequest {
    fn default() -> &'a EnableServiceRequest {
        <EnableServiceRequest as ::protobuf::Message>::default_instance()
    }
}

impl EnableServiceRequest {
    pub fn new() -> EnableServiceRequest {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }

    // string consumer_id = 2;


    pub fn get_consumer_id(&self) -> &str {
        &self.consumer_id
    }
    pub fn clear_consumer_id(&mut self) {
        self.consumer_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: ::std::string::String) {
        self.consumer_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consumer_id(&mut self) -> &mut ::std::string::String {
        &mut self.consumer_id
    }

    // Take field
    pub fn take_consumer_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.consumer_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for EnableServiceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.consumer_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        if !self.consumer_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.consumer_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        if !self.consumer_id.is_empty() {
            os.write_string(2, &self.consumer_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EnableServiceRequest {
        EnableServiceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &EnableServiceRequest| { &m.service_name },
                |m: &mut EnableServiceRequest| { &mut m.service_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "consumer_id",
                |m: &EnableServiceRequest| { &m.consumer_id },
                |m: &mut EnableServiceRequest| { &mut m.consumer_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EnableServiceRequest>(
                "EnableServiceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EnableServiceRequest {
        static instance: ::protobuf::rt::LazyV2<EnableServiceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EnableServiceRequest::new)
    }
}

impl ::protobuf::Clear for EnableServiceRequest {
    fn clear(&mut self) {
        self.service_name.clear();
        self.consumer_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnableServiceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnableServiceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EnableServiceResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EnableServiceResponse {
    fn default() -> &'a EnableServiceResponse {
        <EnableServiceResponse as ::protobuf::Message>::default_instance()
    }
}

impl EnableServiceResponse {
    pub fn new() -> EnableServiceResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for EnableServiceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EnableServiceResponse {
        EnableServiceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EnableServiceResponse>(
                "EnableServiceResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EnableServiceResponse {
        static instance: ::protobuf::rt::LazyV2<EnableServiceResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EnableServiceResponse::new)
    }
}

impl ::protobuf::Clear for EnableServiceResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnableServiceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnableServiceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DisableServiceRequest {
    // message fields
    pub service_name: ::std::string::String,
    pub consumer_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DisableServiceRequest {
    fn default() -> &'a DisableServiceRequest {
        <DisableServiceRequest as ::protobuf::Message>::default_instance()
    }
}

impl DisableServiceRequest {
    pub fn new() -> DisableServiceRequest {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }

    // string consumer_id = 2;


    pub fn get_consumer_id(&self) -> &str {
        &self.consumer_id
    }
    pub fn clear_consumer_id(&mut self) {
        self.consumer_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: ::std::string::String) {
        self.consumer_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consumer_id(&mut self) -> &mut ::std::string::String {
        &mut self.consumer_id
    }

    // Take field
    pub fn take_consumer_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.consumer_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DisableServiceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.consumer_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        if !self.consumer_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.consumer_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        if !self.consumer_id.is_empty() {
            os.write_string(2, &self.consumer_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DisableServiceRequest {
        DisableServiceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &DisableServiceRequest| { &m.service_name },
                |m: &mut DisableServiceRequest| { &mut m.service_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "consumer_id",
                |m: &DisableServiceRequest| { &m.consumer_id },
                |m: &mut DisableServiceRequest| { &mut m.consumer_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DisableServiceRequest>(
                "DisableServiceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DisableServiceRequest {
        static instance: ::protobuf::rt::LazyV2<DisableServiceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DisableServiceRequest::new)
    }
}

impl ::protobuf::Clear for DisableServiceRequest {
    fn clear(&mut self) {
        self.service_name.clear();
        self.consumer_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisableServiceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisableServiceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DisableServiceResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DisableServiceResponse {
    fn default() -> &'a DisableServiceResponse {
        <DisableServiceResponse as ::protobuf::Message>::default_instance()
    }
}

impl DisableServiceResponse {
    pub fn new() -> DisableServiceResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DisableServiceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DisableServiceResponse {
        DisableServiceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DisableServiceResponse>(
                "DisableServiceResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DisableServiceResponse {
        static instance: ::protobuf::rt::LazyV2<DisableServiceResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DisableServiceResponse::new)
    }
}

impl ::protobuf::Clear for DisableServiceResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisableServiceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisableServiceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GenerateConfigReportRequest {
    // message fields
    pub new_config: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub old_config: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenerateConfigReportRequest {
    fn default() -> &'a GenerateConfigReportRequest {
        <GenerateConfigReportRequest as ::protobuf::Message>::default_instance()
    }
}

impl GenerateConfigReportRequest {
    pub fn new() -> GenerateConfigReportRequest {
        ::std::default::Default::default()
    }

    // .google.protobuf.Any new_config = 1;


    pub fn get_new_config(&self) -> &::protobuf::well_known_types::Any {
        self.new_config.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_new_config(&mut self) {
        self.new_config.clear();
    }

    pub fn has_new_config(&self) -> bool {
        self.new_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_config(&mut self, v: ::protobuf::well_known_types::Any) {
        self.new_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_new_config(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.new_config.is_none() {
            self.new_config.set_default();
        }
        self.new_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_new_config(&mut self) -> ::protobuf::well_known_types::Any {
        self.new_config.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // .google.protobuf.Any old_config = 2;


    pub fn get_old_config(&self) -> &::protobuf::well_known_types::Any {
        self.old_config.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_old_config(&mut self) {
        self.old_config.clear();
    }

    pub fn has_old_config(&self) -> bool {
        self.old_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_old_config(&mut self, v: ::protobuf::well_known_types::Any) {
        self.old_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_old_config(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.old_config.is_none() {
            self.old_config.set_default();
        }
        self.old_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_old_config(&mut self) -> ::protobuf::well_known_types::Any {
        self.old_config.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }
}

impl ::protobuf::Message for GenerateConfigReportRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.new_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.old_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.new_config)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.old_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.new_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.old_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.new_config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.old_config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenerateConfigReportRequest {
        GenerateConfigReportRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "new_config",
                |m: &GenerateConfigReportRequest| { &m.new_config },
                |m: &mut GenerateConfigReportRequest| { &mut m.new_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "old_config",
                |m: &GenerateConfigReportRequest| { &m.old_config },
                |m: &mut GenerateConfigReportRequest| { &mut m.old_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GenerateConfigReportRequest>(
                "GenerateConfigReportRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GenerateConfigReportRequest {
        static instance: ::protobuf::rt::LazyV2<GenerateConfigReportRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GenerateConfigReportRequest::new)
    }
}

impl ::protobuf::Clear for GenerateConfigReportRequest {
    fn clear(&mut self) {
        self.new_config.clear();
        self.old_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenerateConfigReportRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenerateConfigReportRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GenerateConfigReportResponse {
    // message fields
    pub service_name: ::std::string::String,
    pub id: ::std::string::String,
    pub change_reports: ::protobuf::RepeatedField<super::resources::ChangeReport>,
    pub diagnostics: ::protobuf::RepeatedField<super::resources::Diagnostic>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenerateConfigReportResponse {
    fn default() -> &'a GenerateConfigReportResponse {
        <GenerateConfigReportResponse as ::protobuf::Message>::default_instance()
    }
}

impl GenerateConfigReportResponse {
    pub fn new() -> GenerateConfigReportResponse {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }

    // string id = 2;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // repeated .google.api.servicemanagement.v1.ChangeReport change_reports = 3;


    pub fn get_change_reports(&self) -> &[super::resources::ChangeReport] {
        &self.change_reports
    }
    pub fn clear_change_reports(&mut self) {
        self.change_reports.clear();
    }

    // Param is passed by value, moved
    pub fn set_change_reports(&mut self, v: ::protobuf::RepeatedField<super::resources::ChangeReport>) {
        self.change_reports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_change_reports(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ChangeReport> {
        &mut self.change_reports
    }

    // Take field
    pub fn take_change_reports(&mut self) -> ::protobuf::RepeatedField<super::resources::ChangeReport> {
        ::std::mem::replace(&mut self.change_reports, ::protobuf::RepeatedField::new())
    }

    // repeated .google.api.servicemanagement.v1.Diagnostic diagnostics = 4;


    pub fn get_diagnostics(&self) -> &[super::resources::Diagnostic] {
        &self.diagnostics
    }
    pub fn clear_diagnostics(&mut self) {
        self.diagnostics.clear();
    }

    // Param is passed by value, moved
    pub fn set_diagnostics(&mut self, v: ::protobuf::RepeatedField<super::resources::Diagnostic>) {
        self.diagnostics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_diagnostics(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Diagnostic> {
        &mut self.diagnostics
    }

    // Take field
    pub fn take_diagnostics(&mut self) -> ::protobuf::RepeatedField<super::resources::Diagnostic> {
        ::std::mem::replace(&mut self.diagnostics, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GenerateConfigReportResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.change_reports {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.diagnostics {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.change_reports)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.diagnostics)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        for value in &self.change_reports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.diagnostics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        for v in &self.change_reports {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.diagnostics {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenerateConfigReportResponse {
        GenerateConfigReportResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &GenerateConfigReportResponse| { &m.service_name },
                |m: &mut GenerateConfigReportResponse| { &mut m.service_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &GenerateConfigReportResponse| { &m.id },
                |m: &mut GenerateConfigReportResponse| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ChangeReport>>(
                "change_reports",
                |m: &GenerateConfigReportResponse| { &m.change_reports },
                |m: &mut GenerateConfigReportResponse| { &mut m.change_reports },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Diagnostic>>(
                "diagnostics",
                |m: &GenerateConfigReportResponse| { &m.diagnostics },
                |m: &mut GenerateConfigReportResponse| { &mut m.diagnostics },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GenerateConfigReportResponse>(
                "GenerateConfigReportResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GenerateConfigReportResponse {
        static instance: ::protobuf::rt::LazyV2<GenerateConfigReportResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GenerateConfigReportResponse::new)
    }
}

impl ::protobuf::Clear for GenerateConfigReportResponse {
    fn clear(&mut self) {
        self.service_name.clear();
        self.id.clear();
        self.change_reports.clear();
        self.diagnostics.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenerateConfigReportResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenerateConfigReportResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n4google/api/servicemanagement/v1/servicemanager.proto\x12\x1fgoogle.ap\
    i.servicemanagement.v1\x1a\x1cgoogle/api/annotations.proto\x1a\x17google\
    /api/client.proto\x1a\x1fgoogle/api/field_behavior.proto\x1a\x18google/a\
    pi/service.proto\x1a/google/api/servicemanagement/v1/resources.proto\x1a\
    #google/longrunning/operations.proto\x1a\x19google/protobuf/any.proto\
    \x1a\x20google/protobuf/field_mask.proto\x1a\x17google/rpc/status.proto\
    \"\xa6\x01\n\x13ListServicesRequest\x12.\n\x13producer_project_id\x18\
    \x01\x20\x01(\tR\x11producerProjectId\x12\x1b\n\tpage_size\x18\x05\x20\
    \x01(\x05R\x08pageSize\x12\x1d\n\npage_token\x18\x06\x20\x01(\tR\tpageTo\
    ken\x12#\n\x0bconsumer_id\x18\x07\x20\x01(\tR\nconsumerIdB\x02\x18\x01\"\
    \x8b\x01\n\x14ListServicesResponse\x12K\n\x08services\x18\x01\x20\x03(\
    \x0b2/.google.api.servicemanagement.v1.ManagedServiceR\x08services\x12&\
    \n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageToken\";\n\x11GetServ\
    iceRequest\x12&\n\x0cservice_name\x18\x01\x20\x01(\tR\x0bserviceNameB\
    \x03\xe0A\x02\"f\n\x14CreateServiceRequest\x12N\n\x07service\x18\x01\x20\
    \x01(\x0b2/.google.api.servicemanagement.v1.ManagedServiceR\x07serviceB\
    \x03\xe0A\x02\">\n\x14DeleteServiceRequest\x12&\n\x0cservice_name\x18\
    \x01\x20\x01(\tR\x0bserviceNameB\x03\xe0A\x02\"@\n\x16UndeleteServiceReq\
    uest\x12&\n\x0cservice_name\x18\x01\x20\x01(\tR\x0bserviceNameB\x03\xe0A\
    \x02\"d\n\x17UndeleteServiceResponse\x12I\n\x07service\x18\x01\x20\x01(\
    \x0b2/.google.api.servicemanagement.v1.ManagedServiceR\x07service\"\xdf\
    \x01\n\x17GetServiceConfigRequest\x12&\n\x0cservice_name\x18\x01\x20\x01\
    (\tR\x0bserviceNameB\x03\xe0A\x02\x12\x20\n\tconfig_id\x18\x02\x20\x01(\
    \tR\x08configIdB\x03\xe0A\x02\x12W\n\x04view\x18\x03\x20\x01(\x0e2C.goog\
    le.api.servicemanagement.v1.GetServiceConfigRequest.ConfigViewR\x04view\
    \"!\n\nConfigView\x12\t\n\x05BASIC\x10\0\x12\x08\n\x04FULL\x10\x01\"\x7f\
    \n\x19ListServiceConfigsRequest\x12&\n\x0cservice_name\x18\x01\x20\x01(\
    \tR\x0bserviceNameB\x03\xe0A\x02\x12\x1d\n\npage_token\x18\x02\x20\x01(\
    \tR\tpageToken\x12\x1b\n\tpage_size\x18\x03\x20\x01(\x05R\x08pageSize\"\
    \x82\x01\n\x1aListServiceConfigsResponse\x12<\n\x0fservice_configs\x18\
    \x01\x20\x03(\x0b2\x13.google.api.ServiceR\x0eserviceConfigs\x12&\n\x0fn\
    ext_page_token\x18\x02\x20\x01(\tR\rnextPageToken\"\x85\x01\n\x1aCreateS\
    erviceConfigRequest\x12&\n\x0cservice_name\x18\x01\x20\x01(\tR\x0bservic\
    eNameB\x03\xe0A\x02\x12?\n\x0eservice_config\x18\x02\x20\x01(\x0b2\x13.g\
    oogle.api.ServiceR\rserviceConfigB\x03\xe0A\x02\"\xc6\x01\n\x19SubmitCon\
    figSourceRequest\x12&\n\x0cservice_name\x18\x01\x20\x01(\tR\x0bserviceNa\
    meB\x03\xe0A\x02\x12W\n\rconfig_source\x18\x02\x20\x01(\x0b2-.google.api\
    .servicemanagement.v1.ConfigSourceR\x0cconfigSourceB\x03\xe0A\x02\x12(\n\
    \rvalidate_only\x18\x03\x20\x01(\x08R\x0cvalidateOnlyB\x03\xe0A\x01\"X\n\
    \x1aSubmitConfigSourceResponse\x12:\n\x0eservice_config\x18\x01\x20\x01(\
    \x0b2\x13.google.api.ServiceR\rserviceConfig\"\x8e\x01\n\x1bCreateServic\
    eRolloutRequest\x12&\n\x0cservice_name\x18\x01\x20\x01(\tR\x0bserviceNam\
    eB\x03\xe0A\x02\x12G\n\x07rollout\x18\x02\x20\x01(\x0b2(.google.api.serv\
    icemanagement.v1.RolloutR\x07rolloutB\x03\xe0A\x02\"\x9d\x01\n\x1aListSe\
    rviceRolloutsRequest\x12&\n\x0cservice_name\x18\x01\x20\x01(\tR\x0bservi\
    ceNameB\x03\xe0A\x02\x12\x1d\n\npage_token\x18\x02\x20\x01(\tR\tpageToke\
    n\x12\x1b\n\tpage_size\x18\x03\x20\x01(\x05R\x08pageSize\x12\x1b\n\x06fi\
    lter\x18\x04\x20\x01(\tR\x06filterB\x03\xe0A\x02\"\x8b\x01\n\x1bListServ\
    iceRolloutsResponse\x12D\n\x08rollouts\x18\x01\x20\x03(\x0b2(.google.api\
    .servicemanagement.v1.RolloutR\x08rollouts\x12&\n\x0fnext_page_token\x18\
    \x02\x20\x01(\tR\rnextPageToken\"f\n\x18GetServiceRolloutRequest\x12&\n\
    \x0cservice_name\x18\x01\x20\x01(\tR\x0bserviceNameB\x03\xe0A\x02\x12\"\
    \n\nrollout_id\x18\x02\x20\x01(\tR\trolloutIdB\x03\xe0A\x02\"d\n\x14Enab\
    leServiceRequest\x12&\n\x0cservice_name\x18\x01\x20\x01(\tR\x0bserviceNa\
    meB\x03\xe0A\x02\x12$\n\x0bconsumer_id\x18\x02\x20\x01(\tR\nconsumerIdB\
    \x03\xe0A\x02\"\x17\n\x15EnableServiceResponse\"e\n\x15DisableServiceReq\
    uest\x12&\n\x0cservice_name\x18\x01\x20\x01(\tR\x0bserviceNameB\x03\xe0A\
    \x02\x12$\n\x0bconsumer_id\x18\x02\x20\x01(\tR\nconsumerIdB\x03\xe0A\x02\
    \"\x18\n\x16DisableServiceResponse\"\x91\x01\n\x1bGenerateConfigReportRe\
    quest\x128\n\nnew_config\x18\x01\x20\x01(\x0b2\x14.google.protobuf.AnyR\
    \tnewConfigB\x03\xe0A\x02\x128\n\nold_config\x18\x02\x20\x01(\x0b2\x14.g\
    oogle.protobuf.AnyR\toldConfigB\x03\xe0A\x01\"\xf6\x01\n\x1cGenerateConf\
    igReportResponse\x12!\n\x0cservice_name\x18\x01\x20\x01(\tR\x0bserviceNa\
    me\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\x12T\n\x0echange_reports\
    \x18\x03\x20\x03(\x0b2-.google.api.servicemanagement.v1.ChangeReportR\rc\
    hangeReports\x12M\n\x0bdiagnostics\x18\x04\x20\x03(\x0b2+.google.api.ser\
    vicemanagement.v1.DiagnosticR\x0bdiagnostics2\x92\x1e\n\x0eServiceManage\
    r\x12\xb3\x01\n\x0cListServices\x124.google.api.servicemanagement.v1.Lis\
    tServicesRequest\x1a5.google.api.servicemanagement.v1.ListServicesRespon\
    se\"6\x82\xd3\xe4\x93\x02\x0e\x12\x0c/v1/services\xdaA\x1fproducer_proje\
    ct_id,consumer_id\x12\xa5\x01\n\nGetService\x122.google.api.servicemanag\
    ement.v1.GetServiceRequest\x1a/.google.api.servicemanagement.v1.ManagedS\
    ervice\"2\xdaA\x0cservice_name\x82\xd3\xe4\x93\x02\x1d\x12\x1b/v1/servic\
    es/{service_name}\x12\xf5\x01\n\rCreateService\x125.google.api.servicema\
    nagement.v1.CreateServiceRequest\x1a\x1d.google.longrunning.Operation\"\
    \x8d\x01\xdaA\x07service\x82\xd3\xe4\x93\x02\x17\"\x0c/v1/services:\x07s\
    ervice\xcaAc\n.google.api.servicemanagement.v1.ManagedService\x121google\
    .api.servicemanagement.v1.OperationMetadata\x12\xe6\x01\n\rDeleteService\
    \x125.google.api.servicemanagement.v1.DeleteServiceRequest\x1a\x1d.googl\
    e.longrunning.Operation\"\x7f\x82\xd3\xe4\x93\x02\x1d*\x1b/v1/services/{\
    service_name}\xdaA\x0cservice_name\xcaAJ\n\x15google.protobuf.Empty\x121\
    google.api.servicemanagement.v1.OperationMetadata\x12\x96\x02\n\x0fUndel\
    eteService\x127.google.api.servicemanagement.v1.UndeleteServiceRequest\
    \x1a\x1d.google.longrunning.Operation\"\xaa\x01\xcaAl\n7google.api.servi\
    cemanagement.v1.UndeleteServiceResponse\x121google.api.servicemanagement\
    .v1.OperationMetadata\x82\xd3\xe4\x93\x02&\"$/v1/services/{service_name}\
    :undelete\xdaA\x0cservice_name\x12\xc9\x01\n\x12ListServiceConfigs\x12:.\
    google.api.servicemanagement.v1.ListServiceConfigsRequest\x1a;.google.ap\
    i.servicemanagement.v1.ListServiceConfigsResponse\":\x82\xd3\xe4\x93\x02\
    %\x12#/v1/services/{service_name}/configs\xdaA\x0cservice_name\x12\xde\
    \x01\n\x10GetServiceConfig\x128.google.api.servicemanagement.v1.GetServi\
    ceConfigRequest\x1a\x13.google.api.Service\"{\x82\xd3\xe4\x93\x02W\x12//\
    v1/services/{service_name}/configs/{config_id}Z$\x12\"/v1/services/{serv\
    ice_name}/config\xdaA\x1bservice_name,config_id,view\x12\xc2\x01\n\x13Cr\
    eateServiceConfig\x12;.google.api.servicemanagement.v1.CreateServiceConf\
    igRequest\x1a\x13.google.api.Service\"Y\xdaA\x1bservice_name,service_con\
    fig\x82\xd3\xe4\x93\x025\"#/v1/services/{service_name}/configs:\x0eservi\
    ce_config\x12\xc4\x02\n\x12SubmitConfigSource\x12:.google.api.serviceman\
    agement.v1.SubmitConfigSourceRequest\x1a\x1d.google.longrunning.Operatio\
    n\"\xd2\x01\x82\xd3\xe4\x93\x02/\"*/v1/services/{service_name}/configs:s\
    ubmit:\x01*\xcaAo\n:google.api.servicemanagement.v1.SubmitConfigSourceRe\
    sponse\x121google.api.servicemanagement.v1.OperationMetadata\xdaA(servic\
    e_name,config_source,validate_only\x12\xd4\x01\n\x13ListServiceRollouts\
    \x12;.google.api.servicemanagement.v1.ListServiceRolloutsRequest\x1a<.go\
    ogle.api.servicemanagement.v1.ListServiceRolloutsResponse\"B\x82\xd3\xe4\
    \x93\x02&\x12$/v1/services/{service_name}/rollouts\xdaA\x13service_name,\
    filter\x12\xcd\x01\n\x11GetServiceRollout\x129.google.api.servicemanagem\
    ent.v1.GetServiceRolloutRequest\x1a(.google.api.servicemanagement.v1.Rol\
    lout\"S\xdaA\x17service_name,rollout_id\x82\xd3\xe4\x93\x023\x121/v1/ser\
    vices/{service_name}/rollouts/{rollout_id}\x12\xa1\x02\n\x14CreateServic\
    eRollout\x12<.google.api.servicemanagement.v1.CreateServiceRolloutReques\
    t\x1a\x1d.google.longrunning.Operation\"\xab\x01\x82\xd3\xe4\x93\x02/\"$\
    /v1/services/{service_name}/rollouts:\x07rollout\xdaA\x14service_name,ro\
    llout\xcaA\\\n'google.api.servicemanagement.v1.Rollout\x121google.api.se\
    rvicemanagement.v1.OperationMetadata\x12\xd9\x01\n\x14GenerateConfigRepo\
    rt\x12<.google.api.servicemanagement.v1.GenerateConfigReportRequest\x1a=\
    .google.api.servicemanagement.v1.GenerateConfigReportResponse\"D\x82\xd3\
    \xe4\x93\x02&\"!/v1/services:generateConfigReport:\x01*\xdaA\x15new_conf\
    ig,old_config\x12\xa0\x02\n\rEnableService\x125.google.api.servicemanage\
    ment.v1.EnableServiceRequest\x1a\x1d.google.longrunning.Operation\"\xb8\
    \x01\x88\x02\x01\xdaA\x18service_name,consumer_id\xcaAj\n5google.api.ser\
    vicemanagement.v1.EnableServiceResponse\x121google.api.servicemanagement\
    .v1.OperationMetadata\x82\xd3\xe4\x93\x02'\"\"/v1/services/{service_name\
    }:enable:\x01*\x12\xa4\x02\n\x0eDisableService\x126.google.api.servicema\
    nagement.v1.DisableServiceRequest\x1a\x1d.google.longrunning.Operation\"\
    \xba\x01\x88\x02\x01\xdaA\x18service_name,consumer_id\x82\xd3\xe4\x93\
    \x02(\"#/v1/services/{service_name}:disable:\x01*\xcaAk\n6google.api.ser\
    vicemanagement.v1.DisableServiceResponse\x121google.api.servicemanagemen\
    t.v1.OperationMetadata\x1a\xfd\x01\xd2A\xd6\x01https://www.googleapis.co\
    m/auth/cloud-platform,https://www.googleapis.com/auth/cloud-platform.rea\
    d-only,https://www.googleapis.com/auth/service.management,https://www.go\
    ogleapis.com/auth/service.management.readonly\xcaA\x20servicemanagement.\
    googleapis.comB\x84\x02\n#com.google.api.servicemanagement.v1B\x13Servic\
    eManagerProtoP\x01ZPgoogle.golang.org/genproto/googleapis/api/serviceman\
    agement/v1;servicemanagement\xa2\x02\x04GASM\xaa\x02!Google.Cloud.Servic\
    eManagement.V1\xca\x02!Google\\Cloud\\ServiceManagement\\V1\xea\x02$Goog\
    le::Cloud::ServiceManagement::V1J\xb3\x99\x01\n\x07\x12\x05\x0e\0\xaf\
    \x04\x01\n\xbd\x04\n\x01\x0c\x12\x03\x0e\0\x122\xb2\x04\x20Copyright\x20\
    2019\x20Google\x20LLC.\n\n\x20Licensed\x20under\x20the\x20Apache\x20Lice\
    nse,\x20Version\x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20not\
    \x20use\x20this\x20file\x20except\x20in\x20compliance\x20with\x20the\x20\
    License.\n\x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\
    \x20at\n\n\x20\x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-2.0\
    \n\n\x20Unless\x20required\x20by\x20applicable\x20law\x20or\x20agreed\
    \x20to\x20in\x20writing,\x20software\n\x20distributed\x20under\x20the\
    \x20License\x20is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\
    \x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20e\
    ither\x20express\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20\
    the\x20specific\x20language\x20governing\x20permissions\x20and\n\x20limi\
    tations\x20under\x20the\x20License.\n\n\x08\n\x01\x02\x12\x03\x10\0(\n\t\
    \n\x02\x03\0\x12\x03\x12\0&\n\t\n\x02\x03\x01\x12\x03\x13\0!\n\t\n\x02\
    \x03\x02\x12\x03\x14\0)\n\t\n\x02\x03\x03\x12\x03\x15\0\"\n\t\n\x02\x03\
    \x04\x12\x03\x16\09\n\t\n\x02\x03\x05\x12\x03\x17\0-\n\t\n\x02\x03\x06\
    \x12\x03\x18\0#\n\t\n\x02\x03\x07\x12\x03\x19\0*\n\t\n\x02\x03\x08\x12\
    \x03\x1a\0!\n\x08\n\x01\x08\x12\x03\x1c\0>\n\t\n\x02\x08%\x12\x03\x1c\0>\
    \n\x08\n\x01\x08\x12\x03\x1d\0g\n\t\n\x02\x08\x0b\x12\x03\x1d\0g\n\x08\n\
    \x01\x08\x12\x03\x1e\0\"\n\t\n\x02\x08\n\x12\x03\x1e\0\"\n\x08\n\x01\x08\
    \x12\x03\x1f\04\n\t\n\x02\x08\x08\x12\x03\x1f\04\n\x08\n\x01\x08\x12\x03\
    \x20\0<\n\t\n\x02\x08\x01\x12\x03\x20\0<\n\x08\n\x01\x08\x12\x03!\0\"\n\
    \t\n\x02\x08$\x12\x03!\0\"\n\x08\n\x01\x08\x12\x03\"\0>\n\t\n\x02\x08)\
    \x12\x03\"\0>\n\x08\n\x01\x08\x12\x03#\0=\n\t\n\x02\x08-\x12\x03#\0=\nL\
    \n\x02\x06\0\x12\x05&\0\x98\x02\x01\x1a?\x20[Google\x20Service\x20Manage\
    ment\x20API](/service-management/overview)\n\n\n\n\x03\x06\0\x01\x12\x03\
    &\x08\x16\n\n\n\x03\x06\0\x03\x12\x03'\x02H\n\x0c\n\x05\x06\0\x03\x99\
    \x08\x12\x03'\x02H\n\x0b\n\x03\x06\0\x03\x12\x04(\x02,D\n\r\n\x05\x06\0\
    \x03\x9a\x08\x12\x04(\x02,D\n\xf3\x02\n\x04\x06\0\x02\0\x12\x047\x02<\
    \x03\x1a\xe4\x02\x20Lists\x20managed\x20services.\n\n\x20Returns\x20all\
    \x20public\x20services.\x20For\x20authenticated\x20users,\x20also\x20ret\
    urns\x20all\n\x20services\x20the\x20calling\x20user\x20has\x20\"servicem\
    anagement.services.get\"\x20permission\n\x20for.\n\n\x20**BETA:**\x20If\
    \x20the\x20caller\x20specifies\x20the\x20`consumer_id`,\x20it\x20returns\
    \x20only\x20the\n\x20services\x20enabled\x20on\x20the\x20consumer.\x20Th\
    e\x20`consumer_id`\x20must\x20have\x20the\x20format\n\x20of\x20\"project\
    :{PROJECT-ID}\".\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x037\x06\x12\n\x0c\n\
    \x05\x06\0\x02\0\x02\x12\x037\x13&\n\x0c\n\x05\x06\0\x02\0\x03\x12\x0371\
    E\n\r\n\x05\x06\0\x02\0\x04\x12\x048\x04:\x06\n\x11\n\t\x06\0\x02\0\x04\
    \xb0\xca\xbc\"\x12\x048\x04:\x06\n\x0c\n\x05\x06\0\x02\0\x04\x12\x03;\
    \x04M\n\x0f\n\x08\x06\0\x02\0\x04\x9b\x08\0\x12\x03;\x04M\na\n\x04\x06\0\
    \x02\x01\x12\x04@\x02E\x03\x1aS\x20Gets\x20a\x20managed\x20service.\x20A\
    uthentication\x20is\x20required\x20unless\x20the\x20service\x20is\n\x20p\
    ublic.\n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03@\x06\x10\n\x0c\n\x05\x06\
    \0\x02\x01\x02\x12\x03@\x11\"\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03@-;\n\
    \r\n\x05\x06\0\x02\x01\x04\x12\x04A\x04C\x06\n\x11\n\t\x06\0\x02\x01\x04\
    \xb0\xca\xbc\"\x12\x04A\x04C\x06\n\x0c\n\x05\x06\0\x02\x01\x04\x12\x03D\
    \x04:\n\x0f\n\x08\x06\0\x02\x01\x04\x9b\x08\0\x12\x03D\x04:\n\x99\x01\n\
    \x04\x06\0\x02\x02\x12\x04K\x02U\x03\x1a\x8a\x01\x20Creates\x20a\x20new\
    \x20managed\x20service.\n\x20Please\x20note\x20one\x20producer\x20projec\
    t\x20can\x20own\x20no\x20more\x20than\x2020\x20services.\n\n\x20Operatio\
    n<response:\x20ManagedService>\n\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03K\
    \x06\x13\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03K\x14(\n\x0c\n\x05\x06\0\
    \x02\x02\x03\x12\x03K3O\n\r\n\x05\x06\0\x02\x02\x04\x12\x04L\x04O\x06\n\
    \x11\n\t\x06\0\x02\x02\x04\xb0\xca\xbc\"\x12\x04L\x04O\x06\n\x0c\n\x05\
    \x06\0\x02\x02\x04\x12\x03P\x045\n\x0f\n\x08\x06\0\x02\x02\x04\x9b\x08\0\
    \x12\x03P\x045\n\r\n\x05\x06\0\x02\x02\x04\x12\x04Q\x04T\x06\n\x0f\n\x07\
    \x06\0\x02\x02\x04\x99\x08\x12\x04Q\x04T\x06\n\xf8\x02\n\x04\x06\0\x02\
    \x03\x12\x04]\x02f\x03\x1a\xe9\x02\x20Deletes\x20a\x20managed\x20service\
    .\x20This\x20method\x20will\x20change\x20the\x20service\x20to\x20the\n\
    \x20`Soft-Delete`\x20state\x20for\x2030\x20days.\x20Within\x20this\x20pe\
    riod,\x20service\x20producers\x20may\n\x20call\x20[UndeleteService][goog\
    le.api.servicemanagement.v1.ServiceManager.UndeleteService]\x20to\x20res\
    tore\x20the\x20service.\n\x20After\x2030\x20days,\x20the\x20service\x20w\
    ill\x20be\x20permanently\x20deleted.\n\n\x20Operation<response:\x20googl\
    e.protobuf.Empty>\n\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x03]\x06\x13\n\x0c\
    \n\x05\x06\0\x02\x03\x02\x12\x03]\x14(\n\x0c\n\x05\x06\0\x02\x03\x03\x12\
    \x03]3O\n\r\n\x05\x06\0\x02\x03\x04\x12\x04^\x04`\x06\n\x11\n\t\x06\0\
    \x02\x03\x04\xb0\xca\xbc\"\x12\x04^\x04`\x06\n\x0c\n\x05\x06\0\x02\x03\
    \x04\x12\x03a\x04:\n\x0f\n\x08\x06\0\x02\x03\x04\x9b\x08\0\x12\x03a\x04:\
    \n\r\n\x05\x06\0\x02\x03\x04\x12\x04b\x04e\x06\n\x0f\n\x07\x06\0\x02\x03\
    \x04\x99\x08\x12\x04b\x04e\x06\n\x9f\x02\n\x04\x06\0\x02\x04\x12\x04n\
    \x02w\x03\x1a\x90\x02\x20Revives\x20a\x20previously\x20deleted\x20manage\
    d\x20service.\x20The\x20method\x20restores\x20the\n\x20service\x20using\
    \x20the\x20configuration\x20at\x20the\x20time\x20the\x20service\x20was\
    \x20deleted.\n\x20The\x20target\x20service\x20must\x20exist\x20and\x20mu\
    st\x20have\x20been\x20deleted\x20within\x20the\n\x20last\x2030\x20days.\
    \n\n\x20Operation<response:\x20UndeleteServiceResponse>\n\n\x0c\n\x05\
    \x06\0\x02\x04\x01\x12\x03n\x06\x15\n\x0c\n\x05\x06\0\x02\x04\x02\x12\
    \x03n\x16,\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03n7S\n\r\n\x05\x06\0\x02\
    \x04\x04\x12\x04o\x04q\x06\n\x11\n\t\x06\0\x02\x04\x04\xb0\xca\xbc\"\x12\
    \x04o\x04q\x06\n\x0c\n\x05\x06\0\x02\x04\x04\x12\x03r\x04:\n\x0f\n\x08\
    \x06\0\x02\x04\x04\x9b\x08\0\x12\x03r\x04:\n\r\n\x05\x06\0\x02\x04\x04\
    \x12\x04s\x04v\x06\n\x0f\n\x07\x06\0\x02\x04\x04\x99\x08\x12\x04s\x04v\
    \x06\nv\n\x04\x06\0\x02\x05\x12\x05{\x02\x80\x01\x03\x1ag\x20Lists\x20th\
    e\x20history\x20of\x20the\x20service\x20configuration\x20for\x20a\x20man\
    aged\x20service,\n\x20from\x20the\x20newest\x20to\x20the\x20oldest.\n\n\
    \x0c\n\x05\x06\0\x02\x05\x01\x12\x03{\x06\x18\n\x0c\n\x05\x06\0\x02\x05\
    \x02\x12\x03{\x192\n\x0c\n\x05\x06\0\x02\x05\x03\x12\x03{=W\n\r\n\x05\
    \x06\0\x02\x05\x04\x12\x04|\x04~\x06\n\x11\n\t\x06\0\x02\x05\x04\xb0\xca\
    \xbc\"\x12\x04|\x04~\x06\n\x0c\n\x05\x06\0\x02\x05\x04\x12\x03\x7f\x04:\
    \n\x0f\n\x08\x06\0\x02\x05\x04\x9b\x08\0\x12\x03\x7f\x04:\nO\n\x04\x06\0\
    \x02\x06\x12\x06\x83\x01\x02\x8b\x01\x03\x1a?\x20Gets\x20a\x20service\
    \x20configuration\x20(version)\x20for\x20a\x20managed\x20service.\n\n\r\
    \n\x05\x06\0\x02\x06\x01\x12\x04\x83\x01\x06\x16\n\r\n\x05\x06\0\x02\x06\
    \x02\x12\x04\x83\x01\x17.\n\r\n\x05\x06\0\x02\x06\x03\x12\x04\x83\x019K\
    \n\x0f\n\x05\x06\0\x02\x06\x04\x12\x06\x84\x01\x04\x89\x01\x06\n\x13\n\t\
    \x06\0\x02\x06\x04\xb0\xca\xbc\"\x12\x06\x84\x01\x04\x89\x01\x06\n\r\n\
    \x05\x06\0\x02\x06\x04\x12\x04\x8a\x01\x04I\n\x10\n\x08\x06\0\x02\x06\
    \x04\x9b\x08\0\x12\x04\x8a\x01\x04I\n\xcc\x03\n\x04\x06\0\x02\x07\x12\
    \x06\x95\x01\x02\x9b\x01\x03\x1a\xbb\x03\x20Creates\x20a\x20new\x20servi\
    ce\x20configuration\x20(version)\x20for\x20a\x20managed\x20service.\n\
    \x20This\x20method\x20only\x20stores\x20the\x20service\x20configuration.\
    \x20To\x20roll\x20out\x20the\x20service\n\x20configuration\x20to\x20back\
    end\x20systems\x20please\x20call\n\x20[CreateServiceRollout][google.api.\
    servicemanagement.v1.ServiceManager.CreateServiceRollout].\n\n\x20Only\
    \x20the\x20100\x20most\x20recent\x20service\x20configurations\x20and\x20\
    ones\x20referenced\x20by\n\x20existing\x20rollouts\x20are\x20kept\x20for\
    \x20each\x20service.\x20The\x20rest\x20will\x20be\x20deleted\n\x20eventu\
    ally.\n\n\r\n\x05\x06\0\x02\x07\x01\x12\x04\x95\x01\x06\x19\n\r\n\x05\
    \x06\0\x02\x07\x02\x12\x04\x95\x01\x1a4\n\r\n\x05\x06\0\x02\x07\x03\x12\
    \x04\x95\x01?Q\n\x0f\n\x05\x06\0\x02\x07\x04\x12\x06\x96\x01\x04\x99\x01\
    \x06\n\x13\n\t\x06\0\x02\x07\x04\xb0\xca\xbc\"\x12\x06\x96\x01\x04\x99\
    \x01\x06\n\r\n\x05\x06\0\x02\x07\x04\x12\x04\x9a\x01\x04I\n\x10\n\x08\
    \x06\0\x02\x07\x04\x9b\x08\0\x12\x04\x9a\x01\x04I\n\x8d\x05\n\x04\x06\0\
    \x02\x08\x12\x06\xaa\x01\x02\xb4\x01\x03\x1a\xfc\x04\x20Creates\x20a\x20\
    new\x20service\x20configuration\x20(version)\x20for\x20a\x20managed\x20s\
    ervice\x20based\n\x20on\n\x20user-supplied\x20configuration\x20source\
    \x20files\x20(for\x20example:\x20OpenAPI\n\x20Specification).\x20This\
    \x20method\x20stores\x20the\x20source\x20configurations\x20as\x20well\
    \x20as\x20the\n\x20generated\x20service\x20configuration.\x20To\x20rollo\
    ut\x20the\x20service\x20configuration\x20to\n\x20other\x20services,\n\
    \x20please\x20call\x20[CreateServiceRollout][google.api.servicemanagemen\
    t.v1.ServiceManager.CreateServiceRollout].\n\n\x20Only\x20the\x20100\x20\
    most\x20recent\x20configuration\x20sources\x20and\x20ones\x20referenced\
    \x20by\n\x20existing\x20service\x20configurtions\x20are\x20kept\x20for\
    \x20each\x20service.\x20The\x20rest\x20will\x20be\n\x20deleted\x20eventu\
    ally.\n\n\x20Operation<response:\x20SubmitConfigSourceResponse>\n\n\r\n\
    \x05\x06\0\x02\x08\x01\x12\x04\xaa\x01\x06\x18\n\r\n\x05\x06\0\x02\x08\
    \x02\x12\x04\xaa\x01\x192\n\r\n\x05\x06\0\x02\x08\x03\x12\x04\xaa\x01=Y\
    \n\x0f\n\x05\x06\0\x02\x08\x04\x12\x06\xab\x01\x04\xae\x01\x06\n\x13\n\t\
    \x06\0\x02\x08\x04\xb0\xca\xbc\"\x12\x06\xab\x01\x04\xae\x01\x06\n\r\n\
    \x05\x06\0\x02\x08\x04\x12\x04\xaf\x01\x04V\n\x10\n\x08\x06\0\x02\x08\
    \x04\x9b\x08\0\x12\x04\xaf\x01\x04V\n\x0f\n\x05\x06\0\x02\x08\x04\x12\
    \x06\xb0\x01\x04\xb3\x01\x06\n\x11\n\x07\x06\0\x02\x08\x04\x99\x08\x12\
    \x06\xb0\x01\x04\xb3\x01\x06\n\x80\x01\n\x04\x06\0\x02\t\x12\x06\xb8\x01\
    \x02\xbd\x01\x03\x1ap\x20Lists\x20the\x20history\x20of\x20the\x20service\
    \x20configuration\x20rollouts\x20for\x20a\x20managed\n\x20service,\x20fr\
    om\x20the\x20newest\x20to\x20the\x20oldest.\n\n\r\n\x05\x06\0\x02\t\x01\
    \x12\x04\xb8\x01\x06\x19\n\r\n\x05\x06\0\x02\t\x02\x12\x04\xb8\x01\x1a4\
    \n\r\n\x05\x06\0\x02\t\x03\x12\x04\xb8\x01?Z\n\x0f\n\x05\x06\0\x02\t\x04\
    \x12\x06\xb9\x01\x04\xbb\x01\x06\n\x13\n\t\x06\0\x02\t\x04\xb0\xca\xbc\"\
    \x12\x06\xb9\x01\x04\xbb\x01\x06\n\r\n\x05\x06\0\x02\t\x04\x12\x04\xbc\
    \x01\x04A\n\x10\n\x08\x06\0\x02\t\x04\x9b\x08\0\x12\x04\xbc\x01\x04A\nb\
    \n\x04\x06\0\x02\n\x12\x06\xc0\x01\x02\xc5\x01\x03\x1aR\x20Gets\x20a\x20\
    service\x20configuration\x20[rollout][google.api.servicemanagement.v1.Ro\
    llout].\n\n\r\n\x05\x06\0\x02\n\x01\x12\x04\xc0\x01\x06\x17\n\r\n\x05\
    \x06\0\x02\n\x02\x12\x04\xc0\x01\x180\n\r\n\x05\x06\0\x02\n\x03\x12\x04\
    \xc0\x01;B\n\x0f\n\x05\x06\0\x02\n\x04\x12\x06\xc1\x01\x04\xc3\x01\x06\n\
    \x13\n\t\x06\0\x02\n\x04\xb0\xca\xbc\"\x12\x06\xc1\x01\x04\xc3\x01\x06\n\
    \r\n\x05\x06\0\x02\n\x04\x12\x04\xc4\x01\x04E\n\x10\n\x08\x06\0\x02\n\
    \x04\x9b\x08\0\x12\x04\xc4\x01\x04E\n\xaa\x05\n\x04\x06\0\x02\x0b\x12\
    \x06\xd5\x01\x02\xdf\x01\x03\x1a\x99\x05\x20Creates\x20a\x20new\x20servi\
    ce\x20configuration\x20rollout.\x20Based\x20on\x20rollout,\x20the\n\x20G\
    oogle\x20Service\x20Management\x20will\x20roll\x20out\x20the\x20service\
    \x20configurations\x20to\n\x20different\x20backend\x20services.\x20For\
    \x20example,\x20the\x20logging\x20configuration\x20will\x20be\n\x20pushe\
    d\x20to\x20Google\x20Cloud\x20Logging.\n\n\x20Please\x20note\x20that\x20\
    any\x20previous\x20pending\x20and\x20running\x20Rollouts\x20and\x20assoc\
    iated\n\x20Operations\x20will\x20be\x20automatically\x20cancelled\x20so\
    \x20that\x20the\x20latest\x20Rollout\x20will\n\x20not\x20be\x20blocked\
    \x20by\x20previous\x20Rollouts.\n\n\x20Only\x20the\x20100\x20most\x20rec\
    ent\x20(in\x20any\x20state)\x20and\x20the\x20last\x2010\x20successful\
    \x20(if\x20not\n\x20already\x20part\x20of\x20the\x20set\x20of\x20100\x20\
    most\x20recent)\x20rollouts\x20are\x20kept\x20for\x20each\n\x20service.\
    \x20The\x20rest\x20will\x20be\x20deleted\x20eventually.\n\n\x20Operation\
    <response:\x20Rollout>\n\n\r\n\x05\x06\0\x02\x0b\x01\x12\x04\xd5\x01\x06\
    \x1a\n\r\n\x05\x06\0\x02\x0b\x02\x12\x04\xd5\x01\x1b6\n\r\n\x05\x06\0\
    \x02\x0b\x03\x12\x04\xd5\x01A]\n\x0f\n\x05\x06\0\x02\x0b\x04\x12\x06\xd6\
    \x01\x04\xd9\x01\x06\n\x13\n\t\x06\0\x02\x0b\x04\xb0\xca\xbc\"\x12\x06\
    \xd6\x01\x04\xd9\x01\x06\n\r\n\x05\x06\0\x02\x0b\x04\x12\x04\xda\x01\x04\
    B\n\x10\n\x08\x06\0\x02\x0b\x04\x9b\x08\0\x12\x04\xda\x01\x04B\n\x0f\n\
    \x05\x06\0\x02\x0b\x04\x12\x06\xdb\x01\x04\xde\x01\x06\n\x11\n\x07\x06\0\
    \x02\x0b\x04\x99\x08\x12\x06\xdb\x01\x04\xde\x01\x06\n\xba\x04\n\x04\x06\
    \0\x02\x0c\x12\x06\xec\x01\x02\xf2\x01\x03\x1a\xa9\x04\x20Generates\x20a\
    nd\x20returns\x20a\x20report\x20(errors,\x20warnings\x20and\x20changes\
    \x20from\n\x20existing\x20configurations)\x20associated\x20with\n\x20Gen\
    erateConfigReportRequest.new_value\n\n\x20If\x20GenerateConfigReportRequ\
    est.old_value\x20is\x20specified,\n\x20GenerateConfigReportRequest\x20wi\
    ll\x20contain\x20a\x20single\x20ChangeReport\x20based\x20on\x20the\n\x20\
    comparison\x20between\x20GenerateConfigReportRequest.new_value\x20and\n\
    \x20GenerateConfigReportRequest.old_value.\n\x20If\x20GenerateConfigRepo\
    rtRequest.old_value\x20is\x20not\x20specified,\x20this\x20method\n\x20wi\
    ll\x20compare\x20GenerateConfigReportRequest.new_value\x20with\x20the\
    \x20last\x20pushed\n\x20service\x20configuration.\n\n\r\n\x05\x06\0\x02\
    \x0c\x01\x12\x04\xec\x01\x06\x1a\n\r\n\x05\x06\0\x02\x0c\x02\x12\x04\xec\
    \x01\x1b6\n\r\n\x05\x06\0\x02\x0c\x03\x12\x04\xec\x01A]\n\x0f\n\x05\x06\
    \0\x02\x0c\x04\x12\x06\xed\x01\x04\xf0\x01\x06\n\x13\n\t\x06\0\x02\x0c\
    \x04\xb0\xca\xbc\"\x12\x06\xed\x01\x04\xf0\x01\x06\n\r\n\x05\x06\0\x02\
    \x0c\x04\x12\x04\xf1\x01\x04C\n\x10\n\x08\x06\0\x02\x0c\x04\x9b\x08\0\
    \x12\x04\xf1\x01\x04C\n\x93\x02\n\x04\x06\0\x02\r\x12\x06\xfa\x01\x02\
    \x85\x02\x03\x1a\x82\x02\x20Enables\x20a\x20[service][google.api.service\
    management.v1.ManagedService]\x20for\x20a\x20project,\x20so\x20it\x20can\
    \x20be\x20used\n\x20for\x20the\x20project.\x20See\n\x20[Cloud\x20Auth\
    \x20Guide](https://cloud.google.com/docs/authentication)\x20for\n\x20mor\
    e\x20information.\n\n\x20Operation<response:\x20EnableServiceResponse>\n\
    \n\r\n\x05\x06\0\x02\r\x01\x12\x04\xfa\x01\x06\x13\n\r\n\x05\x06\0\x02\r\
    \x02\x12\x04\xfa\x01\x14(\n\r\n\x05\x06\0\x02\r\x03\x12\x04\xfa\x013O\n\
    \r\n\x05\x06\0\x02\r\x04\x12\x04\xfb\x01\x04\x1d\n\x0e\n\x06\x06\0\x02\r\
    \x04!\x12\x04\xfb\x01\x04\x1d\n\x0f\n\x05\x06\0\x02\r\x04\x12\x06\xfc\
    \x01\x04\xff\x01\x06\n\x13\n\t\x06\0\x02\r\x04\xb0\xca\xbc\"\x12\x06\xfc\
    \x01\x04\xff\x01\x06\n\r\n\x05\x06\0\x02\r\x04\x12\x04\x80\x02\x04F\n\
    \x10\n\x08\x06\0\x02\r\x04\x9b\x08\0\x12\x04\x80\x02\x04F\n\x0f\n\x05\
    \x06\0\x02\r\x04\x12\x06\x81\x02\x04\x84\x02\x06\n\x11\n\x07\x06\0\x02\r\
    \x04\x99\x08\x12\x06\x81\x02\x04\x84\x02\x06\n\xa0\x02\n\x04\x06\0\x02\
    \x0e\x12\x06\x8c\x02\x02\x97\x02\x03\x1a\x8f\x02\x20Disables\x20a\x20[se\
    rvice][google.api.servicemanagement.v1.ManagedService]\x20for\x20a\x20pr\
    oject,\x20so\x20it\x20can\x20no\x20longer\x20be\n\x20be\x20used\x20for\
    \x20the\x20project.\x20It\x20prevents\x20accidental\x20usage\x20that\x20\
    may\x20cause\n\x20unexpected\x20billing\x20charges\x20or\x20security\x20\
    leaks.\n\n\x20Operation<response:\x20DisableServiceResponse>\n\n\r\n\x05\
    \x06\0\x02\x0e\x01\x12\x04\x8c\x02\x06\x14\n\r\n\x05\x06\0\x02\x0e\x02\
    \x12\x04\x8c\x02\x15*\n\r\n\x05\x06\0\x02\x0e\x03\x12\x04\x8c\x025Q\n\r\
    \n\x05\x06\0\x02\x0e\x04\x12\x04\x8d\x02\x04\x1d\n\x0e\n\x06\x06\0\x02\
    \x0e\x04!\x12\x04\x8d\x02\x04\x1d\n\x0f\n\x05\x06\0\x02\x0e\x04\x12\x06\
    \x8e\x02\x04\x91\x02\x06\n\x13\n\t\x06\0\x02\x0e\x04\xb0\xca\xbc\"\x12\
    \x06\x8e\x02\x04\x91\x02\x06\n\r\n\x05\x06\0\x02\x0e\x04\x12\x04\x92\x02\
    \x04F\n\x10\n\x08\x06\0\x02\x0e\x04\x9b\x08\0\x12\x04\x92\x02\x04F\n\x0f\
    \n\x05\x06\0\x02\x0e\x04\x12\x06\x93\x02\x04\x96\x02\x06\n\x11\n\x07\x06\
    \0\x02\x0e\x04\x99\x08\x12\x06\x93\x02\x04\x96\x02\x06\n:\n\x02\x04\0\
    \x12\x06\x9b\x02\0\xad\x02\x01\x1a,\x20Request\x20message\x20for\x20`Lis\
    tServices`\x20method.\n\n\x0b\n\x03\x04\0\x01\x12\x04\x9b\x02\x08\x1b\nC\
    \n\x04\x04\0\x02\0\x12\x04\x9d\x02\x02!\x1a5\x20Include\x20services\x20p\
    roduced\x20by\x20the\x20specified\x20project.\n\n\x0f\n\x05\x04\0\x02\0\
    \x04\x12\x06\x9d\x02\x02\x9b\x02\x1d\n\r\n\x05\x04\0\x02\0\x05\x12\x04\
    \x9d\x02\x02\x08\n\r\n\x05\x04\0\x02\0\x01\x12\x04\x9d\x02\t\x1c\n\r\n\
    \x05\x04\0\x02\0\x03\x12\x04\x9d\x02\x1f\x20\n\x81\x01\n\x04\x04\0\x02\
    \x01\x12\x04\xa1\x02\x02\x16\x1as\x20The\x20max\x20number\x20of\x20items\
    \x20to\x20include\x20in\x20the\x20response\x20list.\x20Page\x20size\x20i\
    s\x2050\n\x20if\x20not\x20specified.\x20Maximum\x20value\x20is\x20100.\n\
    \n\x0f\n\x05\x04\0\x02\x01\x04\x12\x06\xa1\x02\x02\x9d\x02!\n\r\n\x05\
    \x04\0\x02\x01\x05\x12\x04\xa1\x02\x02\x07\n\r\n\x05\x04\0\x02\x01\x01\
    \x12\x04\xa1\x02\x08\x11\n\r\n\x05\x04\0\x02\x01\x03\x12\x04\xa1\x02\x14\
    \x15\n`\n\x04\x04\0\x02\x02\x12\x04\xa5\x02\x02\x18\x1aR\x20Token\x20ide\
    ntifying\x20which\x20result\x20to\x20start\x20with;\x20returned\x20by\
    \x20a\x20previous\x20list\n\x20call.\n\n\x0f\n\x05\x04\0\x02\x02\x04\x12\
    \x06\xa5\x02\x02\xa1\x02\x16\n\r\n\x05\x04\0\x02\x02\x05\x12\x04\xa5\x02\
    \x02\x08\n\r\n\x05\x04\0\x02\x02\x01\x12\x04\xa5\x02\t\x13\n\r\n\x05\x04\
    \0\x02\x02\x03\x12\x04\xa5\x02\x16\x17\n\xaa\x01\n\x04\x04\0\x02\x03\x12\
    \x04\xac\x02\x02-\x1a\x9b\x01\x20Include\x20services\x20consumed\x20by\
    \x20the\x20specified\x20consumer.\n\n\x20The\x20Google\x20Service\x20Man\
    agement\x20implementation\x20accepts\x20the\x20following\n\x20forms:\n\
    \x20-\x20project:<project_id>\n\n\x0f\n\x05\x04\0\x02\x03\x04\x12\x06\
    \xac\x02\x02\xa5\x02\x18\n\r\n\x05\x04\0\x02\x03\x05\x12\x04\xac\x02\x02\
    \x08\n\r\n\x05\x04\0\x02\x03\x01\x12\x04\xac\x02\t\x14\n\r\n\x05\x04\0\
    \x02\x03\x03\x12\x04\xac\x02\x17\x18\n\r\n\x05\x04\0\x02\x03\x08\x12\x04\
    \xac\x02\x19,\n\x0e\n\x06\x04\0\x02\x03\x08\x03\x12\x04\xac\x02\x1a+\n;\
    \n\x02\x04\x01\x12\x06\xb0\x02\0\xb6\x02\x01\x1a-\x20Response\x20message\
    \x20for\x20`ListServices`\x20method.\n\n\x0b\n\x03\x04\x01\x01\x12\x04\
    \xb0\x02\x08\x1c\nH\n\x04\x04\x01\x02\0\x12\x04\xb2\x02\x02'\x1a:\x20The\
    \x20returned\x20services\x20will\x20only\x20have\x20the\x20name\x20field\
    \x20set.\n\n\r\n\x05\x04\x01\x02\0\x04\x12\x04\xb2\x02\x02\n\n\r\n\x05\
    \x04\x01\x02\0\x06\x12\x04\xb2\x02\x0b\x19\n\r\n\x05\x04\x01\x02\0\x01\
    \x12\x04\xb2\x02\x1a\"\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\xb2\x02%&\nW\
    \n\x04\x04\x01\x02\x01\x12\x04\xb5\x02\x02\x1d\x1aI\x20Token\x20that\x20\
    can\x20be\x20passed\x20to\x20`ListServices`\x20to\x20resume\x20a\x20pagi\
    nated\x20query.\n\n\x0f\n\x05\x04\x01\x02\x01\x04\x12\x06\xb5\x02\x02\
    \xb2\x02'\n\r\n\x05\x04\x01\x02\x01\x05\x12\x04\xb5\x02\x02\x08\n\r\n\
    \x05\x04\x01\x02\x01\x01\x12\x04\xb5\x02\t\x18\n\r\n\x05\x04\x01\x02\x01\
    \x03\x12\x04\xb5\x02\x1b\x1c\n8\n\x02\x04\x02\x12\x06\xb9\x02\0\xbd\x02\
    \x01\x1a*\x20Request\x20message\x20for\x20`GetService`\x20method.\n\n\
    \x0b\n\x03\x04\x02\x01\x12\x04\xb9\x02\x08\x19\n\x98\x01\n\x04\x04\x02\
    \x02\0\x12\x04\xbc\x02\x02C\x1a\x89\x01\x20Required.\x20The\x20name\x20o\
    f\x20the\x20service.\x20\x20See\x20the\x20`ServiceManager`\x20overview\
    \x20for\x20naming\n\x20requirements.\x20\x20For\x20example:\x20`example.\
    googleapis.com`.\n\n\x0f\n\x05\x04\x02\x02\0\x04\x12\x06\xbc\x02\x02\xb9\
    \x02\x1b\n\r\n\x05\x04\x02\x02\0\x05\x12\x04\xbc\x02\x02\x08\n\r\n\x05\
    \x04\x02\x02\0\x01\x12\x04\xbc\x02\t\x15\n\r\n\x05\x04\x02\x02\0\x03\x12\
    \x04\xbc\x02\x18\x19\n\r\n\x05\x04\x02\x02\0\x08\x12\x04\xbc\x02\x1aB\n\
    \x10\n\x08\x04\x02\x02\0\x08\x9c\x08\0\x12\x04\xbc\x02\x1bA\n9\n\x02\x04\
    \x03\x12\x06\xc0\x02\0\xc3\x02\x01\x1a+\x20Request\x20message\x20for\x20\
    CreateService\x20method.\n\n\x0b\n\x03\x04\x03\x01\x12\x04\xc0\x02\x08\
    \x1c\nB\n\x04\x04\x03\x02\0\x12\x04\xc2\x02\x02F\x1a4\x20Required.\x20In\
    itial\x20values\x20for\x20the\x20service\x20resource.\n\n\x0f\n\x05\x04\
    \x03\x02\0\x04\x12\x06\xc2\x02\x02\xc0\x02\x1e\n\r\n\x05\x04\x03\x02\0\
    \x06\x12\x04\xc2\x02\x02\x10\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xc2\x02\
    \x11\x18\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\xc2\x02\x1b\x1c\n\r\n\x05\
    \x04\x03\x02\0\x08\x12\x04\xc2\x02\x1dE\n\x10\n\x08\x04\x03\x02\0\x08\
    \x9c\x08\0\x12\x04\xc2\x02\x1eD\n9\n\x02\x04\x04\x12\x06\xc6\x02\0\xca\
    \x02\x01\x1a+\x20Request\x20message\x20for\x20DeleteService\x20method.\n\
    \n\x0b\n\x03\x04\x04\x01\x12\x04\xc6\x02\x08\x1c\n\xa7\x01\n\x04\x04\x04\
    \x02\0\x12\x04\xc9\x02\x02C\x1a\x98\x01\x20Required.\x20The\x20name\x20o\
    f\x20the\x20service.\x20\x20See\x20the\x20[overview](/service-management\
    /overview)\n\x20for\x20naming\x20requirements.\x20\x20For\x20example:\
    \x20`example.googleapis.com`.\n\n\x0f\n\x05\x04\x04\x02\0\x04\x12\x06\
    \xc9\x02\x02\xc6\x02\x1e\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\xc9\x02\x02\
    \x08\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xc9\x02\t\x15\n\r\n\x05\x04\x04\
    \x02\0\x03\x12\x04\xc9\x02\x18\x19\n\r\n\x05\x04\x04\x02\0\x08\x12\x04\
    \xc9\x02\x1aB\n\x10\n\x08\x04\x04\x02\0\x08\x9c\x08\0\x12\x04\xc9\x02\
    \x1bA\n;\n\x02\x04\x05\x12\x06\xcd\x02\0\xd1\x02\x01\x1a-\x20Request\x20\
    message\x20for\x20UndeleteService\x20method.\n\n\x0b\n\x03\x04\x05\x01\
    \x12\x04\xcd\x02\x08\x1e\n\xa5\x01\n\x04\x04\x05\x02\0\x12\x04\xd0\x02\
    \x02C\x1a\x96\x01\x20Required.\x20The\x20name\x20of\x20the\x20service.\
    \x20See\x20the\x20[overview](/service-management/overview)\n\x20for\x20n\
    aming\x20requirements.\x20For\x20example:\x20`example.googleapis.com`.\n\
    \n\x0f\n\x05\x04\x05\x02\0\x04\x12\x06\xd0\x02\x02\xcd\x02\x20\n\r\n\x05\
    \x04\x05\x02\0\x05\x12\x04\xd0\x02\x02\x08\n\r\n\x05\x04\x05\x02\0\x01\
    \x12\x04\xd0\x02\t\x15\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xd0\x02\x18\
    \x19\n\r\n\x05\x04\x05\x02\0\x08\x12\x04\xd0\x02\x1aB\n\x10\n\x08\x04\
    \x05\x02\0\x08\x9c\x08\0\x12\x04\xd0\x02\x1bA\n<\n\x02\x04\x06\x12\x06\
    \xd4\x02\0\xd7\x02\x01\x1a.\x20Response\x20message\x20for\x20UndeleteSer\
    vice\x20method.\n\n\x0b\n\x03\x04\x06\x01\x12\x04\xd4\x02\x08\x1f\n)\n\
    \x04\x04\x06\x02\0\x12\x04\xd6\x02\x02\x1d\x1a\x1b\x20Revived\x20service\
    \x20resource.\n\n\x0f\n\x05\x04\x06\x02\0\x04\x12\x06\xd6\x02\x02\xd4\
    \x02!\n\r\n\x05\x04\x06\x02\0\x06\x12\x04\xd6\x02\x02\x10\n\r\n\x05\x04\
    \x06\x02\0\x01\x12\x04\xd6\x02\x11\x18\n\r\n\x05\x04\x06\x02\0\x03\x12\
    \x04\xd6\x02\x1b\x1c\n<\n\x02\x04\x07\x12\x06\xda\x02\0\xf3\x02\x01\x1a.\
    \x20Request\x20message\x20for\x20GetServiceConfig\x20method.\n\n\x0b\n\
    \x03\x04\x07\x01\x12\x04\xda\x02\x08\x1f\n\x0e\n\x04\x04\x07\x04\0\x12\
    \x06\xdb\x02\x02\xe4\x02\x03\n\r\n\x05\x04\x07\x04\0\x01\x12\x04\xdb\x02\
    \x07\x11\nH\n\x06\x04\x07\x04\0\x02\0\x12\x04\xdd\x02\x04\x0e\x1a8\x20Se\
    rver\x20response\x20includes\x20all\x20fields\x20except\x20SourceInfo.\n\
    \n\x0f\n\x07\x04\x07\x04\0\x02\0\x01\x12\x04\xdd\x02\x04\t\n\x0f\n\x07\
    \x04\x07\x04\0\x02\0\x02\x12\x04\xdd\x02\x0c\r\n\xe4\x01\n\x06\x04\x07\
    \x04\0\x02\x01\x12\x04\xe3\x02\x04\r\x1a\xd3\x01\x20Server\x20response\
    \x20includes\x20all\x20fields\x20including\x20SourceInfo.\n\x20SourceFil\
    es\x20are\x20of\x20type\x20'google.api.servicemanagement.v1.ConfigFile'\
    \n\x20and\x20are\x20only\x20available\x20for\x20configs\x20created\x20us\
    ing\x20the\n\x20SubmitConfigSource\x20method.\n\n\x0f\n\x07\x04\x07\x04\
    \0\x02\x01\x01\x12\x04\xe3\x02\x04\x08\n\x0f\n\x07\x04\x07\x04\0\x02\x01\
    \x02\x12\x04\xe3\x02\x0b\x0c\n\xa7\x01\n\x04\x04\x07\x02\0\x12\x04\xe8\
    \x02\x02C\x1a\x98\x01\x20Required.\x20The\x20name\x20of\x20the\x20servic\
    e.\x20\x20See\x20the\x20[overview](/service-management/overview)\n\x20fo\
    r\x20naming\x20requirements.\x20\x20For\x20example:\x20`example.googleap\
    is.com`.\n\n\x0f\n\x05\x04\x07\x02\0\x04\x12\x06\xe8\x02\x02\xe4\x02\x03\
    \n\r\n\x05\x04\x07\x02\0\x05\x12\x04\xe8\x02\x02\x08\n\r\n\x05\x04\x07\
    \x02\0\x01\x12\x04\xe8\x02\t\x15\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xe8\
    \x02\x18\x19\n\r\n\x05\x04\x07\x02\0\x08\x12\x04\xe8\x02\x1aB\n\x10\n\
    \x08\x04\x07\x02\0\x08\x9c\x08\0\x12\x04\xe8\x02\x1bA\n\xa5\x01\n\x04\
    \x04\x07\x02\x01\x12\x04\xee\x02\x02@\x1a\x96\x01\x20Required.\x20The\
    \x20id\x20of\x20the\x20service\x20configuration\x20resource.\n\n\x20This\
    \x20field\x20must\x20be\x20specified\x20for\x20the\x20server\x20to\x20re\
    turn\x20all\x20fields,\x20including\n\x20`SourceInfo`.\n\n\x0f\n\x05\x04\
    \x07\x02\x01\x04\x12\x06\xee\x02\x02\xe8\x02C\n\r\n\x05\x04\x07\x02\x01\
    \x05\x12\x04\xee\x02\x02\x08\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\xee\
    \x02\t\x12\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\xee\x02\x15\x16\n\r\n\
    \x05\x04\x07\x02\x01\x08\x12\x04\xee\x02\x17?\n\x10\n\x08\x04\x07\x02\
    \x01\x08\x9c\x08\0\x12\x04\xee\x02\x18>\n`\n\x04\x04\x07\x02\x02\x12\x04\
    \xf2\x02\x02\x16\x1aR\x20Specifies\x20which\x20parts\x20of\x20the\x20Ser\
    vice\x20Config\x20should\x20be\x20returned\x20in\x20the\n\x20response.\n\
    \n\x0f\n\x05\x04\x07\x02\x02\x04\x12\x06\xf2\x02\x02\xee\x02@\n\r\n\x05\
    \x04\x07\x02\x02\x06\x12\x04\xf2\x02\x02\x0c\n\r\n\x05\x04\x07\x02\x02\
    \x01\x12\x04\xf2\x02\r\x11\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\xf2\x02\
    \x14\x15\n>\n\x02\x04\x08\x12\x06\xf6\x02\0\x81\x03\x01\x1a0\x20Request\
    \x20message\x20for\x20ListServiceConfigs\x20method.\n\n\x0b\n\x03\x04\
    \x08\x01\x12\x04\xf6\x02\x08!\n\xa7\x01\n\x04\x04\x08\x02\0\x12\x04\xf9\
    \x02\x02C\x1a\x98\x01\x20Required.\x20The\x20name\x20of\x20the\x20servic\
    e.\x20\x20See\x20the\x20[overview](/service-management/overview)\n\x20fo\
    r\x20naming\x20requirements.\x20\x20For\x20example:\x20`example.googleap\
    is.com`.\n\n\x0f\n\x05\x04\x08\x02\0\x04\x12\x06\xf9\x02\x02\xf6\x02#\n\
    \r\n\x05\x04\x08\x02\0\x05\x12\x04\xf9\x02\x02\x08\n\r\n\x05\x04\x08\x02\
    \0\x01\x12\x04\xf9\x02\t\x15\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xf9\x02\
    \x18\x19\n\r\n\x05\x04\x08\x02\0\x08\x12\x04\xf9\x02\x1aB\n\x10\n\x08\
    \x04\x08\x02\0\x08\x9c\x08\0\x12\x04\xf9\x02\x1bA\n2\n\x04\x04\x08\x02\
    \x01\x12\x04\xfc\x02\x02\x18\x1a$\x20The\x20token\x20of\x20the\x20page\
    \x20to\x20retrieve.\n\n\x0f\n\x05\x04\x08\x02\x01\x04\x12\x06\xfc\x02\
    \x02\xf9\x02C\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\xfc\x02\x02\x08\n\r\
    \n\x05\x04\x08\x02\x01\x01\x12\x04\xfc\x02\t\x13\n\r\n\x05\x04\x08\x02\
    \x01\x03\x12\x04\xfc\x02\x16\x17\n\x81\x01\n\x04\x04\x08\x02\x02\x12\x04\
    \x80\x03\x02\x16\x1as\x20The\x20max\x20number\x20of\x20items\x20to\x20in\
    clude\x20in\x20the\x20response\x20list.\x20Page\x20size\x20is\x2050\n\
    \x20if\x20not\x20specified.\x20Maximum\x20value\x20is\x20100.\n\n\x0f\n\
    \x05\x04\x08\x02\x02\x04\x12\x06\x80\x03\x02\xfc\x02\x18\n\r\n\x05\x04\
    \x08\x02\x02\x05\x12\x04\x80\x03\x02\x07\n\r\n\x05\x04\x08\x02\x02\x01\
    \x12\x04\x80\x03\x08\x11\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\x80\x03\
    \x14\x15\n?\n\x02\x04\t\x12\x06\x84\x03\0\x8a\x03\x01\x1a1\x20Response\
    \x20message\x20for\x20ListServiceConfigs\x20method.\n\n\x0b\n\x03\x04\t\
    \x01\x12\x04\x84\x03\x08\"\n<\n\x04\x04\t\x02\0\x12\x04\x86\x03\x022\x1a\
    .\x20The\x20list\x20of\x20service\x20configuration\x20resources.\n\n\r\n\
    \x05\x04\t\x02\0\x04\x12\x04\x86\x03\x02\n\n\r\n\x05\x04\t\x02\0\x06\x12\
    \x04\x86\x03\x0b\x1d\n\r\n\x05\x04\t\x02\0\x01\x12\x04\x86\x03\x1e-\n\r\
    \n\x05\x04\t\x02\0\x03\x12\x04\x86\x0301\n6\n\x04\x04\t\x02\x01\x12\x04\
    \x89\x03\x02\x1d\x1a(\x20The\x20token\x20of\x20the\x20next\x20page\x20of\
    \x20results.\n\n\x0f\n\x05\x04\t\x02\x01\x04\x12\x06\x89\x03\x02\x86\x03\
    2\n\r\n\x05\x04\t\x02\x01\x05\x12\x04\x89\x03\x02\x08\n\r\n\x05\x04\t\
    \x02\x01\x01\x12\x04\x89\x03\t\x18\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\
    \x89\x03\x1b\x1c\n?\n\x02\x04\n\x12\x06\x8d\x03\0\x94\x03\x01\x1a1\x20Re\
    quest\x20message\x20for\x20CreateServiceConfig\x20method.\n\n\x0b\n\x03\
    \x04\n\x01\x12\x04\x8d\x03\x08\"\n\xa7\x01\n\x04\x04\n\x02\0\x12\x04\x90\
    \x03\x02C\x1a\x98\x01\x20Required.\x20The\x20name\x20of\x20the\x20servic\
    e.\x20\x20See\x20the\x20[overview](/service-management/overview)\n\x20fo\
    r\x20naming\x20requirements.\x20\x20For\x20example:\x20`example.googleap\
    is.com`.\n\n\x0f\n\x05\x04\n\x02\0\x04\x12\x06\x90\x03\x02\x8d\x03$\n\r\
    \n\x05\x04\n\x02\0\x05\x12\x04\x90\x03\x02\x08\n\r\n\x05\x04\n\x02\0\x01\
    \x12\x04\x90\x03\t\x15\n\r\n\x05\x04\n\x02\0\x03\x12\x04\x90\x03\x18\x19\
    \n\r\n\x05\x04\n\x02\0\x08\x12\x04\x90\x03\x1aB\n\x10\n\x08\x04\n\x02\0\
    \x08\x9c\x08\0\x12\x04\x90\x03\x1bA\n=\n\x04\x04\n\x02\x01\x12\x04\x93\
    \x03\x02Q\x1a/\x20Required.\x20The\x20service\x20configuration\x20resour\
    ce.\n\n\x0f\n\x05\x04\n\x02\x01\x04\x12\x06\x93\x03\x02\x90\x03C\n\r\n\
    \x05\x04\n\x02\x01\x06\x12\x04\x93\x03\x02\x14\n\r\n\x05\x04\n\x02\x01\
    \x01\x12\x04\x93\x03\x15#\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\x93\x03&'\
    \n\r\n\x05\x04\n\x02\x01\x08\x12\x04\x93\x03(P\n\x10\n\x08\x04\n\x02\x01\
    \x08\x9c\x08\0\x12\x04\x93\x03)O\n>\n\x02\x04\x0b\x12\x06\x97\x03\0\xa3\
    \x03\x01\x1a0\x20Request\x20message\x20for\x20SubmitConfigSource\x20meth\
    od.\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\x97\x03\x08!\n\xa7\x01\n\x04\x04\
    \x0b\x02\0\x12\x04\x9a\x03\x02C\x1a\x98\x01\x20Required.\x20The\x20name\
    \x20of\x20the\x20service.\x20\x20See\x20the\x20[overview](/service-manag\
    ement/overview)\n\x20for\x20naming\x20requirements.\x20\x20For\x20exampl\
    e:\x20`example.googleapis.com`.\n\n\x0f\n\x05\x04\x0b\x02\0\x04\x12\x06\
    \x9a\x03\x02\x97\x03#\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\x9a\x03\x02\
    \x08\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\x9a\x03\t\x15\n\r\n\x05\x04\x0b\
    \x02\0\x03\x12\x04\x9a\x03\x18\x19\n\r\n\x05\x04\x0b\x02\0\x08\x12\x04\
    \x9a\x03\x1aB\n\x10\n\x08\x04\x0b\x02\0\x08\x9c\x08\0\x12\x04\x9a\x03\
    \x1bA\nC\n\x04\x04\x0b\x02\x01\x12\x04\x9d\x03\x02J\x1a5\x20Required.\
    \x20The\x20source\x20configuration\x20for\x20the\x20service.\n\n\x0f\n\
    \x05\x04\x0b\x02\x01\x04\x12\x06\x9d\x03\x02\x9a\x03C\n\r\n\x05\x04\x0b\
    \x02\x01\x06\x12\x04\x9d\x03\x02\x0e\n\r\n\x05\x04\x0b\x02\x01\x01\x12\
    \x04\x9d\x03\x0f\x1c\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\x9d\x03\x1f\
    \x20\n\r\n\x05\x04\x0b\x02\x01\x08\x12\x04\x9d\x03!I\n\x10\n\x08\x04\x0b\
    \x02\x01\x08\x9c\x08\0\x12\x04\x9d\x03\"H\n\xd5\x01\n\x04\x04\x0b\x02\
    \x02\x12\x04\xa2\x03\x02B\x1a\xc6\x01\x20Optional.\x20If\x20set,\x20this\
    \x20will\x20result\x20in\x20the\x20generation\x20of\x20a\n\x20`google.ap\
    i.Service`\x20configuration\x20based\x20on\x20the\x20`ConfigSource`\x20p\
    rovided,\n\x20but\x20the\x20generated\x20config\x20and\x20the\x20sources\
    \x20will\x20NOT\x20be\x20persisted.\n\n\x0f\n\x05\x04\x0b\x02\x02\x04\
    \x12\x06\xa2\x03\x02\x9d\x03J\n\r\n\x05\x04\x0b\x02\x02\x05\x12\x04\xa2\
    \x03\x02\x06\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\xa2\x03\x07\x14\n\r\n\
    \x05\x04\x0b\x02\x02\x03\x12\x04\xa2\x03\x17\x18\n\r\n\x05\x04\x0b\x02\
    \x02\x08\x12\x04\xa2\x03\x19A\n\x10\n\x08\x04\x0b\x02\x02\x08\x9c\x08\0\
    \x12\x04\xa2\x03\x1a@\n?\n\x02\x04\x0c\x12\x06\xa6\x03\0\xa9\x03\x01\x1a\
    1\x20Response\x20message\x20for\x20SubmitConfigSource\x20method.\n\n\x0b\
    \n\x03\x04\x0c\x01\x12\x04\xa6\x03\x08\"\n4\n\x04\x04\x0c\x02\0\x12\x04\
    \xa8\x03\x02(\x1a&\x20The\x20generated\x20service\x20configuration.\n\n\
    \x0f\n\x05\x04\x0c\x02\0\x04\x12\x06\xa8\x03\x02\xa6\x03$\n\r\n\x05\x04\
    \x0c\x02\0\x06\x12\x04\xa8\x03\x02\x14\n\r\n\x05\x04\x0c\x02\0\x01\x12\
    \x04\xa8\x03\x15#\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xa8\x03&'\n:\n\x02\
    \x04\r\x12\x06\xac\x03\0\xb3\x03\x01\x1a,\x20Request\x20message\x20for\
    \x20'CreateServiceRollout'\n\n\x0b\n\x03\x04\r\x01\x12\x04\xac\x03\x08#\
    \n\xa7\x01\n\x04\x04\r\x02\0\x12\x04\xaf\x03\x02C\x1a\x98\x01\x20Require\
    d.\x20The\x20name\x20of\x20the\x20service.\x20\x20See\x20the\x20[overvie\
    w](/service-management/overview)\n\x20for\x20naming\x20requirements.\x20\
    \x20For\x20example:\x20`example.googleapis.com`.\n\n\x0f\n\x05\x04\r\x02\
    \0\x04\x12\x06\xaf\x03\x02\xac\x03%\n\r\n\x05\x04\r\x02\0\x05\x12\x04\
    \xaf\x03\x02\x08\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xaf\x03\t\x15\n\r\n\
    \x05\x04\r\x02\0\x03\x12\x04\xaf\x03\x18\x19\n\r\n\x05\x04\r\x02\0\x08\
    \x12\x04\xaf\x03\x1aB\n\x10\n\x08\x04\r\x02\0\x08\x9c\x08\0\x12\x04\xaf\
    \x03\x1bA\nX\n\x04\x04\r\x02\x01\x12\x04\xb2\x03\x02?\x1aJ\x20Required.\
    \x20The\x20rollout\x20resource.\x20The\x20`service_name`\x20field\x20is\
    \x20output\x20only.\n\n\x0f\n\x05\x04\r\x02\x01\x04\x12\x06\xb2\x03\x02\
    \xaf\x03C\n\r\n\x05\x04\r\x02\x01\x06\x12\x04\xb2\x03\x02\t\n\r\n\x05\
    \x04\r\x02\x01\x01\x12\x04\xb2\x03\n\x11\n\r\n\x05\x04\r\x02\x01\x03\x12\
    \x04\xb2\x03\x14\x15\n\r\n\x05\x04\r\x02\x01\x08\x12\x04\xb2\x03\x16>\n\
    \x10\n\x08\x04\r\x02\x01\x08\x9c\x08\0\x12\x04\xb2\x03\x17=\n9\n\x02\x04\
    \x0e\x12\x06\xb6\x03\0\xcb\x03\x01\x1a+\x20Request\x20message\x20for\x20\
    'ListServiceRollouts'\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\xb6\x03\x08\"\n\
    \xa7\x01\n\x04\x04\x0e\x02\0\x12\x04\xb9\x03\x02C\x1a\x98\x01\x20Require\
    d.\x20The\x20name\x20of\x20the\x20service.\x20\x20See\x20the\x20[overvie\
    w](/service-management/overview)\n\x20for\x20naming\x20requirements.\x20\
    \x20For\x20example:\x20`example.googleapis.com`.\n\n\x0f\n\x05\x04\x0e\
    \x02\0\x04\x12\x06\xb9\x03\x02\xb6\x03$\n\r\n\x05\x04\x0e\x02\0\x05\x12\
    \x04\xb9\x03\x02\x08\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xb9\x03\t\x15\n\
    \r\n\x05\x04\x0e\x02\0\x03\x12\x04\xb9\x03\x18\x19\n\r\n\x05\x04\x0e\x02\
    \0\x08\x12\x04\xb9\x03\x1aB\n\x10\n\x08\x04\x0e\x02\0\x08\x9c\x08\0\x12\
    \x04\xb9\x03\x1bA\n2\n\x04\x04\x0e\x02\x01\x12\x04\xbc\x03\x02\x18\x1a$\
    \x20The\x20token\x20of\x20the\x20page\x20to\x20retrieve.\n\n\x0f\n\x05\
    \x04\x0e\x02\x01\x04\x12\x06\xbc\x03\x02\xb9\x03C\n\r\n\x05\x04\x0e\x02\
    \x01\x05\x12\x04\xbc\x03\x02\x08\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\
    \xbc\x03\t\x13\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xbc\x03\x16\x17\n\
    \x81\x01\n\x04\x04\x0e\x02\x02\x12\x04\xc0\x03\x02\x16\x1as\x20The\x20ma\
    x\x20number\x20of\x20items\x20to\x20include\x20in\x20the\x20response\x20\
    list.\x20Page\x20size\x20is\x2050\n\x20if\x20not\x20specified.\x20Maximu\
    m\x20value\x20is\x20100.\n\n\x0f\n\x05\x04\x0e\x02\x02\x04\x12\x06\xc0\
    \x03\x02\xbc\x03\x18\n\r\n\x05\x04\x0e\x02\x02\x05\x12\x04\xc0\x03\x02\
    \x07\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xc0\x03\x08\x11\n\r\n\x05\x04\
    \x0e\x02\x02\x03\x12\x04\xc0\x03\x14\x15\n\xb5\x03\n\x04\x04\x0e\x02\x03\
    \x12\x04\xca\x03\x02=\x1a\xa6\x03\x20Required.\x20Use\x20`filter`\x20to\
    \x20return\x20subset\x20of\x20rollouts.\n\x20The\x20following\x20filters\
    \x20are\x20supported:\n\x20\x20\x20--\x20To\x20limit\x20the\x20results\
    \x20to\x20only\x20those\x20in\n\x20\x20\x20\x20\x20\x20[status](google.a\
    pi.servicemanagement.v1.RolloutStatus)\x20'SUCCESS',\n\x20\x20\x20\x20\
    \x20\x20use\x20filter='status=SUCCESS'\n\x20\x20\x20--\x20To\x20limit\
    \x20the\x20results\x20to\x20those\x20in\n\x20\x20\x20\x20\x20\x20[status\
    ](google.api.servicemanagement.v1.RolloutStatus)\x20'CANCELLED'\n\x20\
    \x20\x20\x20\x20\x20or\x20'FAILED',\x20use\x20filter='status=CANCELLED\
    \x20OR\x20status=FAILED'\n\n\x0f\n\x05\x04\x0e\x02\x03\x04\x12\x06\xca\
    \x03\x02\xc0\x03\x16\n\r\n\x05\x04\x0e\x02\x03\x05\x12\x04\xca\x03\x02\
    \x08\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\xca\x03\t\x0f\n\r\n\x05\x04\
    \x0e\x02\x03\x03\x12\x04\xca\x03\x12\x13\n\r\n\x05\x04\x0e\x02\x03\x08\
    \x12\x04\xca\x03\x14<\n\x10\n\x08\x04\x0e\x02\x03\x08\x9c\x08\0\x12\x04\
    \xca\x03\x15;\n@\n\x02\x04\x0f\x12\x06\xce\x03\0\xd4\x03\x01\x1a2\x20Res\
    ponse\x20message\x20for\x20ListServiceRollouts\x20method.\n\n\x0b\n\x03\
    \x04\x0f\x01\x12\x04\xce\x03\x08#\n.\n\x04\x04\x0f\x02\0\x12\x04\xd0\x03\
    \x02\x20\x1a\x20\x20The\x20list\x20of\x20rollout\x20resources.\n\n\r\n\
    \x05\x04\x0f\x02\0\x04\x12\x04\xd0\x03\x02\n\n\r\n\x05\x04\x0f\x02\0\x06\
    \x12\x04\xd0\x03\x0b\x12\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xd0\x03\x13\
    \x1b\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xd0\x03\x1e\x1f\n6\n\x04\x04\
    \x0f\x02\x01\x12\x04\xd3\x03\x02\x1d\x1a(\x20The\x20token\x20of\x20the\
    \x20next\x20page\x20of\x20results.\n\n\x0f\n\x05\x04\x0f\x02\x01\x04\x12\
    \x06\xd3\x03\x02\xd0\x03\x20\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\xd3\
    \x03\x02\x08\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\xd3\x03\t\x18\n\r\n\
    \x05\x04\x0f\x02\x01\x03\x12\x04\xd3\x03\x1b\x1c\n=\n\x02\x04\x10\x12\
    \x06\xd7\x03\0\xde\x03\x01\x1a/\x20Request\x20message\x20for\x20GetServi\
    ceRollout\x20method.\n\n\x0b\n\x03\x04\x10\x01\x12\x04\xd7\x03\x08\x20\n\
    \xa7\x01\n\x04\x04\x10\x02\0\x12\x04\xda\x03\x02C\x1a\x98\x01\x20Require\
    d.\x20The\x20name\x20of\x20the\x20service.\x20\x20See\x20the\x20[overvie\
    w](/service-management/overview)\n\x20for\x20naming\x20requirements.\x20\
    \x20For\x20example:\x20`example.googleapis.com`.\n\n\x0f\n\x05\x04\x10\
    \x02\0\x04\x12\x06\xda\x03\x02\xd7\x03\"\n\r\n\x05\x04\x10\x02\0\x05\x12\
    \x04\xda\x03\x02\x08\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xda\x03\t\x15\n\
    \r\n\x05\x04\x10\x02\0\x03\x12\x04\xda\x03\x18\x19\n\r\n\x05\x04\x10\x02\
    \0\x08\x12\x04\xda\x03\x1aB\n\x10\n\x08\x04\x10\x02\0\x08\x9c\x08\0\x12\
    \x04\xda\x03\x1bA\n9\n\x04\x04\x10\x02\x01\x12\x04\xdd\x03\x02A\x1a+\x20\
    Required.\x20The\x20id\x20of\x20the\x20rollout\x20resource.\n\n\x0f\n\
    \x05\x04\x10\x02\x01\x04\x12\x06\xdd\x03\x02\xda\x03C\n\r\n\x05\x04\x10\
    \x02\x01\x05\x12\x04\xdd\x03\x02\x08\n\r\n\x05\x04\x10\x02\x01\x01\x12\
    \x04\xdd\x03\t\x13\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xdd\x03\x16\x17\
    \n\r\n\x05\x04\x10\x02\x01\x08\x12\x04\xdd\x03\x18@\n\x10\n\x08\x04\x10\
    \x02\x01\x08\x9c\x08\0\x12\x04\xdd\x03\x19?\n9\n\x02\x04\x11\x12\x06\xe1\
    \x03\0\xf0\x03\x01\x1a+\x20Request\x20message\x20for\x20EnableService\
    \x20method.\n\n\x0b\n\x03\x04\x11\x01\x12\x04\xe1\x03\x08\x1c\n|\n\x04\
    \x04\x11\x02\0\x12\x04\xe4\x03\x02C\x1an\x20Required.\x20Name\x20of\x20t\
    he\x20service\x20to\x20enable.\x20Specifying\x20an\x20unknown\x20service\
    \x20name\x20will\n\x20cause\x20the\x20request\x20to\x20fail.\n\n\x0f\n\
    \x05\x04\x11\x02\0\x04\x12\x06\xe4\x03\x02\xe1\x03\x1e\n\r\n\x05\x04\x11\
    \x02\0\x05\x12\x04\xe4\x03\x02\x08\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\
    \xe4\x03\t\x15\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xe4\x03\x18\x19\n\r\n\
    \x05\x04\x11\x02\0\x08\x12\x04\xe4\x03\x1aB\n\x10\n\x08\x04\x11\x02\0\
    \x08\x9c\x08\0\x12\x04\xe4\x03\x1bA\n\xab\x02\n\x04\x04\x11\x02\x01\x12\
    \x04\xef\x03\x02B\x1a\x9c\x02\x20Required.\x20The\x20identity\x20of\x20c\
    onsumer\x20resource\x20which\x20service\x20enablement\x20will\x20be\n\
    \x20applied\x20to.\n\n\x20The\x20Google\x20Service\x20Management\x20impl\
    ementation\x20accepts\x20the\x20following\n\x20forms:\n\x20-\x20\"projec\
    t:<project_id>\"\n\n\x20Note:\x20this\x20is\x20made\x20compatible\x20wit\
    h\n\x20google.api.servicecontrol.v1.Operation.consumer_id.\n\n\x0f\n\x05\
    \x04\x11\x02\x01\x04\x12\x06\xef\x03\x02\xe4\x03C\n\r\n\x05\x04\x11\x02\
    \x01\x05\x12\x04\xef\x03\x02\x08\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\
    \xef\x03\t\x14\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xef\x03\x17\x18\n\r\
    \n\x05\x04\x11\x02\x01\x08\x12\x04\xef\x03\x19A\n\x10\n\x08\x04\x11\x02\
    \x01\x08\x9c\x08\0\x12\x04\xef\x03\x1a@\n;\n\x02\x04\x12\x12\x06\xf3\x03\
    \0\xf5\x03\x01\x1a-\x20Operation\x20payload\x20for\x20EnableService\x20m\
    ethod.\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xf3\x03\x08\x1d\n:\n\x02\x04\
    \x13\x12\x06\xf8\x03\0\x87\x04\x01\x1a,\x20Request\x20message\x20for\x20\
    DisableService\x20method.\n\n\x0b\n\x03\x04\x13\x01\x12\x04\xf8\x03\x08\
    \x1d\n}\n\x04\x04\x13\x02\0\x12\x04\xfb\x03\x02C\x1ao\x20Required.\x20Na\
    me\x20of\x20the\x20service\x20to\x20disable.\x20Specifying\x20an\x20unkn\
    own\x20service\x20name\n\x20will\x20cause\x20the\x20request\x20to\x20fai\
    l.\n\n\x0f\n\x05\x04\x13\x02\0\x04\x12\x06\xfb\x03\x02\xf8\x03\x1f\n\r\n\
    \x05\x04\x13\x02\0\x05\x12\x04\xfb\x03\x02\x08\n\r\n\x05\x04\x13\x02\0\
    \x01\x12\x04\xfb\x03\t\x15\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xfb\x03\
    \x18\x19\n\r\n\x05\x04\x13\x02\0\x08\x12\x04\xfb\x03\x1aB\n\x10\n\x08\
    \x04\x13\x02\0\x08\x9c\x08\0\x12\x04\xfb\x03\x1bA\n\xac\x02\n\x04\x04\
    \x13\x02\x01\x12\x04\x86\x04\x02B\x1a\x9d\x02\x20Required.\x20The\x20ide\
    ntity\x20of\x20consumer\x20resource\x20which\x20service\x20disablement\
    \x20will\x20be\n\x20applied\x20to.\n\n\x20The\x20Google\x20Service\x20Ma\
    nagement\x20implementation\x20accepts\x20the\x20following\n\x20forms:\n\
    \x20-\x20\"project:<project_id>\"\n\n\x20Note:\x20this\x20is\x20made\x20\
    compatible\x20with\n\x20google.api.servicecontrol.v1.Operation.consumer_\
    id.\n\n\x0f\n\x05\x04\x13\x02\x01\x04\x12\x06\x86\x04\x02\xfb\x03C\n\r\n\
    \x05\x04\x13\x02\x01\x05\x12\x04\x86\x04\x02\x08\n\r\n\x05\x04\x13\x02\
    \x01\x01\x12\x04\x86\x04\t\x14\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\x86\
    \x04\x17\x18\n\r\n\x05\x04\x13\x02\x01\x08\x12\x04\x86\x04\x19A\n\x10\n\
    \x08\x04\x13\x02\x01\x08\x9c\x08\0\x12\x04\x86\x04\x1a@\n<\n\x02\x04\x14\
    \x12\x06\x8a\x04\0\x8c\x04\x01\x1a.\x20Operation\x20payload\x20for\x20Di\
    sableService\x20method.\n\n\x0b\n\x03\x04\x14\x01\x12\x04\x8a\x04\x08\
    \x1e\n@\n\x02\x04\x15\x12\x06\x8f\x04\0\x9d\x04\x01\x1a2\x20Request\x20m\
    essage\x20for\x20GenerateConfigReport\x20method.\n\n\x0b\n\x03\x04\x15\
    \x01\x12\x04\x8f\x04\x08#\n\xf2\x02\n\x04\x04\x15\x02\0\x12\x04\x95\x04\
    \x02N\x1a\xe3\x02\x20Required.\x20Service\x20configuration\x20for\x20whi\
    ch\x20we\x20want\x20to\x20generate\x20the\x20report.\n\x20For\x20this\
    \x20version\x20of\x20API,\x20the\x20supported\x20types\x20are\n\x20[goog\
    le.api.servicemanagement.v1.ConfigRef][google.api.servicemanagement.v1.C\
    onfigRef],\n\x20[google.api.servicemanagement.v1.ConfigSource][google.ap\
    i.servicemanagement.v1.ConfigSource],\n\x20and\x20[google.api.Service][g\
    oogle.api.Service]\n\n\x0f\n\x05\x04\x15\x02\0\x04\x12\x06\x95\x04\x02\
    \x8f\x04%\n\r\n\x05\x04\x15\x02\0\x06\x12\x04\x95\x04\x02\x15\n\r\n\x05\
    \x04\x15\x02\0\x01\x12\x04\x95\x04\x16\x20\n\r\n\x05\x04\x15\x02\0\x03\
    \x12\x04\x95\x04#$\n\r\n\x05\x04\x15\x02\0\x08\x12\x04\x95\x04%M\n\x10\n\
    \x08\x04\x15\x02\0\x08\x9c\x08\0\x12\x04\x95\x04&L\n\xf3\x02\n\x04\x04\
    \x15\x02\x01\x12\x04\x9c\x04\x02N\x1a\xe4\x02\x20Optional.\x20Service\
    \x20configuration\x20against\x20which\x20the\x20comparison\x20will\x20be\
    \x20done.\n\x20For\x20this\x20version\x20of\x20API,\x20the\x20supported\
    \x20types\x20are\n\x20[google.api.servicemanagement.v1.ConfigRef][google\
    .api.servicemanagement.v1.ConfigRef],\n\x20[google.api.servicemanagement\
    .v1.ConfigSource][google.api.servicemanagement.v1.ConfigSource],\n\x20an\
    d\x20[google.api.Service][google.api.Service]\n\n\x0f\n\x05\x04\x15\x02\
    \x01\x04\x12\x06\x9c\x04\x02\x95\x04N\n\r\n\x05\x04\x15\x02\x01\x06\x12\
    \x04\x9c\x04\x02\x15\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\x9c\x04\x16\
    \x20\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\x9c\x04#$\n\r\n\x05\x04\x15\
    \x02\x01\x08\x12\x04\x9c\x04%M\n\x10\n\x08\x04\x15\x02\x01\x08\x9c\x08\0\
    \x12\x04\x9c\x04&L\nA\n\x02\x04\x16\x12\x06\xa0\x04\0\xaf\x04\x01\x1a3\
    \x20Response\x20message\x20for\x20GenerateConfigReport\x20method.\n\n\
    \x0b\n\x03\x04\x16\x01\x12\x04\xa0\x04\x08$\n;\n\x04\x04\x16\x02\0\x12\
    \x04\xa2\x04\x02\x1a\x1a-\x20Name\x20of\x20the\x20service\x20this\x20rep\
    ort\x20belongs\x20to.\n\n\x0f\n\x05\x04\x16\x02\0\x04\x12\x06\xa2\x04\
    \x02\xa0\x04&\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\xa2\x04\x02\x08\n\r\n\
    \x05\x04\x16\x02\0\x01\x12\x04\xa2\x04\t\x15\n\r\n\x05\x04\x16\x02\0\x03\
    \x12\x04\xa2\x04\x18\x19\nG\n\x04\x04\x16\x02\x01\x12\x04\xa5\x04\x02\
    \x10\x1a9\x20ID\x20of\x20the\x20service\x20configuration\x20this\x20repo\
    rt\x20belongs\x20to.\n\n\x0f\n\x05\x04\x16\x02\x01\x04\x12\x06\xa5\x04\
    \x02\xa2\x04\x1a\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\xa5\x04\x02\x08\n\
    \r\n\x05\x04\x16\x02\x01\x01\x12\x04\xa5\x04\t\x0b\n\r\n\x05\x04\x16\x02\
    \x01\x03\x12\x04\xa5\x04\x0e\x0f\nk\n\x04\x04\x16\x02\x02\x12\x04\xa9\
    \x04\x02+\x1a]\x20list\x20of\x20ChangeReport,\x20each\x20corresponding\
    \x20to\x20comparison\x20between\x20two\n\x20service\x20configurations.\n\
    \n\r\n\x05\x04\x16\x02\x02\x04\x12\x04\xa9\x04\x02\n\n\r\n\x05\x04\x16\
    \x02\x02\x06\x12\x04\xa9\x04\x0b\x17\n\r\n\x05\x04\x16\x02\x02\x01\x12\
    \x04\xa9\x04\x18&\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\xa9\x04)*\ni\n\
    \x04\x04\x16\x02\x03\x12\x04\xae\x04\x02&\x1a[\x20Errors\x20/\x20Linter\
    \x20warnings\x20associated\x20with\x20the\x20service\x20definition\x20th\
    is\n\x20report\n\x20belongs\x20to.\n\n\r\n\x05\x04\x16\x02\x03\x04\x12\
    \x04\xae\x04\x02\n\n\r\n\x05\x04\x16\x02\x03\x06\x12\x04\xae\x04\x0b\x15\
    \n\r\n\x05\x04\x16\x02\x03\x01\x12\x04\xae\x04\x16!\n\r\n\x05\x04\x16\
    \x02\x03\x03\x12\x04\xae\x04$%b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
