// This file is generated by rust-protobuf 2.23.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/api/servicemanagement/v1/servicemanager.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_23_0;

#[derive(PartialEq,Clone,Default)]
pub struct ListServicesRequest {
    // message fields
    pub producer_project_id: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    pub consumer_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListServicesRequest {
    fn default() -> &'a ListServicesRequest {
        <ListServicesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListServicesRequest {
    pub fn new() -> ListServicesRequest {
        ::std::default::Default::default()
    }

    // string producer_project_id = 1;


    pub fn get_producer_project_id(&self) -> &str {
        &self.producer_project_id
    }
    pub fn clear_producer_project_id(&mut self) {
        self.producer_project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_producer_project_id(&mut self, v: ::std::string::String) {
        self.producer_project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_producer_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.producer_project_id
    }

    // Take field
    pub fn take_producer_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.producer_project_id, ::std::string::String::new())
    }

    // int32 page_size = 5;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 6;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    // string consumer_id = 7;


    pub fn get_consumer_id(&self) -> &str {
        &self.consumer_id
    }
    pub fn clear_consumer_id(&mut self) {
        self.consumer_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: ::std::string::String) {
        self.consumer_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consumer_id(&mut self) -> &mut ::std::string::String {
        &mut self.consumer_id
    }

    // Take field
    pub fn take_consumer_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.consumer_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListServicesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.producer_project_id)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.consumer_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.producer_project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.producer_project_id);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(5, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.page_token);
        }
        if !self.consumer_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.consumer_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.producer_project_id.is_empty() {
            os.write_string(1, &self.producer_project_id)?;
        }
        if self.page_size != 0 {
            os.write_int32(5, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(6, &self.page_token)?;
        }
        if !self.consumer_id.is_empty() {
            os.write_string(7, &self.consumer_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListServicesRequest {
        ListServicesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "producer_project_id",
                |m: &ListServicesRequest| { &m.producer_project_id },
                |m: &mut ListServicesRequest| { &mut m.producer_project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListServicesRequest| { &m.page_size },
                |m: &mut ListServicesRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListServicesRequest| { &m.page_token },
                |m: &mut ListServicesRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "consumer_id",
                |m: &ListServicesRequest| { &m.consumer_id },
                |m: &mut ListServicesRequest| { &mut m.consumer_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListServicesRequest>(
                "ListServicesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListServicesRequest {
        static instance: ::protobuf::rt::LazyV2<ListServicesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListServicesRequest::new)
    }
}

impl ::protobuf::Clear for ListServicesRequest {
    fn clear(&mut self) {
        self.producer_project_id.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.consumer_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListServicesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListServicesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListServicesResponse {
    // message fields
    pub services: ::protobuf::RepeatedField<super::resources::ManagedService>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListServicesResponse {
    fn default() -> &'a ListServicesResponse {
        <ListServicesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListServicesResponse {
    pub fn new() -> ListServicesResponse {
        ::std::default::Default::default()
    }

    // repeated .google.api.servicemanagement.v1.ManagedService services = 1;


    pub fn get_services(&self) -> &[super::resources::ManagedService] {
        &self.services
    }
    pub fn clear_services(&mut self) {
        self.services.clear();
    }

    // Param is passed by value, moved
    pub fn set_services(&mut self, v: ::protobuf::RepeatedField<super::resources::ManagedService>) {
        self.services = v;
    }

    // Mutable pointer to the field.
    pub fn mut_services(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ManagedService> {
        &mut self.services
    }

    // Take field
    pub fn take_services(&mut self) -> ::protobuf::RepeatedField<super::resources::ManagedService> {
        ::std::mem::replace(&mut self.services, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListServicesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.services {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.services)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.services {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.services {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListServicesResponse {
        ListServicesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ManagedService>>(
                "services",
                |m: &ListServicesResponse| { &m.services },
                |m: &mut ListServicesResponse| { &mut m.services },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListServicesResponse| { &m.next_page_token },
                |m: &mut ListServicesResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListServicesResponse>(
                "ListServicesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListServicesResponse {
        static instance: ::protobuf::rt::LazyV2<ListServicesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListServicesResponse::new)
    }
}

impl ::protobuf::Clear for ListServicesResponse {
    fn clear(&mut self) {
        self.services.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListServicesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListServicesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetServiceRequest {
    // message fields
    pub service_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetServiceRequest {
    fn default() -> &'a GetServiceRequest {
        <GetServiceRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetServiceRequest {
    pub fn new() -> GetServiceRequest {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetServiceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetServiceRequest {
        GetServiceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &GetServiceRequest| { &m.service_name },
                |m: &mut GetServiceRequest| { &mut m.service_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetServiceRequest>(
                "GetServiceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetServiceRequest {
        static instance: ::protobuf::rt::LazyV2<GetServiceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetServiceRequest::new)
    }
}

impl ::protobuf::Clear for GetServiceRequest {
    fn clear(&mut self) {
        self.service_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetServiceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetServiceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateServiceRequest {
    // message fields
    pub service: ::protobuf::SingularPtrField<super::resources::ManagedService>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateServiceRequest {
    fn default() -> &'a CreateServiceRequest {
        <CreateServiceRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateServiceRequest {
    pub fn new() -> CreateServiceRequest {
        ::std::default::Default::default()
    }

    // .google.api.servicemanagement.v1.ManagedService service = 1;


    pub fn get_service(&self) -> &super::resources::ManagedService {
        self.service.as_ref().unwrap_or_else(|| <super::resources::ManagedService as ::protobuf::Message>::default_instance())
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    pub fn has_service(&self) -> bool {
        self.service.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: super::resources::ManagedService) {
        self.service = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut super::resources::ManagedService {
        if self.service.is_none() {
            self.service.set_default();
        }
        self.service.as_mut().unwrap()
    }

    // Take field
    pub fn take_service(&mut self) -> super::resources::ManagedService {
        self.service.take().unwrap_or_else(|| super::resources::ManagedService::new())
    }
}

impl ::protobuf::Message for CreateServiceRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.service {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.service)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.service.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateServiceRequest {
        CreateServiceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ManagedService>>(
                "service",
                |m: &CreateServiceRequest| { &m.service },
                |m: &mut CreateServiceRequest| { &mut m.service },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateServiceRequest>(
                "CreateServiceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateServiceRequest {
        static instance: ::protobuf::rt::LazyV2<CreateServiceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateServiceRequest::new)
    }
}

impl ::protobuf::Clear for CreateServiceRequest {
    fn clear(&mut self) {
        self.service.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateServiceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateServiceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteServiceRequest {
    // message fields
    pub service_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteServiceRequest {
    fn default() -> &'a DeleteServiceRequest {
        <DeleteServiceRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteServiceRequest {
    pub fn new() -> DeleteServiceRequest {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteServiceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteServiceRequest {
        DeleteServiceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &DeleteServiceRequest| { &m.service_name },
                |m: &mut DeleteServiceRequest| { &mut m.service_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteServiceRequest>(
                "DeleteServiceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteServiceRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteServiceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteServiceRequest::new)
    }
}

impl ::protobuf::Clear for DeleteServiceRequest {
    fn clear(&mut self) {
        self.service_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteServiceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteServiceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UndeleteServiceRequest {
    // message fields
    pub service_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UndeleteServiceRequest {
    fn default() -> &'a UndeleteServiceRequest {
        <UndeleteServiceRequest as ::protobuf::Message>::default_instance()
    }
}

impl UndeleteServiceRequest {
    pub fn new() -> UndeleteServiceRequest {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UndeleteServiceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UndeleteServiceRequest {
        UndeleteServiceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &UndeleteServiceRequest| { &m.service_name },
                |m: &mut UndeleteServiceRequest| { &mut m.service_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UndeleteServiceRequest>(
                "UndeleteServiceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UndeleteServiceRequest {
        static instance: ::protobuf::rt::LazyV2<UndeleteServiceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UndeleteServiceRequest::new)
    }
}

impl ::protobuf::Clear for UndeleteServiceRequest {
    fn clear(&mut self) {
        self.service_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UndeleteServiceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UndeleteServiceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UndeleteServiceResponse {
    // message fields
    pub service: ::protobuf::SingularPtrField<super::resources::ManagedService>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UndeleteServiceResponse {
    fn default() -> &'a UndeleteServiceResponse {
        <UndeleteServiceResponse as ::protobuf::Message>::default_instance()
    }
}

impl UndeleteServiceResponse {
    pub fn new() -> UndeleteServiceResponse {
        ::std::default::Default::default()
    }

    // .google.api.servicemanagement.v1.ManagedService service = 1;


    pub fn get_service(&self) -> &super::resources::ManagedService {
        self.service.as_ref().unwrap_or_else(|| <super::resources::ManagedService as ::protobuf::Message>::default_instance())
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    pub fn has_service(&self) -> bool {
        self.service.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: super::resources::ManagedService) {
        self.service = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut super::resources::ManagedService {
        if self.service.is_none() {
            self.service.set_default();
        }
        self.service.as_mut().unwrap()
    }

    // Take field
    pub fn take_service(&mut self) -> super::resources::ManagedService {
        self.service.take().unwrap_or_else(|| super::resources::ManagedService::new())
    }
}

impl ::protobuf::Message for UndeleteServiceResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.service {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.service)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.service.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UndeleteServiceResponse {
        UndeleteServiceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ManagedService>>(
                "service",
                |m: &UndeleteServiceResponse| { &m.service },
                |m: &mut UndeleteServiceResponse| { &mut m.service },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UndeleteServiceResponse>(
                "UndeleteServiceResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UndeleteServiceResponse {
        static instance: ::protobuf::rt::LazyV2<UndeleteServiceResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UndeleteServiceResponse::new)
    }
}

impl ::protobuf::Clear for UndeleteServiceResponse {
    fn clear(&mut self) {
        self.service.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UndeleteServiceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UndeleteServiceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetServiceConfigRequest {
    // message fields
    pub service_name: ::std::string::String,
    pub config_id: ::std::string::String,
    pub view: GetServiceConfigRequest_ConfigView,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetServiceConfigRequest {
    fn default() -> &'a GetServiceConfigRequest {
        <GetServiceConfigRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetServiceConfigRequest {
    pub fn new() -> GetServiceConfigRequest {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }

    // string config_id = 2;


    pub fn get_config_id(&self) -> &str {
        &self.config_id
    }
    pub fn clear_config_id(&mut self) {
        self.config_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_config_id(&mut self, v: ::std::string::String) {
        self.config_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config_id(&mut self) -> &mut ::std::string::String {
        &mut self.config_id
    }

    // Take field
    pub fn take_config_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.config_id, ::std::string::String::new())
    }

    // .google.api.servicemanagement.v1.GetServiceConfigRequest.ConfigView view = 3;


    pub fn get_view(&self) -> GetServiceConfigRequest_ConfigView {
        self.view
    }
    pub fn clear_view(&mut self) {
        self.view = GetServiceConfigRequest_ConfigView::BASIC;
    }

    // Param is passed by value, moved
    pub fn set_view(&mut self, v: GetServiceConfigRequest_ConfigView) {
        self.view = v;
    }
}

impl ::protobuf::Message for GetServiceConfigRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.config_id)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.view, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        if !self.config_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.config_id);
        }
        if self.view != GetServiceConfigRequest_ConfigView::BASIC {
            my_size += ::protobuf::rt::enum_size(3, self.view);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        if !self.config_id.is_empty() {
            os.write_string(2, &self.config_id)?;
        }
        if self.view != GetServiceConfigRequest_ConfigView::BASIC {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.view))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetServiceConfigRequest {
        GetServiceConfigRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &GetServiceConfigRequest| { &m.service_name },
                |m: &mut GetServiceConfigRequest| { &mut m.service_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "config_id",
                |m: &GetServiceConfigRequest| { &m.config_id },
                |m: &mut GetServiceConfigRequest| { &mut m.config_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GetServiceConfigRequest_ConfigView>>(
                "view",
                |m: &GetServiceConfigRequest| { &m.view },
                |m: &mut GetServiceConfigRequest| { &mut m.view },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetServiceConfigRequest>(
                "GetServiceConfigRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetServiceConfigRequest {
        static instance: ::protobuf::rt::LazyV2<GetServiceConfigRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetServiceConfigRequest::new)
    }
}

impl ::protobuf::Clear for GetServiceConfigRequest {
    fn clear(&mut self) {
        self.service_name.clear();
        self.config_id.clear();
        self.view = GetServiceConfigRequest_ConfigView::BASIC;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetServiceConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetServiceConfigRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GetServiceConfigRequest_ConfigView {
    BASIC = 0,
    FULL = 1,
}

impl ::protobuf::ProtobufEnum for GetServiceConfigRequest_ConfigView {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GetServiceConfigRequest_ConfigView> {
        match value {
            0 => ::std::option::Option::Some(GetServiceConfigRequest_ConfigView::BASIC),
            1 => ::std::option::Option::Some(GetServiceConfigRequest_ConfigView::FULL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GetServiceConfigRequest_ConfigView] = &[
            GetServiceConfigRequest_ConfigView::BASIC,
            GetServiceConfigRequest_ConfigView::FULL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<GetServiceConfigRequest_ConfigView>("GetServiceConfigRequest.ConfigView", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for GetServiceConfigRequest_ConfigView {
}

impl ::std::default::Default for GetServiceConfigRequest_ConfigView {
    fn default() -> Self {
        GetServiceConfigRequest_ConfigView::BASIC
    }
}

impl ::protobuf::reflect::ProtobufValue for GetServiceConfigRequest_ConfigView {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListServiceConfigsRequest {
    // message fields
    pub service_name: ::std::string::String,
    pub page_token: ::std::string::String,
    pub page_size: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListServiceConfigsRequest {
    fn default() -> &'a ListServiceConfigsRequest {
        <ListServiceConfigsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListServiceConfigsRequest {
    pub fn new() -> ListServiceConfigsRequest {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }

    // string page_token = 2;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    // int32 page_size = 3;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }
}

impl ::protobuf::Message for ListServiceConfigsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.page_token);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(2, &self.page_token)?;
        }
        if self.page_size != 0 {
            os.write_int32(3, self.page_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListServiceConfigsRequest {
        ListServiceConfigsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &ListServiceConfigsRequest| { &m.service_name },
                |m: &mut ListServiceConfigsRequest| { &mut m.service_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListServiceConfigsRequest| { &m.page_token },
                |m: &mut ListServiceConfigsRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListServiceConfigsRequest| { &m.page_size },
                |m: &mut ListServiceConfigsRequest| { &mut m.page_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListServiceConfigsRequest>(
                "ListServiceConfigsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListServiceConfigsRequest {
        static instance: ::protobuf::rt::LazyV2<ListServiceConfigsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListServiceConfigsRequest::new)
    }
}

impl ::protobuf::Clear for ListServiceConfigsRequest {
    fn clear(&mut self) {
        self.service_name.clear();
        self.page_token.clear();
        self.page_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListServiceConfigsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListServiceConfigsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListServiceConfigsResponse {
    // message fields
    pub service_configs: ::protobuf::RepeatedField<super::service::Service>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListServiceConfigsResponse {
    fn default() -> &'a ListServiceConfigsResponse {
        <ListServiceConfigsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListServiceConfigsResponse {
    pub fn new() -> ListServiceConfigsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.api.Service service_configs = 1;


    pub fn get_service_configs(&self) -> &[super::service::Service] {
        &self.service_configs
    }
    pub fn clear_service_configs(&mut self) {
        self.service_configs.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_configs(&mut self, v: ::protobuf::RepeatedField<super::service::Service>) {
        self.service_configs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_service_configs(&mut self) -> &mut ::protobuf::RepeatedField<super::service::Service> {
        &mut self.service_configs
    }

    // Take field
    pub fn take_service_configs(&mut self) -> ::protobuf::RepeatedField<super::service::Service> {
        ::std::mem::replace(&mut self.service_configs, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListServiceConfigsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.service_configs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.service_configs)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.service_configs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.service_configs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListServiceConfigsResponse {
        ListServiceConfigsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::service::Service>>(
                "service_configs",
                |m: &ListServiceConfigsResponse| { &m.service_configs },
                |m: &mut ListServiceConfigsResponse| { &mut m.service_configs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListServiceConfigsResponse| { &m.next_page_token },
                |m: &mut ListServiceConfigsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListServiceConfigsResponse>(
                "ListServiceConfigsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListServiceConfigsResponse {
        static instance: ::protobuf::rt::LazyV2<ListServiceConfigsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListServiceConfigsResponse::new)
    }
}

impl ::protobuf::Clear for ListServiceConfigsResponse {
    fn clear(&mut self) {
        self.service_configs.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListServiceConfigsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListServiceConfigsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateServiceConfigRequest {
    // message fields
    pub service_name: ::std::string::String,
    pub service_config: ::protobuf::SingularPtrField<super::service::Service>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateServiceConfigRequest {
    fn default() -> &'a CreateServiceConfigRequest {
        <CreateServiceConfigRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateServiceConfigRequest {
    pub fn new() -> CreateServiceConfigRequest {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }

    // .google.api.Service service_config = 2;


    pub fn get_service_config(&self) -> &super::service::Service {
        self.service_config.as_ref().unwrap_or_else(|| <super::service::Service as ::protobuf::Message>::default_instance())
    }
    pub fn clear_service_config(&mut self) {
        self.service_config.clear();
    }

    pub fn has_service_config(&self) -> bool {
        self.service_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_config(&mut self, v: super::service::Service) {
        self.service_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_config(&mut self) -> &mut super::service::Service {
        if self.service_config.is_none() {
            self.service_config.set_default();
        }
        self.service_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_service_config(&mut self) -> super::service::Service {
        self.service_config.take().unwrap_or_else(|| super::service::Service::new())
    }
}

impl ::protobuf::Message for CreateServiceConfigRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.service_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.service_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        if let Some(ref v) = self.service_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        if let Some(ref v) = self.service_config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateServiceConfigRequest {
        CreateServiceConfigRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &CreateServiceConfigRequest| { &m.service_name },
                |m: &mut CreateServiceConfigRequest| { &mut m.service_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::service::Service>>(
                "service_config",
                |m: &CreateServiceConfigRequest| { &m.service_config },
                |m: &mut CreateServiceConfigRequest| { &mut m.service_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateServiceConfigRequest>(
                "CreateServiceConfigRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateServiceConfigRequest {
        static instance: ::protobuf::rt::LazyV2<CreateServiceConfigRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateServiceConfigRequest::new)
    }
}

impl ::protobuf::Clear for CreateServiceConfigRequest {
    fn clear(&mut self) {
        self.service_name.clear();
        self.service_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateServiceConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateServiceConfigRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubmitConfigSourceRequest {
    // message fields
    pub service_name: ::std::string::String,
    pub config_source: ::protobuf::SingularPtrField<super::resources::ConfigSource>,
    pub validate_only: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubmitConfigSourceRequest {
    fn default() -> &'a SubmitConfigSourceRequest {
        <SubmitConfigSourceRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubmitConfigSourceRequest {
    pub fn new() -> SubmitConfigSourceRequest {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }

    // .google.api.servicemanagement.v1.ConfigSource config_source = 2;


    pub fn get_config_source(&self) -> &super::resources::ConfigSource {
        self.config_source.as_ref().unwrap_or_else(|| <super::resources::ConfigSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config_source(&mut self) {
        self.config_source.clear();
    }

    pub fn has_config_source(&self) -> bool {
        self.config_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config_source(&mut self, v: super::resources::ConfigSource) {
        self.config_source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config_source(&mut self) -> &mut super::resources::ConfigSource {
        if self.config_source.is_none() {
            self.config_source.set_default();
        }
        self.config_source.as_mut().unwrap()
    }

    // Take field
    pub fn take_config_source(&mut self) -> super::resources::ConfigSource {
        self.config_source.take().unwrap_or_else(|| super::resources::ConfigSource::new())
    }

    // bool validate_only = 3;


    pub fn get_validate_only(&self) -> bool {
        self.validate_only
    }
    pub fn clear_validate_only(&mut self) {
        self.validate_only = false;
    }

    // Param is passed by value, moved
    pub fn set_validate_only(&mut self, v: bool) {
        self.validate_only = v;
    }
}

impl ::protobuf::Message for SubmitConfigSourceRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.config_source {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config_source)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.validate_only = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        if let Some(ref v) = self.config_source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.validate_only != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        if let Some(ref v) = self.config_source.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.validate_only != false {
            os.write_bool(3, self.validate_only)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubmitConfigSourceRequest {
        SubmitConfigSourceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &SubmitConfigSourceRequest| { &m.service_name },
                |m: &mut SubmitConfigSourceRequest| { &mut m.service_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ConfigSource>>(
                "config_source",
                |m: &SubmitConfigSourceRequest| { &m.config_source },
                |m: &mut SubmitConfigSourceRequest| { &mut m.config_source },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "validate_only",
                |m: &SubmitConfigSourceRequest| { &m.validate_only },
                |m: &mut SubmitConfigSourceRequest| { &mut m.validate_only },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubmitConfigSourceRequest>(
                "SubmitConfigSourceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubmitConfigSourceRequest {
        static instance: ::protobuf::rt::LazyV2<SubmitConfigSourceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubmitConfigSourceRequest::new)
    }
}

impl ::protobuf::Clear for SubmitConfigSourceRequest {
    fn clear(&mut self) {
        self.service_name.clear();
        self.config_source.clear();
        self.validate_only = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubmitConfigSourceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubmitConfigSourceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubmitConfigSourceResponse {
    // message fields
    pub service_config: ::protobuf::SingularPtrField<super::service::Service>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubmitConfigSourceResponse {
    fn default() -> &'a SubmitConfigSourceResponse {
        <SubmitConfigSourceResponse as ::protobuf::Message>::default_instance()
    }
}

impl SubmitConfigSourceResponse {
    pub fn new() -> SubmitConfigSourceResponse {
        ::std::default::Default::default()
    }

    // .google.api.Service service_config = 1;


    pub fn get_service_config(&self) -> &super::service::Service {
        self.service_config.as_ref().unwrap_or_else(|| <super::service::Service as ::protobuf::Message>::default_instance())
    }
    pub fn clear_service_config(&mut self) {
        self.service_config.clear();
    }

    pub fn has_service_config(&self) -> bool {
        self.service_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_config(&mut self, v: super::service::Service) {
        self.service_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_config(&mut self) -> &mut super::service::Service {
        if self.service_config.is_none() {
            self.service_config.set_default();
        }
        self.service_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_service_config(&mut self) -> super::service::Service {
        self.service_config.take().unwrap_or_else(|| super::service::Service::new())
    }
}

impl ::protobuf::Message for SubmitConfigSourceResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.service_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.service_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.service_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.service_config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubmitConfigSourceResponse {
        SubmitConfigSourceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::service::Service>>(
                "service_config",
                |m: &SubmitConfigSourceResponse| { &m.service_config },
                |m: &mut SubmitConfigSourceResponse| { &mut m.service_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubmitConfigSourceResponse>(
                "SubmitConfigSourceResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubmitConfigSourceResponse {
        static instance: ::protobuf::rt::LazyV2<SubmitConfigSourceResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubmitConfigSourceResponse::new)
    }
}

impl ::protobuf::Clear for SubmitConfigSourceResponse {
    fn clear(&mut self) {
        self.service_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubmitConfigSourceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubmitConfigSourceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateServiceRolloutRequest {
    // message fields
    pub service_name: ::std::string::String,
    pub rollout: ::protobuf::SingularPtrField<super::resources::Rollout>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateServiceRolloutRequest {
    fn default() -> &'a CreateServiceRolloutRequest {
        <CreateServiceRolloutRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateServiceRolloutRequest {
    pub fn new() -> CreateServiceRolloutRequest {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }

    // .google.api.servicemanagement.v1.Rollout rollout = 2;


    pub fn get_rollout(&self) -> &super::resources::Rollout {
        self.rollout.as_ref().unwrap_or_else(|| <super::resources::Rollout as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rollout(&mut self) {
        self.rollout.clear();
    }

    pub fn has_rollout(&self) -> bool {
        self.rollout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollout(&mut self, v: super::resources::Rollout) {
        self.rollout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollout(&mut self) -> &mut super::resources::Rollout {
        if self.rollout.is_none() {
            self.rollout.set_default();
        }
        self.rollout.as_mut().unwrap()
    }

    // Take field
    pub fn take_rollout(&mut self) -> super::resources::Rollout {
        self.rollout.take().unwrap_or_else(|| super::resources::Rollout::new())
    }
}

impl ::protobuf::Message for CreateServiceRolloutRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.rollout {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rollout)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        if let Some(ref v) = self.rollout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        if let Some(ref v) = self.rollout.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateServiceRolloutRequest {
        CreateServiceRolloutRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &CreateServiceRolloutRequest| { &m.service_name },
                |m: &mut CreateServiceRolloutRequest| { &mut m.service_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Rollout>>(
                "rollout",
                |m: &CreateServiceRolloutRequest| { &m.rollout },
                |m: &mut CreateServiceRolloutRequest| { &mut m.rollout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateServiceRolloutRequest>(
                "CreateServiceRolloutRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateServiceRolloutRequest {
        static instance: ::protobuf::rt::LazyV2<CreateServiceRolloutRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateServiceRolloutRequest::new)
    }
}

impl ::protobuf::Clear for CreateServiceRolloutRequest {
    fn clear(&mut self) {
        self.service_name.clear();
        self.rollout.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateServiceRolloutRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateServiceRolloutRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListServiceRolloutsRequest {
    // message fields
    pub service_name: ::std::string::String,
    pub page_token: ::std::string::String,
    pub page_size: i32,
    pub filter: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListServiceRolloutsRequest {
    fn default() -> &'a ListServiceRolloutsRequest {
        <ListServiceRolloutsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListServiceRolloutsRequest {
    pub fn new() -> ListServiceRolloutsRequest {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }

    // string page_token = 2;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    // int32 page_size = 3;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string filter = 4;


    pub fn get_filter(&self) -> &str {
        &self.filter
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListServiceRolloutsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.page_token);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.filter);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(2, &self.page_token)?;
        }
        if self.page_size != 0 {
            os.write_int32(3, self.page_size)?;
        }
        if !self.filter.is_empty() {
            os.write_string(4, &self.filter)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListServiceRolloutsRequest {
        ListServiceRolloutsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &ListServiceRolloutsRequest| { &m.service_name },
                |m: &mut ListServiceRolloutsRequest| { &mut m.service_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListServiceRolloutsRequest| { &m.page_token },
                |m: &mut ListServiceRolloutsRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListServiceRolloutsRequest| { &m.page_size },
                |m: &mut ListServiceRolloutsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &ListServiceRolloutsRequest| { &m.filter },
                |m: &mut ListServiceRolloutsRequest| { &mut m.filter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListServiceRolloutsRequest>(
                "ListServiceRolloutsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListServiceRolloutsRequest {
        static instance: ::protobuf::rt::LazyV2<ListServiceRolloutsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListServiceRolloutsRequest::new)
    }
}

impl ::protobuf::Clear for ListServiceRolloutsRequest {
    fn clear(&mut self) {
        self.service_name.clear();
        self.page_token.clear();
        self.page_size = 0;
        self.filter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListServiceRolloutsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListServiceRolloutsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListServiceRolloutsResponse {
    // message fields
    pub rollouts: ::protobuf::RepeatedField<super::resources::Rollout>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListServiceRolloutsResponse {
    fn default() -> &'a ListServiceRolloutsResponse {
        <ListServiceRolloutsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListServiceRolloutsResponse {
    pub fn new() -> ListServiceRolloutsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.api.servicemanagement.v1.Rollout rollouts = 1;


    pub fn get_rollouts(&self) -> &[super::resources::Rollout] {
        &self.rollouts
    }
    pub fn clear_rollouts(&mut self) {
        self.rollouts.clear();
    }

    // Param is passed by value, moved
    pub fn set_rollouts(&mut self, v: ::protobuf::RepeatedField<super::resources::Rollout>) {
        self.rollouts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rollouts(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Rollout> {
        &mut self.rollouts
    }

    // Take field
    pub fn take_rollouts(&mut self) -> ::protobuf::RepeatedField<super::resources::Rollout> {
        ::std::mem::replace(&mut self.rollouts, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListServiceRolloutsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.rollouts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rollouts)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.rollouts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.rollouts {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListServiceRolloutsResponse {
        ListServiceRolloutsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Rollout>>(
                "rollouts",
                |m: &ListServiceRolloutsResponse| { &m.rollouts },
                |m: &mut ListServiceRolloutsResponse| { &mut m.rollouts },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListServiceRolloutsResponse| { &m.next_page_token },
                |m: &mut ListServiceRolloutsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListServiceRolloutsResponse>(
                "ListServiceRolloutsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListServiceRolloutsResponse {
        static instance: ::protobuf::rt::LazyV2<ListServiceRolloutsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListServiceRolloutsResponse::new)
    }
}

impl ::protobuf::Clear for ListServiceRolloutsResponse {
    fn clear(&mut self) {
        self.rollouts.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListServiceRolloutsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListServiceRolloutsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetServiceRolloutRequest {
    // message fields
    pub service_name: ::std::string::String,
    pub rollout_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetServiceRolloutRequest {
    fn default() -> &'a GetServiceRolloutRequest {
        <GetServiceRolloutRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetServiceRolloutRequest {
    pub fn new() -> GetServiceRolloutRequest {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }

    // string rollout_id = 2;


    pub fn get_rollout_id(&self) -> &str {
        &self.rollout_id
    }
    pub fn clear_rollout_id(&mut self) {
        self.rollout_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_rollout_id(&mut self, v: ::std::string::String) {
        self.rollout_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollout_id(&mut self) -> &mut ::std::string::String {
        &mut self.rollout_id
    }

    // Take field
    pub fn take_rollout_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rollout_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetServiceRolloutRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rollout_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        if !self.rollout_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.rollout_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        if !self.rollout_id.is_empty() {
            os.write_string(2, &self.rollout_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetServiceRolloutRequest {
        GetServiceRolloutRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &GetServiceRolloutRequest| { &m.service_name },
                |m: &mut GetServiceRolloutRequest| { &mut m.service_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rollout_id",
                |m: &GetServiceRolloutRequest| { &m.rollout_id },
                |m: &mut GetServiceRolloutRequest| { &mut m.rollout_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetServiceRolloutRequest>(
                "GetServiceRolloutRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetServiceRolloutRequest {
        static instance: ::protobuf::rt::LazyV2<GetServiceRolloutRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetServiceRolloutRequest::new)
    }
}

impl ::protobuf::Clear for GetServiceRolloutRequest {
    fn clear(&mut self) {
        self.service_name.clear();
        self.rollout_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetServiceRolloutRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetServiceRolloutRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EnableServiceRequest {
    // message fields
    pub service_name: ::std::string::String,
    pub consumer_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EnableServiceRequest {
    fn default() -> &'a EnableServiceRequest {
        <EnableServiceRequest as ::protobuf::Message>::default_instance()
    }
}

impl EnableServiceRequest {
    pub fn new() -> EnableServiceRequest {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }

    // string consumer_id = 2;


    pub fn get_consumer_id(&self) -> &str {
        &self.consumer_id
    }
    pub fn clear_consumer_id(&mut self) {
        self.consumer_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: ::std::string::String) {
        self.consumer_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consumer_id(&mut self) -> &mut ::std::string::String {
        &mut self.consumer_id
    }

    // Take field
    pub fn take_consumer_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.consumer_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for EnableServiceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.consumer_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        if !self.consumer_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.consumer_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        if !self.consumer_id.is_empty() {
            os.write_string(2, &self.consumer_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EnableServiceRequest {
        EnableServiceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &EnableServiceRequest| { &m.service_name },
                |m: &mut EnableServiceRequest| { &mut m.service_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "consumer_id",
                |m: &EnableServiceRequest| { &m.consumer_id },
                |m: &mut EnableServiceRequest| { &mut m.consumer_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EnableServiceRequest>(
                "EnableServiceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EnableServiceRequest {
        static instance: ::protobuf::rt::LazyV2<EnableServiceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EnableServiceRequest::new)
    }
}

impl ::protobuf::Clear for EnableServiceRequest {
    fn clear(&mut self) {
        self.service_name.clear();
        self.consumer_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnableServiceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnableServiceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DisableServiceRequest {
    // message fields
    pub service_name: ::std::string::String,
    pub consumer_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DisableServiceRequest {
    fn default() -> &'a DisableServiceRequest {
        <DisableServiceRequest as ::protobuf::Message>::default_instance()
    }
}

impl DisableServiceRequest {
    pub fn new() -> DisableServiceRequest {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }

    // string consumer_id = 2;


    pub fn get_consumer_id(&self) -> &str {
        &self.consumer_id
    }
    pub fn clear_consumer_id(&mut self) {
        self.consumer_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: ::std::string::String) {
        self.consumer_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consumer_id(&mut self) -> &mut ::std::string::String {
        &mut self.consumer_id
    }

    // Take field
    pub fn take_consumer_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.consumer_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DisableServiceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.consumer_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        if !self.consumer_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.consumer_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        if !self.consumer_id.is_empty() {
            os.write_string(2, &self.consumer_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DisableServiceRequest {
        DisableServiceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &DisableServiceRequest| { &m.service_name },
                |m: &mut DisableServiceRequest| { &mut m.service_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "consumer_id",
                |m: &DisableServiceRequest| { &m.consumer_id },
                |m: &mut DisableServiceRequest| { &mut m.consumer_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DisableServiceRequest>(
                "DisableServiceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DisableServiceRequest {
        static instance: ::protobuf::rt::LazyV2<DisableServiceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DisableServiceRequest::new)
    }
}

impl ::protobuf::Clear for DisableServiceRequest {
    fn clear(&mut self) {
        self.service_name.clear();
        self.consumer_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisableServiceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisableServiceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GenerateConfigReportRequest {
    // message fields
    pub new_config: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub old_config: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenerateConfigReportRequest {
    fn default() -> &'a GenerateConfigReportRequest {
        <GenerateConfigReportRequest as ::protobuf::Message>::default_instance()
    }
}

impl GenerateConfigReportRequest {
    pub fn new() -> GenerateConfigReportRequest {
        ::std::default::Default::default()
    }

    // .google.protobuf.Any new_config = 1;


    pub fn get_new_config(&self) -> &::protobuf::well_known_types::Any {
        self.new_config.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_new_config(&mut self) {
        self.new_config.clear();
    }

    pub fn has_new_config(&self) -> bool {
        self.new_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_config(&mut self, v: ::protobuf::well_known_types::Any) {
        self.new_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_new_config(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.new_config.is_none() {
            self.new_config.set_default();
        }
        self.new_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_new_config(&mut self) -> ::protobuf::well_known_types::Any {
        self.new_config.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // .google.protobuf.Any old_config = 2;


    pub fn get_old_config(&self) -> &::protobuf::well_known_types::Any {
        self.old_config.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_old_config(&mut self) {
        self.old_config.clear();
    }

    pub fn has_old_config(&self) -> bool {
        self.old_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_old_config(&mut self, v: ::protobuf::well_known_types::Any) {
        self.old_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_old_config(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.old_config.is_none() {
            self.old_config.set_default();
        }
        self.old_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_old_config(&mut self) -> ::protobuf::well_known_types::Any {
        self.old_config.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }
}

impl ::protobuf::Message for GenerateConfigReportRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.new_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.old_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.new_config)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.old_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.new_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.old_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.new_config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.old_config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenerateConfigReportRequest {
        GenerateConfigReportRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "new_config",
                |m: &GenerateConfigReportRequest| { &m.new_config },
                |m: &mut GenerateConfigReportRequest| { &mut m.new_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "old_config",
                |m: &GenerateConfigReportRequest| { &m.old_config },
                |m: &mut GenerateConfigReportRequest| { &mut m.old_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GenerateConfigReportRequest>(
                "GenerateConfigReportRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GenerateConfigReportRequest {
        static instance: ::protobuf::rt::LazyV2<GenerateConfigReportRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GenerateConfigReportRequest::new)
    }
}

impl ::protobuf::Clear for GenerateConfigReportRequest {
    fn clear(&mut self) {
        self.new_config.clear();
        self.old_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenerateConfigReportRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenerateConfigReportRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GenerateConfigReportResponse {
    // message fields
    pub service_name: ::std::string::String,
    pub id: ::std::string::String,
    pub change_reports: ::protobuf::RepeatedField<super::resources::ChangeReport>,
    pub diagnostics: ::protobuf::RepeatedField<super::resources::Diagnostic>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenerateConfigReportResponse {
    fn default() -> &'a GenerateConfigReportResponse {
        <GenerateConfigReportResponse as ::protobuf::Message>::default_instance()
    }
}

impl GenerateConfigReportResponse {
    pub fn new() -> GenerateConfigReportResponse {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }

    // string id = 2;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // repeated .google.api.servicemanagement.v1.ChangeReport change_reports = 3;


    pub fn get_change_reports(&self) -> &[super::resources::ChangeReport] {
        &self.change_reports
    }
    pub fn clear_change_reports(&mut self) {
        self.change_reports.clear();
    }

    // Param is passed by value, moved
    pub fn set_change_reports(&mut self, v: ::protobuf::RepeatedField<super::resources::ChangeReport>) {
        self.change_reports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_change_reports(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::ChangeReport> {
        &mut self.change_reports
    }

    // Take field
    pub fn take_change_reports(&mut self) -> ::protobuf::RepeatedField<super::resources::ChangeReport> {
        ::std::mem::replace(&mut self.change_reports, ::protobuf::RepeatedField::new())
    }

    // repeated .google.api.servicemanagement.v1.Diagnostic diagnostics = 4;


    pub fn get_diagnostics(&self) -> &[super::resources::Diagnostic] {
        &self.diagnostics
    }
    pub fn clear_diagnostics(&mut self) {
        self.diagnostics.clear();
    }

    // Param is passed by value, moved
    pub fn set_diagnostics(&mut self, v: ::protobuf::RepeatedField<super::resources::Diagnostic>) {
        self.diagnostics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_diagnostics(&mut self) -> &mut ::protobuf::RepeatedField<super::resources::Diagnostic> {
        &mut self.diagnostics
    }

    // Take field
    pub fn take_diagnostics(&mut self) -> ::protobuf::RepeatedField<super::resources::Diagnostic> {
        ::std::mem::replace(&mut self.diagnostics, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GenerateConfigReportResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.change_reports {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.diagnostics {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.change_reports)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.diagnostics)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        for value in &self.change_reports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.diagnostics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        for v in &self.change_reports {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.diagnostics {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenerateConfigReportResponse {
        GenerateConfigReportResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &GenerateConfigReportResponse| { &m.service_name },
                |m: &mut GenerateConfigReportResponse| { &mut m.service_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &GenerateConfigReportResponse| { &m.id },
                |m: &mut GenerateConfigReportResponse| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::ChangeReport>>(
                "change_reports",
                |m: &GenerateConfigReportResponse| { &m.change_reports },
                |m: &mut GenerateConfigReportResponse| { &mut m.change_reports },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resources::Diagnostic>>(
                "diagnostics",
                |m: &GenerateConfigReportResponse| { &m.diagnostics },
                |m: &mut GenerateConfigReportResponse| { &mut m.diagnostics },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GenerateConfigReportResponse>(
                "GenerateConfigReportResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GenerateConfigReportResponse {
        static instance: ::protobuf::rt::LazyV2<GenerateConfigReportResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GenerateConfigReportResponse::new)
    }
}

impl ::protobuf::Clear for GenerateConfigReportResponse {
    fn clear(&mut self) {
        self.service_name.clear();
        self.id.clear();
        self.change_reports.clear();
        self.diagnostics.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenerateConfigReportResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenerateConfigReportResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n4google/api/servicemanagement/v1/servicemanager.proto\x12\x1fgoogle.ap\
    i.servicemanagement.v1\x1a\x1cgoogle/api/annotations.proto\x1a\x18google\
    /api/service.proto\x1a/google/api/servicemanagement/v1/resources.proto\
    \x1a#google/longrunning/operations.proto\x1a\x19google/protobuf/any.prot\
    o\x1a\x20google/protobuf/field_mask.proto\x1a\x1cgoogle/protobuf/struct.\
    proto\x1a\x17google/rpc/status.proto\"\xa2\x01\n\x13ListServicesRequest\
    \x12.\n\x13producer_project_id\x18\x01\x20\x01(\tR\x11producerProjectId\
    \x12\x1b\n\tpage_size\x18\x05\x20\x01(\x05R\x08pageSize\x12\x1d\n\npage_\
    token\x18\x06\x20\x01(\tR\tpageToken\x12\x1f\n\x0bconsumer_id\x18\x07\
    \x20\x01(\tR\nconsumerId\"\x8b\x01\n\x14ListServicesResponse\x12K\n\x08s\
    ervices\x18\x01\x20\x03(\x0b2/.google.api.servicemanagement.v1.ManagedSe\
    rviceR\x08services\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPa\
    geToken\"6\n\x11GetServiceRequest\x12!\n\x0cservice_name\x18\x01\x20\x01\
    (\tR\x0bserviceName\"a\n\x14CreateServiceRequest\x12I\n\x07service\x18\
    \x01\x20\x01(\x0b2/.google.api.servicemanagement.v1.ManagedServiceR\x07s\
    ervice\"9\n\x14DeleteServiceRequest\x12!\n\x0cservice_name\x18\x01\x20\
    \x01(\tR\x0bserviceName\";\n\x16UndeleteServiceRequest\x12!\n\x0cservice\
    _name\x18\x01\x20\x01(\tR\x0bserviceName\"d\n\x17UndeleteServiceResponse\
    \x12I\n\x07service\x18\x01\x20\x01(\x0b2/.google.api.servicemanagement.v\
    1.ManagedServiceR\x07service\"\xd5\x01\n\x17GetServiceConfigRequest\x12!\
    \n\x0cservice_name\x18\x01\x20\x01(\tR\x0bserviceName\x12\x1b\n\tconfig_\
    id\x18\x02\x20\x01(\tR\x08configId\x12W\n\x04view\x18\x03\x20\x01(\x0e2C\
    .google.api.servicemanagement.v1.GetServiceConfigRequest.ConfigViewR\x04\
    view\"!\n\nConfigView\x12\t\n\x05BASIC\x10\0\x12\x08\n\x04FULL\x10\x01\"\
    z\n\x19ListServiceConfigsRequest\x12!\n\x0cservice_name\x18\x01\x20\x01(\
    \tR\x0bserviceName\x12\x1d\n\npage_token\x18\x02\x20\x01(\tR\tpageToken\
    \x12\x1b\n\tpage_size\x18\x03\x20\x01(\x05R\x08pageSize\"\x82\x01\n\x1aL\
    istServiceConfigsResponse\x12<\n\x0fservice_configs\x18\x01\x20\x03(\x0b\
    2\x13.google.api.ServiceR\x0eserviceConfigs\x12&\n\x0fnext_page_token\
    \x18\x02\x20\x01(\tR\rnextPageToken\"{\n\x1aCreateServiceConfigRequest\
    \x12!\n\x0cservice_name\x18\x01\x20\x01(\tR\x0bserviceName\x12:\n\x0eser\
    vice_config\x18\x02\x20\x01(\x0b2\x13.google.api.ServiceR\rserviceConfig\
    \"\xb7\x01\n\x19SubmitConfigSourceRequest\x12!\n\x0cservice_name\x18\x01\
    \x20\x01(\tR\x0bserviceName\x12R\n\rconfig_source\x18\x02\x20\x01(\x0b2-\
    .google.api.servicemanagement.v1.ConfigSourceR\x0cconfigSource\x12#\n\rv\
    alidate_only\x18\x03\x20\x01(\x08R\x0cvalidateOnly\"X\n\x1aSubmitConfigS\
    ourceResponse\x12:\n\x0eservice_config\x18\x01\x20\x01(\x0b2\x13.google.\
    api.ServiceR\rserviceConfig\"\x84\x01\n\x1bCreateServiceRolloutRequest\
    \x12!\n\x0cservice_name\x18\x01\x20\x01(\tR\x0bserviceName\x12B\n\x07rol\
    lout\x18\x02\x20\x01(\x0b2(.google.api.servicemanagement.v1.RolloutR\x07\
    rollout\"\x93\x01\n\x1aListServiceRolloutsRequest\x12!\n\x0cservice_name\
    \x18\x01\x20\x01(\tR\x0bserviceName\x12\x1d\n\npage_token\x18\x02\x20\
    \x01(\tR\tpageToken\x12\x1b\n\tpage_size\x18\x03\x20\x01(\x05R\x08pageSi\
    ze\x12\x16\n\x06filter\x18\x04\x20\x01(\tR\x06filter\"\x8b\x01\n\x1bList\
    ServiceRolloutsResponse\x12D\n\x08rollouts\x18\x01\x20\x03(\x0b2(.google\
    .api.servicemanagement.v1.RolloutR\x08rollouts\x12&\n\x0fnext_page_token\
    \x18\x02\x20\x01(\tR\rnextPageToken\"\\\n\x18GetServiceRolloutRequest\
    \x12!\n\x0cservice_name\x18\x01\x20\x01(\tR\x0bserviceName\x12\x1d\n\nro\
    llout_id\x18\x02\x20\x01(\tR\trolloutId\"Z\n\x14EnableServiceRequest\x12\
    !\n\x0cservice_name\x18\x01\x20\x01(\tR\x0bserviceName\x12\x1f\n\x0bcons\
    umer_id\x18\x02\x20\x01(\tR\nconsumerId\"[\n\x15DisableServiceRequest\
    \x12!\n\x0cservice_name\x18\x01\x20\x01(\tR\x0bserviceName\x12\x1f\n\x0b\
    consumer_id\x18\x02\x20\x01(\tR\nconsumerId\"\x87\x01\n\x1bGenerateConfi\
    gReportRequest\x123\n\nnew_config\x18\x01\x20\x01(\x0b2\x14.google.proto\
    buf.AnyR\tnewConfig\x123\n\nold_config\x18\x02\x20\x01(\x0b2\x14.google.\
    protobuf.AnyR\toldConfig\"\xf6\x01\n\x1cGenerateConfigReportResponse\x12\
    !\n\x0cservice_name\x18\x01\x20\x01(\tR\x0bserviceName\x12\x0e\n\x02id\
    \x18\x02\x20\x01(\tR\x02id\x12T\n\x0echange_reports\x18\x03\x20\x03(\x0b\
    2-.google.api.servicemanagement.v1.ChangeReportR\rchangeReports\x12M\n\
    \x0bdiagnostics\x18\x04\x20\x03(\x0b2+.google.api.servicemanagement.v1.D\
    iagnosticR\x0bdiagnostics2\xd4\x13\n\x0eServiceManager\x12\x91\x01\n\x0c\
    ListServices\x124.google.api.servicemanagement.v1.ListServicesRequest\
    \x1a5.google.api.servicemanagement.v1.ListServicesResponse\"\x14\x82\xd3\
    \xe4\x93\x02\x0e\x12\x0c/v1/services\x12\x96\x01\n\nGetService\x122.goog\
    le.api.servicemanagement.v1.GetServiceRequest\x1a/.google.api.serviceman\
    agement.v1.ManagedService\"#\x82\xd3\xe4\x93\x02\x1d\x12\x1b/v1/services\
    /{service_name}\x12\x84\x01\n\rCreateService\x125.google.api.servicemana\
    gement.v1.CreateServiceRequest\x1a\x1d.google.longrunning.Operation\"\
    \x1d\x82\xd3\xe4\x93\x02\x17\"\x0c/v1/services:\x07service\x12\x8a\x01\n\
    \rDeleteService\x125.google.api.servicemanagement.v1.DeleteServiceReques\
    t\x1a\x1d.google.longrunning.Operation\"#\x82\xd3\xe4\x93\x02\x1d*\x1b/v\
    1/services/{service_name}\x12\x97\x01\n\x0fUndeleteService\x127.google.a\
    pi.servicemanagement.v1.UndeleteServiceRequest\x1a\x1d.google.longrunnin\
    g.Operation\",\x82\xd3\xe4\x93\x02&\"$/v1/services/{service_name}:undele\
    te\x12\xba\x01\n\x12ListServiceConfigs\x12:.google.api.servicemanagement\
    .v1.ListServiceConfigsRequest\x1a;.google.api.servicemanagement.v1.ListS\
    erviceConfigsResponse\"+\x82\xd3\xe4\x93\x02%\x12#/v1/services/{service_\
    name}/configs\x12\xc0\x01\n\x10GetServiceConfig\x128.google.api.servicem\
    anagement.v1.GetServiceConfigRequest\x1a\x13.google.api.Service\"]\x82\
    \xd3\xe4\x93\x02W\x12//v1/services/{service_name}/configs/{config_id}Z$\
    \x12\"/v1/services/{service_name}/config\x12\xa4\x01\n\x13CreateServiceC\
    onfig\x12;.google.api.servicemanagement.v1.CreateServiceConfigRequest\
    \x1a\x13.google.api.Service\";\x82\xd3\xe4\x93\x025\"#/v1/services/{serv\
    ice_name}/configs:\x0eservice_config\x12\xa6\x01\n\x12SubmitConfigSource\
    \x12:.google.api.servicemanagement.v1.SubmitConfigSourceRequest\x1a\x1d.\
    google.longrunning.Operation\"5\x82\xd3\xe4\x93\x02/\"*/v1/services/{ser\
    vice_name}/configs:submit:\x01*\x12\xbe\x01\n\x13ListServiceRollouts\x12\
    ;.google.api.servicemanagement.v1.ListServiceRolloutsRequest\x1a<.google\
    .api.servicemanagement.v1.ListServiceRolloutsResponse\",\x82\xd3\xe4\x93\
    \x02&\x12$/v1/services/{service_name}/rollouts\x12\xb3\x01\n\x11GetServi\
    ceRollout\x129.google.api.servicemanagement.v1.GetServiceRolloutRequest\
    \x1a(.google.api.servicemanagement.v1.Rollout\"9\x82\xd3\xe4\x93\x023\
    \x121/v1/services/{service_name}/rollouts/{rollout_id}\x12\xaa\x01\n\x14\
    CreateServiceRollout\x12<.google.api.servicemanagement.v1.CreateServiceR\
    olloutRequest\x1a\x1d.google.longrunning.Operation\"5\x82\xd3\xe4\x93\
    \x02/\"$/v1/services/{service_name}/rollouts:\x07rollout\x12\xc1\x01\n\
    \x14GenerateConfigReport\x12<.google.api.servicemanagement.v1.GenerateCo\
    nfigReportRequest\x1a=.google.api.servicemanagement.v1.GenerateConfigRep\
    ortResponse\",\x82\xd3\xe4\x93\x02&\"!/v1/services:generateConfigReport:\
    \x01*\x12\x94\x01\n\rEnableService\x125.google.api.servicemanagement.v1.\
    EnableServiceRequest\x1a\x1d.google.longrunning.Operation\"-\x82\xd3\xe4\
    \x93\x02'\"\"/v1/services/{service_name}:enable:\x01*\x12\x97\x01\n\x0eD\
    isableService\x126.google.api.servicemanagement.v1.DisableServiceRequest\
    \x1a\x1d.google.longrunning.Operation\".\x82\xd3\xe4\x93\x02(\"#/v1/serv\
    ices/{service_name}:disable:\x01*B\xdd\x01\n#com.google.api.servicemanag\
    ement.v1B\x13ServiceManagerProtoP\x01ZPgoogle.golang.org/genproto/google\
    apis/api/servicemanagement/v1;servicemanagement\xa2\x02\x04GASM\xaa\x02!\
    Google.Cloud.ServiceManagement.V1\xca\x02!Google\\Cloud\\ServiceManageme\
    nt\\V1J\xf0\x86\x01\n\x07\x12\x05\x0e\0\xf6\x03\x01\n\xbd\x04\n\x01\x0c\
    \x12\x03\x0e\0\x122\xb2\x04\x20Copyright\x202018\x20Google\x20Inc.\n\n\
    \x20Licensed\x20under\x20the\x20Apache\x20License,\x20Version\x202.0\x20\
    (the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\x20file\x20e\
    xcept\x20in\x20compliance\x20with\x20the\x20License.\n\x20You\x20may\x20\
    obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\x20\
    \x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\x20required\
    \x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\x20s\
    oftware\n\x20distributed\x20under\x20the\x20License\x20is\x20distributed\
    \x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\
    \x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\x20impli\
    ed.\n\x20See\x20the\x20License\x20for\x20the\x20specific\x20language\x20\
    governing\x20permissions\x20and\n\x20limitations\x20under\x20the\x20Lice\
    nse.\n\n\x08\n\x01\x02\x12\x03\x10\0(\n\t\n\x02\x03\0\x12\x03\x12\0&\n\t\
    \n\x02\x03\x01\x12\x03\x13\0\"\n\t\n\x02\x03\x02\x12\x03\x14\09\n\t\n\
    \x02\x03\x03\x12\x03\x15\0-\n\t\n\x02\x03\x04\x12\x03\x16\0#\n\t\n\x02\
    \x03\x05\x12\x03\x17\0*\n\t\n\x02\x03\x06\x12\x03\x18\0&\n\t\n\x02\x03\
    \x07\x12\x03\x19\0!\n\x08\n\x01\x08\x12\x03\x1b\0>\n\t\n\x02\x08%\x12\
    \x03\x1b\0>\n\x08\n\x01\x08\x12\x03\x1c\0g\n\t\n\x02\x08\x0b\x12\x03\x1c\
    \0g\n\x08\n\x01\x08\x12\x03\x1d\0\"\n\t\n\x02\x08\n\x12\x03\x1d\0\"\n\
    \x08\n\x01\x08\x12\x03\x1e\04\n\t\n\x02\x08\x08\x12\x03\x1e\04\n\x08\n\
    \x01\x08\x12\x03\x1f\0<\n\t\n\x02\x08\x01\x12\x03\x1f\0<\n\x08\n\x01\x08\
    \x12\x03\x20\0\"\n\t\n\x02\x08$\x12\x03\x20\0\"\n\x08\n\x01\x08\x12\x03!\
    \0>\n\t\n\x02\x08)\x12\x03!\0>\nL\n\x02\x06\0\x12\x05$\0\xef\x01\x01\x1a\
    ?\x20[Google\x20Service\x20Management\x20API](/service-management/overvi\
    ew)\n\n\n\n\x03\x06\0\x01\x12\x03$\x08\x16\n\xf3\x02\n\x04\x06\0\x02\0\
    \x12\x04.\x022\x03\x1a\xe4\x02\x20Lists\x20managed\x20services.\n\n\x20R\
    eturns\x20all\x20public\x20services.\x20For\x20authenticated\x20users,\
    \x20also\x20returns\x20all\n\x20services\x20the\x20calling\x20user\x20ha\
    s\x20\"servicemanagement.services.get\"\x20permission\n\x20for.\n\n\x20*\
    *BETA:**\x20If\x20the\x20caller\x20specifies\x20the\x20`consumer_id`,\
    \x20it\x20returns\x20only\x20the\n\x20services\x20enabled\x20on\x20the\
    \x20consumer.\x20The\x20`consumer_id`\x20must\x20have\x20the\x20format\n\
    \x20of\x20\"project:{PROJECT-ID}\".\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\
    \x03.\x06\x12\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03.\x13&\n\x0c\n\x05\x06\
    \0\x02\0\x03\x12\x03.1E\n\r\n\x05\x06\0\x02\0\x04\x12\x04/\x041\x06\n\
    \x11\n\t\x06\0\x02\0\x04\xb0\xca\xbc\"\x12\x04/\x041\x06\na\n\x04\x06\0\
    \x02\x01\x12\x046\x02:\x03\x1aS\x20Gets\x20a\x20managed\x20service.\x20A\
    uthentication\x20is\x20required\x20unless\x20the\x20service\x20is\n\x20p\
    ublic.\n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x036\x06\x10\n\x0c\n\x05\x06\
    \0\x02\x01\x02\x12\x036\x11\"\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x036-;\n\
    \r\n\x05\x06\0\x02\x01\x04\x12\x047\x049\x06\n\x11\n\t\x06\0\x02\x01\x04\
    \xb0\xca\xbc\"\x12\x047\x049\x06\n\x99\x01\n\x04\x06\0\x02\x02\x12\x04@\
    \x02F\x03\x1a\x8a\x01\x20Creates\x20a\x20new\x20managed\x20service.\n\
    \x20Please\x20note\x20one\x20producer\x20project\x20can\x20own\x20no\x20\
    more\x20than\x2020\x20services.\n\n\x20Operation<response:\x20ManagedSer\
    vice>\n\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03@\x06\x13\n\x0c\n\x05\x06\0\
    \x02\x02\x02\x12\x03@\x14(\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03A\x0f+\n\
    \r\n\x05\x06\0\x02\x02\x04\x12\x04B\x04E\x06\n\x11\n\t\x06\0\x02\x02\x04\
    \xb0\xca\xbc\"\x12\x04B\x04E\x06\n\xfa\x02\n\x04\x06\0\x02\x03\x12\x04P\
    \x02U\x03\x1a\xeb\x02\x20Deletes\x20a\x20managed\x20service.\x20This\x20\
    method\x20will\x20change\x20the\x20service\x20to\x20the\n\x20`Soft-Delet\
    e`\x20state\x20for\x2030\x20days.\x20Within\x20this\x20period,\x20servic\
    e\x20producers\x20may\n\x20call\n\x20[UndeleteService][google.api.servic\
    emanagement.v1.ServiceManager.UndeleteService]\n\x20to\x20restore\x20the\
    \x20service.\x20After\x2030\x20days,\x20the\x20service\x20will\x20be\x20\
    permanently\n\x20deleted.\n\n\x20Operation<response:\x20google.protobuf.\
    Empty>\n\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x03P\x06\x13\n\x0c\n\x05\x06\
    \0\x02\x03\x02\x12\x03P\x14(\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03Q\x0f+\
    \n\r\n\x05\x06\0\x02\x03\x04\x12\x04R\x04T\x06\n\x11\n\t\x06\0\x02\x03\
    \x04\xb0\xca\xbc\"\x12\x04R\x04T\x06\n\x9f\x02\n\x04\x06\0\x02\x04\x12\
    \x04]\x02b\x03\x1a\x90\x02\x20Revives\x20a\x20previously\x20deleted\x20m\
    anaged\x20service.\x20The\x20method\x20restores\x20the\n\x20service\x20u\
    sing\x20the\x20configuration\x20at\x20the\x20time\x20the\x20service\x20w\
    as\x20deleted.\n\x20The\x20target\x20service\x20must\x20exist\x20and\x20\
    must\x20have\x20been\x20deleted\x20within\x20the\n\x20last\x2030\x20days\
    .\n\n\x20Operation<response:\x20UndeleteServiceResponse>\n\n\x0c\n\x05\
    \x06\0\x02\x04\x01\x12\x03]\x06\x15\n\x0c\n\x05\x06\0\x02\x04\x02\x12\
    \x03]\x16,\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03^\x0f+\n\r\n\x05\x06\0\
    \x02\x04\x04\x12\x04_\x04a\x06\n\x11\n\t\x06\0\x02\x04\x04\xb0\xca\xbc\"\
    \x12\x04_\x04a\x06\nu\n\x04\x06\0\x02\x05\x12\x04f\x02k\x03\x1ag\x20List\
    s\x20the\x20history\x20of\x20the\x20service\x20configuration\x20for\x20a\
    \x20managed\x20service,\n\x20from\x20the\x20newest\x20to\x20the\x20oldes\
    t.\n\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03f\x06\x18\n\x0c\n\x05\x06\0\
    \x02\x05\x02\x12\x03f\x192\n\x0c\n\x05\x06\0\x02\x05\x03\x12\x03g\x0f)\n\
    \r\n\x05\x06\0\x02\x05\x04\x12\x04h\x04j\x06\n\x11\n\t\x06\0\x02\x05\x04\
    \xb0\xca\xbc\"\x12\x04h\x04j\x06\nM\n\x04\x06\0\x02\x06\x12\x04n\x02s\
    \x03\x1a?\x20Gets\x20a\x20service\x20configuration\x20(version)\x20for\
    \x20a\x20managed\x20service.\n\n\x0c\n\x05\x06\0\x02\x06\x01\x12\x03n\
    \x06\x16\n\x0c\n\x05\x06\0\x02\x06\x02\x12\x03n\x17.\n\x0c\n\x05\x06\0\
    \x02\x06\x03\x12\x03n9K\n\r\n\x05\x06\0\x02\x06\x04\x12\x04o\x04r\x06\n\
    \x11\n\t\x06\0\x02\x06\x04\xb0\xca\xbc\"\x12\x04o\x04r\x06\n\xcb\x03\n\
    \x04\x06\0\x02\x07\x12\x05}\x02\x83\x01\x03\x1a\xbb\x03\x20Creates\x20a\
    \x20new\x20service\x20configuration\x20(version)\x20for\x20a\x20managed\
    \x20service.\n\x20This\x20method\x20only\x20stores\x20the\x20service\x20\
    configuration.\x20To\x20roll\x20out\x20the\x20service\n\x20configuration\
    \x20to\x20backend\x20systems\x20please\x20call\n\x20[CreateServiceRollou\
    t][google.api.servicemanagement.v1.ServiceManager.CreateServiceRollout].\
    \n\n\x20Only\x20the\x20100\x20most\x20recent\x20service\x20configuration\
    s\x20and\x20ones\x20referenced\x20by\n\x20existing\x20rollouts\x20are\
    \x20kept\x20for\x20each\x20service.\x20The\x20rest\x20will\x20be\x20dele\
    ted\n\x20eventually.\n\n\x0c\n\x05\x06\0\x02\x07\x01\x12\x03}\x06\x19\n\
    \x0c\n\x05\x06\0\x02\x07\x02\x12\x03}\x1a4\n\x0c\n\x05\x06\0\x02\x07\x03\
    \x12\x03~\x0f!\n\x0e\n\x05\x06\0\x02\x07\x04\x12\x05\x7f\x04\x82\x01\x06\
    \n\x12\n\t\x06\0\x02\x07\x04\xb0\xca\xbc\"\x12\x05\x7f\x04\x82\x01\x06\n\
    \x8e\x05\n\x04\x06\0\x02\x08\x12\x06\x93\x01\x02\x99\x01\x03\x1a\xfd\x04\
    \x20Creates\x20a\x20new\x20service\x20configuration\x20(version)\x20for\
    \x20a\x20managed\x20service\x20based\n\x20on\n\x20user-supplied\x20confi\
    guration\x20source\x20files\x20(for\x20example:\x20OpenAPI\n\x20Specific\
    ation).\x20This\x20method\x20stores\x20the\x20source\x20configurations\
    \x20as\x20well\x20as\x20the\n\x20generated\x20service\x20configuration.\
    \x20To\x20rollout\x20the\x20service\x20configuration\x20to\n\x20other\
    \x20services,\n\x20please\x20call\n\x20[CreateServiceRollout][google.api\
    .servicemanagement.v1.ServiceManager.CreateServiceRollout].\n\n\x20Only\
    \x20the\x20100\x20most\x20recent\x20configuration\x20sources\x20and\x20o\
    nes\x20referenced\x20by\n\x20existing\x20service\x20configurtions\x20are\
    \x20kept\x20for\x20each\x20service.\x20The\x20rest\x20will\x20be\n\x20de\
    leted\x20eventually.\n\n\x20Operation<response:\x20SubmitConfigSourceRes\
    ponse>\n\n\r\n\x05\x06\0\x02\x08\x01\x12\x04\x93\x01\x06\x18\n\r\n\x05\
    \x06\0\x02\x08\x02\x12\x04\x93\x01\x192\n\r\n\x05\x06\0\x02\x08\x03\x12\
    \x04\x94\x01\x0f+\n\x0f\n\x05\x06\0\x02\x08\x04\x12\x06\x95\x01\x04\x98\
    \x01\x06\n\x13\n\t\x06\0\x02\x08\x04\xb0\xca\xbc\"\x12\x06\x95\x01\x04\
    \x98\x01\x06\n\x80\x01\n\x04\x06\0\x02\t\x12\x06\x9d\x01\x02\xa2\x01\x03\
    \x1ap\x20Lists\x20the\x20history\x20of\x20the\x20service\x20configuratio\
    n\x20rollouts\x20for\x20a\x20managed\n\x20service,\x20from\x20the\x20new\
    est\x20to\x20the\x20oldest.\n\n\r\n\x05\x06\0\x02\t\x01\x12\x04\x9d\x01\
    \x06\x19\n\r\n\x05\x06\0\x02\t\x02\x12\x04\x9d\x01\x1a4\n\r\n\x05\x06\0\
    \x02\t\x03\x12\x04\x9e\x01\x0f*\n\x0f\n\x05\x06\0\x02\t\x04\x12\x06\x9f\
    \x01\x04\xa1\x01\x06\n\x13\n\t\x06\0\x02\t\x04\xb0\xca\xbc\"\x12\x06\x9f\
    \x01\x04\xa1\x01\x06\nc\n\x04\x06\0\x02\n\x12\x06\xa6\x01\x02\xaa\x01\
    \x03\x1aS\x20Gets\x20a\x20service\x20configuration\n\x20[rollout][google\
    .api.servicemanagement.v1.Rollout].\n\n\r\n\x05\x06\0\x02\n\x01\x12\x04\
    \xa6\x01\x06\x17\n\r\n\x05\x06\0\x02\n\x02\x12\x04\xa6\x01\x180\n\r\n\
    \x05\x06\0\x02\n\x03\x12\x04\xa6\x01;B\n\x0f\n\x05\x06\0\x02\n\x04\x12\
    \x06\xa7\x01\x04\xa9\x01\x06\n\x13\n\t\x06\0\x02\n\x04\xb0\xca\xbc\"\x12\
    \x06\xa7\x01\x04\xa9\x01\x06\n\xaa\x05\n\x04\x06\0\x02\x0b\x12\x06\xba\
    \x01\x02\xc0\x01\x03\x1a\x99\x05\x20Creates\x20a\x20new\x20service\x20co\
    nfiguration\x20rollout.\x20Based\x20on\x20rollout,\x20the\n\x20Google\
    \x20Service\x20Management\x20will\x20roll\x20out\x20the\x20service\x20co\
    nfigurations\x20to\n\x20different\x20backend\x20services.\x20For\x20exam\
    ple,\x20the\x20logging\x20configuration\x20will\x20be\n\x20pushed\x20to\
    \x20Google\x20Cloud\x20Logging.\n\n\x20Please\x20note\x20that\x20any\x20\
    previous\x20pending\x20and\x20running\x20Rollouts\x20and\x20associated\n\
    \x20Operations\x20will\x20be\x20automatically\x20cancelled\x20so\x20that\
    \x20the\x20latest\x20Rollout\x20will\n\x20not\x20be\x20blocked\x20by\x20\
    previous\x20Rollouts.\n\n\x20Only\x20the\x20100\x20most\x20recent\x20(in\
    \x20any\x20state)\x20and\x20the\x20last\x2010\x20successful\x20(if\x20no\
    t\n\x20already\x20part\x20of\x20the\x20set\x20of\x20100\x20most\x20recen\
    t)\x20rollouts\x20are\x20kept\x20for\x20each\n\x20service.\x20The\x20res\
    t\x20will\x20be\x20deleted\x20eventually.\n\n\x20Operation<response:\x20\
    Rollout>\n\n\r\n\x05\x06\0\x02\x0b\x01\x12\x04\xba\x01\x06\x1a\n\r\n\x05\
    \x06\0\x02\x0b\x02\x12\x04\xba\x01\x1b6\n\r\n\x05\x06\0\x02\x0b\x03\x12\
    \x04\xbb\x01\x0f+\n\x0f\n\x05\x06\0\x02\x0b\x04\x12\x06\xbc\x01\x04\xbf\
    \x01\x06\n\x13\n\t\x06\0\x02\x0b\x04\xb0\xca\xbc\"\x12\x06\xbc\x01\x04\
    \xbf\x01\x06\n\xba\x04\n\x04\x06\0\x02\x0c\x12\x06\xcd\x01\x02\xd3\x01\
    \x03\x1a\xa9\x04\x20Generates\x20and\x20returns\x20a\x20report\x20(error\
    s,\x20warnings\x20and\x20changes\x20from\n\x20existing\x20configurations\
    )\x20associated\x20with\n\x20GenerateConfigReportRequest.new_value\n\n\
    \x20If\x20GenerateConfigReportRequest.old_value\x20is\x20specified,\n\
    \x20GenerateConfigReportRequest\x20will\x20contain\x20a\x20single\x20Cha\
    ngeReport\x20based\x20on\x20the\n\x20comparison\x20between\x20GenerateCo\
    nfigReportRequest.new_value\x20and\n\x20GenerateConfigReportRequest.old_\
    value.\n\x20If\x20GenerateConfigReportRequest.old_value\x20is\x20not\x20\
    specified,\x20this\x20method\n\x20will\x20compare\x20GenerateConfigRepor\
    tRequest.new_value\x20with\x20the\x20last\x20pushed\n\x20service\x20conf\
    iguration.\n\n\r\n\x05\x06\0\x02\x0c\x01\x12\x04\xcd\x01\x06\x1a\n\r\n\
    \x05\x06\0\x02\x0c\x02\x12\x04\xcd\x01\x1b6\n\r\n\x05\x06\0\x02\x0c\x03\
    \x12\x04\xce\x01\x0f+\n\x0f\n\x05\x06\0\x02\x0c\x04\x12\x06\xcf\x01\x04\
    \xd2\x01\x06\n\x13\n\t\x06\0\x02\x0c\x04\xb0\xca\xbc\"\x12\x06\xcf\x01\
    \x04\xd2\x01\x06\n\x92\x02\n\x04\x06\0\x02\r\x12\x06\xda\x01\x02\xe0\x01\
    \x03\x1a\x81\x02\x20Enables\x20a\x20[service][google.api.servicemanageme\
    nt.v1.ManagedService]\x20for\x20a\n\x20project,\x20so\x20it\x20can\x20be\
    \x20used\x20for\x20the\x20project.\x20See\x20[Cloud\x20Auth\n\x20Guide](\
    https://cloud.google.com/docs/authentication)\x20for\x20more\x20informat\
    ion.\n\n\x20Operation<response:\x20EnableServiceResponse>\n\n\r\n\x05\
    \x06\0\x02\r\x01\x12\x04\xda\x01\x06\x13\n\r\n\x05\x06\0\x02\r\x02\x12\
    \x04\xda\x01\x14(\n\r\n\x05\x06\0\x02\r\x03\x12\x04\xdb\x01\x0f+\n\x0f\n\
    \x05\x06\0\x02\r\x04\x12\x06\xdc\x01\x04\xdf\x01\x06\n\x13\n\t\x06\0\x02\
    \r\x04\xb0\xca\xbc\"\x12\x06\xdc\x01\x04\xdf\x01\x06\n\xa1\x02\n\x04\x06\
    \0\x02\x0e\x12\x06\xe8\x01\x02\xee\x01\x03\x1a\x90\x02\x20Disables\x20a\
    \x20[service][google.api.servicemanagement.v1.ManagedService]\x20for\x20\
    a\n\x20project,\x20so\x20it\x20can\x20no\x20longer\x20be\x20be\x20used\
    \x20for\x20the\x20project.\x20It\x20prevents\n\x20accidental\x20usage\
    \x20that\x20may\x20cause\x20unexpected\x20billing\x20charges\x20or\x20se\
    curity\n\x20leaks.\n\n\x20Operation<response:\x20DisableServiceResponse>\
    \n\n\r\n\x05\x06\0\x02\x0e\x01\x12\x04\xe8\x01\x06\x14\n\r\n\x05\x06\0\
    \x02\x0e\x02\x12\x04\xe8\x01\x15*\n\r\n\x05\x06\0\x02\x0e\x03\x12\x04\
    \xe9\x01\x0f+\n\x0f\n\x05\x06\0\x02\x0e\x04\x12\x06\xea\x01\x04\xed\x01\
    \x06\n\x13\n\t\x06\0\x02\x0e\x04\xb0\xca\xbc\"\x12\x06\xea\x01\x04\xed\
    \x01\x06\n:\n\x02\x04\0\x12\x06\xf2\x01\0\x83\x02\x01\x1a,\x20Request\
    \x20message\x20for\x20`ListServices`\x20method.\n\n\x0b\n\x03\x04\0\x01\
    \x12\x04\xf2\x01\x08\x1b\nC\n\x04\x04\0\x02\0\x12\x04\xf4\x01\x02!\x1a5\
    \x20Include\x20services\x20produced\x20by\x20the\x20specified\x20project\
    .\n\n\x0f\n\x05\x04\0\x02\0\x04\x12\x06\xf4\x01\x02\xf2\x01\x1d\n\r\n\
    \x05\x04\0\x02\0\x05\x12\x04\xf4\x01\x02\x08\n\r\n\x05\x04\0\x02\0\x01\
    \x12\x04\xf4\x01\t\x1c\n\r\n\x05\x04\0\x02\0\x03\x12\x04\xf4\x01\x1f\x20\
    \n8\n\x04\x04\0\x02\x01\x12\x04\xf7\x01\x02\x16\x1a*\x20Requested\x20siz\
    e\x20of\x20the\x20next\x20page\x20of\x20data.\n\n\x0f\n\x05\x04\0\x02\
    \x01\x04\x12\x06\xf7\x01\x02\xf4\x01!\n\r\n\x05\x04\0\x02\x01\x05\x12\
    \x04\xf7\x01\x02\x07\n\r\n\x05\x04\0\x02\x01\x01\x12\x04\xf7\x01\x08\x11\
    \n\r\n\x05\x04\0\x02\x01\x03\x12\x04\xf7\x01\x14\x15\n`\n\x04\x04\0\x02\
    \x02\x12\x04\xfb\x01\x02\x18\x1aR\x20Token\x20identifying\x20which\x20re\
    sult\x20to\x20start\x20with;\x20returned\x20by\x20a\x20previous\x20list\
    \n\x20call.\n\n\x0f\n\x05\x04\0\x02\x02\x04\x12\x06\xfb\x01\x02\xf7\x01\
    \x16\n\r\n\x05\x04\0\x02\x02\x05\x12\x04\xfb\x01\x02\x08\n\r\n\x05\x04\0\
    \x02\x02\x01\x12\x04\xfb\x01\t\x13\n\r\n\x05\x04\0\x02\x02\x03\x12\x04\
    \xfb\x01\x16\x17\n\xaa\x01\n\x04\x04\0\x02\x03\x12\x04\x82\x02\x02\x19\
    \x1a\x9b\x01\x20Include\x20services\x20consumed\x20by\x20the\x20specifie\
    d\x20consumer.\n\n\x20The\x20Google\x20Service\x20Management\x20implemen\
    tation\x20accepts\x20the\x20following\n\x20forms:\n\x20-\x20project:<pro\
    ject_id>\n\n\x0f\n\x05\x04\0\x02\x03\x04\x12\x06\x82\x02\x02\xfb\x01\x18\
    \n\r\n\x05\x04\0\x02\x03\x05\x12\x04\x82\x02\x02\x08\n\r\n\x05\x04\0\x02\
    \x03\x01\x12\x04\x82\x02\t\x14\n\r\n\x05\x04\0\x02\x03\x03\x12\x04\x82\
    \x02\x17\x18\n;\n\x02\x04\x01\x12\x06\x86\x02\0\x8c\x02\x01\x1a-\x20Resp\
    onse\x20message\x20for\x20`ListServices`\x20method.\n\n\x0b\n\x03\x04\
    \x01\x01\x12\x04\x86\x02\x08\x1c\nH\n\x04\x04\x01\x02\0\x12\x04\x88\x02\
    \x02'\x1a:\x20The\x20returned\x20services\x20will\x20only\x20have\x20the\
    \x20name\x20field\x20set.\n\n\r\n\x05\x04\x01\x02\0\x04\x12\x04\x88\x02\
    \x02\n\n\r\n\x05\x04\x01\x02\0\x06\x12\x04\x88\x02\x0b\x19\n\r\n\x05\x04\
    \x01\x02\0\x01\x12\x04\x88\x02\x1a\"\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\
    \x88\x02%&\nW\n\x04\x04\x01\x02\x01\x12\x04\x8b\x02\x02\x1d\x1aI\x20Toke\
    n\x20that\x20can\x20be\x20passed\x20to\x20`ListServices`\x20to\x20resume\
    \x20a\x20paginated\x20query.\n\n\x0f\n\x05\x04\x01\x02\x01\x04\x12\x06\
    \x8b\x02\x02\x88\x02'\n\r\n\x05\x04\x01\x02\x01\x05\x12\x04\x8b\x02\x02\
    \x08\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\x8b\x02\t\x18\n\r\n\x05\x04\
    \x01\x02\x01\x03\x12\x04\x8b\x02\x1b\x1c\n8\n\x02\x04\x02\x12\x06\x8f\
    \x02\0\x93\x02\x01\x1a*\x20Request\x20message\x20for\x20`GetService`\x20\
    method.\n\n\x0b\n\x03\x04\x02\x01\x12\x04\x8f\x02\x08\x19\n\x8d\x01\n\
    \x04\x04\x02\x02\0\x12\x04\x92\x02\x02\x1a\x1a\x7f\x20The\x20name\x20of\
    \x20the\x20service.\x20\x20See\x20the\x20`ServiceManager`\x20overview\
    \x20for\x20naming\n\x20requirements.\x20\x20For\x20example:\x20`example.\
    googleapis.com`.\n\n\x0f\n\x05\x04\x02\x02\0\x04\x12\x06\x92\x02\x02\x8f\
    \x02\x1b\n\r\n\x05\x04\x02\x02\0\x05\x12\x04\x92\x02\x02\x08\n\r\n\x05\
    \x04\x02\x02\0\x01\x12\x04\x92\x02\t\x15\n\r\n\x05\x04\x02\x02\0\x03\x12\
    \x04\x92\x02\x18\x19\n9\n\x02\x04\x03\x12\x06\x96\x02\0\x99\x02\x01\x1a+\
    \x20Request\x20message\x20for\x20CreateService\x20method.\n\n\x0b\n\x03\
    \x04\x03\x01\x12\x04\x96\x02\x08\x1c\n8\n\x04\x04\x03\x02\0\x12\x04\x98\
    \x02\x02\x1d\x1a*\x20Initial\x20values\x20for\x20the\x20service\x20resou\
    rce.\n\n\x0f\n\x05\x04\x03\x02\0\x04\x12\x06\x98\x02\x02\x96\x02\x1e\n\r\
    \n\x05\x04\x03\x02\0\x06\x12\x04\x98\x02\x02\x10\n\r\n\x05\x04\x03\x02\0\
    \x01\x12\x04\x98\x02\x11\x18\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\x98\x02\
    \x1b\x1c\n9\n\x02\x04\x04\x12\x06\x9c\x02\0\xa0\x02\x01\x1a+\x20Request\
    \x20message\x20for\x20DeleteService\x20method.\n\n\x0b\n\x03\x04\x04\x01\
    \x12\x04\x9c\x02\x08\x1c\n\x9d\x01\n\x04\x04\x04\x02\0\x12\x04\x9f\x02\
    \x02\x1a\x1a\x8e\x01\x20The\x20name\x20of\x20the\x20service.\x20\x20See\
    \x20the\x20[overview](/service-management/overview)\n\x20for\x20naming\
    \x20requirements.\x20\x20For\x20example:\x20`example.googleapis.com`.\n\
    \n\x0f\n\x05\x04\x04\x02\0\x04\x12\x06\x9f\x02\x02\x9c\x02\x1e\n\r\n\x05\
    \x04\x04\x02\0\x05\x12\x04\x9f\x02\x02\x08\n\r\n\x05\x04\x04\x02\0\x01\
    \x12\x04\x9f\x02\t\x15\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\x9f\x02\x18\
    \x19\n;\n\x02\x04\x05\x12\x06\xa3\x02\0\xa7\x02\x01\x1a-\x20Request\x20m\
    essage\x20for\x20UndeleteService\x20method.\n\n\x0b\n\x03\x04\x05\x01\
    \x12\x04\xa3\x02\x08\x1e\n\x9b\x01\n\x04\x04\x05\x02\0\x12\x04\xa6\x02\
    \x02\x1a\x1a\x8c\x01\x20The\x20name\x20of\x20the\x20service.\x20See\x20t\
    he\x20[overview](/service-management/overview)\n\x20for\x20naming\x20req\
    uirements.\x20For\x20example:\x20`example.googleapis.com`.\n\n\x0f\n\x05\
    \x04\x05\x02\0\x04\x12\x06\xa6\x02\x02\xa3\x02\x20\n\r\n\x05\x04\x05\x02\
    \0\x05\x12\x04\xa6\x02\x02\x08\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xa6\
    \x02\t\x15\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xa6\x02\x18\x19\n<\n\x02\
    \x04\x06\x12\x06\xaa\x02\0\xad\x02\x01\x1a.\x20Response\x20message\x20fo\
    r\x20UndeleteService\x20method.\n\n\x0b\n\x03\x04\x06\x01\x12\x04\xaa\
    \x02\x08\x1f\n)\n\x04\x04\x06\x02\0\x12\x04\xac\x02\x02\x1d\x1a\x1b\x20R\
    evived\x20service\x20resource.\n\n\x0f\n\x05\x04\x06\x02\0\x04\x12\x06\
    \xac\x02\x02\xaa\x02!\n\r\n\x05\x04\x06\x02\0\x06\x12\x04\xac\x02\x02\
    \x10\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xac\x02\x11\x18\n\r\n\x05\x04\
    \x06\x02\0\x03\x12\x04\xac\x02\x1b\x1c\n<\n\x02\x04\x07\x12\x06\xb0\x02\
    \0\xc6\x02\x01\x1a.\x20Request\x20message\x20for\x20GetServiceConfig\x20\
    method.\n\n\x0b\n\x03\x04\x07\x01\x12\x04\xb0\x02\x08\x1f\n\x0e\n\x04\
    \x04\x07\x04\0\x12\x06\xb1\x02\x02\xba\x02\x03\n\r\n\x05\x04\x07\x04\0\
    \x01\x12\x04\xb1\x02\x07\x11\nH\n\x06\x04\x07\x04\0\x02\0\x12\x04\xb3\
    \x02\x04\x0e\x1a8\x20Server\x20response\x20includes\x20all\x20fields\x20\
    except\x20SourceInfo.\n\n\x0f\n\x07\x04\x07\x04\0\x02\0\x01\x12\x04\xb3\
    \x02\x04\t\n\x0f\n\x07\x04\x07\x04\0\x02\0\x02\x12\x04\xb3\x02\x0c\r\n\
    \xe4\x01\n\x06\x04\x07\x04\0\x02\x01\x12\x04\xb9\x02\x04\r\x1a\xd3\x01\
    \x20Server\x20response\x20includes\x20all\x20fields\x20including\x20Sour\
    ceInfo.\n\x20SourceFiles\x20are\x20of\x20type\x20'google.api.servicemana\
    gement.v1.ConfigFile'\n\x20and\x20are\x20only\x20available\x20for\x20con\
    figs\x20created\x20using\x20the\n\x20SubmitConfigSource\x20method.\n\n\
    \x0f\n\x07\x04\x07\x04\0\x02\x01\x01\x12\x04\xb9\x02\x04\x08\n\x0f\n\x07\
    \x04\x07\x04\0\x02\x01\x02\x12\x04\xb9\x02\x0b\x0c\n\x9d\x01\n\x04\x04\
    \x07\x02\0\x12\x04\xbe\x02\x02\x1a\x1a\x8e\x01\x20The\x20name\x20of\x20t\
    he\x20service.\x20\x20See\x20the\x20[overview](/service-management/overv\
    iew)\n\x20for\x20naming\x20requirements.\x20\x20For\x20example:\x20`exam\
    ple.googleapis.com`.\n\n\x0f\n\x05\x04\x07\x02\0\x04\x12\x06\xbe\x02\x02\
    \xba\x02\x03\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\xbe\x02\x02\x08\n\r\n\
    \x05\x04\x07\x02\0\x01\x12\x04\xbe\x02\t\x15\n\r\n\x05\x04\x07\x02\0\x03\
    \x12\x04\xbe\x02\x18\x19\n=\n\x04\x04\x07\x02\x01\x12\x04\xc1\x02\x02\
    \x17\x1a/\x20The\x20id\x20of\x20the\x20service\x20configuration\x20resou\
    rce.\n\n\x0f\n\x05\x04\x07\x02\x01\x04\x12\x06\xc1\x02\x02\xbe\x02\x1a\n\
    \r\n\x05\x04\x07\x02\x01\x05\x12\x04\xc1\x02\x02\x08\n\r\n\x05\x04\x07\
    \x02\x01\x01\x12\x04\xc1\x02\t\x12\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\
    \xc1\x02\x15\x16\n`\n\x04\x04\x07\x02\x02\x12\x04\xc5\x02\x02\x16\x1aR\
    \x20Specifies\x20which\x20parts\x20of\x20the\x20Service\x20Config\x20sho\
    uld\x20be\x20returned\x20in\x20the\n\x20response.\n\n\x0f\n\x05\x04\x07\
    \x02\x02\x04\x12\x06\xc5\x02\x02\xc1\x02\x17\n\r\n\x05\x04\x07\x02\x02\
    \x06\x12\x04\xc5\x02\x02\x0c\n\r\n\x05\x04\x07\x02\x02\x01\x12\x04\xc5\
    \x02\r\x11\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\xc5\x02\x14\x15\n>\n\
    \x02\x04\x08\x12\x06\xc9\x02\0\xd3\x02\x01\x1a0\x20Request\x20message\
    \x20for\x20ListServiceConfigs\x20method.\n\n\x0b\n\x03\x04\x08\x01\x12\
    \x04\xc9\x02\x08!\n\x9d\x01\n\x04\x04\x08\x02\0\x12\x04\xcc\x02\x02\x1a\
    \x1a\x8e\x01\x20The\x20name\x20of\x20the\x20service.\x20\x20See\x20the\
    \x20[overview](/service-management/overview)\n\x20for\x20naming\x20requi\
    rements.\x20\x20For\x20example:\x20`example.googleapis.com`.\n\n\x0f\n\
    \x05\x04\x08\x02\0\x04\x12\x06\xcc\x02\x02\xc9\x02#\n\r\n\x05\x04\x08\
    \x02\0\x05\x12\x04\xcc\x02\x02\x08\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\
    \xcc\x02\t\x15\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xcc\x02\x18\x19\n2\n\
    \x04\x04\x08\x02\x01\x12\x04\xcf\x02\x02\x18\x1a$\x20The\x20token\x20of\
    \x20the\x20page\x20to\x20retrieve.\n\n\x0f\n\x05\x04\x08\x02\x01\x04\x12\
    \x06\xcf\x02\x02\xcc\x02\x1a\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\xcf\
    \x02\x02\x08\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xcf\x02\t\x13\n\r\n\
    \x05\x04\x08\x02\x01\x03\x12\x04\xcf\x02\x16\x17\nH\n\x04\x04\x08\x02\
    \x02\x12\x04\xd2\x02\x02\x16\x1a:\x20The\x20max\x20number\x20of\x20items\
    \x20to\x20include\x20in\x20the\x20response\x20list.\n\n\x0f\n\x05\x04\
    \x08\x02\x02\x04\x12\x06\xd2\x02\x02\xcf\x02\x18\n\r\n\x05\x04\x08\x02\
    \x02\x05\x12\x04\xd2\x02\x02\x07\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\
    \xd2\x02\x08\x11\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\xd2\x02\x14\x15\n\
    ?\n\x02\x04\t\x12\x06\xd6\x02\0\xdc\x02\x01\x1a1\x20Response\x20message\
    \x20for\x20ListServiceConfigs\x20method.\n\n\x0b\n\x03\x04\t\x01\x12\x04\
    \xd6\x02\x08\"\n<\n\x04\x04\t\x02\0\x12\x04\xd8\x02\x022\x1a.\x20The\x20\
    list\x20of\x20service\x20configuration\x20resources.\n\n\r\n\x05\x04\t\
    \x02\0\x04\x12\x04\xd8\x02\x02\n\n\r\n\x05\x04\t\x02\0\x06\x12\x04\xd8\
    \x02\x0b\x1d\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xd8\x02\x1e-\n\r\n\x05\
    \x04\t\x02\0\x03\x12\x04\xd8\x0201\n6\n\x04\x04\t\x02\x01\x12\x04\xdb\
    \x02\x02\x1d\x1a(\x20The\x20token\x20of\x20the\x20next\x20page\x20of\x20\
    results.\n\n\x0f\n\x05\x04\t\x02\x01\x04\x12\x06\xdb\x02\x02\xd8\x022\n\
    \r\n\x05\x04\t\x02\x01\x05\x12\x04\xdb\x02\x02\x08\n\r\n\x05\x04\t\x02\
    \x01\x01\x12\x04\xdb\x02\t\x18\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xdb\
    \x02\x1b\x1c\n?\n\x02\x04\n\x12\x06\xdf\x02\0\xe6\x02\x01\x1a1\x20Reques\
    t\x20message\x20for\x20CreateServiceConfig\x20method.\n\n\x0b\n\x03\x04\
    \n\x01\x12\x04\xdf\x02\x08\"\n\x9d\x01\n\x04\x04\n\x02\0\x12\x04\xe2\x02\
    \x02\x1a\x1a\x8e\x01\x20The\x20name\x20of\x20the\x20service.\x20\x20See\
    \x20the\x20[overview](/service-management/overview)\n\x20for\x20naming\
    \x20requirements.\x20\x20For\x20example:\x20`example.googleapis.com`.\n\
    \n\x0f\n\x05\x04\n\x02\0\x04\x12\x06\xe2\x02\x02\xdf\x02$\n\r\n\x05\x04\
    \n\x02\0\x05\x12\x04\xe2\x02\x02\x08\n\r\n\x05\x04\n\x02\0\x01\x12\x04\
    \xe2\x02\t\x15\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xe2\x02\x18\x19\n3\n\
    \x04\x04\n\x02\x01\x12\x04\xe5\x02\x02(\x1a%\x20The\x20service\x20config\
    uration\x20resource.\n\n\x0f\n\x05\x04\n\x02\x01\x04\x12\x06\xe5\x02\x02\
    \xe2\x02\x1a\n\r\n\x05\x04\n\x02\x01\x06\x12\x04\xe5\x02\x02\x14\n\r\n\
    \x05\x04\n\x02\x01\x01\x12\x04\xe5\x02\x15#\n\r\n\x05\x04\n\x02\x01\x03\
    \x12\x04\xe5\x02&'\n>\n\x02\x04\x0b\x12\x06\xe9\x02\0\xf5\x02\x01\x1a0\
    \x20Request\x20message\x20for\x20SubmitConfigSource\x20method.\n\n\x0b\n\
    \x03\x04\x0b\x01\x12\x04\xe9\x02\x08!\n\x9d\x01\n\x04\x04\x0b\x02\0\x12\
    \x04\xec\x02\x02\x1a\x1a\x8e\x01\x20The\x20name\x20of\x20the\x20service.\
    \x20\x20See\x20the\x20[overview](/service-management/overview)\n\x20for\
    \x20naming\x20requirements.\x20\x20For\x20example:\x20`example.googleapi\
    s.com`.\n\n\x0f\n\x05\x04\x0b\x02\0\x04\x12\x06\xec\x02\x02\xe9\x02#\n\r\
    \n\x05\x04\x0b\x02\0\x05\x12\x04\xec\x02\x02\x08\n\r\n\x05\x04\x0b\x02\0\
    \x01\x12\x04\xec\x02\t\x15\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xec\x02\
    \x18\x19\n9\n\x04\x04\x0b\x02\x01\x12\x04\xef\x02\x02!\x1a+\x20The\x20so\
    urce\x20configuration\x20for\x20the\x20service.\n\n\x0f\n\x05\x04\x0b\
    \x02\x01\x04\x12\x06\xef\x02\x02\xec\x02\x1a\n\r\n\x05\x04\x0b\x02\x01\
    \x06\x12\x04\xef\x02\x02\x0e\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xef\
    \x02\x0f\x1c\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\xef\x02\x1f\x20\n\xd5\
    \x01\n\x04\x04\x0b\x02\x02\x12\x04\xf4\x02\x02\x19\x1a\xc6\x01\x20Option\
    al.\x20If\x20set,\x20this\x20will\x20result\x20in\x20the\x20generation\
    \x20of\x20a\n\x20`google.api.Service`\x20configuration\x20based\x20on\
    \x20the\x20`ConfigSource`\x20provided,\n\x20but\x20the\x20generated\x20c\
    onfig\x20and\x20the\x20sources\x20will\x20NOT\x20be\x20persisted.\n\n\
    \x0f\n\x05\x04\x0b\x02\x02\x04\x12\x06\xf4\x02\x02\xef\x02!\n\r\n\x05\
    \x04\x0b\x02\x02\x05\x12\x04\xf4\x02\x02\x06\n\r\n\x05\x04\x0b\x02\x02\
    \x01\x12\x04\xf4\x02\x07\x14\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\xf4\
    \x02\x17\x18\n?\n\x02\x04\x0c\x12\x06\xf8\x02\0\xfb\x02\x01\x1a1\x20Resp\
    onse\x20message\x20for\x20SubmitConfigSource\x20method.\n\n\x0b\n\x03\
    \x04\x0c\x01\x12\x04\xf8\x02\x08\"\n4\n\x04\x04\x0c\x02\0\x12\x04\xfa\
    \x02\x02(\x1a&\x20The\x20generated\x20service\x20configuration.\n\n\x0f\
    \n\x05\x04\x0c\x02\0\x04\x12\x06\xfa\x02\x02\xf8\x02$\n\r\n\x05\x04\x0c\
    \x02\0\x06\x12\x04\xfa\x02\x02\x14\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\
    \xfa\x02\x15#\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xfa\x02&'\n:\n\x02\x04\
    \r\x12\x06\xfe\x02\0\x85\x03\x01\x1a,\x20Request\x20message\x20for\x20'C\
    reateServiceRollout'\n\n\x0b\n\x03\x04\r\x01\x12\x04\xfe\x02\x08#\n\x9d\
    \x01\n\x04\x04\r\x02\0\x12\x04\x81\x03\x02\x1a\x1a\x8e\x01\x20The\x20nam\
    e\x20of\x20the\x20service.\x20\x20See\x20the\x20[overview](/service-mana\
    gement/overview)\n\x20for\x20naming\x20requirements.\x20\x20For\x20examp\
    le:\x20`example.googleapis.com`.\n\n\x0f\n\x05\x04\r\x02\0\x04\x12\x06\
    \x81\x03\x02\xfe\x02%\n\r\n\x05\x04\r\x02\0\x05\x12\x04\x81\x03\x02\x08\
    \n\r\n\x05\x04\r\x02\0\x01\x12\x04\x81\x03\t\x15\n\r\n\x05\x04\r\x02\0\
    \x03\x12\x04\x81\x03\x18\x19\nN\n\x04\x04\r\x02\x01\x12\x04\x84\x03\x02\
    \x16\x1a@\x20The\x20rollout\x20resource.\x20The\x20`service_name`\x20fie\
    ld\x20is\x20output\x20only.\n\n\x0f\n\x05\x04\r\x02\x01\x04\x12\x06\x84\
    \x03\x02\x81\x03\x1a\n\r\n\x05\x04\r\x02\x01\x06\x12\x04\x84\x03\x02\t\n\
    \r\n\x05\x04\r\x02\x01\x01\x12\x04\x84\x03\n\x11\n\r\n\x05\x04\r\x02\x01\
    \x03\x12\x04\x84\x03\x14\x15\n9\n\x02\x04\x0e\x12\x06\x88\x03\0\x9c\x03\
    \x01\x1a+\x20Request\x20message\x20for\x20'ListServiceRollouts'\n\n\x0b\
    \n\x03\x04\x0e\x01\x12\x04\x88\x03\x08\"\n\x9d\x01\n\x04\x04\x0e\x02\0\
    \x12\x04\x8b\x03\x02\x1a\x1a\x8e\x01\x20The\x20name\x20of\x20the\x20serv\
    ice.\x20\x20See\x20the\x20[overview](/service-management/overview)\n\x20\
    for\x20naming\x20requirements.\x20\x20For\x20example:\x20`example.google\
    apis.com`.\n\n\x0f\n\x05\x04\x0e\x02\0\x04\x12\x06\x8b\x03\x02\x88\x03$\
    \n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\x8b\x03\x02\x08\n\r\n\x05\x04\x0e\
    \x02\0\x01\x12\x04\x8b\x03\t\x15\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\x8b\
    \x03\x18\x19\n2\n\x04\x04\x0e\x02\x01\x12\x04\x8e\x03\x02\x18\x1a$\x20Th\
    e\x20token\x20of\x20the\x20page\x20to\x20retrieve.\n\n\x0f\n\x05\x04\x0e\
    \x02\x01\x04\x12\x06\x8e\x03\x02\x8b\x03\x1a\n\r\n\x05\x04\x0e\x02\x01\
    \x05\x12\x04\x8e\x03\x02\x08\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\x8e\
    \x03\t\x13\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\x8e\x03\x16\x17\nH\n\
    \x04\x04\x0e\x02\x02\x12\x04\x91\x03\x02\x16\x1a:\x20The\x20max\x20numbe\
    r\x20of\x20items\x20to\x20include\x20in\x20the\x20response\x20list.\n\n\
    \x0f\n\x05\x04\x0e\x02\x02\x04\x12\x06\x91\x03\x02\x8e\x03\x18\n\r\n\x05\
    \x04\x0e\x02\x02\x05\x12\x04\x91\x03\x02\x07\n\r\n\x05\x04\x0e\x02\x02\
    \x01\x12\x04\x91\x03\x08\x11\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\x91\
    \x03\x14\x15\n\xab\x03\n\x04\x04\x0e\x02\x03\x12\x04\x9b\x03\x02\x14\x1a\
    \x9c\x03\x20Use\x20`filter`\x20to\x20return\x20subset\x20of\x20rollouts.\
    \n\x20The\x20following\x20filters\x20are\x20supported:\n\x20\x20\x20--\
    \x20To\x20limit\x20the\x20results\x20to\x20only\x20those\x20in\n\x20\x20\
    \x20\x20\x20\x20[status](google.api.servicemanagement.v1.RolloutStatus)\
    \x20'SUCCESS',\n\x20\x20\x20\x20\x20\x20use\x20filter='status=SUCCESS'\n\
    \x20\x20\x20--\x20To\x20limit\x20the\x20results\x20to\x20those\x20in\n\
    \x20\x20\x20\x20\x20\x20[status](google.api.servicemanagement.v1.Rollout\
    Status)\x20'CANCELLED'\n\x20\x20\x20\x20\x20\x20or\x20'FAILED',\x20use\
    \x20filter='status=CANCELLED\x20OR\x20status=FAILED'\n\n\x0f\n\x05\x04\
    \x0e\x02\x03\x04\x12\x06\x9b\x03\x02\x91\x03\x16\n\r\n\x05\x04\x0e\x02\
    \x03\x05\x12\x04\x9b\x03\x02\x08\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\
    \x9b\x03\t\x0f\n\r\n\x05\x04\x0e\x02\x03\x03\x12\x04\x9b\x03\x12\x13\n@\
    \n\x02\x04\x0f\x12\x06\x9f\x03\0\xa5\x03\x01\x1a2\x20Response\x20message\
    \x20for\x20ListServiceRollouts\x20method.\n\n\x0b\n\x03\x04\x0f\x01\x12\
    \x04\x9f\x03\x08#\n.\n\x04\x04\x0f\x02\0\x12\x04\xa1\x03\x02\x20\x1a\x20\
    \x20The\x20list\x20of\x20rollout\x20resources.\n\n\r\n\x05\x04\x0f\x02\0\
    \x04\x12\x04\xa1\x03\x02\n\n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\xa1\x03\
    \x0b\x12\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xa1\x03\x13\x1b\n\r\n\x05\
    \x04\x0f\x02\0\x03\x12\x04\xa1\x03\x1e\x1f\n6\n\x04\x04\x0f\x02\x01\x12\
    \x04\xa4\x03\x02\x1d\x1a(\x20The\x20token\x20of\x20the\x20next\x20page\
    \x20of\x20results.\n\n\x0f\n\x05\x04\x0f\x02\x01\x04\x12\x06\xa4\x03\x02\
    \xa1\x03\x20\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\xa4\x03\x02\x08\n\r\n\
    \x05\x04\x0f\x02\x01\x01\x12\x04\xa4\x03\t\x18\n\r\n\x05\x04\x0f\x02\x01\
    \x03\x12\x04\xa4\x03\x1b\x1c\n=\n\x02\x04\x10\x12\x06\xa8\x03\0\xaf\x03\
    \x01\x1a/\x20Request\x20message\x20for\x20GetServiceRollout\x20method.\n\
    \n\x0b\n\x03\x04\x10\x01\x12\x04\xa8\x03\x08\x20\n\x9d\x01\n\x04\x04\x10\
    \x02\0\x12\x04\xab\x03\x02\x1a\x1a\x8e\x01\x20The\x20name\x20of\x20the\
    \x20service.\x20\x20See\x20the\x20[overview](/service-management/overvie\
    w)\n\x20for\x20naming\x20requirements.\x20\x20For\x20example:\x20`exampl\
    e.googleapis.com`.\n\n\x0f\n\x05\x04\x10\x02\0\x04\x12\x06\xab\x03\x02\
    \xa8\x03\"\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xab\x03\x02\x08\n\r\n\x05\
    \x04\x10\x02\0\x01\x12\x04\xab\x03\t\x15\n\r\n\x05\x04\x10\x02\0\x03\x12\
    \x04\xab\x03\x18\x19\n/\n\x04\x04\x10\x02\x01\x12\x04\xae\x03\x02\x18\
    \x1a!\x20The\x20id\x20of\x20the\x20rollout\x20resource.\n\n\x0f\n\x05\
    \x04\x10\x02\x01\x04\x12\x06\xae\x03\x02\xab\x03\x1a\n\r\n\x05\x04\x10\
    \x02\x01\x05\x12\x04\xae\x03\x02\x08\n\r\n\x05\x04\x10\x02\x01\x01\x12\
    \x04\xae\x03\t\x13\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xae\x03\x16\x17\
    \n9\n\x02\x04\x11\x12\x06\xb2\x03\0\xc1\x03\x01\x1a+\x20Request\x20messa\
    ge\x20for\x20EnableService\x20method.\n\n\x0b\n\x03\x04\x11\x01\x12\x04\
    \xb2\x03\x08\x1c\nr\n\x04\x04\x11\x02\0\x12\x04\xb5\x03\x02\x1a\x1ad\x20\
    Name\x20of\x20the\x20service\x20to\x20enable.\x20Specifying\x20an\x20unk\
    nown\x20service\x20name\x20will\n\x20cause\x20the\x20request\x20to\x20fa\
    il.\n\n\x0f\n\x05\x04\x11\x02\0\x04\x12\x06\xb5\x03\x02\xb2\x03\x1e\n\r\
    \n\x05\x04\x11\x02\0\x05\x12\x04\xb5\x03\x02\x08\n\r\n\x05\x04\x11\x02\0\
    \x01\x12\x04\xb5\x03\t\x15\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xb5\x03\
    \x18\x19\n\xa1\x02\n\x04\x04\x11\x02\x01\x12\x04\xc0\x03\x02\x19\x1a\x92\
    \x02\x20The\x20identity\x20of\x20consumer\x20resource\x20which\x20servic\
    e\x20enablement\x20will\x20be\n\x20applied\x20to.\n\n\x20The\x20Google\
    \x20Service\x20Management\x20implementation\x20accepts\x20the\x20followi\
    ng\n\x20forms:\n\x20-\x20\"project:<project_id>\"\n\n\x20Note:\x20this\
    \x20is\x20made\x20compatible\x20with\n\x20google.api.servicecontrol.v1.O\
    peration.consumer_id.\n\n\x0f\n\x05\x04\x11\x02\x01\x04\x12\x06\xc0\x03\
    \x02\xb5\x03\x1a\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\xc0\x03\x02\x08\n\
    \r\n\x05\x04\x11\x02\x01\x01\x12\x04\xc0\x03\t\x14\n\r\n\x05\x04\x11\x02\
    \x01\x03\x12\x04\xc0\x03\x17\x18\n:\n\x02\x04\x12\x12\x06\xc4\x03\0\xd3\
    \x03\x01\x1a,\x20Request\x20message\x20for\x20DisableService\x20method.\
    \n\n\x0b\n\x03\x04\x12\x01\x12\x04\xc4\x03\x08\x1d\ns\n\x04\x04\x12\x02\
    \0\x12\x04\xc7\x03\x02\x1a\x1ae\x20Name\x20of\x20the\x20service\x20to\
    \x20disable.\x20Specifying\x20an\x20unknown\x20service\x20name\n\x20will\
    \x20cause\x20the\x20request\x20to\x20fail.\n\n\x0f\n\x05\x04\x12\x02\0\
    \x04\x12\x06\xc7\x03\x02\xc4\x03\x1f\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\
    \xc7\x03\x02\x08\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xc7\x03\t\x15\n\r\n\
    \x05\x04\x12\x02\0\x03\x12\x04\xc7\x03\x18\x19\n\xa2\x02\n\x04\x04\x12\
    \x02\x01\x12\x04\xd2\x03\x02\x19\x1a\x93\x02\x20The\x20identity\x20of\
    \x20consumer\x20resource\x20which\x20service\x20disablement\x20will\x20b\
    e\n\x20applied\x20to.\n\n\x20The\x20Google\x20Service\x20Management\x20i\
    mplementation\x20accepts\x20the\x20following\n\x20forms:\n\x20-\x20\"pro\
    ject:<project_id>\"\n\n\x20Note:\x20this\x20is\x20made\x20compatible\x20\
    with\n\x20google.api.servicecontrol.v1.Operation.consumer_id.\n\n\x0f\n\
    \x05\x04\x12\x02\x01\x04\x12\x06\xd2\x03\x02\xc7\x03\x1a\n\r\n\x05\x04\
    \x12\x02\x01\x05\x12\x04\xd2\x03\x02\x08\n\r\n\x05\x04\x12\x02\x01\x01\
    \x12\x04\xd2\x03\t\x14\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\xd2\x03\x17\
    \x18\n@\n\x02\x04\x13\x12\x06\xd6\x03\0\xe4\x03\x01\x1a2\x20Request\x20m\
    essage\x20for\x20GenerateConfigReport\x20method.\n\n\x0b\n\x03\x04\x13\
    \x01\x12\x04\xd6\x03\x08#\n\xe8\x02\n\x04\x04\x13\x02\0\x12\x04\xdc\x03\
    \x02%\x1a\xd9\x02\x20Service\x20configuration\x20for\x20which\x20we\x20w\
    ant\x20to\x20generate\x20the\x20report.\n\x20For\x20this\x20version\x20o\
    f\x20API,\x20the\x20supported\x20types\x20are\n\x20[google.api.servicema\
    nagement.v1.ConfigRef][google.api.servicemanagement.v1.ConfigRef],\n\x20\
    [google.api.servicemanagement.v1.ConfigSource][google.api.servicemanagem\
    ent.v1.ConfigSource],\n\x20and\x20[google.api.Service][google.api.Servic\
    e]\n\n\x0f\n\x05\x04\x13\x02\0\x04\x12\x06\xdc\x03\x02\xd6\x03%\n\r\n\
    \x05\x04\x13\x02\0\x06\x12\x04\xdc\x03\x02\x15\n\r\n\x05\x04\x13\x02\0\
    \x01\x12\x04\xdc\x03\x16\x20\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xdc\x03\
    #$\n\xe9\x02\n\x04\x04\x13\x02\x01\x12\x04\xe3\x03\x02%\x1a\xda\x02\x20S\
    ervice\x20configuration\x20against\x20which\x20the\x20comparison\x20will\
    \x20be\x20done.\n\x20For\x20this\x20version\x20of\x20API,\x20the\x20supp\
    orted\x20types\x20are\n\x20[google.api.servicemanagement.v1.ConfigRef][g\
    oogle.api.servicemanagement.v1.ConfigRef],\n\x20[google.api.servicemanag\
    ement.v1.ConfigSource][google.api.servicemanagement.v1.ConfigSource],\n\
    \x20and\x20[google.api.Service][google.api.Service]\n\n\x0f\n\x05\x04\
    \x13\x02\x01\x04\x12\x06\xe3\x03\x02\xdc\x03%\n\r\n\x05\x04\x13\x02\x01\
    \x06\x12\x04\xe3\x03\x02\x15\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xe3\
    \x03\x16\x20\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\xe3\x03#$\nA\n\x02\
    \x04\x14\x12\x06\xe7\x03\0\xf6\x03\x01\x1a3\x20Response\x20message\x20fo\
    r\x20GenerateConfigReport\x20method.\n\n\x0b\n\x03\x04\x14\x01\x12\x04\
    \xe7\x03\x08$\n;\n\x04\x04\x14\x02\0\x12\x04\xe9\x03\x02\x1a\x1a-\x20Nam\
    e\x20of\x20the\x20service\x20this\x20report\x20belongs\x20to.\n\n\x0f\n\
    \x05\x04\x14\x02\0\x04\x12\x06\xe9\x03\x02\xe7\x03&\n\r\n\x05\x04\x14\
    \x02\0\x05\x12\x04\xe9\x03\x02\x08\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\
    \xe9\x03\t\x15\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xe9\x03\x18\x19\nG\n\
    \x04\x04\x14\x02\x01\x12\x04\xec\x03\x02\x10\x1a9\x20ID\x20of\x20the\x20\
    service\x20configuration\x20this\x20report\x20belongs\x20to.\n\n\x0f\n\
    \x05\x04\x14\x02\x01\x04\x12\x06\xec\x03\x02\xe9\x03\x1a\n\r\n\x05\x04\
    \x14\x02\x01\x05\x12\x04\xec\x03\x02\x08\n\r\n\x05\x04\x14\x02\x01\x01\
    \x12\x04\xec\x03\t\x0b\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\xec\x03\x0e\
    \x0f\nk\n\x04\x04\x14\x02\x02\x12\x04\xf0\x03\x02+\x1a]\x20list\x20of\
    \x20ChangeReport,\x20each\x20corresponding\x20to\x20comparison\x20betwee\
    n\x20two\n\x20service\x20configurations.\n\n\r\n\x05\x04\x14\x02\x02\x04\
    \x12\x04\xf0\x03\x02\n\n\r\n\x05\x04\x14\x02\x02\x06\x12\x04\xf0\x03\x0b\
    \x17\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\xf0\x03\x18&\n\r\n\x05\x04\
    \x14\x02\x02\x03\x12\x04\xf0\x03)*\ni\n\x04\x04\x14\x02\x03\x12\x04\xf5\
    \x03\x02&\x1a[\x20Errors\x20/\x20Linter\x20warnings\x20associated\x20wit\
    h\x20the\x20service\x20definition\x20this\n\x20report\n\x20belongs\x20to\
    .\n\n\r\n\x05\x04\x14\x02\x03\x04\x12\x04\xf5\x03\x02\n\n\r\n\x05\x04\
    \x14\x02\x03\x06\x12\x04\xf5\x03\x0b\x15\n\r\n\x05\x04\x14\x02\x03\x01\
    \x12\x04\xf5\x03\x16!\n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\xf5\x03$%b\
    \x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
