// This file is generated by rust-protobuf 2.22.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/api/servicemanagement/v1/resources.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_22_0;

#[derive(PartialEq,Clone,Default)]
pub struct ManagedService {
    // message fields
    pub service_name: ::std::string::String,
    pub producer_project_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ManagedService {
    fn default() -> &'a ManagedService {
        <ManagedService as ::protobuf::Message>::default_instance()
    }
}

impl ManagedService {
    pub fn new() -> ManagedService {
        ::std::default::Default::default()
    }

    // string service_name = 2;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }

    // string producer_project_id = 3;


    pub fn get_producer_project_id(&self) -> &str {
        &self.producer_project_id
    }
    pub fn clear_producer_project_id(&mut self) {
        self.producer_project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_producer_project_id(&mut self, v: ::std::string::String) {
        self.producer_project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_producer_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.producer_project_id
    }

    // Take field
    pub fn take_producer_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.producer_project_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ManagedService {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.producer_project_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.service_name);
        }
        if !self.producer_project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.producer_project_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(2, &self.service_name)?;
        }
        if !self.producer_project_id.is_empty() {
            os.write_string(3, &self.producer_project_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ManagedService {
        ManagedService::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &ManagedService| { &m.service_name },
                |m: &mut ManagedService| { &mut m.service_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "producer_project_id",
                |m: &ManagedService| { &m.producer_project_id },
                |m: &mut ManagedService| { &mut m.producer_project_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ManagedService>(
                "ManagedService",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ManagedService {
        static instance: ::protobuf::rt::LazyV2<ManagedService> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ManagedService::new)
    }
}

impl ::protobuf::Clear for ManagedService {
    fn clear(&mut self) {
        self.service_name.clear();
        self.producer_project_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ManagedService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ManagedService {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OperationMetadata {
    // message fields
    pub resource_names: ::protobuf::RepeatedField<::std::string::String>,
    pub steps: ::protobuf::RepeatedField<OperationMetadata_Step>,
    pub progress_percentage: i32,
    pub start_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OperationMetadata {
    fn default() -> &'a OperationMetadata {
        <OperationMetadata as ::protobuf::Message>::default_instance()
    }
}

impl OperationMetadata {
    pub fn new() -> OperationMetadata {
        ::std::default::Default::default()
    }

    // repeated string resource_names = 1;


    pub fn get_resource_names(&self) -> &[::std::string::String] {
        &self.resource_names
    }
    pub fn clear_resource_names(&mut self) {
        self.resource_names.clear();
    }

    // Param is passed by value, moved
    pub fn set_resource_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.resource_names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resource_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.resource_names
    }

    // Take field
    pub fn take_resource_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.resource_names, ::protobuf::RepeatedField::new())
    }

    // repeated .google.api.servicemanagement.v1.OperationMetadata.Step steps = 2;


    pub fn get_steps(&self) -> &[OperationMetadata_Step] {
        &self.steps
    }
    pub fn clear_steps(&mut self) {
        self.steps.clear();
    }

    // Param is passed by value, moved
    pub fn set_steps(&mut self, v: ::protobuf::RepeatedField<OperationMetadata_Step>) {
        self.steps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steps(&mut self) -> &mut ::protobuf::RepeatedField<OperationMetadata_Step> {
        &mut self.steps
    }

    // Take field
    pub fn take_steps(&mut self) -> ::protobuf::RepeatedField<OperationMetadata_Step> {
        ::std::mem::replace(&mut self.steps, ::protobuf::RepeatedField::new())
    }

    // int32 progress_percentage = 3;


    pub fn get_progress_percentage(&self) -> i32 {
        self.progress_percentage
    }
    pub fn clear_progress_percentage(&mut self) {
        self.progress_percentage = 0;
    }

    // Param is passed by value, moved
    pub fn set_progress_percentage(&mut self, v: i32) {
        self.progress_percentage = v;
    }

    // .google.protobuf.Timestamp start_time = 4;


    pub fn get_start_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.start_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_start_time(&mut self) {
        self.start_time.clear();
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.start_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.start_time.is_none() {
            self.start_time.set_default();
        }
        self.start_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.start_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for OperationMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.steps {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.start_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.resource_names)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.steps)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.progress_percentage = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.resource_names {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.steps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.progress_percentage != 0 {
            my_size += ::protobuf::rt::value_size(3, self.progress_percentage, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.resource_names {
            os.write_string(1, &v)?;
        };
        for v in &self.steps {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.progress_percentage != 0 {
            os.write_int32(3, self.progress_percentage)?;
        }
        if let Some(ref v) = self.start_time.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OperationMetadata {
        OperationMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resource_names",
                |m: &OperationMetadata| { &m.resource_names },
                |m: &mut OperationMetadata| { &mut m.resource_names },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OperationMetadata_Step>>(
                "steps",
                |m: &OperationMetadata| { &m.steps },
                |m: &mut OperationMetadata| { &mut m.steps },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "progress_percentage",
                |m: &OperationMetadata| { &m.progress_percentage },
                |m: &mut OperationMetadata| { &mut m.progress_percentage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "start_time",
                |m: &OperationMetadata| { &m.start_time },
                |m: &mut OperationMetadata| { &mut m.start_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OperationMetadata>(
                "OperationMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OperationMetadata {
        static instance: ::protobuf::rt::LazyV2<OperationMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OperationMetadata::new)
    }
}

impl ::protobuf::Clear for OperationMetadata {
    fn clear(&mut self) {
        self.resource_names.clear();
        self.steps.clear();
        self.progress_percentage = 0;
        self.start_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OperationMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OperationMetadata_Step {
    // message fields
    pub description: ::std::string::String,
    pub status: OperationMetadata_Status,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OperationMetadata_Step {
    fn default() -> &'a OperationMetadata_Step {
        <OperationMetadata_Step as ::protobuf::Message>::default_instance()
    }
}

impl OperationMetadata_Step {
    pub fn new() -> OperationMetadata_Step {
        ::std::default::Default::default()
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .google.api.servicemanagement.v1.OperationMetadata.Status status = 4;


    pub fn get_status(&self) -> OperationMetadata_Status {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = OperationMetadata_Status::STATUS_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: OperationMetadata_Status) {
        self.status = v;
    }
}

impl ::protobuf::Message for OperationMetadata_Step {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if self.status != OperationMetadata_Status::STATUS_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.status);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if self.status != OperationMetadata_Status::STATUS_UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OperationMetadata_Step {
        OperationMetadata_Step::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &OperationMetadata_Step| { &m.description },
                |m: &mut OperationMetadata_Step| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OperationMetadata_Status>>(
                "status",
                |m: &OperationMetadata_Step| { &m.status },
                |m: &mut OperationMetadata_Step| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OperationMetadata_Step>(
                "OperationMetadata.Step",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OperationMetadata_Step {
        static instance: ::protobuf::rt::LazyV2<OperationMetadata_Step> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OperationMetadata_Step::new)
    }
}

impl ::protobuf::Clear for OperationMetadata_Step {
    fn clear(&mut self) {
        self.description.clear();
        self.status = OperationMetadata_Status::STATUS_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OperationMetadata_Step {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationMetadata_Step {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OperationMetadata_Status {
    STATUS_UNSPECIFIED = 0,
    DONE = 1,
    NOT_STARTED = 2,
    IN_PROGRESS = 3,
    FAILED = 4,
    CANCELLED = 5,
}

impl ::protobuf::ProtobufEnum for OperationMetadata_Status {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OperationMetadata_Status> {
        match value {
            0 => ::std::option::Option::Some(OperationMetadata_Status::STATUS_UNSPECIFIED),
            1 => ::std::option::Option::Some(OperationMetadata_Status::DONE),
            2 => ::std::option::Option::Some(OperationMetadata_Status::NOT_STARTED),
            3 => ::std::option::Option::Some(OperationMetadata_Status::IN_PROGRESS),
            4 => ::std::option::Option::Some(OperationMetadata_Status::FAILED),
            5 => ::std::option::Option::Some(OperationMetadata_Status::CANCELLED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OperationMetadata_Status] = &[
            OperationMetadata_Status::STATUS_UNSPECIFIED,
            OperationMetadata_Status::DONE,
            OperationMetadata_Status::NOT_STARTED,
            OperationMetadata_Status::IN_PROGRESS,
            OperationMetadata_Status::FAILED,
            OperationMetadata_Status::CANCELLED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<OperationMetadata_Status>("OperationMetadata.Status", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for OperationMetadata_Status {
}

impl ::std::default::Default for OperationMetadata_Status {
    fn default() -> Self {
        OperationMetadata_Status::STATUS_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationMetadata_Status {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Diagnostic {
    // message fields
    pub location: ::std::string::String,
    pub kind: Diagnostic_Kind,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Diagnostic {
    fn default() -> &'a Diagnostic {
        <Diagnostic as ::protobuf::Message>::default_instance()
    }
}

impl Diagnostic {
    pub fn new() -> Diagnostic {
        ::std::default::Default::default()
    }

    // string location = 1;


    pub fn get_location(&self) -> &str {
        &self.location
    }
    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: ::std::string::String) {
        self.location = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut ::std::string::String {
        &mut self.location
    }

    // Take field
    pub fn take_location(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.location, ::std::string::String::new())
    }

    // .google.api.servicemanagement.v1.Diagnostic.Kind kind = 2;


    pub fn get_kind(&self) -> Diagnostic_Kind {
        self.kind
    }
    pub fn clear_kind(&mut self) {
        self.kind = Diagnostic_Kind::WARNING;
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: Diagnostic_Kind) {
        self.kind = v;
    }

    // string message = 3;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Diagnostic {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.location)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.kind, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.location.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.location);
        }
        if self.kind != Diagnostic_Kind::WARNING {
            my_size += ::protobuf::rt::enum_size(2, self.kind);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.location.is_empty() {
            os.write_string(1, &self.location)?;
        }
        if self.kind != Diagnostic_Kind::WARNING {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.kind))?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Diagnostic {
        Diagnostic::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "location",
                |m: &Diagnostic| { &m.location },
                |m: &mut Diagnostic| { &mut m.location },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Diagnostic_Kind>>(
                "kind",
                |m: &Diagnostic| { &m.kind },
                |m: &mut Diagnostic| { &mut m.kind },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &Diagnostic| { &m.message },
                |m: &mut Diagnostic| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Diagnostic>(
                "Diagnostic",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Diagnostic {
        static instance: ::protobuf::rt::LazyV2<Diagnostic> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Diagnostic::new)
    }
}

impl ::protobuf::Clear for Diagnostic {
    fn clear(&mut self) {
        self.location.clear();
        self.kind = Diagnostic_Kind::WARNING;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Diagnostic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Diagnostic {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Diagnostic_Kind {
    WARNING = 0,
    ERROR = 1,
}

impl ::protobuf::ProtobufEnum for Diagnostic_Kind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Diagnostic_Kind> {
        match value {
            0 => ::std::option::Option::Some(Diagnostic_Kind::WARNING),
            1 => ::std::option::Option::Some(Diagnostic_Kind::ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Diagnostic_Kind] = &[
            Diagnostic_Kind::WARNING,
            Diagnostic_Kind::ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Diagnostic_Kind>("Diagnostic.Kind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Diagnostic_Kind {
}

impl ::std::default::Default for Diagnostic_Kind {
    fn default() -> Self {
        Diagnostic_Kind::WARNING
    }
}

impl ::protobuf::reflect::ProtobufValue for Diagnostic_Kind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfigSource {
    // message fields
    pub id: ::std::string::String,
    pub files: ::protobuf::RepeatedField<ConfigFile>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigSource {
    fn default() -> &'a ConfigSource {
        <ConfigSource as ::protobuf::Message>::default_instance()
    }
}

impl ConfigSource {
    pub fn new() -> ConfigSource {
        ::std::default::Default::default()
    }

    // string id = 5;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // repeated .google.api.servicemanagement.v1.ConfigFile files = 2;


    pub fn get_files(&self) -> &[ConfigFile] {
        &self.files
    }
    pub fn clear_files(&mut self) {
        self.files.clear();
    }

    // Param is passed by value, moved
    pub fn set_files(&mut self, v: ::protobuf::RepeatedField<ConfigFile>) {
        self.files = v;
    }

    // Mutable pointer to the field.
    pub fn mut_files(&mut self) -> &mut ::protobuf::RepeatedField<ConfigFile> {
        &mut self.files
    }

    // Take field
    pub fn take_files(&mut self) -> ::protobuf::RepeatedField<ConfigFile> {
        ::std::mem::replace(&mut self.files, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ConfigSource {
    fn is_initialized(&self) -> bool {
        for v in &self.files {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.files)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.id);
        }
        for value in &self.files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(5, &self.id)?;
        }
        for v in &self.files {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigSource {
        ConfigSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &ConfigSource| { &m.id },
                |m: &mut ConfigSource| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConfigFile>>(
                "files",
                |m: &ConfigSource| { &m.files },
                |m: &mut ConfigSource| { &mut m.files },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfigSource>(
                "ConfigSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConfigSource {
        static instance: ::protobuf::rt::LazyV2<ConfigSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfigSource::new)
    }
}

impl ::protobuf::Clear for ConfigSource {
    fn clear(&mut self) {
        self.id.clear();
        self.files.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfigFile {
    // message fields
    pub file_path: ::std::string::String,
    pub file_contents: ::std::vec::Vec<u8>,
    pub file_type: ConfigFile_FileType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigFile {
    fn default() -> &'a ConfigFile {
        <ConfigFile as ::protobuf::Message>::default_instance()
    }
}

impl ConfigFile {
    pub fn new() -> ConfigFile {
        ::std::default::Default::default()
    }

    // string file_path = 1;


    pub fn get_file_path(&self) -> &str {
        &self.file_path
    }
    pub fn clear_file_path(&mut self) {
        self.file_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_file_path(&mut self, v: ::std::string::String) {
        self.file_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_path(&mut self) -> &mut ::std::string::String {
        &mut self.file_path
    }

    // Take field
    pub fn take_file_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.file_path, ::std::string::String::new())
    }

    // bytes file_contents = 3;


    pub fn get_file_contents(&self) -> &[u8] {
        &self.file_contents
    }
    pub fn clear_file_contents(&mut self) {
        self.file_contents.clear();
    }

    // Param is passed by value, moved
    pub fn set_file_contents(&mut self, v: ::std::vec::Vec<u8>) {
        self.file_contents = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_contents(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.file_contents
    }

    // Take field
    pub fn take_file_contents(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.file_contents, ::std::vec::Vec::new())
    }

    // .google.api.servicemanagement.v1.ConfigFile.FileType file_type = 4;


    pub fn get_file_type(&self) -> ConfigFile_FileType {
        self.file_type
    }
    pub fn clear_file_type(&mut self) {
        self.file_type = ConfigFile_FileType::FILE_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_file_type(&mut self, v: ConfigFile_FileType) {
        self.file_type = v;
    }
}

impl ::protobuf::Message for ConfigFile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.file_path)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.file_contents)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.file_type, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.file_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.file_path);
        }
        if !self.file_contents.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.file_contents);
        }
        if self.file_type != ConfigFile_FileType::FILE_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.file_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.file_path.is_empty() {
            os.write_string(1, &self.file_path)?;
        }
        if !self.file_contents.is_empty() {
            os.write_bytes(3, &self.file_contents)?;
        }
        if self.file_type != ConfigFile_FileType::FILE_TYPE_UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.file_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigFile {
        ConfigFile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "file_path",
                |m: &ConfigFile| { &m.file_path },
                |m: &mut ConfigFile| { &mut m.file_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "file_contents",
                |m: &ConfigFile| { &m.file_contents },
                |m: &mut ConfigFile| { &mut m.file_contents },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ConfigFile_FileType>>(
                "file_type",
                |m: &ConfigFile| { &m.file_type },
                |m: &mut ConfigFile| { &mut m.file_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfigFile>(
                "ConfigFile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConfigFile {
        static instance: ::protobuf::rt::LazyV2<ConfigFile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfigFile::new)
    }
}

impl ::protobuf::Clear for ConfigFile {
    fn clear(&mut self) {
        self.file_path.clear();
        self.file_contents.clear();
        self.file_type = ConfigFile_FileType::FILE_TYPE_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigFile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ConfigFile_FileType {
    FILE_TYPE_UNSPECIFIED = 0,
    SERVICE_CONFIG_YAML = 1,
    OPEN_API_JSON = 2,
    OPEN_API_YAML = 3,
    FILE_DESCRIPTOR_SET_PROTO = 4,
    PROTO_FILE = 6,
}

impl ::protobuf::ProtobufEnum for ConfigFile_FileType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ConfigFile_FileType> {
        match value {
            0 => ::std::option::Option::Some(ConfigFile_FileType::FILE_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(ConfigFile_FileType::SERVICE_CONFIG_YAML),
            2 => ::std::option::Option::Some(ConfigFile_FileType::OPEN_API_JSON),
            3 => ::std::option::Option::Some(ConfigFile_FileType::OPEN_API_YAML),
            4 => ::std::option::Option::Some(ConfigFile_FileType::FILE_DESCRIPTOR_SET_PROTO),
            6 => ::std::option::Option::Some(ConfigFile_FileType::PROTO_FILE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ConfigFile_FileType] = &[
            ConfigFile_FileType::FILE_TYPE_UNSPECIFIED,
            ConfigFile_FileType::SERVICE_CONFIG_YAML,
            ConfigFile_FileType::OPEN_API_JSON,
            ConfigFile_FileType::OPEN_API_YAML,
            ConfigFile_FileType::FILE_DESCRIPTOR_SET_PROTO,
            ConfigFile_FileType::PROTO_FILE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ConfigFile_FileType>("ConfigFile.FileType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ConfigFile_FileType {
}

impl ::std::default::Default for ConfigFile_FileType {
    fn default() -> Self {
        ConfigFile_FileType::FILE_TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigFile_FileType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfigRef {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigRef {
    fn default() -> &'a ConfigRef {
        <ConfigRef as ::protobuf::Message>::default_instance()
    }
}

impl ConfigRef {
    pub fn new() -> ConfigRef {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ConfigRef {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigRef {
        ConfigRef::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ConfigRef| { &m.name },
                |m: &mut ConfigRef| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfigRef>(
                "ConfigRef",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConfigRef {
        static instance: ::protobuf::rt::LazyV2<ConfigRef> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfigRef::new)
    }
}

impl ::protobuf::Clear for ConfigRef {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigRef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigRef {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChangeReport {
    // message fields
    pub config_changes: ::protobuf::RepeatedField<super::config_change::ConfigChange>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChangeReport {
    fn default() -> &'a ChangeReport {
        <ChangeReport as ::protobuf::Message>::default_instance()
    }
}

impl ChangeReport {
    pub fn new() -> ChangeReport {
        ::std::default::Default::default()
    }

    // repeated .google.api.ConfigChange config_changes = 1;


    pub fn get_config_changes(&self) -> &[super::config_change::ConfigChange] {
        &self.config_changes
    }
    pub fn clear_config_changes(&mut self) {
        self.config_changes.clear();
    }

    // Param is passed by value, moved
    pub fn set_config_changes(&mut self, v: ::protobuf::RepeatedField<super::config_change::ConfigChange>) {
        self.config_changes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_config_changes(&mut self) -> &mut ::protobuf::RepeatedField<super::config_change::ConfigChange> {
        &mut self.config_changes
    }

    // Take field
    pub fn take_config_changes(&mut self) -> ::protobuf::RepeatedField<super::config_change::ConfigChange> {
        ::std::mem::replace(&mut self.config_changes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ChangeReport {
    fn is_initialized(&self) -> bool {
        for v in &self.config_changes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.config_changes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.config_changes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.config_changes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChangeReport {
        ChangeReport::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::config_change::ConfigChange>>(
                "config_changes",
                |m: &ChangeReport| { &m.config_changes },
                |m: &mut ChangeReport| { &mut m.config_changes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChangeReport>(
                "ChangeReport",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChangeReport {
        static instance: ::protobuf::rt::LazyV2<ChangeReport> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChangeReport::new)
    }
}

impl ::protobuf::Clear for ChangeReport {
    fn clear(&mut self) {
        self.config_changes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChangeReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangeReport {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Rollout {
    // message fields
    pub rollout_id: ::std::string::String,
    pub create_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub created_by: ::std::string::String,
    pub status: Rollout_RolloutStatus,
    pub service_name: ::std::string::String,
    // message oneof groups
    pub strategy: ::std::option::Option<Rollout_oneof_strategy>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Rollout {
    fn default() -> &'a Rollout {
        <Rollout as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Rollout_oneof_strategy {
    traffic_percent_strategy(Rollout_TrafficPercentStrategy),
    delete_service_strategy(Rollout_DeleteServiceStrategy),
}

impl Rollout {
    pub fn new() -> Rollout {
        ::std::default::Default::default()
    }

    // string rollout_id = 1;


    pub fn get_rollout_id(&self) -> &str {
        &self.rollout_id
    }
    pub fn clear_rollout_id(&mut self) {
        self.rollout_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_rollout_id(&mut self, v: ::std::string::String) {
        self.rollout_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollout_id(&mut self) -> &mut ::std::string::String {
        &mut self.rollout_id
    }

    // Take field
    pub fn take_rollout_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rollout_id, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp create_time = 2;


    pub fn get_create_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.create_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    pub fn has_create_time(&self) -> bool {
        self.create_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.create_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.create_time.is_none() {
            self.create_time.set_default();
        }
        self.create_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.create_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string created_by = 3;


    pub fn get_created_by(&self) -> &str {
        &self.created_by
    }
    pub fn clear_created_by(&mut self) {
        self.created_by.clear();
    }

    // Param is passed by value, moved
    pub fn set_created_by(&mut self, v: ::std::string::String) {
        self.created_by = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_by(&mut self) -> &mut ::std::string::String {
        &mut self.created_by
    }

    // Take field
    pub fn take_created_by(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.created_by, ::std::string::String::new())
    }

    // .google.api.servicemanagement.v1.Rollout.RolloutStatus status = 4;


    pub fn get_status(&self) -> Rollout_RolloutStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = Rollout_RolloutStatus::ROLLOUT_STATUS_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Rollout_RolloutStatus) {
        self.status = v;
    }

    // .google.api.servicemanagement.v1.Rollout.TrafficPercentStrategy traffic_percent_strategy = 5;


    pub fn get_traffic_percent_strategy(&self) -> &Rollout_TrafficPercentStrategy {
        match self.strategy {
            ::std::option::Option::Some(Rollout_oneof_strategy::traffic_percent_strategy(ref v)) => v,
            _ => <Rollout_TrafficPercentStrategy as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_traffic_percent_strategy(&mut self) {
        self.strategy = ::std::option::Option::None;
    }

    pub fn has_traffic_percent_strategy(&self) -> bool {
        match self.strategy {
            ::std::option::Option::Some(Rollout_oneof_strategy::traffic_percent_strategy(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_traffic_percent_strategy(&mut self, v: Rollout_TrafficPercentStrategy) {
        self.strategy = ::std::option::Option::Some(Rollout_oneof_strategy::traffic_percent_strategy(v))
    }

    // Mutable pointer to the field.
    pub fn mut_traffic_percent_strategy(&mut self) -> &mut Rollout_TrafficPercentStrategy {
        if let ::std::option::Option::Some(Rollout_oneof_strategy::traffic_percent_strategy(_)) = self.strategy {
        } else {
            self.strategy = ::std::option::Option::Some(Rollout_oneof_strategy::traffic_percent_strategy(Rollout_TrafficPercentStrategy::new()));
        }
        match self.strategy {
            ::std::option::Option::Some(Rollout_oneof_strategy::traffic_percent_strategy(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_traffic_percent_strategy(&mut self) -> Rollout_TrafficPercentStrategy {
        if self.has_traffic_percent_strategy() {
            match self.strategy.take() {
                ::std::option::Option::Some(Rollout_oneof_strategy::traffic_percent_strategy(v)) => v,
                _ => panic!(),
            }
        } else {
            Rollout_TrafficPercentStrategy::new()
        }
    }

    // .google.api.servicemanagement.v1.Rollout.DeleteServiceStrategy delete_service_strategy = 200;


    pub fn get_delete_service_strategy(&self) -> &Rollout_DeleteServiceStrategy {
        match self.strategy {
            ::std::option::Option::Some(Rollout_oneof_strategy::delete_service_strategy(ref v)) => v,
            _ => <Rollout_DeleteServiceStrategy as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_delete_service_strategy(&mut self) {
        self.strategy = ::std::option::Option::None;
    }

    pub fn has_delete_service_strategy(&self) -> bool {
        match self.strategy {
            ::std::option::Option::Some(Rollout_oneof_strategy::delete_service_strategy(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delete_service_strategy(&mut self, v: Rollout_DeleteServiceStrategy) {
        self.strategy = ::std::option::Option::Some(Rollout_oneof_strategy::delete_service_strategy(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delete_service_strategy(&mut self) -> &mut Rollout_DeleteServiceStrategy {
        if let ::std::option::Option::Some(Rollout_oneof_strategy::delete_service_strategy(_)) = self.strategy {
        } else {
            self.strategy = ::std::option::Option::Some(Rollout_oneof_strategy::delete_service_strategy(Rollout_DeleteServiceStrategy::new()));
        }
        match self.strategy {
            ::std::option::Option::Some(Rollout_oneof_strategy::delete_service_strategy(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delete_service_strategy(&mut self) -> Rollout_DeleteServiceStrategy {
        if self.has_delete_service_strategy() {
            match self.strategy.take() {
                ::std::option::Option::Some(Rollout_oneof_strategy::delete_service_strategy(v)) => v,
                _ => panic!(),
            }
        } else {
            Rollout_DeleteServiceStrategy::new()
        }
    }

    // string service_name = 8;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Rollout {
    fn is_initialized(&self) -> bool {
        for v in &self.create_time {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(Rollout_oneof_strategy::traffic_percent_strategy(ref v)) = self.strategy {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Rollout_oneof_strategy::delete_service_strategy(ref v)) = self.strategy {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rollout_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_time)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.created_by)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.strategy = ::std::option::Option::Some(Rollout_oneof_strategy::traffic_percent_strategy(is.read_message()?));
                },
                200 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.strategy = ::std::option::Option::Some(Rollout_oneof_strategy::delete_service_strategy(is.read_message()?));
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.rollout_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.rollout_id);
        }
        if let Some(ref v) = self.create_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.created_by.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.created_by);
        }
        if self.status != Rollout_RolloutStatus::ROLLOUT_STATUS_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.status);
        }
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.service_name);
        }
        if let ::std::option::Option::Some(ref v) = self.strategy {
            match v {
                &Rollout_oneof_strategy::traffic_percent_strategy(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Rollout_oneof_strategy::delete_service_strategy(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.rollout_id.is_empty() {
            os.write_string(1, &self.rollout_id)?;
        }
        if let Some(ref v) = self.create_time.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.created_by.is_empty() {
            os.write_string(3, &self.created_by)?;
        }
        if self.status != Rollout_RolloutStatus::ROLLOUT_STATUS_UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        if !self.service_name.is_empty() {
            os.write_string(8, &self.service_name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.strategy {
            match v {
                &Rollout_oneof_strategy::traffic_percent_strategy(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Rollout_oneof_strategy::delete_service_strategy(ref v) => {
                    os.write_tag(200, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Rollout {
        Rollout::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rollout_id",
                |m: &Rollout| { &m.rollout_id },
                |m: &mut Rollout| { &mut m.rollout_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "create_time",
                |m: &Rollout| { &m.create_time },
                |m: &mut Rollout| { &mut m.create_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "created_by",
                |m: &Rollout| { &m.created_by },
                |m: &mut Rollout| { &mut m.created_by },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Rollout_RolloutStatus>>(
                "status",
                |m: &Rollout| { &m.status },
                |m: &mut Rollout| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Rollout_TrafficPercentStrategy>(
                "traffic_percent_strategy",
                Rollout::has_traffic_percent_strategy,
                Rollout::get_traffic_percent_strategy,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Rollout_DeleteServiceStrategy>(
                "delete_service_strategy",
                Rollout::has_delete_service_strategy,
                Rollout::get_delete_service_strategy,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &Rollout| { &m.service_name },
                |m: &mut Rollout| { &mut m.service_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Rollout>(
                "Rollout",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Rollout {
        static instance: ::protobuf::rt::LazyV2<Rollout> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Rollout::new)
    }
}

impl ::protobuf::Clear for Rollout {
    fn clear(&mut self) {
        self.rollout_id.clear();
        self.create_time.clear();
        self.created_by.clear();
        self.status = Rollout_RolloutStatus::ROLLOUT_STATUS_UNSPECIFIED;
        self.strategy = ::std::option::Option::None;
        self.strategy = ::std::option::Option::None;
        self.service_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Rollout {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rollout {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Rollout_TrafficPercentStrategy {
    // message fields
    pub percentages: ::std::collections::HashMap<::std::string::String, f64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Rollout_TrafficPercentStrategy {
    fn default() -> &'a Rollout_TrafficPercentStrategy {
        <Rollout_TrafficPercentStrategy as ::protobuf::Message>::default_instance()
    }
}

impl Rollout_TrafficPercentStrategy {
    pub fn new() -> Rollout_TrafficPercentStrategy {
        ::std::default::Default::default()
    }

    // repeated .google.api.servicemanagement.v1.Rollout.TrafficPercentStrategy.PercentagesEntry percentages = 1;


    pub fn get_percentages(&self) -> &::std::collections::HashMap<::std::string::String, f64> {
        &self.percentages
    }
    pub fn clear_percentages(&mut self) {
        self.percentages.clear();
    }

    // Param is passed by value, moved
    pub fn set_percentages(&mut self, v: ::std::collections::HashMap<::std::string::String, f64>) {
        self.percentages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_percentages(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f64> {
        &mut self.percentages
    }

    // Take field
    pub fn take_percentages(&mut self) -> ::std::collections::HashMap<::std::string::String, f64> {
        ::std::mem::replace(&mut self.percentages, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for Rollout_TrafficPercentStrategy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(wire_type, is, &mut self.percentages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(1, &self.percentages);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(1, &self.percentages, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Rollout_TrafficPercentStrategy {
        Rollout_TrafficPercentStrategy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(
                "percentages",
                |m: &Rollout_TrafficPercentStrategy| { &m.percentages },
                |m: &mut Rollout_TrafficPercentStrategy| { &mut m.percentages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Rollout_TrafficPercentStrategy>(
                "Rollout.TrafficPercentStrategy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Rollout_TrafficPercentStrategy {
        static instance: ::protobuf::rt::LazyV2<Rollout_TrafficPercentStrategy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Rollout_TrafficPercentStrategy::new)
    }
}

impl ::protobuf::Clear for Rollout_TrafficPercentStrategy {
    fn clear(&mut self) {
        self.percentages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Rollout_TrafficPercentStrategy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rollout_TrafficPercentStrategy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Rollout_DeleteServiceStrategy {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Rollout_DeleteServiceStrategy {
    fn default() -> &'a Rollout_DeleteServiceStrategy {
        <Rollout_DeleteServiceStrategy as ::protobuf::Message>::default_instance()
    }
}

impl Rollout_DeleteServiceStrategy {
    pub fn new() -> Rollout_DeleteServiceStrategy {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Rollout_DeleteServiceStrategy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Rollout_DeleteServiceStrategy {
        Rollout_DeleteServiceStrategy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Rollout_DeleteServiceStrategy>(
                "Rollout.DeleteServiceStrategy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Rollout_DeleteServiceStrategy {
        static instance: ::protobuf::rt::LazyV2<Rollout_DeleteServiceStrategy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Rollout_DeleteServiceStrategy::new)
    }
}

impl ::protobuf::Clear for Rollout_DeleteServiceStrategy {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Rollout_DeleteServiceStrategy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rollout_DeleteServiceStrategy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Rollout_RolloutStatus {
    ROLLOUT_STATUS_UNSPECIFIED = 0,
    IN_PROGRESS = 1,
    SUCCESS = 2,
    CANCELLED = 3,
    FAILED = 4,
    PENDING = 5,
    FAILED_ROLLED_BACK = 6,
}

impl ::protobuf::ProtobufEnum for Rollout_RolloutStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Rollout_RolloutStatus> {
        match value {
            0 => ::std::option::Option::Some(Rollout_RolloutStatus::ROLLOUT_STATUS_UNSPECIFIED),
            1 => ::std::option::Option::Some(Rollout_RolloutStatus::IN_PROGRESS),
            2 => ::std::option::Option::Some(Rollout_RolloutStatus::SUCCESS),
            3 => ::std::option::Option::Some(Rollout_RolloutStatus::CANCELLED),
            4 => ::std::option::Option::Some(Rollout_RolloutStatus::FAILED),
            5 => ::std::option::Option::Some(Rollout_RolloutStatus::PENDING),
            6 => ::std::option::Option::Some(Rollout_RolloutStatus::FAILED_ROLLED_BACK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Rollout_RolloutStatus] = &[
            Rollout_RolloutStatus::ROLLOUT_STATUS_UNSPECIFIED,
            Rollout_RolloutStatus::IN_PROGRESS,
            Rollout_RolloutStatus::SUCCESS,
            Rollout_RolloutStatus::CANCELLED,
            Rollout_RolloutStatus::FAILED,
            Rollout_RolloutStatus::PENDING,
            Rollout_RolloutStatus::FAILED_ROLLED_BACK,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Rollout_RolloutStatus>("Rollout.RolloutStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Rollout_RolloutStatus {
}

impl ::std::default::Default for Rollout_RolloutStatus {
    fn default() -> Self {
        Rollout_RolloutStatus::ROLLOUT_STATUS_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Rollout_RolloutStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n/google/api/servicemanagement/v1/resources.proto\x12\x1fgoogle.api.ser\
    vicemanagement.v1\x1a\x1cgoogle/api/annotations.proto\x1a\x1egoogle/api/\
    config_change.proto\x1a\x1fgoogle/api/field_behavior.proto\x1a\x17google\
    /api/metric.proto\x1a\x16google/api/quota.proto\x1a\x18google/api/servic\
    e.proto\x1a#google/longrunning/operations.proto\x1a\x19google/protobuf/a\
    ny.proto\x1a\x20google/protobuf/field_mask.proto\x1a\x1fgoogle/protobuf/\
    timestamp.proto\x1a\x17google/rpc/status.proto\"c\n\x0eManagedService\
    \x12!\n\x0cservice_name\x18\x02\x20\x01(\tR\x0bserviceName\x12.\n\x13pro\
    ducer_project_id\x18\x03\x20\x01(\tR\x11producerProjectId\"\xdb\x03\n\
    \x11OperationMetadata\x12%\n\x0eresource_names\x18\x01\x20\x03(\tR\rreso\
    urceNames\x12M\n\x05steps\x18\x02\x20\x03(\x0b27.google.api.servicemanag\
    ement.v1.OperationMetadata.StepR\x05steps\x12/\n\x13progress_percentage\
    \x18\x03\x20\x01(\x05R\x12progressPercentage\x129\n\nstart_time\x18\x04\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tstartTime\x1a{\n\x04Step\
    \x12\x20\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescription\x12Q\n\x06s\
    tatus\x18\x04\x20\x01(\x0e29.google.api.servicemanagement.v1.OperationMe\
    tadata.StatusR\x06status\"g\n\x06Status\x12\x16\n\x12STATUS_UNSPECIFIED\
    \x10\0\x12\x08\n\x04DONE\x10\x01\x12\x0f\n\x0bNOT_STARTED\x10\x02\x12\
    \x0f\n\x0bIN_PROGRESS\x10\x03\x12\n\n\x06FAILED\x10\x04\x12\r\n\tCANCELL\
    ED\x10\x05\"\xa8\x01\n\nDiagnostic\x12\x1a\n\x08location\x18\x01\x20\x01\
    (\tR\x08location\x12D\n\x04kind\x18\x02\x20\x01(\x0e20.google.api.servic\
    emanagement.v1.Diagnostic.KindR\x04kind\x12\x18\n\x07message\x18\x03\x20\
    \x01(\tR\x07message\"\x1e\n\x04Kind\x12\x0b\n\x07WARNING\x10\0\x12\t\n\
    \x05ERROR\x10\x01\"a\n\x0cConfigSource\x12\x0e\n\x02id\x18\x05\x20\x01(\
    \tR\x02id\x12A\n\x05files\x18\x02\x20\x03(\x0b2+.google.api.servicemanag\
    ement.v1.ConfigFileR\x05files\"\xb7\x02\n\nConfigFile\x12\x1b\n\tfile_pa\
    th\x18\x01\x20\x01(\tR\x08filePath\x12#\n\rfile_contents\x18\x03\x20\x01\
    (\x0cR\x0cfileContents\x12Q\n\tfile_type\x18\x04\x20\x01(\x0e24.google.a\
    pi.servicemanagement.v1.ConfigFile.FileTypeR\x08fileType\"\x93\x01\n\x08\
    FileType\x12\x19\n\x15FILE_TYPE_UNSPECIFIED\x10\0\x12\x17\n\x13SERVICE_C\
    ONFIG_YAML\x10\x01\x12\x11\n\rOPEN_API_JSON\x10\x02\x12\x11\n\rOPEN_API_\
    YAML\x10\x03\x12\x1d\n\x19FILE_DESCRIPTOR_SET_PROTO\x10\x04\x12\x0e\n\nP\
    ROTO_FILE\x10\x06\"\x1f\n\tConfigRef\x12\x12\n\x04name\x18\x01\x20\x01(\
    \tR\x04name\"O\n\x0cChangeReport\x12?\n\x0econfig_changes\x18\x01\x20\
    \x03(\x0b2\x18.google.api.ConfigChangeR\rconfigChanges\"\xf8\x06\n\x07Ro\
    llout\x12\"\n\nrollout_id\x18\x01\x20\x01(\tR\trolloutIdB\x03\xe0A\x01\
    \x12;\n\x0bcreate_time\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.Timesta\
    mpR\ncreateTime\x12\x1d\n\ncreated_by\x18\x03\x20\x01(\tR\tcreatedBy\x12\
    N\n\x06status\x18\x04\x20\x01(\x0e26.google.api.servicemanagement.v1.Rol\
    lout.RolloutStatusR\x06status\x12{\n\x18traffic_percent_strategy\x18\x05\
    \x20\x01(\x0b2?.google.api.servicemanagement.v1.Rollout.TrafficPercentSt\
    rategyH\0R\x16trafficPercentStrategy\x12y\n\x17delete_service_strategy\
    \x18\xc8\x01\x20\x01(\x0b2>.google.api.servicemanagement.v1.Rollout.Dele\
    teServiceStrategyH\0R\x15deleteServiceStrategy\x12!\n\x0cservice_name\
    \x18\x08\x20\x01(\tR\x0bserviceName\x1a\xcc\x01\n\x16TrafficPercentStrat\
    egy\x12r\n\x0bpercentages\x18\x01\x20\x03(\x0b2P.google.api.servicemanag\
    ement.v1.Rollout.TrafficPercentStrategy.PercentagesEntryR\x0bpercentages\
    \x1a>\n\x10PercentagesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\x01R\x05value:\x028\x01\x1a\x17\n\
    \x15DeleteServiceStrategy\"\x8d\x01\n\rRolloutStatus\x12\x1e\n\x1aROLLOU\
    T_STATUS_UNSPECIFIED\x10\0\x12\x0f\n\x0bIN_PROGRESS\x10\x01\x12\x0b\n\
    \x07SUCCESS\x10\x02\x12\r\n\tCANCELLED\x10\x03\x12\n\n\x06FAILED\x10\x04\
    \x12\x0b\n\x07PENDING\x10\x05\x12\x16\n\x12FAILED_ROLLED_BACK\x10\x06B\n\
    \n\x08strategyB\xff\x01\n#com.google.api.servicemanagement.v1B\x0eResour\
    cesProtoP\x01ZPgoogle.golang.org/genproto/googleapis/api/servicemanageme\
    nt/v1;servicemanagement\xa2\x02\x04GASM\xaa\x02!Google.Cloud.ServiceMana\
    gement.V1\xca\x02!Google\\Cloud\\ServiceManagement\\V1\xea\x02$Google::C\
    loud::ServiceManagement::V1J\x8dS\n\x07\x12\x05\x0f\0\xaf\x02\x01\n\xbe\
    \x04\n\x01\x0c\x12\x03\x0f\0\x122\xb3\x04\x20Copyright\x202019\x20Google\
    \x20LLC.\n\n\x20Licensed\x20under\x20the\x20Apache\x20License,\x20Versio\
    n\x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\
    \x20file\x20except\x20in\x20compliance\x20with\x20the\x20License.\n\x20Y\
    ou\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\
    \x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\
    \x20required\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20w\
    riting,\x20software\n\x20distributed\x20under\x20the\x20License\x20is\
    \x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WA\
    RRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\
    \x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20specific\
    \x20language\x20governing\x20permissions\x20and\n\x20limitations\x20unde\
    r\x20the\x20License.\n\n\n\x08\n\x01\x02\x12\x03\x11\0(\n\t\n\x02\x03\0\
    \x12\x03\x13\0&\n\t\n\x02\x03\x01\x12\x03\x14\0(\n\t\n\x02\x03\x02\x12\
    \x03\x15\0)\n\t\n\x02\x03\x03\x12\x03\x16\0!\n\t\n\x02\x03\x04\x12\x03\
    \x17\0\x20\n\t\n\x02\x03\x05\x12\x03\x18\0\"\n\t\n\x02\x03\x06\x12\x03\
    \x19\0-\n\t\n\x02\x03\x07\x12\x03\x1a\0#\n\t\n\x02\x03\x08\x12\x03\x1b\0\
    *\n\t\n\x02\x03\t\x12\x03\x1c\0)\n\t\n\x02\x03\n\x12\x03\x1d\0!\n\x08\n\
    \x01\x08\x12\x03\x1f\0>\n\t\n\x02\x08%\x12\x03\x1f\0>\n\x08\n\x01\x08\
    \x12\x03\x20\0g\n\t\n\x02\x08\x0b\x12\x03\x20\0g\n\x08\n\x01\x08\x12\x03\
    !\0\"\n\t\n\x02\x08\n\x12\x03!\0\"\n\x08\n\x01\x08\x12\x03\"\0/\n\t\n\
    \x02\x08\x08\x12\x03\"\0/\n\x08\n\x01\x08\x12\x03#\0<\n\t\n\x02\x08\x01\
    \x12\x03#\0<\n\x08\n\x01\x08\x12\x03$\0\"\n\t\n\x02\x08$\x12\x03$\0\"\n\
    \x08\n\x01\x08\x12\x03%\0>\n\t\n\x02\x08)\x12\x03%\0>\n\x08\n\x01\x08\
    \x12\x03&\0=\n\t\n\x02\x08-\x12\x03&\0=\na\n\x02\x04\0\x12\x04*\01\x01\
    \x1aU\x20The\x20full\x20representation\x20of\x20a\x20Service\x20that\x20\
    is\x20managed\x20by\n\x20Google\x20Service\x20Management.\n\n\n\n\x03\
    \x04\0\x01\x12\x03*\x08\x16\nr\n\x04\x04\0\x02\0\x12\x03-\x02\x1a\x1ae\
    \x20The\x20name\x20of\x20the\x20service.\x20See\x20the\x20[overview](/se\
    rvice-management/overview)\n\x20for\x20naming\x20requirements.\n\n\r\n\
    \x05\x04\0\x02\0\x04\x12\x04-\x02*\x18\n\x0c\n\x05\x04\0\x02\0\x05\x12\
    \x03-\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03-\t\x15\n\x0c\n\x05\x04\
    \0\x02\0\x03\x12\x03-\x18\x19\nE\n\x04\x04\0\x02\x01\x12\x030\x02!\x1a8\
    \x20ID\x20of\x20the\x20project\x20that\x20produces\x20and\x20owns\x20thi\
    s\x20service.\n\n\r\n\x05\x04\0\x02\x01\x04\x12\x040\x02-\x1a\n\x0c\n\
    \x05\x04\0\x02\x01\x05\x12\x030\x02\x08\n\x0c\n\x05\x04\0\x02\x01\x01\
    \x12\x030\t\x1c\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x030\x1f\x20\nM\n\x02\
    \x04\x01\x12\x044\0`\x01\x1aA\x20The\x20metadata\x20associated\x20with\
    \x20a\x20long\x20running\x20operation\x20resource.\n\n\n\n\x03\x04\x01\
    \x01\x12\x034\x08\x19\n<\n\x04\x04\x01\x03\0\x12\x046\x02<\x03\x1a.\x20R\
    epresents\x20the\x20status\x20of\x20one\x20operation\x20step.\n\n\x0c\n\
    \x05\x04\x01\x03\0\x01\x12\x036\n\x0e\n3\n\x06\x04\x01\x03\0\x02\0\x12\
    \x038\x04\x1b\x1a$\x20The\x20short\x20description\x20of\x20the\x20step.\
    \n\n\x0f\n\x07\x04\x01\x03\0\x02\0\x04\x12\x048\x046\x10\n\x0e\n\x07\x04\
    \x01\x03\0\x02\0\x05\x12\x038\x04\n\n\x0e\n\x07\x04\x01\x03\0\x02\0\x01\
    \x12\x038\x0b\x16\n\x0e\n\x07\x04\x01\x03\0\x02\0\x03\x12\x038\x19\x1a\n\
    !\n\x06\x04\x01\x03\0\x02\x01\x12\x03;\x04\x16\x1a\x12\x20The\x20status\
    \x20code.\n\n\x0f\n\x07\x04\x01\x03\0\x02\x01\x04\x12\x04;\x048\x1b\n\
    \x0e\n\x07\x04\x01\x03\0\x02\x01\x06\x12\x03;\x04\n\n\x0e\n\x07\x04\x01\
    \x03\0\x02\x01\x01\x12\x03;\x0b\x11\n\x0e\n\x07\x04\x01\x03\0\x02\x01\
    \x03\x12\x03;\x14\x15\nQ\n\x04\x04\x01\x04\0\x12\x04?\x02R\x03\x1aC\x20C\
    ode\x20describes\x20the\x20status\x20of\x20the\x20operation\x20(or\x20on\
    e\x20of\x20its\x20steps).\n\n\x0c\n\x05\x04\x01\x04\0\x01\x12\x03?\x07\r\
    \n!\n\x06\x04\x01\x04\0\x02\0\x12\x03A\x04\x1b\x1a\x12\x20Unspecifed\x20\
    code.\n\n\x0e\n\x07\x04\x01\x04\0\x02\0\x01\x12\x03A\x04\x16\n\x0e\n\x07\
    \x04\x01\x04\0\x02\0\x02\x12\x03A\x19\x1a\nD\n\x06\x04\x01\x04\0\x02\x01\
    \x12\x03D\x04\r\x1a5\x20The\x20operation\x20or\x20step\x20has\x20complet\
    ed\x20without\x20errors.\n\n\x0e\n\x07\x04\x01\x04\0\x02\x01\x01\x12\x03\
    D\x04\x08\n\x0e\n\x07\x04\x01\x04\0\x02\x01\x02\x12\x03D\x0b\x0c\n;\n\
    \x06\x04\x01\x04\0\x02\x02\x12\x03G\x04\x14\x1a,\x20The\x20operation\x20\
    or\x20step\x20has\x20not\x20started\x20yet.\n\n\x0e\n\x07\x04\x01\x04\0\
    \x02\x02\x01\x12\x03G\x04\x0f\n\x0e\n\x07\x04\x01\x04\0\x02\x02\x02\x12\
    \x03G\x12\x13\n6\n\x06\x04\x01\x04\0\x02\x03\x12\x03J\x04\x14\x1a'\x20Th\
    e\x20operation\x20or\x20step\x20is\x20in\x20progress.\n\n\x0e\n\x07\x04\
    \x01\x04\0\x02\x03\x01\x12\x03J\x04\x0f\n\x0e\n\x07\x04\x01\x04\0\x02\
    \x03\x02\x12\x03J\x12\x13\n\x8c\x01\n\x06\x04\x01\x04\0\x02\x04\x12\x03N\
    \x04\x0f\x1a}\x20The\x20operation\x20or\x20step\x20has\x20completed\x20w\
    ith\x20errors.\x20If\x20the\x20operation\x20is\n\x20rollbackable,\x20the\
    \x20rollback\x20completed\x20with\x20errors\x20too.\n\n\x0e\n\x07\x04\
    \x01\x04\0\x02\x04\x01\x12\x03N\x04\n\n\x0e\n\x07\x04\x01\x04\0\x02\x04\
    \x02\x12\x03N\r\x0e\nG\n\x06\x04\x01\x04\0\x02\x05\x12\x03Q\x04\x12\x1a8\
    \x20The\x20operation\x20or\x20step\x20has\x20completed\x20with\x20cancel\
    lation.\n\n\x0e\n\x07\x04\x01\x04\0\x02\x05\x01\x12\x03Q\x04\r\n\x0e\n\
    \x07\x04\x01\x04\0\x02\x05\x02\x12\x03Q\x10\x11\n_\n\x04\x04\x01\x02\0\
    \x12\x03V\x02%\x1aR\x20The\x20full\x20name\x20of\x20the\x20resources\x20\
    that\x20this\x20operation\x20is\x20directly\n\x20associated\x20with.\n\n\
    \x0c\n\x05\x04\x01\x02\0\x04\x12\x03V\x02\n\n\x0c\n\x05\x04\x01\x02\0\
    \x05\x12\x03V\x0b\x11\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03V\x12\x20\n\
    \x0c\n\x05\x04\x01\x02\0\x03\x12\x03V#$\nT\n\x04\x04\x01\x02\x01\x12\x03\
    Y\x02\x1a\x1aG\x20Detailed\x20status\x20information\x20for\x20each\x20st\
    ep.\x20The\x20order\x20is\x20undetermined.\n\n\x0c\n\x05\x04\x01\x02\x01\
    \x04\x12\x03Y\x02\n\n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x03Y\x0b\x0f\n\
    \x0c\n\x05\x04\x01\x02\x01\x01\x12\x03Y\x10\x15\n\x0c\n\x05\x04\x01\x02\
    \x01\x03\x12\x03Y\x18\x19\nQ\n\x04\x04\x01\x02\x02\x12\x03\\\x02\x20\x1a\
    D\x20Percentage\x20of\x20completion\x20of\x20this\x20operation,\x20rangi\
    ng\x20from\x200\x20to\x20100.\n\n\r\n\x05\x04\x01\x02\x02\x04\x12\x04\\\
    \x02Y\x1a\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03\\\x02\x07\n\x0c\n\x05\
    \x04\x01\x02\x02\x01\x12\x03\\\x08\x1b\n\x0c\n\x05\x04\x01\x02\x02\x03\
    \x12\x03\\\x1e\x1f\n/\n\x04\x04\x01\x02\x03\x12\x03_\x02+\x1a\"\x20The\
    \x20start\x20time\x20of\x20the\x20operation.\n\n\r\n\x05\x04\x01\x02\x03\
    \x04\x12\x04_\x02\\\x20\n\x0c\n\x05\x04\x01\x02\x03\x06\x12\x03_\x02\x1b\
    \n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03_\x1c&\n\x0c\n\x05\x04\x01\x02\
    \x03\x03\x12\x03_)*\n@\n\x02\x04\x02\x12\x04c\0u\x01\x1a4\x20Represents\
    \x20a\x20diagnostic\x20message\x20(error\x20or\x20warning)\n\n\n\n\x03\
    \x04\x02\x01\x12\x03c\x08\x12\n<\n\x04\x04\x02\x04\0\x12\x04e\x02k\x03\
    \x1a.\x20The\x20kind\x20of\x20diagnostic\x20information\x20possible.\n\n\
    \x0c\n\x05\x04\x02\x04\0\x01\x12\x03e\x07\x0b\n$\n\x06\x04\x02\x04\0\x02\
    \0\x12\x03g\x04\x10\x1a\x15\x20Warnings\x20and\x20errors\n\n\x0e\n\x07\
    \x04\x02\x04\0\x02\0\x01\x12\x03g\x04\x0b\n\x0e\n\x07\x04\x02\x04\0\x02\
    \0\x02\x12\x03g\x0e\x0f\n\x1c\n\x06\x04\x02\x04\0\x02\x01\x12\x03j\x04\
    \x0e\x1a\r\x20Only\x20errors\n\n\x0e\n\x07\x04\x02\x04\0\x02\x01\x01\x12\
    \x03j\x04\t\n\x0e\n\x07\x04\x02\x04\0\x02\x01\x02\x12\x03j\x0c\r\nA\n\
    \x04\x04\x02\x02\0\x12\x03n\x02\x16\x1a4\x20File\x20name\x20and\x20line\
    \x20number\x20of\x20the\x20error\x20or\x20warning.\n\n\r\n\x05\x04\x02\
    \x02\0\x04\x12\x04n\x02k\x03\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03n\x02\
    \x08\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03n\t\x11\n\x0c\n\x05\x04\x02\
    \x02\0\x03\x12\x03n\x14\x15\n;\n\x04\x04\x02\x02\x01\x12\x03q\x02\x10\
    \x1a.\x20The\x20kind\x20of\x20diagnostic\x20information\x20provided.\n\n\
    \r\n\x05\x04\x02\x02\x01\x04\x12\x04q\x02n\x16\n\x0c\n\x05\x04\x02\x02\
    \x01\x06\x12\x03q\x02\x06\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03q\x07\
    \x0b\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03q\x0e\x0f\n7\n\x04\x04\x02\
    \x02\x02\x12\x03t\x02\x15\x1a*\x20Message\x20describing\x20the\x20error\
    \x20or\x20warning.\n\n\r\n\x05\x04\x02\x02\x02\x04\x12\x04t\x02q\x10\n\
    \x0c\n\x05\x04\x02\x02\x02\x05\x12\x03t\x02\x08\n\x0c\n\x05\x04\x02\x02\
    \x02\x01\x12\x03t\t\x10\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03t\x13\x14\
    \n}\n\x02\x04\x03\x12\x05y\0\x82\x01\x01\x1ap\x20Represents\x20a\x20sour\
    ce\x20file\x20which\x20is\x20used\x20to\x20generate\x20the\x20service\
    \x20configuration\n\x20defined\x20by\x20`google.api.Service`.\n\n\n\n\
    \x03\x04\x03\x01\x12\x03y\x08\x14\n\xb6\x01\n\x04\x04\x03\x02\0\x12\x03}\
    \x02\x10\x1a\xa8\x01\x20A\x20unique\x20ID\x20for\x20a\x20specific\x20ins\
    tance\x20of\x20this\x20message,\x20typically\x20assigned\n\x20by\x20the\
    \x20client\x20for\x20tracking\x20purpose.\x20If\x20empty,\x20the\x20serv\
    er\x20may\x20choose\x20to\n\x20generate\x20one\x20instead.\n\n\r\n\x05\
    \x04\x03\x02\0\x04\x12\x04}\x02y\x16\n\x0c\n\x05\x04\x03\x02\0\x05\x12\
    \x03}\x02\x08\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03}\t\x0b\n\x0c\n\x05\
    \x04\x03\x02\0\x03\x12\x03}\x0e\x0f\n|\n\x04\x04\x03\x02\x01\x12\x04\x81\
    \x01\x02\x20\x1an\x20Set\x20of\x20source\x20configuration\x20files\x20th\
    at\x20are\x20used\x20to\x20generate\x20a\x20service\n\x20configuration\
    \x20(`google.api.Service`).\n\n\r\n\x05\x04\x03\x02\x01\x04\x12\x04\x81\
    \x01\x02\n\n\r\n\x05\x04\x03\x02\x01\x06\x12\x04\x81\x01\x0b\x15\n\r\n\
    \x05\x04\x03\x02\x01\x01\x12\x04\x81\x01\x16\x1b\n\r\n\x05\x04\x03\x02\
    \x01\x03\x12\x04\x81\x01\x1e\x1f\nD\n\x02\x04\x04\x12\x06\x85\x01\0\xac\
    \x01\x01\x1a6\x20Generic\x20specification\x20of\x20a\x20source\x20config\
    uration\x20file\n\n\x0b\n\x03\x04\x04\x01\x12\x04\x85\x01\x08\x12\n\x0e\
    \n\x04\x04\x04\x04\0\x12\x06\x86\x01\x02\xa2\x01\x03\n\r\n\x05\x04\x04\
    \x04\0\x01\x12\x04\x86\x01\x07\x0f\n$\n\x06\x04\x04\x04\0\x02\0\x12\x04\
    \x88\x01\x04\x1e\x1a\x14\x20Unknown\x20file\x20type.\n\n\x0f\n\x07\x04\
    \x04\x04\0\x02\0\x01\x12\x04\x88\x01\x04\x19\n\x0f\n\x07\x04\x04\x04\0\
    \x02\0\x02\x12\x04\x88\x01\x1c\x1d\n0\n\x06\x04\x04\x04\0\x02\x01\x12\
    \x04\x8b\x01\x04\x1c\x1a\x20\x20YAML-specification\x20of\x20service.\n\n\
    \x0f\n\x07\x04\x04\x04\0\x02\x01\x01\x12\x04\x8b\x01\x04\x17\n\x0f\n\x07\
    \x04\x04\x04\0\x02\x01\x02\x12\x04\x8b\x01\x1a\x1b\n<\n\x06\x04\x04\x04\
    \0\x02\x02\x12\x04\x8e\x01\x04\x16\x1a,\x20OpenAPI\x20specification,\x20\
    serialized\x20in\x20JSON.\n\n\x0f\n\x07\x04\x04\x04\0\x02\x02\x01\x12\
    \x04\x8e\x01\x04\x11\n\x0f\n\x07\x04\x04\x04\0\x02\x02\x02\x12\x04\x8e\
    \x01\x14\x15\n<\n\x06\x04\x04\x04\0\x02\x03\x12\x04\x91\x01\x04\x16\x1a,\
    \x20OpenAPI\x20specification,\x20serialized\x20in\x20YAML.\n\n\x0f\n\x07\
    \x04\x04\x04\0\x02\x03\x01\x12\x04\x91\x01\x04\x11\n\x0f\n\x07\x04\x04\
    \x04\0\x02\x03\x02\x12\x04\x91\x01\x14\x15\n\xaa\x02\n\x06\x04\x04\x04\0\
    \x02\x04\x12\x04\x9a\x01\x04\"\x1a\x99\x02\x20FileDescriptorSet,\x20gene\
    rated\x20by\x20protoc.\n\n\x20To\x20generate,\x20use\x20protoc\x20with\
    \x20imports\x20and\x20source\x20info\x20included.\n\x20For\x20an\x20exam\
    ple\x20test.proto\x20file,\x20the\x20following\x20command\x20would\x20pu\
    t\x20the\x20value\n\x20in\x20a\x20new\x20file\x20named\x20out.pb.\n\n\
    \x20$protoc\x20--include_imports\x20--include_source_info\x20test.proto\
    \x20-o\x20out.pb\n\n\x0f\n\x07\x04\x04\x04\0\x02\x04\x01\x12\x04\x9a\x01\
    \x04\x1d\n\x0f\n\x07\x04\x04\x04\0\x02\x04\x02\x12\x04\x9a\x01\x20!\n\
    \xd3\x02\n\x06\x04\x04\x04\0\x02\x05\x12\x04\xa1\x01\x04\x13\x1a\xc2\x02\
    \x20Uncompiled\x20Proto\x20file.\x20Used\x20for\x20storage\x20and\x20dis\
    play\x20purposes\x20only,\n\x20currently\x20server-side\x20compilation\
    \x20is\x20not\x20supported.\x20Should\x20match\x20the\n\x20inputs\x20to\
    \x20'protoc'\x20command\x20used\x20to\x20generated\x20FILE_DESCRIPTOR_SE\
    T_PROTO.\x20A\n\x20file\x20of\x20this\x20type\x20can\x20only\x20be\x20in\
    cluded\x20if\x20at\x20least\x20one\x20file\x20of\x20type\n\x20FILE_DESCR\
    IPTOR_SET_PROTO\x20is\x20included.\n\n\x0f\n\x07\x04\x04\x04\0\x02\x05\
    \x01\x12\x04\xa1\x01\x04\x0e\n\x0f\n\x07\x04\x04\x04\0\x02\x05\x02\x12\
    \x04\xa1\x01\x11\x12\nP\n\x04\x04\x04\x02\0\x12\x04\xa5\x01\x02\x17\x1aB\
    \x20The\x20file\x20name\x20of\x20the\x20configuration\x20file\x20(full\
    \x20or\x20relative\x20path).\n\n\x0f\n\x05\x04\x04\x02\0\x04\x12\x06\xa5\
    \x01\x02\xa2\x01\x03\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\xa5\x01\x02\x08\
    \n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xa5\x01\t\x12\n\r\n\x05\x04\x04\x02\
    \0\x03\x12\x04\xa5\x01\x15\x16\n3\n\x04\x04\x04\x02\x01\x12\x04\xa8\x01\
    \x02\x1a\x1a%\x20The\x20bytes\x20that\x20constitute\x20the\x20file.\n\n\
    \x0f\n\x05\x04\x04\x02\x01\x04\x12\x06\xa8\x01\x02\xa5\x01\x17\n\r\n\x05\
    \x04\x04\x02\x01\x05\x12\x04\xa8\x01\x02\x07\n\r\n\x05\x04\x04\x02\x01\
    \x01\x12\x04\xa8\x01\x08\x15\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\xa8\
    \x01\x18\x19\n?\n\x04\x04\x04\x02\x02\x12\x04\xab\x01\x02\x19\x1a1\x20Th\
    e\x20type\x20of\x20configuration\x20file\x20this\x20represents.\n\n\x0f\
    \n\x05\x04\x04\x02\x02\x04\x12\x06\xab\x01\x02\xa8\x01\x1a\n\r\n\x05\x04\
    \x04\x02\x02\x06\x12\x04\xab\x01\x02\n\n\r\n\x05\x04\x04\x02\x02\x01\x12\
    \x04\xab\x01\x0b\x14\n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\xab\x01\x17\
    \x18\nH\n\x02\x04\x05\x12\x06\xaf\x01\0\xb3\x01\x01\x1a:\x20Represents\
    \x20a\x20service\x20configuration\x20with\x20its\x20name\x20and\x20id.\n\
    \n\x0b\n\x03\x04\x05\x01\x12\x04\xaf\x01\x08\x11\n\x85\x01\n\x04\x04\x05\
    \x02\0\x12\x04\xb2\x01\x02\x12\x1aw\x20Resource\x20name\x20of\x20a\x20se\
    rvice\x20config.\x20It\x20must\x20have\x20the\x20following\n\x20format:\
    \x20\"services/{service\x20name}/configs/{config\x20id}\".\n\n\x0f\n\x05\
    \x04\x05\x02\0\x04\x12\x06\xb2\x01\x02\xaf\x01\x13\n\r\n\x05\x04\x05\x02\
    \0\x05\x12\x04\xb2\x01\x02\x08\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xb2\
    \x01\t\r\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xb2\x01\x10\x11\n\xb5\x01\n\
    \x02\x04\x06\x12\x06\xb9\x01\0\xc0\x01\x01\x1a\xa6\x01\x20Change\x20repo\
    rt\x20associated\x20with\x20a\x20particular\x20service\x20configuration.\
    \n\n\x20It\x20contains\x20a\x20list\x20of\x20ConfigChanges\x20based\x20o\
    n\x20the\x20comparison\x20between\n\x20two\x20service\x20configurations.\
    \n\n\x0b\n\x03\x04\x06\x01\x12\x04\xb9\x01\x08\x14\n\xae\x02\n\x04\x04\
    \x06\x02\0\x12\x04\xbf\x01\x026\x1a\x9f\x02\x20List\x20of\x20changes\x20\
    between\x20two\x20service\x20configurations.\n\x20The\x20changes\x20will\
    \x20be\x20alphabetically\x20sorted\x20based\x20on\x20the\x20identifier\n\
    \x20of\x20each\x20change.\n\x20A\x20ConfigChange\x20identifier\x20is\x20\
    a\x20dot\x20separated\x20path\x20to\x20the\x20configuration.\n\x20Exampl\
    e:\x20visibility.rules[selector='LibraryService.CreateBook'].restriction\
    \n\n\r\n\x05\x04\x06\x02\0\x04\x12\x04\xbf\x01\x02\n\n\r\n\x05\x04\x06\
    \x02\0\x06\x12\x04\xbf\x01\x0b\"\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xbf\
    \x01#1\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xbf\x0145\n\xeb\x01\n\x02\x04\
    \x07\x12\x06\xc5\x01\0\xaf\x02\x01\x1a\xdc\x01\x20A\x20rollout\x20resour\
    ce\x20that\x20defines\x20how\x20service\x20configuration\x20versions\x20\
    are\x20pushed\n\x20to\x20control\x20plane\x20systems.\x20Typically,\x20y\
    ou\x20create\x20a\x20new\x20version\x20of\x20the\n\x20service\x20config,\
    \x20and\x20then\x20create\x20a\x20Rollout\x20to\x20push\x20the\x20servic\
    e\x20config.\n\n\x0b\n\x03\x04\x07\x01\x12\x04\xc5\x01\x08\x0f\n\xbd\x06\
    \n\x04\x04\x07\x03\0\x12\x06\xe4\x01\x02\xe9\x01\x03\x1a\xac\x06\x20Stra\
    tegy\x20that\x20specifies\x20how\x20clients\x20of\x20Google\x20Service\
    \x20Controller\x20want\x20to\n\x20send\x20traffic\x20to\x20use\x20differ\
    ent\x20config\x20versions.\x20This\x20is\x20generally\n\x20used\x20by\
    \x20API\x20proxy\x20to\x20split\x20traffic\x20based\x20on\x20your\x20con\
    figured\x20percentage\x20for\n\x20each\x20config\x20version.\n\n\x20One\
    \x20example\x20of\x20how\x20to\x20gradually\x20rollout\x20a\x20new\x20se\
    rvice\x20configuration\x20using\n\x20this\n\x20strategy:\n\x20Day\x201\n\
    \n\x20\x20\x20\x20\x20Rollout\x20{\n\x20\x20\x20\x20\x20\x20\x20id:\x20\
    \"example.googleapis.com/rollout_20160206\"\n\x20\x20\x20\x20\x20\x20\
    \x20traffic_percent_strategy\x20{\n\x20\x20\x20\x20\x20\x20\x20\x20\x20p\
    ercentages:\x20{\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\"example.\
    googleapis.com/20160201\":\x2070.00\n\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\"example.googleapis.com/20160206\":\x2030.00\n\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20}\n\x20\x20\x20\x20\x20\x20\x20}\n\x20\x20\x20\
    \x20\x20}\n\n\x20Day\x202\n\n\x20\x20\x20\x20\x20Rollout\x20{\n\x20\x20\
    \x20\x20\x20\x20\x20id:\x20\"example.googleapis.com/rollout_20160207\"\n\
    \x20\x20\x20\x20\x20\x20\x20traffic_percent_strategy:\x20{\n\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20percentages:\x20{\n\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\"example.googleapis.com/20160206\":\x20100.00\n\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20}\n\x20\x20\x20\x20\x20\x20\x20}\n\x20\x20\
    \x20\x20\x20}\n\n\r\n\x05\x04\x07\x03\0\x01\x12\x04\xe4\x01\n\x20\n\xe3\
    \x01\n\x06\x04\x07\x03\0\x02\0\x12\x04\xe8\x01\x04(\x1a\xd2\x01\x20Maps\
    \x20service\x20configuration\x20IDs\x20to\x20their\x20corresponding\x20t\
    raffic\x20percentage.\n\x20Key\x20is\x20the\x20service\x20configuration\
    \x20ID,\x20Value\x20is\x20the\x20traffic\x20percentage\n\x20which\x20mus\
    t\x20be\x20greater\x20than\x200.0\x20and\x20the\x20sum\x20must\x20equal\
    \x20to\x20100.0.\n\n\x11\n\x07\x04\x07\x03\0\x02\0\x04\x12\x06\xe8\x01\
    \x04\xe4\x01\"\n\x0f\n\x07\x04\x07\x03\0\x02\0\x06\x12\x04\xe8\x01\x04\
    \x17\n\x0f\n\x07\x04\x07\x03\0\x02\0\x01\x12\x04\xe8\x01\x18#\n\x0f\n\
    \x07\x04\x07\x03\0\x02\0\x03\x12\x04\xe8\x01&'\n\x94\x01\n\x04\x04\x07\
    \x03\x01\x12\x06\xed\x01\x02\xef\x01\x03\x1a\x83\x01\x20Strategy\x20used\
    \x20to\x20delete\x20a\x20service.\x20This\x20strategy\x20is\x20a\x20plac\
    eholder\x20only\n\x20used\x20by\x20the\x20system\x20generated\x20rollout\
    \x20to\x20delete\x20a\x20service.\n\n\r\n\x05\x04\x07\x03\x01\x01\x12\
    \x04\xed\x01\n\x1f\n&\n\x04\x04\x07\x04\0\x12\x06\xf2\x01\x02\x89\x02\
    \x03\x1a\x16\x20Status\x20of\x20a\x20Rollout.\n\n\r\n\x05\x04\x07\x04\0\
    \x01\x12\x04\xf2\x01\x07\x14\n&\n\x06\x04\x07\x04\0\x02\0\x12\x04\xf4\
    \x01\x04#\x1a\x16\x20No\x20status\x20specified.\n\n\x0f\n\x07\x04\x07\
    \x04\0\x02\0\x01\x12\x04\xf4\x01\x04\x1e\n\x0f\n\x07\x04\x07\x04\0\x02\0\
    \x02\x12\x04\xf4\x01!\"\n-\n\x06\x04\x07\x04\0\x02\x01\x12\x04\xf7\x01\
    \x04\x14\x1a\x1d\x20The\x20Rollout\x20is\x20in\x20progress.\n\n\x0f\n\
    \x07\x04\x07\x04\0\x02\x01\x01\x12\x04\xf7\x01\x04\x0f\n\x0f\n\x07\x04\
    \x07\x04\0\x02\x01\x02\x12\x04\xf7\x01\x12\x13\n9\n\x06\x04\x07\x04\0\
    \x02\x02\x12\x04\xfa\x01\x04\x10\x1a)\x20The\x20Rollout\x20has\x20comple\
    ted\x20successfully.\n\n\x0f\n\x07\x04\x07\x04\0\x02\x02\x01\x12\x04\xfa\
    \x01\x04\x0b\n\x0f\n\x07\x04\x07\x04\0\x02\x02\x02\x12\x04\xfa\x01\x0e\
    \x0f\n\x94\x01\n\x06\x04\x07\x04\0\x02\x03\x12\x04\xfe\x01\x04\x12\x1a\
    \x83\x01\x20The\x20Rollout\x20has\x20been\x20cancelled.\x20This\x20can\
    \x20happen\x20if\x20you\x20have\x20overlapping\n\x20Rollout\x20pushes,\
    \x20and\x20the\x20previous\x20ones\x20will\x20be\x20cancelled.\n\n\x0f\n\
    \x07\x04\x07\x04\0\x02\x03\x01\x12\x04\xfe\x01\x04\r\n\x0f\n\x07\x04\x07\
    \x04\0\x02\x03\x02\x12\x04\xfe\x01\x10\x11\nQ\n\x06\x04\x07\x04\0\x02\
    \x04\x12\x04\x81\x02\x04\x0f\x1aA\x20The\x20Rollout\x20has\x20failed\x20\
    and\x20the\x20rollback\x20attempt\x20has\x20failed\x20too.\n\n\x0f\n\x07\
    \x04\x07\x04\0\x02\x04\x01\x12\x04\x81\x02\x04\n\n\x0f\n\x07\x04\x07\x04\
    \0\x02\x04\x02\x12\x04\x81\x02\r\x0e\nO\n\x06\x04\x07\x04\0\x02\x05\x12\
    \x04\x84\x02\x04\x10\x1a?\x20The\x20Rollout\x20has\x20not\x20started\x20\
    yet\x20and\x20is\x20pending\x20for\x20execution.\n\n\x0f\n\x07\x04\x07\
    \x04\0\x02\x05\x01\x12\x04\x84\x02\x04\x0b\n\x0f\n\x07\x04\x07\x04\0\x02\
    \x05\x02\x12\x04\x84\x02\x0e\x0f\n]\n\x06\x04\x07\x04\0\x02\x06\x12\x04\
    \x88\x02\x04\x1b\x1aM\x20The\x20Rollout\x20has\x20failed\x20and\x20rolle\
    d\x20back\x20to\x20the\x20previous\x20successful\n\x20Rollout.\n\n\x0f\n\
    \x07\x04\x07\x04\0\x02\x06\x01\x12\x04\x88\x02\x04\x16\n\x0f\n\x07\x04\
    \x07\x04\0\x02\x06\x02\x12\x04\x88\x02\x19\x1a\n\xfe\x03\n\x04\x04\x07\
    \x02\0\x12\x04\x93\x02\x02A\x1a\xef\x03\x20Optional.\x20Unique\x20identi\
    fier\x20of\x20this\x20Rollout.\x20Must\x20be\x20no\x20longer\x20than\x20\
    63\x20characters\n\x20and\x20only\x20lower\x20case\x20letters,\x20digits\
    ,\x20'.',\x20'_'\x20and\x20'-'\x20are\x20allowed.\n\n\x20If\x20not\x20sp\
    ecified\x20by\x20client,\x20the\x20server\x20will\x20generate\x20one.\
    \x20The\x20generated\x20id\n\x20will\x20have\x20the\x20form\x20of\x20<da\
    te><revision\x20number>,\x20where\x20\"date\"\x20is\x20the\x20create\n\
    \x20date\x20in\x20ISO\x208601\x20format.\x20\x20\"revision\x20number\"\
    \x20is\x20a\x20monotonically\x20increasing\n\x20positive\x20number\x20th\
    at\x20is\x20reset\x20every\x20day\x20for\x20each\x20service.\n\x20An\x20\
    example\x20of\x20the\x20generated\x20rollout_id\x20is\x20'2016-02-16r1'\
    \n\n\x0f\n\x05\x04\x07\x02\0\x04\x12\x06\x93\x02\x02\x89\x02\x03\n\r\n\
    \x05\x04\x07\x02\0\x05\x12\x04\x93\x02\x02\x08\n\r\n\x05\x04\x07\x02\0\
    \x01\x12\x04\x93\x02\t\x13\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\x93\x02\
    \x16\x17\n\r\n\x05\x04\x07\x02\0\x08\x12\x04\x93\x02\x18@\n\x10\n\x08\
    \x04\x07\x02\0\x08\x9c\x08\0\x12\x04\x93\x02\x19?\n7\n\x04\x04\x07\x02\
    \x01\x12\x04\x96\x02\x02,\x1a)\x20Creation\x20time\x20of\x20the\x20rollo\
    ut.\x20Readonly.\n\n\x0f\n\x05\x04\x07\x02\x01\x04\x12\x06\x96\x02\x02\
    \x93\x02A\n\r\n\x05\x04\x07\x02\x01\x06\x12\x04\x96\x02\x02\x1b\n\r\n\
    \x05\x04\x07\x02\x01\x01\x12\x04\x96\x02\x1c'\n\r\n\x05\x04\x07\x02\x01\
    \x03\x12\x04\x96\x02*+\n;\n\x04\x04\x07\x02\x02\x12\x04\x99\x02\x02\x18\
    \x1a-\x20The\x20user\x20who\x20created\x20the\x20Rollout.\x20Readonly.\n\
    \n\x0f\n\x05\x04\x07\x02\x02\x04\x12\x06\x99\x02\x02\x96\x02,\n\r\n\x05\
    \x04\x07\x02\x02\x05\x12\x04\x99\x02\x02\x08\n\r\n\x05\x04\x07\x02\x02\
    \x01\x12\x04\x99\x02\t\x13\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\x99\x02\
    \x16\x17\n\xa6\x01\n\x04\x04\x07\x02\x03\x12\x04\x9e\x02\x02\x1b\x1a\x97\
    \x01\x20The\x20status\x20of\x20this\x20rollout.\x20Readonly.\x20In\x20ca\
    se\x20of\x20a\x20failed\x20rollout,\n\x20the\x20system\x20will\x20automa\
    tically\x20rollback\x20to\x20the\x20current\x20Rollout\n\x20version.\x20\
    Readonly.\n\n\x0f\n\x05\x04\x07\x02\x03\x04\x12\x06\x9e\x02\x02\x99\x02\
    \x18\n\r\n\x05\x04\x07\x02\x03\x06\x12\x04\x9e\x02\x02\x0f\n\r\n\x05\x04\
    \x07\x02\x03\x01\x12\x04\x9e\x02\x10\x16\n\r\n\x05\x04\x07\x02\x03\x03\
    \x12\x04\x9e\x02\x19\x1a\n\x8b\x01\n\x04\x04\x07\x08\0\x12\x06\xa3\x02\
    \x02\xab\x02\x03\x1a{\x20Strategy\x20that\x20defines\x20which\x20version\
    s\x20of\x20service\x20configurations\x20should\x20be\n\x20pushed\n\x20an\
    d\x20how\x20they\x20should\x20be\x20used\x20at\x20runtime.\n\n\r\n\x05\
    \x04\x07\x08\0\x01\x12\x04\xa3\x02\x08\x10\nc\n\x04\x04\x07\x02\x04\x12\
    \x04\xa6\x02\x048\x1aU\x20Google\x20Service\x20Control\x20selects\x20ser\
    vice\x20configurations\x20based\x20on\n\x20traffic\x20percentage.\n\n\r\
    \n\x05\x04\x07\x02\x04\x06\x12\x04\xa6\x02\x04\x1a\n\r\n\x05\x04\x07\x02\
    \x04\x01\x12\x04\xa6\x02\x1b3\n\r\n\x05\x04\x07\x02\x04\x03\x12\x04\xa6\
    \x0267\n_\n\x04\x04\x07\x02\x05\x12\x04\xaa\x02\x048\x1aQ\x20The\x20stra\
    tegy\x20associated\x20with\x20a\x20rollout\x20to\x20delete\x20a\x20`Mana\
    gedService`.\n\x20Readonly.\n\n\r\n\x05\x04\x07\x02\x05\x06\x12\x04\xaa\
    \x02\x04\x19\n\r\n\x05\x04\x07\x02\x05\x01\x12\x04\xaa\x02\x1a1\n\r\n\
    \x05\x04\x07\x02\x05\x03\x12\x04\xaa\x0247\nE\n\x04\x04\x07\x02\x06\x12\
    \x04\xae\x02\x02\x1a\x1a7\x20The\x20name\x20of\x20the\x20service\x20asso\
    ciated\x20with\x20this\x20Rollout.\n\n\x0f\n\x05\x04\x07\x02\x06\x04\x12\
    \x06\xae\x02\x02\xab\x02\x03\n\r\n\x05\x04\x07\x02\x06\x05\x12\x04\xae\
    \x02\x02\x08\n\r\n\x05\x04\x07\x02\x06\x01\x12\x04\xae\x02\t\x15\n\r\n\
    \x05\x04\x07\x02\x06\x03\x12\x04\xae\x02\x18\x19b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
