// This file is generated by rust-protobuf 2.22.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/api/quota.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_22_0;

#[derive(PartialEq,Clone,Default)]
pub struct Quota {
    // message fields
    pub limits: ::protobuf::RepeatedField<QuotaLimit>,
    pub metric_rules: ::protobuf::RepeatedField<MetricRule>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Quota {
    fn default() -> &'a Quota {
        <Quota as ::protobuf::Message>::default_instance()
    }
}

impl Quota {
    pub fn new() -> Quota {
        ::std::default::Default::default()
    }

    // repeated .google.api.QuotaLimit limits = 3;


    pub fn get_limits(&self) -> &[QuotaLimit] {
        &self.limits
    }
    pub fn clear_limits(&mut self) {
        self.limits.clear();
    }

    // Param is passed by value, moved
    pub fn set_limits(&mut self, v: ::protobuf::RepeatedField<QuotaLimit>) {
        self.limits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_limits(&mut self) -> &mut ::protobuf::RepeatedField<QuotaLimit> {
        &mut self.limits
    }

    // Take field
    pub fn take_limits(&mut self) -> ::protobuf::RepeatedField<QuotaLimit> {
        ::std::mem::replace(&mut self.limits, ::protobuf::RepeatedField::new())
    }

    // repeated .google.api.MetricRule metric_rules = 4;


    pub fn get_metric_rules(&self) -> &[MetricRule] {
        &self.metric_rules
    }
    pub fn clear_metric_rules(&mut self) {
        self.metric_rules.clear();
    }

    // Param is passed by value, moved
    pub fn set_metric_rules(&mut self, v: ::protobuf::RepeatedField<MetricRule>) {
        self.metric_rules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metric_rules(&mut self) -> &mut ::protobuf::RepeatedField<MetricRule> {
        &mut self.metric_rules
    }

    // Take field
    pub fn take_metric_rules(&mut self) -> ::protobuf::RepeatedField<MetricRule> {
        ::std::mem::replace(&mut self.metric_rules, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Quota {
    fn is_initialized(&self) -> bool {
        for v in &self.limits {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metric_rules {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.limits)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metric_rules)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.limits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.metric_rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.limits {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.metric_rules {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Quota {
        Quota::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QuotaLimit>>(
                "limits",
                |m: &Quota| { &m.limits },
                |m: &mut Quota| { &mut m.limits },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetricRule>>(
                "metric_rules",
                |m: &Quota| { &m.metric_rules },
                |m: &mut Quota| { &mut m.metric_rules },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Quota>(
                "Quota",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Quota {
        static instance: ::protobuf::rt::LazyV2<Quota> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Quota::new)
    }
}

impl ::protobuf::Clear for Quota {
    fn clear(&mut self) {
        self.limits.clear();
        self.metric_rules.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Quota {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Quota {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetricRule {
    // message fields
    pub selector: ::std::string::String,
    pub metric_costs: ::std::collections::HashMap<::std::string::String, i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetricRule {
    fn default() -> &'a MetricRule {
        <MetricRule as ::protobuf::Message>::default_instance()
    }
}

impl MetricRule {
    pub fn new() -> MetricRule {
        ::std::default::Default::default()
    }

    // string selector = 1;


    pub fn get_selector(&self) -> &str {
        &self.selector
    }
    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: ::std::string::String) {
        self.selector = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selector(&mut self) -> &mut ::std::string::String {
        &mut self.selector
    }

    // Take field
    pub fn take_selector(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.selector, ::std::string::String::new())
    }

    // repeated .google.api.MetricRule.MetricCostsEntry metric_costs = 2;


    pub fn get_metric_costs(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.metric_costs
    }
    pub fn clear_metric_costs(&mut self) {
        self.metric_costs.clear();
    }

    // Param is passed by value, moved
    pub fn set_metric_costs(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.metric_costs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metric_costs(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.metric_costs
    }

    // Take field
    pub fn take_metric_costs(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.metric_costs, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for MetricRule {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.selector)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.metric_costs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.selector.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.selector);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(2, &self.metric_costs);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.selector.is_empty() {
            os.write_string(1, &self.selector)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(2, &self.metric_costs, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetricRule {
        MetricRule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "selector",
                |m: &MetricRule| { &m.selector },
                |m: &mut MetricRule| { &mut m.selector },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                "metric_costs",
                |m: &MetricRule| { &m.metric_costs },
                |m: &mut MetricRule| { &mut m.metric_costs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MetricRule>(
                "MetricRule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MetricRule {
        static instance: ::protobuf::rt::LazyV2<MetricRule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MetricRule::new)
    }
}

impl ::protobuf::Clear for MetricRule {
    fn clear(&mut self) {
        self.selector.clear();
        self.metric_costs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetricRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetricRule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QuotaLimit {
    // message fields
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    pub default_limit: i64,
    pub max_limit: i64,
    pub free_tier: i64,
    pub duration: ::std::string::String,
    pub metric: ::std::string::String,
    pub unit: ::std::string::String,
    pub values: ::std::collections::HashMap<::std::string::String, i64>,
    pub display_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuotaLimit {
    fn default() -> &'a QuotaLimit {
        <QuotaLimit as ::protobuf::Message>::default_instance()
    }
}

impl QuotaLimit {
    pub fn new() -> QuotaLimit {
        ::std::default::Default::default()
    }

    // string name = 6;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // int64 default_limit = 3;


    pub fn get_default_limit(&self) -> i64 {
        self.default_limit
    }
    pub fn clear_default_limit(&mut self) {
        self.default_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_default_limit(&mut self, v: i64) {
        self.default_limit = v;
    }

    // int64 max_limit = 4;


    pub fn get_max_limit(&self) -> i64 {
        self.max_limit
    }
    pub fn clear_max_limit(&mut self) {
        self.max_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_limit(&mut self, v: i64) {
        self.max_limit = v;
    }

    // int64 free_tier = 7;


    pub fn get_free_tier(&self) -> i64 {
        self.free_tier
    }
    pub fn clear_free_tier(&mut self) {
        self.free_tier = 0;
    }

    // Param is passed by value, moved
    pub fn set_free_tier(&mut self, v: i64) {
        self.free_tier = v;
    }

    // string duration = 5;


    pub fn get_duration(&self) -> &str {
        &self.duration
    }
    pub fn clear_duration(&mut self) {
        self.duration.clear();
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: ::std::string::String) {
        self.duration = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duration(&mut self) -> &mut ::std::string::String {
        &mut self.duration
    }

    // Take field
    pub fn take_duration(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.duration, ::std::string::String::new())
    }

    // string metric = 8;


    pub fn get_metric(&self) -> &str {
        &self.metric
    }
    pub fn clear_metric(&mut self) {
        self.metric.clear();
    }

    // Param is passed by value, moved
    pub fn set_metric(&mut self, v: ::std::string::String) {
        self.metric = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metric(&mut self) -> &mut ::std::string::String {
        &mut self.metric
    }

    // Take field
    pub fn take_metric(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.metric, ::std::string::String::new())
    }

    // string unit = 9;


    pub fn get_unit(&self) -> &str {
        &self.unit
    }
    pub fn clear_unit(&mut self) {
        self.unit.clear();
    }

    // Param is passed by value, moved
    pub fn set_unit(&mut self, v: ::std::string::String) {
        self.unit = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit(&mut self) -> &mut ::std::string::String {
        &mut self.unit
    }

    // Take field
    pub fn take_unit(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unit, ::std::string::String::new())
    }

    // repeated .google.api.QuotaLimit.ValuesEntry values = 10;


    pub fn get_values(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.values
    }
    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.values, ::std::collections::HashMap::new())
    }

    // string display_name = 12;


    pub fn get_display_name(&self) -> &str {
        &self.display_name
    }
    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        &mut self.display_name
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.display_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for QuotaLimit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.default_limit = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_limit = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.free_tier = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.duration)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.metric)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unit)?;
                },
                10 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.values)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.display_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if self.default_limit != 0 {
            my_size += ::protobuf::rt::value_size(3, self.default_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_limit != 0 {
            my_size += ::protobuf::rt::value_size(4, self.max_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.free_tier != 0 {
            my_size += ::protobuf::rt::value_size(7, self.free_tier, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.duration.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.duration);
        }
        if !self.metric.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.metric);
        }
        if !self.unit.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.unit);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(10, &self.values);
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.display_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(6, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if self.default_limit != 0 {
            os.write_int64(3, self.default_limit)?;
        }
        if self.max_limit != 0 {
            os.write_int64(4, self.max_limit)?;
        }
        if self.free_tier != 0 {
            os.write_int64(7, self.free_tier)?;
        }
        if !self.duration.is_empty() {
            os.write_string(5, &self.duration)?;
        }
        if !self.metric.is_empty() {
            os.write_string(8, &self.metric)?;
        }
        if !self.unit.is_empty() {
            os.write_string(9, &self.unit)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(10, &self.values, os)?;
        if !self.display_name.is_empty() {
            os.write_string(12, &self.display_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuotaLimit {
        QuotaLimit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &QuotaLimit| { &m.name },
                |m: &mut QuotaLimit| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &QuotaLimit| { &m.description },
                |m: &mut QuotaLimit| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "default_limit",
                |m: &QuotaLimit| { &m.default_limit },
                |m: &mut QuotaLimit| { &mut m.default_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "max_limit",
                |m: &QuotaLimit| { &m.max_limit },
                |m: &mut QuotaLimit| { &mut m.max_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "free_tier",
                |m: &QuotaLimit| { &m.free_tier },
                |m: &mut QuotaLimit| { &mut m.free_tier },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "duration",
                |m: &QuotaLimit| { &m.duration },
                |m: &mut QuotaLimit| { &mut m.duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "metric",
                |m: &QuotaLimit| { &m.metric },
                |m: &mut QuotaLimit| { &mut m.metric },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unit",
                |m: &QuotaLimit| { &m.unit },
                |m: &mut QuotaLimit| { &mut m.unit },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                "values",
                |m: &QuotaLimit| { &m.values },
                |m: &mut QuotaLimit| { &mut m.values },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "display_name",
                |m: &QuotaLimit| { &m.display_name },
                |m: &mut QuotaLimit| { &mut m.display_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QuotaLimit>(
                "QuotaLimit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QuotaLimit {
        static instance: ::protobuf::rt::LazyV2<QuotaLimit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuotaLimit::new)
    }
}

impl ::protobuf::Clear for QuotaLimit {
    fn clear(&mut self) {
        self.name.clear();
        self.description.clear();
        self.default_limit = 0;
        self.max_limit = 0;
        self.free_tier = 0;
        self.duration.clear();
        self.metric.clear();
        self.unit.clear();
        self.values.clear();
        self.display_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QuotaLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuotaLimit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x16google/api/quota.proto\x12\ngoogle.api\"r\n\x05Quota\x12.\n\x06lim\
    its\x18\x03\x20\x03(\x0b2\x16.google.api.QuotaLimitR\x06limits\x129\n\
    \x0cmetric_rules\x18\x04\x20\x03(\x0b2\x16.google.api.MetricRuleR\x0bmet\
    ricRules\"\xb4\x01\n\nMetricRule\x12\x1a\n\x08selector\x18\x01\x20\x01(\
    \tR\x08selector\x12J\n\x0cmetric_costs\x18\x02\x20\x03(\x0b2'.google.api\
    .MetricRule.MetricCostsEntryR\x0bmetricCosts\x1a>\n\x10MetricCostsEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\x03R\x05value:\x028\x01\"\x83\x03\n\nQuotaLimit\x12\x12\n\x04n\
    ame\x18\x06\x20\x01(\tR\x04name\x12\x20\n\x0bdescription\x18\x02\x20\x01\
    (\tR\x0bdescription\x12#\n\rdefault_limit\x18\x03\x20\x01(\x03R\x0cdefau\
    ltLimit\x12\x1b\n\tmax_limit\x18\x04\x20\x01(\x03R\x08maxLimit\x12\x1b\n\
    \tfree_tier\x18\x07\x20\x01(\x03R\x08freeTier\x12\x1a\n\x08duration\x18\
    \x05\x20\x01(\tR\x08duration\x12\x16\n\x06metric\x18\x08\x20\x01(\tR\x06\
    metric\x12\x12\n\x04unit\x18\t\x20\x01(\tR\x04unit\x12:\n\x06values\x18\
    \n\x20\x03(\x0b2\".google.api.QuotaLimit.ValuesEntryR\x06values\x12!\n\
    \x0cdisplay_name\x18\x0c\x20\x01(\tR\x0bdisplayName\x1a9\n\x0bValuesEntr\
    y\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\x03R\x05value:\x028\x01Bl\n\x0ecom.google.apiB\nQuotaProtoP\
    \x01ZEgoogle.golang.org/genproto/googleapis/api/serviceconfig;servicecon\
    fig\xa2\x02\x04GAPIJ\xea8\n\x07\x12\x05\x0e\0\xb6\x01\x01\n\xbc\x04\n\
    \x01\x0c\x12\x03\x0e\0\x122\xb1\x04\x20Copyright\x202020\x20Google\x20LL\
    C\n\n\x20Licensed\x20under\x20the\x20Apache\x20License,\x20Version\x202.\
    0\x20(the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\x20file\
    \x20except\x20in\x20compliance\x20with\x20the\x20License.\n\x20You\x20ma\
    y\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\
    \x20\x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\x20requ\
    ired\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\
    \x20software\n\x20distributed\x20under\x20the\x20License\x20is\x20distri\
    buted\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\
    \x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\
    \x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20specific\x20lan\
    guage\x20governing\x20permissions\x20and\n\x20limitations\x20under\x20th\
    e\x20License.\n\n\x08\n\x01\x02\x12\x03\x10\0\x13\n\x08\n\x01\x08\x12\
    \x03\x12\0\\\n\t\n\x02\x08\x0b\x12\x03\x12\0\\\n\x08\n\x01\x08\x12\x03\
    \x13\0\"\n\t\n\x02\x08\n\x12\x03\x13\0\"\n\x08\n\x01\x08\x12\x03\x14\0+\
    \n\t\n\x02\x08\x08\x12\x03\x14\0+\n\x08\n\x01\x08\x12\x03\x15\0'\n\t\n\
    \x02\x08\x01\x12\x03\x15\0'\n\x08\n\x01\x08\x12\x03\x16\0\"\n\t\n\x02\
    \x08$\x12\x03\x16\0\"\n\x87\r\n\x02\x04\0\x12\x04K\0R\x01\x1a\xfa\x0c\
    \x20Quota\x20configuration\x20helps\x20to\x20achieve\x20fairness\x20and\
    \x20budgeting\x20in\x20service\n\x20usage.\n\n\x20The\x20metric\x20based\
    \x20quota\x20configuration\x20works\x20this\x20way:\n\x20-\x20The\x20ser\
    vice\x20configuration\x20defines\x20a\x20set\x20of\x20metrics.\n\x20-\
    \x20For\x20API\x20calls,\x20the\x20quota.metric_rules\x20maps\x20methods\
    \x20to\x20metrics\x20with\n\x20\x20\x20corresponding\x20costs.\n\x20-\
    \x20The\x20quota.limits\x20defines\x20limits\x20on\x20the\x20metrics,\
    \x20which\x20will\x20be\x20used\x20for\n\x20\x20\x20quota\x20checks\x20a\
    t\x20runtime.\n\n\x20An\x20example\x20quota\x20configuration\x20in\x20ya\
    ml\x20format:\n\n\x20\x20\x20\x20quota:\n\x20\x20\x20\x20\x20\x20limits:\
    \n\n\x20\x20\x20\x20\x20\x20-\x20name:\x20apiWriteQpsPerProject\n\x20\
    \x20\x20\x20\x20\x20\x20\x20metric:\x20library.googleapis.com/write_call\
    s\n\x20\x20\x20\x20\x20\x20\x20\x20unit:\x20\"1/min/{project}\"\x20\x20#\
    \x20rate\x20limit\x20for\x20consumer\x20projects\n\x20\x20\x20\x20\x20\
    \x20\x20\x20values:\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20STANDARD:\
    \x2010000\n\n\n\x20\x20\x20\x20\x20\x20#\x20The\x20metric\x20rules\x20bi\
    nd\x20all\x20methods\x20to\x20the\x20read_calls\x20metric,\n\x20\x20\x20\
    \x20\x20\x20#\x20except\x20for\x20the\x20UpdateBook\x20and\x20DeleteBook\
    \x20methods.\x20These\x20two\x20methods\n\x20\x20\x20\x20\x20\x20#\x20ar\
    e\x20mapped\x20to\x20the\x20write_calls\x20metric,\x20with\x20the\x20Upd\
    ateBook\x20method\n\x20\x20\x20\x20\x20\x20#\x20consuming\x20at\x20twice\
    \x20rate\x20as\x20the\x20DeleteBook\x20method.\n\x20\x20\x20\x20\x20\x20\
    metric_rules:\n\x20\x20\x20\x20\x20\x20-\x20selector:\x20\"*\"\n\x20\x20\
    \x20\x20\x20\x20\x20\x20metric_costs:\n\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20library.googleapis.com/read_calls:\x201\n\x20\x20\x20\x20\x20\
    \x20-\x20selector:\x20google.example.library.v1.LibraryService.UpdateBoo\
    k\n\x20\x20\x20\x20\x20\x20\x20\x20metric_costs:\n\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20library.googleapis.com/write_calls:\x202\n\x20\x20\
    \x20\x20\x20\x20-\x20selector:\x20google.example.library.v1.LibraryServi\
    ce.DeleteBook\n\x20\x20\x20\x20\x20\x20\x20\x20metric_costs:\n\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20library.googleapis.com/write_calls:\x201\
    \n\n\x20\x20Corresponding\x20Metric\x20definition:\n\n\x20\x20\x20\x20\
    \x20\x20metrics:\n\x20\x20\x20\x20\x20\x20-\x20name:\x20library.googleap\
    is.com/read_calls\n\x20\x20\x20\x20\x20\x20\x20\x20display_name:\x20Read\
    \x20requests\n\x20\x20\x20\x20\x20\x20\x20\x20metric_kind:\x20DELTA\n\
    \x20\x20\x20\x20\x20\x20\x20\x20value_type:\x20INT64\n\n\x20\x20\x20\x20\
    \x20\x20-\x20name:\x20library.googleapis.com/write_calls\n\x20\x20\x20\
    \x20\x20\x20\x20\x20display_name:\x20Write\x20requests\n\x20\x20\x20\x20\
    \x20\x20\x20\x20metric_kind:\x20DELTA\n\x20\x20\x20\x20\x20\x20\x20\x20v\
    alue_type:\x20INT64\n\n\n\n\n\n\x03\x04\0\x01\x12\x03K\x08\r\n@\n\x04\
    \x04\0\x02\0\x12\x03M\x02!\x1a3\x20List\x20of\x20`QuotaLimit`\x20definit\
    ions\x20for\x20the\x20service.\n\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03M\
    \x02\n\n\x0c\n\x05\x04\0\x02\0\x06\x12\x03M\x0b\x15\n\x0c\n\x05\x04\0\
    \x02\0\x01\x12\x03M\x16\x1c\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03M\x1f\x20\
    \nl\n\x04\x04\0\x02\x01\x12\x03Q\x02'\x1a_\x20List\x20of\x20`MetricRule`\
    \x20definitions,\x20each\x20one\x20mapping\x20a\x20selected\x20method\
    \x20to\x20one\n\x20or\x20more\x20metrics.\n\n\x0c\n\x05\x04\0\x02\x01\
    \x04\x12\x03Q\x02\n\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x03Q\x0b\x15\n\x0c\
    \n\x05\x04\0\x02\x01\x01\x12\x03Q\x16\"\n\x0c\n\x05\x04\0\x02\x01\x03\
    \x12\x03Q%&\n\x96\x01\n\x02\x04\x01\x12\x04V\0c\x01\x1a\x89\x01\x20Bind\
    \x20API\x20methods\x20to\x20metrics.\x20Binding\x20a\x20method\x20to\x20\
    a\x20metric\x20causes\x20that\n\x20metric's\x20configured\x20quota\x20be\
    haviors\x20to\x20apply\x20to\x20the\x20method\x20call.\n\n\n\n\x03\x04\
    \x01\x01\x12\x03V\x08\x12\n\x90\x01\n\x04\x04\x01\x02\0\x12\x03Z\x02\x16\
    \x1a\x82\x01\x20Selects\x20the\x20methods\x20to\x20which\x20this\x20rule\
    \x20applies.\n\n\x20Refer\x20to\x20[selector][google.api.DocumentationRu\
    le.selector]\x20for\x20syntax\x20details.\n\n\r\n\x05\x04\x01\x02\0\x04\
    \x12\x04Z\x02V\x14\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03Z\x02\x08\n\x0c\
    \n\x05\x04\x01\x02\0\x01\x12\x03Z\t\x11\n\x0c\n\x05\x04\x01\x02\0\x03\
    \x12\x03Z\x14\x15\n\xa6\x02\n\x04\x04\x01\x02\x01\x12\x03b\x02&\x1a\x98\
    \x02\x20Metrics\x20to\x20update\x20when\x20the\x20selected\x20methods\
    \x20are\x20called,\x20and\x20the\x20associated\n\x20cost\x20applied\x20t\
    o\x20each\x20metric.\n\n\x20The\x20key\x20of\x20the\x20map\x20is\x20the\
    \x20metric\x20name,\x20and\x20the\x20values\x20are\x20the\x20amount\n\
    \x20increased\x20for\x20the\x20metric\x20against\x20which\x20the\x20quot\
    a\x20limits\x20are\x20defined.\n\x20The\x20value\x20must\x20not\x20be\
    \x20negative.\n\n\r\n\x05\x04\x01\x02\x01\x04\x12\x04b\x02Z\x16\n\x0c\n\
    \x05\x04\x01\x02\x01\x06\x12\x03b\x02\x14\n\x0c\n\x05\x04\x01\x02\x01\
    \x01\x12\x03b\x15!\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03b$%\n\xd8\x01\
    \n\x02\x04\x02\x12\x05h\0\xb6\x01\x01\x1a\xca\x01\x20`QuotaLimit`\x20def\
    ines\x20a\x20specific\x20limit\x20that\x20applies\x20over\x20a\x20specif\
    ied\x20duration\n\x20for\x20a\x20limit\x20type.\x20There\x20can\x20be\
    \x20at\x20most\x20one\x20limit\x20for\x20a\x20duration\x20and\x20limit\n\
    \x20type\x20combination\x20defined\x20within\x20a\x20`QuotaGroup`.\n\n\n\
    \n\x03\x04\x02\x01\x12\x03h\x08\x12\n\xeb\x01\n\x04\x04\x02\x02\0\x12\
    \x03o\x02\x12\x1a\xdd\x01\x20Name\x20of\x20the\x20quota\x20limit.\n\n\
    \x20The\x20name\x20must\x20be\x20provided,\x20and\x20it\x20must\x20be\
    \x20unique\x20within\x20the\x20service.\x20The\n\x20name\x20can\x20only\
    \x20include\x20alphanumeric\x20characters\x20as\x20well\x20as\x20'-'.\n\
    \n\x20The\x20maximum\x20length\x20of\x20the\x20limit\x20name\x20is\x2064\
    \x20characters.\n\n\r\n\x05\x04\x02\x02\0\x04\x12\x04o\x02h\x14\n\x0c\n\
    \x05\x04\x02\x02\0\x05\x12\x03o\x02\x08\n\x0c\n\x05\x04\x02\x02\0\x01\
    \x12\x03o\t\r\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03o\x10\x11\n\xde\x01\n\
    \x04\x04\x02\x02\x01\x12\x03t\x02\x19\x1a\xd0\x01\x20Optional.\x20User-v\
    isible,\x20extended\x20description\x20for\x20this\x20quota\x20limit.\n\
    \x20Should\x20be\x20used\x20only\x20when\x20more\x20context\x20is\x20nee\
    ded\x20to\x20understand\x20this\x20limit\n\x20than\x20provided\x20by\x20\
    the\x20limit's\x20display\x20name\x20(see:\x20`display_name`).\n\n\r\n\
    \x05\x04\x02\x02\x01\x04\x12\x04t\x02o\x12\n\x0c\n\x05\x04\x02\x02\x01\
    \x05\x12\x03t\x02\x08\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03t\t\x14\n\
    \x0c\n\x05\x04\x02\x02\x01\x03\x12\x03t\x17\x18\n\xe8\x03\n\x04\x04\x02\
    \x02\x02\x12\x04\x80\x01\x02\x1a\x1a\xd9\x03\x20Default\x20number\x20of\
    \x20tokens\x20that\x20can\x20be\x20consumed\x20during\x20the\x20specifie\
    d\n\x20duration.\x20This\x20is\x20the\x20number\x20of\x20tokens\x20assig\
    ned\x20when\x20a\x20client\n\x20application\x20developer\x20activates\
    \x20the\x20service\x20for\x20his/her\x20project.\n\n\x20Specifying\x20a\
    \x20value\x20of\x200\x20will\x20block\x20all\x20requests.\x20This\x20can\
    \x20be\x20used\x20if\x20you\n\x20are\x20provisioning\x20quota\x20to\x20s\
    elected\x20consumers\x20and\x20blocking\x20others.\n\x20Similarly,\x20a\
    \x20value\x20of\x20-1\x20will\x20indicate\x20an\x20unlimited\x20quota.\
    \x20No\x20other\n\x20negative\x20values\x20are\x20allowed.\n\n\x20Used\
    \x20by\x20group-based\x20quotas\x20only.\n\n\x0e\n\x05\x04\x02\x02\x02\
    \x04\x12\x05\x80\x01\x02t\x19\n\r\n\x05\x04\x02\x02\x02\x05\x12\x04\x80\
    \x01\x02\x07\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\x80\x01\x08\x15\n\r\n\
    \x05\x04\x02\x02\x02\x03\x12\x04\x80\x01\x18\x19\n\xc5\x03\n\x04\x04\x02\
    \x02\x03\x12\x04\x8b\x01\x02\x16\x1a\xb6\x03\x20Maximum\x20number\x20of\
    \x20tokens\x20that\x20can\x20be\x20consumed\x20during\x20the\x20specifie\
    d\n\x20duration.\x20Client\x20application\x20developers\x20can\x20overri\
    de\x20the\x20default\x20limit\x20up\n\x20to\x20this\x20maximum.\x20If\
    \x20specified,\x20this\x20value\x20cannot\x20be\x20set\x20to\x20a\x20val\
    ue\x20less\n\x20than\x20the\x20default\x20limit.\x20If\x20not\x20specifi\
    ed,\x20it\x20is\x20set\x20to\x20the\x20default\x20limit.\n\n\x20To\x20al\
    low\x20clients\x20to\x20apply\x20overrides\x20with\x20no\x20upper\x20bou\
    nd,\x20set\x20this\x20to\x20-1,\n\x20indicating\x20unlimited\x20maximum\
    \x20quota.\n\n\x20Used\x20by\x20group-based\x20quotas\x20only.\n\n\x0f\n\
    \x05\x04\x02\x02\x03\x04\x12\x06\x8b\x01\x02\x80\x01\x1a\n\r\n\x05\x04\
    \x02\x02\x03\x05\x12\x04\x8b\x01\x02\x07\n\r\n\x05\x04\x02\x02\x03\x01\
    \x12\x04\x8b\x01\x08\x11\n\r\n\x05\x04\x02\x02\x03\x03\x12\x04\x8b\x01\
    \x14\x15\n\xbf\x03\n\x04\x04\x02\x02\x04\x12\x04\x95\x01\x02\x16\x1a\xb0\
    \x03\x20Free\x20tier\x20value\x20displayed\x20in\x20the\x20Developers\
    \x20Console\x20for\x20this\x20limit.\n\x20The\x20free\x20tier\x20is\x20t\
    he\x20number\x20of\x20tokens\x20that\x20will\x20be\x20subtracted\x20from\
    \x20the\n\x20billed\x20amount\x20when\x20billing\x20is\x20enabled.\n\x20\
    This\x20field\x20can\x20only\x20be\x20set\x20on\x20a\x20limit\x20with\
    \x20duration\x20\"1d\",\x20in\x20a\x20billable\n\x20group;\x20it\x20is\
    \x20invalid\x20on\x20any\x20other\x20limit.\x20If\x20this\x20field\x20is\
    \x20not\x20set,\x20it\n\x20defaults\x20to\x200,\x20indicating\x20that\
    \x20there\x20is\x20no\x20free\x20tier\x20for\x20this\x20service.\n\n\x20\
    Used\x20by\x20group-based\x20quotas\x20only.\n\n\x0f\n\x05\x04\x02\x02\
    \x04\x04\x12\x06\x95\x01\x02\x8b\x01\x16\n\r\n\x05\x04\x02\x02\x04\x05\
    \x12\x04\x95\x01\x02\x07\n\r\n\x05\x04\x02\x02\x04\x01\x12\x04\x95\x01\
    \x08\x11\n\r\n\x05\x04\x02\x02\x04\x03\x12\x04\x95\x01\x14\x15\nv\n\x04\
    \x04\x02\x02\x05\x12\x04\x9a\x01\x02\x16\x1ah\x20Duration\x20of\x20this\
    \x20limit\x20in\x20textual\x20notation.\x20Must\x20be\x20\"100s\"\x20or\
    \x20\"1d\".\n\n\x20Used\x20by\x20group-based\x20quotas\x20only.\n\n\x0f\
    \n\x05\x04\x02\x02\x05\x04\x12\x06\x9a\x01\x02\x95\x01\x16\n\r\n\x05\x04\
    \x02\x02\x05\x05\x12\x04\x9a\x01\x02\x08\n\r\n\x05\x04\x02\x02\x05\x01\
    \x12\x04\x9a\x01\t\x11\n\r\n\x05\x04\x02\x02\x05\x03\x12\x04\x9a\x01\x14\
    \x15\n\xcb\x01\n\x04\x04\x02\x02\x06\x12\x04\x9f\x01\x02\x14\x1a\xbc\x01\
    \x20The\x20name\x20of\x20the\x20metric\x20this\x20quota\x20limit\x20appl\
    ies\x20to.\x20The\x20quota\x20limits\x20with\n\x20the\x20same\x20metric\
    \x20will\x20be\x20checked\x20together\x20during\x20runtime.\x20The\x20me\
    tric\x20must\x20be\n\x20defined\x20within\x20the\x20service\x20config.\n\
    \n\x0f\n\x05\x04\x02\x02\x06\x04\x12\x06\x9f\x01\x02\x9a\x01\x16\n\r\n\
    \x05\x04\x02\x02\x06\x05\x12\x04\x9f\x01\x02\x08\n\r\n\x05\x04\x02\x02\
    \x06\x01\x12\x04\x9f\x01\t\x0f\n\r\n\x05\x04\x02\x02\x06\x03\x12\x04\x9f\
    \x01\x12\x13\n\xf8\x02\n\x04\x04\x02\x02\x07\x12\x04\xaa\x01\x02\x12\x1a\
    \xe9\x02\x20Specify\x20the\x20unit\x20of\x20the\x20quota\x20limit.\x20It\
    \x20uses\x20the\x20same\x20syntax\x20as\n\x20[Metric.unit][].\x20The\x20\
    supported\x20unit\x20kinds\x20are\x20determined\x20by\x20the\x20quota\n\
    \x20backend\x20system.\n\n\x20Here\x20are\x20some\x20examples:\n\x20*\
    \x20\"1/min/{project}\"\x20for\x20quota\x20per\x20minute\x20per\x20proje\
    ct.\n\n\x20Note:\x20the\x20order\x20of\x20unit\x20components\x20is\x20in\
    significant.\n\x20The\x20\"1\"\x20at\x20the\x20beginning\x20is\x20requir\
    ed\x20to\x20follow\x20the\x20metric\x20unit\x20syntax.\n\n\x0f\n\x05\x04\
    \x02\x02\x07\x04\x12\x06\xaa\x01\x02\x9f\x01\x14\n\r\n\x05\x04\x02\x02\
    \x07\x05\x12\x04\xaa\x01\x02\x08\n\r\n\x05\x04\x02\x02\x07\x01\x12\x04\
    \xaa\x01\t\r\n\r\n\x05\x04\x02\x02\x07\x03\x12\x04\xaa\x01\x10\x11\n\xd5\
    \x01\n\x04\x04\x02\x02\x08\x12\x04\xaf\x01\x02!\x1a\xc6\x01\x20Tiered\
    \x20limit\x20values.\x20You\x20must\x20specify\x20this\x20as\x20a\x20key\
    :value\x20pair,\x20with\x20an\n\x20integer\x20value\x20that\x20is\x20the\
    \x20maximum\x20number\x20of\x20requests\x20allowed\x20for\x20the\n\x20sp\
    ecified\x20unit.\x20Currently\x20only\x20STANDARD\x20is\x20supported.\n\
    \n\x0f\n\x05\x04\x02\x02\x08\x04\x12\x06\xaf\x01\x02\xaa\x01\x12\n\r\n\
    \x05\x04\x02\x02\x08\x06\x12\x04\xaf\x01\x02\x14\n\r\n\x05\x04\x02\x02\
    \x08\x01\x12\x04\xaf\x01\x15\x1b\n\r\n\x05\x04\x02\x02\x08\x03\x12\x04\
    \xaf\x01\x1e\x20\n\xfe\x01\n\x04\x04\x02\x02\t\x12\x04\xb5\x01\x02\x1b\
    \x1a\xef\x01\x20User-visible\x20display\x20name\x20for\x20this\x20limit.\
    \n\x20Optional.\x20If\x20not\x20set,\x20the\x20UI\x20will\x20provide\x20\
    a\x20default\x20display\x20name\x20based\x20on\n\x20the\x20quota\x20conf\
    iguration.\x20This\x20field\x20can\x20be\x20used\x20to\x20override\x20th\
    e\x20default\n\x20display\x20name\x20generated\x20from\x20the\x20configu\
    ration.\n\n\x0f\n\x05\x04\x02\x02\t\x04\x12\x06\xb5\x01\x02\xaf\x01!\n\r\
    \n\x05\x04\x02\x02\t\x05\x12\x04\xb5\x01\x02\x08\n\r\n\x05\x04\x02\x02\t\
    \x01\x12\x04\xb5\x01\t\x15\n\r\n\x05\x04\x02\x02\t\x03\x12\x04\xb5\x01\
    \x18\x1ab\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
