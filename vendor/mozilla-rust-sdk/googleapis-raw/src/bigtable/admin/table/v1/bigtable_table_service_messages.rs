// This file is generated by rust-protobuf 2.7.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/bigtable/admin/table/v1/bigtable_table_service_messages.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_7_0;

#[derive(PartialEq,Clone,Default)]
pub struct CreateTableRequest {
    // message fields
    pub name: ::std::string::String,
    pub table_id: ::std::string::String,
    pub table: ::protobuf::SingularPtrField<super::bigtable_table_data::Table>,
    pub initial_split_keys: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateTableRequest {
    fn default() -> &'a CreateTableRequest {
        <CreateTableRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateTableRequest {
    pub fn new() -> CreateTableRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string table_id = 2;


    pub fn get_table_id(&self) -> &str {
        &self.table_id
    }
    pub fn clear_table_id(&mut self) {
        self.table_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_table_id(&mut self, v: ::std::string::String) {
        self.table_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_id(&mut self) -> &mut ::std::string::String {
        &mut self.table_id
    }

    // Take field
    pub fn take_table_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.table_id, ::std::string::String::new())
    }

    // .google.bigtable.admin.table.v1.Table table = 3;


    pub fn get_table(&self) -> &super::bigtable_table_data::Table {
        self.table.as_ref().unwrap_or_else(|| super::bigtable_table_data::Table::default_instance())
    }
    pub fn clear_table(&mut self) {
        self.table.clear();
    }

    pub fn has_table(&self) -> bool {
        self.table.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table(&mut self, v: super::bigtable_table_data::Table) {
        self.table = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table(&mut self) -> &mut super::bigtable_table_data::Table {
        if self.table.is_none() {
            self.table.set_default();
        }
        self.table.as_mut().unwrap()
    }

    // Take field
    pub fn take_table(&mut self) -> super::bigtable_table_data::Table {
        self.table.take().unwrap_or_else(|| super::bigtable_table_data::Table::new())
    }

    // repeated string initial_split_keys = 4;


    pub fn get_initial_split_keys(&self) -> &[::std::string::String] {
        &self.initial_split_keys
    }
    pub fn clear_initial_split_keys(&mut self) {
        self.initial_split_keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_initial_split_keys(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.initial_split_keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_initial_split_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.initial_split_keys
    }

    // Take field
    pub fn take_initial_split_keys(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.initial_split_keys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CreateTableRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.table {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.table_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.table)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.initial_split_keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.table_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.table_id);
        }
        if let Some(ref v) = self.table.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.initial_split_keys {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.table_id.is_empty() {
            os.write_string(2, &self.table_id)?;
        }
        if let Some(ref v) = self.table.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.initial_split_keys {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateTableRequest {
        CreateTableRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CreateTableRequest| { &m.name },
                    |m: &mut CreateTableRequest| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "table_id",
                    |m: &CreateTableRequest| { &m.table_id },
                    |m: &mut CreateTableRequest| { &mut m.table_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bigtable_table_data::Table>>(
                    "table",
                    |m: &CreateTableRequest| { &m.table },
                    |m: &mut CreateTableRequest| { &mut m.table },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "initial_split_keys",
                    |m: &CreateTableRequest| { &m.initial_split_keys },
                    |m: &mut CreateTableRequest| { &mut m.initial_split_keys },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateTableRequest>(
                    "CreateTableRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateTableRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateTableRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateTableRequest,
        };
        unsafe {
            instance.get(CreateTableRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateTableRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.table_id.clear();
        self.table.clear();
        self.initial_split_keys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateTableRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateTableRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListTablesRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListTablesRequest {
    fn default() -> &'a ListTablesRequest {
        <ListTablesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListTablesRequest {
    pub fn new() -> ListTablesRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListTablesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListTablesRequest {
        ListTablesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &ListTablesRequest| { &m.name },
                    |m: &mut ListTablesRequest| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListTablesRequest>(
                    "ListTablesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListTablesRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListTablesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListTablesRequest,
        };
        unsafe {
            instance.get(ListTablesRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListTablesRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListTablesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTablesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListTablesResponse {
    // message fields
    pub tables: ::protobuf::RepeatedField<super::bigtable_table_data::Table>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListTablesResponse {
    fn default() -> &'a ListTablesResponse {
        <ListTablesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListTablesResponse {
    pub fn new() -> ListTablesResponse {
        ::std::default::Default::default()
    }

    // repeated .google.bigtable.admin.table.v1.Table tables = 1;


    pub fn get_tables(&self) -> &[super::bigtable_table_data::Table] {
        &self.tables
    }
    pub fn clear_tables(&mut self) {
        self.tables.clear();
    }

    // Param is passed by value, moved
    pub fn set_tables(&mut self, v: ::protobuf::RepeatedField<super::bigtable_table_data::Table>) {
        self.tables = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tables(&mut self) -> &mut ::protobuf::RepeatedField<super::bigtable_table_data::Table> {
        &mut self.tables
    }

    // Take field
    pub fn take_tables(&mut self) -> ::protobuf::RepeatedField<super::bigtable_table_data::Table> {
        ::std::mem::replace(&mut self.tables, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListTablesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.tables {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tables)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tables {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tables {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListTablesResponse {
        ListTablesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bigtable_table_data::Table>>(
                    "tables",
                    |m: &ListTablesResponse| { &m.tables },
                    |m: &mut ListTablesResponse| { &mut m.tables },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListTablesResponse>(
                    "ListTablesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListTablesResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListTablesResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListTablesResponse,
        };
        unsafe {
            instance.get(ListTablesResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListTablesResponse {
    fn clear(&mut self) {
        self.tables.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListTablesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTablesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTableRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTableRequest {
    fn default() -> &'a GetTableRequest {
        <GetTableRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTableRequest {
    pub fn new() -> GetTableRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetTableRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTableRequest {
        GetTableRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &GetTableRequest| { &m.name },
                    |m: &mut GetTableRequest| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetTableRequest>(
                    "GetTableRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetTableRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetTableRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetTableRequest,
        };
        unsafe {
            instance.get(GetTableRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetTableRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTableRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTableRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteTableRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteTableRequest {
    fn default() -> &'a DeleteTableRequest {
        <DeleteTableRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteTableRequest {
    pub fn new() -> DeleteTableRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteTableRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteTableRequest {
        DeleteTableRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &DeleteTableRequest| { &m.name },
                    |m: &mut DeleteTableRequest| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteTableRequest>(
                    "DeleteTableRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteTableRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteTableRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteTableRequest,
        };
        unsafe {
            instance.get(DeleteTableRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteTableRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteTableRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteTableRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RenameTableRequest {
    // message fields
    pub name: ::std::string::String,
    pub new_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RenameTableRequest {
    fn default() -> &'a RenameTableRequest {
        <RenameTableRequest as ::protobuf::Message>::default_instance()
    }
}

impl RenameTableRequest {
    pub fn new() -> RenameTableRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string new_id = 2;


    pub fn get_new_id(&self) -> &str {
        &self.new_id
    }
    pub fn clear_new_id(&mut self) {
        self.new_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_new_id(&mut self, v: ::std::string::String) {
        self.new_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_new_id(&mut self) -> &mut ::std::string::String {
        &mut self.new_id
    }

    // Take field
    pub fn take_new_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.new_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RenameTableRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.new_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.new_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.new_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.new_id.is_empty() {
            os.write_string(2, &self.new_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RenameTableRequest {
        RenameTableRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &RenameTableRequest| { &m.name },
                    |m: &mut RenameTableRequest| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "new_id",
                    |m: &RenameTableRequest| { &m.new_id },
                    |m: &mut RenameTableRequest| { &mut m.new_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RenameTableRequest>(
                    "RenameTableRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RenameTableRequest {
        static mut instance: ::protobuf::lazy::Lazy<RenameTableRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RenameTableRequest,
        };
        unsafe {
            instance.get(RenameTableRequest::new)
        }
    }
}

impl ::protobuf::Clear for RenameTableRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.new_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RenameTableRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenameTableRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateColumnFamilyRequest {
    // message fields
    pub name: ::std::string::String,
    pub column_family_id: ::std::string::String,
    pub column_family: ::protobuf::SingularPtrField<super::bigtable_table_data::ColumnFamily>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateColumnFamilyRequest {
    fn default() -> &'a CreateColumnFamilyRequest {
        <CreateColumnFamilyRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateColumnFamilyRequest {
    pub fn new() -> CreateColumnFamilyRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string column_family_id = 2;


    pub fn get_column_family_id(&self) -> &str {
        &self.column_family_id
    }
    pub fn clear_column_family_id(&mut self) {
        self.column_family_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_column_family_id(&mut self, v: ::std::string::String) {
        self.column_family_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_column_family_id(&mut self) -> &mut ::std::string::String {
        &mut self.column_family_id
    }

    // Take field
    pub fn take_column_family_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.column_family_id, ::std::string::String::new())
    }

    // .google.bigtable.admin.table.v1.ColumnFamily column_family = 3;


    pub fn get_column_family(&self) -> &super::bigtable_table_data::ColumnFamily {
        self.column_family.as_ref().unwrap_or_else(|| super::bigtable_table_data::ColumnFamily::default_instance())
    }
    pub fn clear_column_family(&mut self) {
        self.column_family.clear();
    }

    pub fn has_column_family(&self) -> bool {
        self.column_family.is_some()
    }

    // Param is passed by value, moved
    pub fn set_column_family(&mut self, v: super::bigtable_table_data::ColumnFamily) {
        self.column_family = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_column_family(&mut self) -> &mut super::bigtable_table_data::ColumnFamily {
        if self.column_family.is_none() {
            self.column_family.set_default();
        }
        self.column_family.as_mut().unwrap()
    }

    // Take field
    pub fn take_column_family(&mut self) -> super::bigtable_table_data::ColumnFamily {
        self.column_family.take().unwrap_or_else(|| super::bigtable_table_data::ColumnFamily::new())
    }
}

impl ::protobuf::Message for CreateColumnFamilyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.column_family {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.column_family_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.column_family)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.column_family_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.column_family_id);
        }
        if let Some(ref v) = self.column_family.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.column_family_id.is_empty() {
            os.write_string(2, &self.column_family_id)?;
        }
        if let Some(ref v) = self.column_family.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateColumnFamilyRequest {
        CreateColumnFamilyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CreateColumnFamilyRequest| { &m.name },
                    |m: &mut CreateColumnFamilyRequest| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "column_family_id",
                    |m: &CreateColumnFamilyRequest| { &m.column_family_id },
                    |m: &mut CreateColumnFamilyRequest| { &mut m.column_family_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bigtable_table_data::ColumnFamily>>(
                    "column_family",
                    |m: &CreateColumnFamilyRequest| { &m.column_family },
                    |m: &mut CreateColumnFamilyRequest| { &mut m.column_family },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateColumnFamilyRequest>(
                    "CreateColumnFamilyRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateColumnFamilyRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateColumnFamilyRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateColumnFamilyRequest,
        };
        unsafe {
            instance.get(CreateColumnFamilyRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateColumnFamilyRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.column_family_id.clear();
        self.column_family.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateColumnFamilyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateColumnFamilyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteColumnFamilyRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteColumnFamilyRequest {
    fn default() -> &'a DeleteColumnFamilyRequest {
        <DeleteColumnFamilyRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteColumnFamilyRequest {
    pub fn new() -> DeleteColumnFamilyRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteColumnFamilyRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteColumnFamilyRequest {
        DeleteColumnFamilyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &DeleteColumnFamilyRequest| { &m.name },
                    |m: &mut DeleteColumnFamilyRequest| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteColumnFamilyRequest>(
                    "DeleteColumnFamilyRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteColumnFamilyRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteColumnFamilyRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteColumnFamilyRequest,
        };
        unsafe {
            instance.get(DeleteColumnFamilyRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteColumnFamilyRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteColumnFamilyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteColumnFamilyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BulkDeleteRowsRequest {
    // message fields
    pub table_name: ::std::string::String,
    // message oneof groups
    pub target: ::std::option::Option<BulkDeleteRowsRequest_oneof_target>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BulkDeleteRowsRequest {
    fn default() -> &'a BulkDeleteRowsRequest {
        <BulkDeleteRowsRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum BulkDeleteRowsRequest_oneof_target {
    row_key_prefix(::std::vec::Vec<u8>),
    delete_all_data_from_table(bool),
}

impl BulkDeleteRowsRequest {
    pub fn new() -> BulkDeleteRowsRequest {
        ::std::default::Default::default()
    }

    // string table_name = 1;


    pub fn get_table_name(&self) -> &str {
        &self.table_name
    }
    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: ::std::string::String) {
        self.table_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
        &mut self.table_name
    }

    // Take field
    pub fn take_table_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.table_name, ::std::string::String::new())
    }

    // bytes row_key_prefix = 2;


    pub fn get_row_key_prefix(&self) -> &[u8] {
        match self.target {
            ::std::option::Option::Some(BulkDeleteRowsRequest_oneof_target::row_key_prefix(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_row_key_prefix(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_row_key_prefix(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(BulkDeleteRowsRequest_oneof_target::row_key_prefix(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_row_key_prefix(&mut self, v: ::std::vec::Vec<u8>) {
        self.target = ::std::option::Option::Some(BulkDeleteRowsRequest_oneof_target::row_key_prefix(v))
    }

    // Mutable pointer to the field.
    pub fn mut_row_key_prefix(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(BulkDeleteRowsRequest_oneof_target::row_key_prefix(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(BulkDeleteRowsRequest_oneof_target::row_key_prefix(::std::vec::Vec::new()));
        }
        match self.target {
            ::std::option::Option::Some(BulkDeleteRowsRequest_oneof_target::row_key_prefix(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_row_key_prefix(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_row_key_prefix() {
            match self.target.take() {
                ::std::option::Option::Some(BulkDeleteRowsRequest_oneof_target::row_key_prefix(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bool delete_all_data_from_table = 3;


    pub fn get_delete_all_data_from_table(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(BulkDeleteRowsRequest_oneof_target::delete_all_data_from_table(v)) => v,
            _ => false,
        }
    }
    pub fn clear_delete_all_data_from_table(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_delete_all_data_from_table(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(BulkDeleteRowsRequest_oneof_target::delete_all_data_from_table(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delete_all_data_from_table(&mut self, v: bool) {
        self.target = ::std::option::Option::Some(BulkDeleteRowsRequest_oneof_target::delete_all_data_from_table(v))
    }
}

impl ::protobuf::Message for BulkDeleteRowsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.table_name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target = ::std::option::Option::Some(BulkDeleteRowsRequest_oneof_target::row_key_prefix(is.read_bytes()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target = ::std::option::Option::Some(BulkDeleteRowsRequest_oneof_target::delete_all_data_from_table(is.read_bool()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.table_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.table_name);
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &BulkDeleteRowsRequest_oneof_target::row_key_prefix(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
                &BulkDeleteRowsRequest_oneof_target::delete_all_data_from_table(v) => {
                    my_size += 2;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.table_name.is_empty() {
            os.write_string(1, &self.table_name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &BulkDeleteRowsRequest_oneof_target::row_key_prefix(ref v) => {
                    os.write_bytes(2, v)?;
                },
                &BulkDeleteRowsRequest_oneof_target::delete_all_data_from_table(v) => {
                    os.write_bool(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BulkDeleteRowsRequest {
        BulkDeleteRowsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "table_name",
                    |m: &BulkDeleteRowsRequest| { &m.table_name },
                    |m: &mut BulkDeleteRowsRequest| { &mut m.table_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                    "row_key_prefix",
                    BulkDeleteRowsRequest::has_row_key_prefix,
                    BulkDeleteRowsRequest::get_row_key_prefix,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                    "delete_all_data_from_table",
                    BulkDeleteRowsRequest::has_delete_all_data_from_table,
                    BulkDeleteRowsRequest::get_delete_all_data_from_table,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BulkDeleteRowsRequest>(
                    "BulkDeleteRowsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BulkDeleteRowsRequest {
        static mut instance: ::protobuf::lazy::Lazy<BulkDeleteRowsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BulkDeleteRowsRequest,
        };
        unsafe {
            instance.get(BulkDeleteRowsRequest::new)
        }
    }
}

impl ::protobuf::Clear for BulkDeleteRowsRequest {
    fn clear(&mut self) {
        self.table_name.clear();
        self.target = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BulkDeleteRowsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BulkDeleteRowsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \nDgoogle/bigtable/admin/table/v1/bigtable_table_service_messages.proto\
    \x12\x1egoogle.bigtable.admin.table.v1\x1a8google/bigtable/admin/table/v\
    1/bigtable_table_data.proto\"\xae\x01\n\x12CreateTableRequest\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x12\x19\n\x08table_id\x18\x02\x20\
    \x01(\tR\x07tableId\x12;\n\x05table\x18\x03\x20\x01(\x0b2%.google.bigtab\
    le.admin.table.v1.TableR\x05table\x12,\n\x12initial_split_keys\x18\x04\
    \x20\x03(\tR\x10initialSplitKeys\"'\n\x11ListTablesRequest\x12\x12\n\x04\
    name\x18\x01\x20\x01(\tR\x04name\"S\n\x12ListTablesResponse\x12=\n\x06ta\
    bles\x18\x01\x20\x03(\x0b2%.google.bigtable.admin.table.v1.TableR\x06tab\
    les\"%\n\x0fGetTableRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04nam\
    e\"(\n\x12DeleteTableRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04na\
    me\"?\n\x12RenameTableRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04n\
    ame\x12\x15\n\x06new_id\x18\x02\x20\x01(\tR\x05newId\"\xac\x01\n\x19Crea\
    teColumnFamilyRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12(\
    \n\x10column_family_id\x18\x02\x20\x01(\tR\x0ecolumnFamilyId\x12Q\n\rcol\
    umn_family\x18\x03\x20\x01(\x0b2,.google.bigtable.admin.table.v1.ColumnF\
    amilyR\x0ccolumnFamily\"/\n\x19DeleteColumnFamilyRequest\x12\x12\n\x04na\
    me\x18\x01\x20\x01(\tR\x04name\"\xa6\x01\n\x15BulkDeleteRowsRequest\x12\
    \x1d\n\ntable_name\x18\x01\x20\x01(\tR\ttableName\x12&\n\x0erow_key_pref\
    ix\x18\x02\x20\x01(\x0cH\0R\x0crowKeyPrefix\x12<\n\x1adelete_all_data_fr\
    om_table\x18\x03\x20\x01(\x08H\0R\x16deleteAllDataFromTableB\x08\n\x06ta\
    rgetB\x8e\x01\n\"com.google.bigtable.admin.table.v1B!BigtableTableServic\
    eMessagesProtoP\x01ZCgoogle.golang.org/genproto/googleapis/bigtable/admi\
    n/table/v1;tableJ\x85!\n\x06\x12\x04\x0e\0s\x01\n\xbd\x04\n\x01\x0c\x12\
    \x03\x0e\0\x122\xb2\x04\x20Copyright\x202017\x20Google\x20Inc.\n\n\x20Li\
    censed\x20under\x20the\x20Apache\x20License,\x20Version\x202.0\x20(the\
    \x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\x20file\x20excep\
    t\x20in\x20compliance\x20with\x20the\x20License.\n\x20You\x20may\x20obta\
    in\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\x20\x20htt\
    p://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\x20required\x20by\
    \x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\x20softwar\
    e\n\x20distributed\x20under\x20the\x20License\x20is\x20distributed\x20on\
    \x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\x20CON\
    DITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\x20implied.\n\
    \x20See\x20the\x20License\x20for\x20the\x20specific\x20language\x20gover\
    ning\x20permissions\x20and\n\x20limitations\x20under\x20the\x20License.\
    \n\n\x08\n\x01\x02\x12\x03\x10\0'\n\t\n\x02\x03\0\x12\x03\x12\0B\n\x08\n\
    \x01\x08\x12\x03\x14\0Z\n\t\n\x02\x08\x0b\x12\x03\x14\0Z\n\x08\n\x01\x08\
    \x12\x03\x15\0\"\n\t\n\x02\x08\n\x12\x03\x15\0\"\n\x08\n\x01\x08\x12\x03\
    \x16\0B\n\t\n\x02\x08\x08\x12\x03\x16\0B\n\x08\n\x01\x08\x12\x03\x17\0;\
    \n\t\n\x02\x08\x01\x12\x03\x17\0;\n\n\n\x02\x04\0\x12\x04\x1a\06\x01\n\n\
    \n\x03\x04\0\x01\x12\x03\x1a\x08\x1a\nO\n\x04\x04\0\x02\0\x12\x03\x1c\
    \x02\x12\x1aB\x20The\x20unique\x20name\x20of\x20the\x20cluster\x20in\x20\
    which\x20to\x20create\x20the\x20new\x20table.\n\n\r\n\x05\x04\0\x02\0\
    \x04\x12\x04\x1c\x02\x1a\x1c\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x1c\x02\
    \x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x1c\t\r\n\x0c\n\x05\x04\0\x02\0\
    \x03\x12\x03\x1c\x10\x11\n\x94\x01\n\x04\x04\0\x02\x01\x12\x03\x20\x02\
    \x16\x1a\x86\x01\x20The\x20name\x20by\x20which\x20the\x20new\x20table\
    \x20should\x20be\x20referred\x20to\x20within\x20the\x20cluster,\n\x20e.g\
    .\x20\"foobar\"\x20rather\x20than\x20\"<cluster_name>/tables/foobar\".\n\
    \n\r\n\x05\x04\0\x02\x01\x04\x12\x04\x20\x02\x1c\x12\n\x0c\n\x05\x04\0\
    \x02\x01\x05\x12\x03\x20\x02\x08\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\
    \x20\t\x11\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x20\x14\x15\n\x9c\x01\n\
    \x04\x04\0\x02\x02\x12\x03$\x02\x12\x1a\x8e\x01\x20The\x20Table\x20to\
    \x20create.\x20The\x20`name`\x20field\x20of\x20the\x20Table\x20and\x20al\
    l\x20of\x20its\n\x20ColumnFamilies\x20must\x20be\x20left\x20blank,\x20an\
    d\x20will\x20be\x20populated\x20in\x20the\x20response.\n\n\r\n\x05\x04\0\
    \x02\x02\x04\x12\x04$\x02\x20\x16\n\x0c\n\x05\x04\0\x02\x02\x06\x12\x03$\
    \x02\x07\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03$\x08\r\n\x0c\n\x05\x04\0\
    \x02\x02\x03\x12\x03$\x10\x11\n\x84\x06\n\x04\x04\0\x02\x03\x12\x035\x02\
    )\x1a\xf6\x05\x20The\x20optional\x20list\x20of\x20row\x20keys\x20that\
    \x20will\x20be\x20used\x20to\x20initially\x20split\x20the\n\x20table\x20\
    into\x20several\x20tablets\x20(Tablets\x20are\x20similar\x20to\x20HBase\
    \x20regions).\n\x20Given\x20two\x20split\x20keys,\x20\"s1\"\x20and\x20\"\
    s2\",\x20three\x20tablets\x20will\x20be\x20created,\n\x20spanning\x20the\
    \x20key\x20ranges:\x20[,\x20s1),\x20[s1,\x20s2),\x20[s2,\x20).\n\n\x20Ex\
    ample:\n\x20\x20*\x20Row\x20keys\x20:=\x20[\"a\",\x20\"apple\",\x20\"cus\
    tom\",\x20\"customer_1\",\x20\"customer_2\",\n\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\"other\",\x20\"zz\"]\n\x20\
    \x20*\x20initial_split_keys\x20:=\x20[\"apple\",\x20\"customer_1\",\x20\
    \"customer_2\",\x20\"other\"]\n\x20\x20*\x20Key\x20assignment:\n\x20\x20\
    \x20\x20-\x20Tablet\x201\x20[,\x20apple)\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20=>\x20{\"a\"}.\n\x20\x20\x20\x20-\x20Tab\
    let\x202\x20[apple,\x20customer_1)\x20\x20\x20\x20\x20\x20=>\x20{\"apple\
    \",\x20\"custom\"}.\n\x20\x20\x20\x20-\x20Tablet\x203\x20[customer_1,\
    \x20customer_2)\x20=>\x20{\"customer_1\"}.\n\x20\x20\x20\x20-\x20Tablet\
    \x204\x20[customer_2,\x20other)\x20\x20\x20\x20\x20\x20=>\x20{\"customer\
    _2\"}.\n\x20\x20\x20\x20-\x20Tablet\x205\x20[other,\x20)\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20=>\x20{\"other\",\x20\"z\
    z\"}.\n\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x035\x02\n\n\x0c\n\x05\x04\0\
    \x02\x03\x05\x12\x035\x0b\x11\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x035\x12\
    $\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x035'(\n\n\n\x02\x04\x01\x12\x048\0;\
    \x01\n\n\n\x03\x04\x01\x01\x12\x038\x08\x19\nP\n\x04\x04\x01\x02\0\x12\
    \x03:\x02\x12\x1aC\x20The\x20unique\x20name\x20of\x20the\x20cluster\x20f\
    or\x20which\x20tables\x20should\x20be\x20listed.\n\n\r\n\x05\x04\x01\x02\
    \0\x04\x12\x04:\x028\x1b\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03:\x02\x08\
    \n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03:\t\r\n\x0c\n\x05\x04\x01\x02\0\
    \x03\x12\x03:\x10\x11\n\n\n\x02\x04\x02\x12\x04=\0A\x01\n\n\n\x03\x04\
    \x02\x01\x12\x03=\x08\x1a\nt\n\x04\x04\x02\x02\0\x12\x03@\x02\x1c\x1ag\
    \x20The\x20tables\x20present\x20in\x20the\x20requested\x20cluster.\n\x20\
    At\x20present,\x20only\x20the\x20names\x20of\x20the\x20tables\x20are\x20\
    populated.\n\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03@\x02\n\n\x0c\n\x05\
    \x04\x02\x02\0\x06\x12\x03@\x0b\x10\n\x0c\n\x05\x04\x02\x02\0\x01\x12\
    \x03@\x11\x17\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03@\x1a\x1b\n\n\n\x02\
    \x04\x03\x12\x04C\0F\x01\n\n\n\x03\x04\x03\x01\x12\x03C\x08\x17\n6\n\x04\
    \x04\x03\x02\0\x12\x03E\x02\x12\x1a)\x20The\x20unique\x20name\x20of\x20t\
    he\x20requested\x20table.\n\n\r\n\x05\x04\x03\x02\0\x04\x12\x04E\x02C\
    \x19\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03E\x02\x08\n\x0c\n\x05\x04\x03\
    \x02\0\x01\x12\x03E\t\r\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03E\x10\x11\n\
    \n\n\x02\x04\x04\x12\x04H\0K\x01\n\n\n\x03\x04\x04\x01\x12\x03H\x08\x1a\
    \n:\n\x04\x04\x04\x02\0\x12\x03J\x02\x12\x1a-\x20The\x20unique\x20name\
    \x20of\x20the\x20table\x20to\x20be\x20deleted.\n\n\r\n\x05\x04\x04\x02\0\
    \x04\x12\x04J\x02H\x1c\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03J\x02\x08\n\
    \x0c\n\x05\x04\x04\x02\0\x01\x12\x03J\t\r\n\x0c\n\x05\x04\x04\x02\0\x03\
    \x12\x03J\x10\x11\n\n\n\x02\x04\x05\x12\x04M\0T\x01\n\n\n\x03\x04\x05\
    \x01\x12\x03M\x08\x1a\n4\n\x04\x04\x05\x02\0\x12\x03O\x02\x12\x1a'\x20Th\
    e\x20current\x20unique\x20name\x20of\x20the\x20table.\n\n\r\n\x05\x04\
    \x05\x02\0\x04\x12\x04O\x02M\x1c\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03O\
    \x02\x08\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03O\t\r\n\x0c\n\x05\x04\x05\
    \x02\0\x03\x12\x03O\x10\x11\n\x9f\x01\n\x04\x04\x05\x02\x01\x12\x03S\x02\
    \x14\x1a\x91\x01\x20The\x20new\x20name\x20by\x20which\x20the\x20table\
    \x20should\x20be\x20referred\x20to\x20within\x20its\x20containing\n\x20c\
    luster,\x20e.g.\x20\"foobar\"\x20rather\x20than\x20\"<cluster_name>/tabl\
    es/foobar\".\n\n\r\n\x05\x04\x05\x02\x01\x04\x12\x04S\x02O\x12\n\x0c\n\
    \x05\x04\x05\x02\x01\x05\x12\x03S\x02\x08\n\x0c\n\x05\x04\x05\x02\x01\
    \x01\x12\x03S\t\x0f\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03S\x12\x13\n\n\
    \n\x02\x04\x06\x12\x04V\0`\x01\n\n\n\x03\x04\x06\x01\x12\x03V\x08!\nU\n\
    \x04\x04\x06\x02\0\x12\x03X\x02\x12\x1aH\x20The\x20unique\x20name\x20of\
    \x20the\x20table\x20in\x20which\x20to\x20create\x20the\x20new\x20column\
    \x20family.\n\n\r\n\x05\x04\x06\x02\0\x04\x12\x04X\x02V#\n\x0c\n\x05\x04\
    \x06\x02\0\x05\x12\x03X\x02\x08\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03X\t\
    \r\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03X\x10\x11\n\xa0\x01\n\x04\x04\
    \x06\x02\x01\x12\x03\\\x02\x1e\x1a\x92\x01\x20The\x20name\x20by\x20which\
    \x20the\x20new\x20column\x20family\x20should\x20be\x20referred\x20to\x20\
    within\x20the\n\x20table,\x20e.g.\x20\"foobar\"\x20rather\x20than\x20\"<\
    table_name>/columnFamilies/foobar\".\n\n\r\n\x05\x04\x06\x02\x01\x04\x12\
    \x04\\\x02X\x12\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03\\\x02\x08\n\x0c\
    \n\x05\x04\x06\x02\x01\x01\x12\x03\\\t\x19\n\x0c\n\x05\x04\x06\x02\x01\
    \x03\x12\x03\\\x1c\x1d\nP\n\x04\x04\x06\x02\x02\x12\x03_\x02!\x1aC\x20Th\
    e\x20column\x20family\x20to\x20create.\x20The\x20`name`\x20field\x20must\
    \x20be\x20left\x20blank.\n\n\r\n\x05\x04\x06\x02\x02\x04\x12\x04_\x02\\\
    \x1e\n\x0c\n\x05\x04\x06\x02\x02\x06\x12\x03_\x02\x0e\n\x0c\n\x05\x04\
    \x06\x02\x02\x01\x12\x03_\x0f\x1c\n\x0c\n\x05\x04\x06\x02\x02\x03\x12\
    \x03_\x1f\x20\n\n\n\x02\x04\x07\x12\x04b\0e\x01\n\n\n\x03\x04\x07\x01\
    \x12\x03b\x08!\nB\n\x04\x04\x07\x02\0\x12\x03d\x02\x12\x1a5\x20The\x20un\
    ique\x20name\x20of\x20the\x20column\x20family\x20to\x20be\x20deleted.\n\
    \n\r\n\x05\x04\x07\x02\0\x04\x12\x04d\x02b#\n\x0c\n\x05\x04\x07\x02\0\
    \x05\x12\x03d\x02\x08\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03d\t\r\n\x0c\n\
    \x05\x04\x07\x02\0\x03\x12\x03d\x10\x11\n\n\n\x02\x04\x08\x12\x04g\0s\
    \x01\n\n\n\x03\x04\x08\x01\x12\x03g\x08\x1d\nO\n\x04\x04\x08\x02\0\x12\
    \x03i\x02\x18\x1aB\x20The\x20unique\x20name\x20of\x20the\x20table\x20on\
    \x20which\x20to\x20perform\x20the\x20bulk\x20delete\n\n\r\n\x05\x04\x08\
    \x02\0\x04\x12\x04i\x02g\x1f\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03i\x02\
    \x08\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03i\t\x13\n\x0c\n\x05\x04\x08\
    \x02\0\x03\x12\x03i\x16\x17\n\x0c\n\x04\x04\x08\x08\0\x12\x04k\x02r\x03\
    \n\x0c\n\x05\x04\x08\x08\0\x01\x12\x03k\x08\x0e\nb\n\x04\x04\x08\x02\x01\
    \x12\x03n\x04\x1d\x1aU\x20Delete\x20all\x20rows\x20that\x20start\x20with\
    \x20this\x20row\x20key\x20prefix.\x20Prefix\x20cannot\x20be\n\x20zero\
    \x20length.\n\n\x0c\n\x05\x04\x08\x02\x01\x05\x12\x03n\x04\t\n\x0c\n\x05\
    \x04\x08\x02\x01\x01\x12\x03n\n\x18\n\x0c\n\x05\x04\x08\x02\x01\x03\x12\
    \x03n\x1b\x1c\nN\n\x04\x04\x08\x02\x02\x12\x03q\x04(\x1aA\x20Delete\x20a\
    ll\x20rows\x20in\x20the\x20table.\x20Setting\x20this\x20to\x20false\x20i\
    s\x20a\x20no-op.\n\n\x0c\n\x05\x04\x08\x02\x02\x05\x12\x03q\x04\x08\n\
    \x0c\n\x05\x04\x08\x02\x02\x01\x12\x03q\t#\n\x0c\n\x05\x04\x08\x02\x02\
    \x03\x12\x03q&'b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
