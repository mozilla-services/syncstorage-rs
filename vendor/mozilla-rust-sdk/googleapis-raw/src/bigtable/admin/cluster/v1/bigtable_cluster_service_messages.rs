// This file is generated by rust-protobuf 2.7.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/bigtable/admin/cluster/v1/bigtable_cluster_service_messages.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_7_0;

#[derive(PartialEq,Clone,Default)]
pub struct ListZonesRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListZonesRequest {
    fn default() -> &'a ListZonesRequest {
        <ListZonesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListZonesRequest {
    pub fn new() -> ListZonesRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListZonesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListZonesRequest {
        ListZonesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &ListZonesRequest| { &m.name },
                    |m: &mut ListZonesRequest| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListZonesRequest>(
                    "ListZonesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListZonesRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListZonesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListZonesRequest,
        };
        unsafe {
            instance.get(ListZonesRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListZonesRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListZonesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListZonesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListZonesResponse {
    // message fields
    pub zones: ::protobuf::RepeatedField<super::bigtable_cluster_data::Zone>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListZonesResponse {
    fn default() -> &'a ListZonesResponse {
        <ListZonesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListZonesResponse {
    pub fn new() -> ListZonesResponse {
        ::std::default::Default::default()
    }

    // repeated .google.bigtable.admin.cluster.v1.Zone zones = 1;


    pub fn get_zones(&self) -> &[super::bigtable_cluster_data::Zone] {
        &self.zones
    }
    pub fn clear_zones(&mut self) {
        self.zones.clear();
    }

    // Param is passed by value, moved
    pub fn set_zones(&mut self, v: ::protobuf::RepeatedField<super::bigtable_cluster_data::Zone>) {
        self.zones = v;
    }

    // Mutable pointer to the field.
    pub fn mut_zones(&mut self) -> &mut ::protobuf::RepeatedField<super::bigtable_cluster_data::Zone> {
        &mut self.zones
    }

    // Take field
    pub fn take_zones(&mut self) -> ::protobuf::RepeatedField<super::bigtable_cluster_data::Zone> {
        ::std::mem::replace(&mut self.zones, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListZonesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.zones {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.zones)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.zones {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.zones {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListZonesResponse {
        ListZonesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bigtable_cluster_data::Zone>>(
                    "zones",
                    |m: &ListZonesResponse| { &m.zones },
                    |m: &mut ListZonesResponse| { &mut m.zones },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListZonesResponse>(
                    "ListZonesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListZonesResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListZonesResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListZonesResponse,
        };
        unsafe {
            instance.get(ListZonesResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListZonesResponse {
    fn clear(&mut self) {
        self.zones.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListZonesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListZonesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetClusterRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetClusterRequest {
    fn default() -> &'a GetClusterRequest {
        <GetClusterRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetClusterRequest {
    pub fn new() -> GetClusterRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetClusterRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetClusterRequest {
        GetClusterRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &GetClusterRequest| { &m.name },
                    |m: &mut GetClusterRequest| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetClusterRequest>(
                    "GetClusterRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetClusterRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetClusterRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetClusterRequest,
        };
        unsafe {
            instance.get(GetClusterRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetClusterRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetClusterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetClusterRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListClustersRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListClustersRequest {
    fn default() -> &'a ListClustersRequest {
        <ListClustersRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListClustersRequest {
    pub fn new() -> ListClustersRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListClustersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListClustersRequest {
        ListClustersRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &ListClustersRequest| { &m.name },
                    |m: &mut ListClustersRequest| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListClustersRequest>(
                    "ListClustersRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListClustersRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListClustersRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListClustersRequest,
        };
        unsafe {
            instance.get(ListClustersRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListClustersRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListClustersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListClustersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListClustersResponse {
    // message fields
    pub clusters: ::protobuf::RepeatedField<super::bigtable_cluster_data::Cluster>,
    pub failed_zones: ::protobuf::RepeatedField<super::bigtable_cluster_data::Zone>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListClustersResponse {
    fn default() -> &'a ListClustersResponse {
        <ListClustersResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListClustersResponse {
    pub fn new() -> ListClustersResponse {
        ::std::default::Default::default()
    }

    // repeated .google.bigtable.admin.cluster.v1.Cluster clusters = 1;


    pub fn get_clusters(&self) -> &[super::bigtable_cluster_data::Cluster] {
        &self.clusters
    }
    pub fn clear_clusters(&mut self) {
        self.clusters.clear();
    }

    // Param is passed by value, moved
    pub fn set_clusters(&mut self, v: ::protobuf::RepeatedField<super::bigtable_cluster_data::Cluster>) {
        self.clusters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_clusters(&mut self) -> &mut ::protobuf::RepeatedField<super::bigtable_cluster_data::Cluster> {
        &mut self.clusters
    }

    // Take field
    pub fn take_clusters(&mut self) -> ::protobuf::RepeatedField<super::bigtable_cluster_data::Cluster> {
        ::std::mem::replace(&mut self.clusters, ::protobuf::RepeatedField::new())
    }

    // repeated .google.bigtable.admin.cluster.v1.Zone failed_zones = 2;


    pub fn get_failed_zones(&self) -> &[super::bigtable_cluster_data::Zone] {
        &self.failed_zones
    }
    pub fn clear_failed_zones(&mut self) {
        self.failed_zones.clear();
    }

    // Param is passed by value, moved
    pub fn set_failed_zones(&mut self, v: ::protobuf::RepeatedField<super::bigtable_cluster_data::Zone>) {
        self.failed_zones = v;
    }

    // Mutable pointer to the field.
    pub fn mut_failed_zones(&mut self) -> &mut ::protobuf::RepeatedField<super::bigtable_cluster_data::Zone> {
        &mut self.failed_zones
    }

    // Take field
    pub fn take_failed_zones(&mut self) -> ::protobuf::RepeatedField<super::bigtable_cluster_data::Zone> {
        ::std::mem::replace(&mut self.failed_zones, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListClustersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.clusters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.failed_zones {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.clusters)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.failed_zones)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.clusters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.failed_zones {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.clusters {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.failed_zones {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListClustersResponse {
        ListClustersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bigtable_cluster_data::Cluster>>(
                    "clusters",
                    |m: &ListClustersResponse| { &m.clusters },
                    |m: &mut ListClustersResponse| { &mut m.clusters },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bigtable_cluster_data::Zone>>(
                    "failed_zones",
                    |m: &ListClustersResponse| { &m.failed_zones },
                    |m: &mut ListClustersResponse| { &mut m.failed_zones },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListClustersResponse>(
                    "ListClustersResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListClustersResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListClustersResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListClustersResponse,
        };
        unsafe {
            instance.get(ListClustersResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListClustersResponse {
    fn clear(&mut self) {
        self.clusters.clear();
        self.failed_zones.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListClustersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListClustersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateClusterRequest {
    // message fields
    pub name: ::std::string::String,
    pub cluster_id: ::std::string::String,
    pub cluster: ::protobuf::SingularPtrField<super::bigtable_cluster_data::Cluster>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateClusterRequest {
    fn default() -> &'a CreateClusterRequest {
        <CreateClusterRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateClusterRequest {
    pub fn new() -> CreateClusterRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string cluster_id = 2;


    pub fn get_cluster_id(&self) -> &str {
        &self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: ::std::string::String) {
        self.cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_id
    }

    // Take field
    pub fn take_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_id, ::std::string::String::new())
    }

    // .google.bigtable.admin.cluster.v1.Cluster cluster = 3;


    pub fn get_cluster(&self) -> &super::bigtable_cluster_data::Cluster {
        self.cluster.as_ref().unwrap_or_else(|| super::bigtable_cluster_data::Cluster::default_instance())
    }
    pub fn clear_cluster(&mut self) {
        self.cluster.clear();
    }

    pub fn has_cluster(&self) -> bool {
        self.cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cluster(&mut self, v: super::bigtable_cluster_data::Cluster) {
        self.cluster = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster(&mut self) -> &mut super::bigtable_cluster_data::Cluster {
        if self.cluster.is_none() {
            self.cluster.set_default();
        }
        self.cluster.as_mut().unwrap()
    }

    // Take field
    pub fn take_cluster(&mut self) -> super::bigtable_cluster_data::Cluster {
        self.cluster.take().unwrap_or_else(|| super::bigtable_cluster_data::Cluster::new())
    }
}

impl ::protobuf::Message for CreateClusterRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.cluster {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cluster)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cluster_id);
        }
        if let Some(ref v) = self.cluster.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.cluster_id.is_empty() {
            os.write_string(2, &self.cluster_id)?;
        }
        if let Some(ref v) = self.cluster.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateClusterRequest {
        CreateClusterRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CreateClusterRequest| { &m.name },
                    |m: &mut CreateClusterRequest| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cluster_id",
                    |m: &CreateClusterRequest| { &m.cluster_id },
                    |m: &mut CreateClusterRequest| { &mut m.cluster_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bigtable_cluster_data::Cluster>>(
                    "cluster",
                    |m: &CreateClusterRequest| { &m.cluster },
                    |m: &mut CreateClusterRequest| { &mut m.cluster },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateClusterRequest>(
                    "CreateClusterRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateClusterRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateClusterRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateClusterRequest,
        };
        unsafe {
            instance.get(CreateClusterRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateClusterRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.cluster_id.clear();
        self.cluster.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateClusterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateClusterRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateClusterMetadata {
    // message fields
    pub original_request: ::protobuf::SingularPtrField<CreateClusterRequest>,
    pub request_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub finish_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateClusterMetadata {
    fn default() -> &'a CreateClusterMetadata {
        <CreateClusterMetadata as ::protobuf::Message>::default_instance()
    }
}

impl CreateClusterMetadata {
    pub fn new() -> CreateClusterMetadata {
        ::std::default::Default::default()
    }

    // .google.bigtable.admin.cluster.v1.CreateClusterRequest original_request = 1;


    pub fn get_original_request(&self) -> &CreateClusterRequest {
        self.original_request.as_ref().unwrap_or_else(|| CreateClusterRequest::default_instance())
    }
    pub fn clear_original_request(&mut self) {
        self.original_request.clear();
    }

    pub fn has_original_request(&self) -> bool {
        self.original_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_request(&mut self, v: CreateClusterRequest) {
        self.original_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_request(&mut self) -> &mut CreateClusterRequest {
        if self.original_request.is_none() {
            self.original_request.set_default();
        }
        self.original_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_request(&mut self) -> CreateClusterRequest {
        self.original_request.take().unwrap_or_else(|| CreateClusterRequest::new())
    }

    // .google.protobuf.Timestamp request_time = 2;


    pub fn get_request_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.request_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_request_time(&mut self) {
        self.request_time.clear();
    }

    pub fn has_request_time(&self) -> bool {
        self.request_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.request_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.request_time.is_none() {
            self.request_time.set_default();
        }
        self.request_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_request_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.request_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp finish_time = 3;


    pub fn get_finish_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.finish_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_finish_time(&mut self) {
        self.finish_time.clear();
    }

    pub fn has_finish_time(&self) -> bool {
        self.finish_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_finish_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.finish_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_finish_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.finish_time.is_none() {
            self.finish_time.set_default();
        }
        self.finish_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_finish_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.finish_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for CreateClusterMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.original_request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.request_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.finish_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.original_request)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.request_time)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.finish_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.original_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.request_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.finish_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.original_request.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.request_time.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.finish_time.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateClusterMetadata {
        CreateClusterMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CreateClusterRequest>>(
                    "original_request",
                    |m: &CreateClusterMetadata| { &m.original_request },
                    |m: &mut CreateClusterMetadata| { &mut m.original_request },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "request_time",
                    |m: &CreateClusterMetadata| { &m.request_time },
                    |m: &mut CreateClusterMetadata| { &mut m.request_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "finish_time",
                    |m: &CreateClusterMetadata| { &m.finish_time },
                    |m: &mut CreateClusterMetadata| { &mut m.finish_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateClusterMetadata>(
                    "CreateClusterMetadata",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateClusterMetadata {
        static mut instance: ::protobuf::lazy::Lazy<CreateClusterMetadata> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateClusterMetadata,
        };
        unsafe {
            instance.get(CreateClusterMetadata::new)
        }
    }
}

impl ::protobuf::Clear for CreateClusterMetadata {
    fn clear(&mut self) {
        self.original_request.clear();
        self.request_time.clear();
        self.finish_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateClusterMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateClusterMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateClusterMetadata {
    // message fields
    pub original_request: ::protobuf::SingularPtrField<super::bigtable_cluster_data::Cluster>,
    pub request_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub cancel_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub finish_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateClusterMetadata {
    fn default() -> &'a UpdateClusterMetadata {
        <UpdateClusterMetadata as ::protobuf::Message>::default_instance()
    }
}

impl UpdateClusterMetadata {
    pub fn new() -> UpdateClusterMetadata {
        ::std::default::Default::default()
    }

    // .google.bigtable.admin.cluster.v1.Cluster original_request = 1;


    pub fn get_original_request(&self) -> &super::bigtable_cluster_data::Cluster {
        self.original_request.as_ref().unwrap_or_else(|| super::bigtable_cluster_data::Cluster::default_instance())
    }
    pub fn clear_original_request(&mut self) {
        self.original_request.clear();
    }

    pub fn has_original_request(&self) -> bool {
        self.original_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_request(&mut self, v: super::bigtable_cluster_data::Cluster) {
        self.original_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_request(&mut self) -> &mut super::bigtable_cluster_data::Cluster {
        if self.original_request.is_none() {
            self.original_request.set_default();
        }
        self.original_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_request(&mut self) -> super::bigtable_cluster_data::Cluster {
        self.original_request.take().unwrap_or_else(|| super::bigtable_cluster_data::Cluster::new())
    }

    // .google.protobuf.Timestamp request_time = 2;


    pub fn get_request_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.request_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_request_time(&mut self) {
        self.request_time.clear();
    }

    pub fn has_request_time(&self) -> bool {
        self.request_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.request_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.request_time.is_none() {
            self.request_time.set_default();
        }
        self.request_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_request_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.request_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp cancel_time = 3;


    pub fn get_cancel_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.cancel_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_cancel_time(&mut self) {
        self.cancel_time.clear();
    }

    pub fn has_cancel_time(&self) -> bool {
        self.cancel_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cancel_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.cancel_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cancel_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.cancel_time.is_none() {
            self.cancel_time.set_default();
        }
        self.cancel_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_cancel_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.cancel_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp finish_time = 4;


    pub fn get_finish_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.finish_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_finish_time(&mut self) {
        self.finish_time.clear();
    }

    pub fn has_finish_time(&self) -> bool {
        self.finish_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_finish_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.finish_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_finish_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.finish_time.is_none() {
            self.finish_time.set_default();
        }
        self.finish_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_finish_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.finish_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for UpdateClusterMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.original_request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.request_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cancel_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.finish_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.original_request)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.request_time)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cancel_time)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.finish_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.original_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.request_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cancel_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.finish_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.original_request.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.request_time.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cancel_time.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.finish_time.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateClusterMetadata {
        UpdateClusterMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bigtable_cluster_data::Cluster>>(
                    "original_request",
                    |m: &UpdateClusterMetadata| { &m.original_request },
                    |m: &mut UpdateClusterMetadata| { &mut m.original_request },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "request_time",
                    |m: &UpdateClusterMetadata| { &m.request_time },
                    |m: &mut UpdateClusterMetadata| { &mut m.request_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "cancel_time",
                    |m: &UpdateClusterMetadata| { &m.cancel_time },
                    |m: &mut UpdateClusterMetadata| { &mut m.cancel_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "finish_time",
                    |m: &UpdateClusterMetadata| { &m.finish_time },
                    |m: &mut UpdateClusterMetadata| { &mut m.finish_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateClusterMetadata>(
                    "UpdateClusterMetadata",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateClusterMetadata {
        static mut instance: ::protobuf::lazy::Lazy<UpdateClusterMetadata> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateClusterMetadata,
        };
        unsafe {
            instance.get(UpdateClusterMetadata::new)
        }
    }
}

impl ::protobuf::Clear for UpdateClusterMetadata {
    fn clear(&mut self) {
        self.original_request.clear();
        self.request_time.clear();
        self.cancel_time.clear();
        self.finish_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateClusterMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateClusterMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteClusterRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteClusterRequest {
    fn default() -> &'a DeleteClusterRequest {
        <DeleteClusterRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteClusterRequest {
    pub fn new() -> DeleteClusterRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteClusterRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteClusterRequest {
        DeleteClusterRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &DeleteClusterRequest| { &m.name },
                    |m: &mut DeleteClusterRequest| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteClusterRequest>(
                    "DeleteClusterRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteClusterRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteClusterRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteClusterRequest,
        };
        unsafe {
            instance.get(DeleteClusterRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteClusterRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteClusterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteClusterRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UndeleteClusterRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UndeleteClusterRequest {
    fn default() -> &'a UndeleteClusterRequest {
        <UndeleteClusterRequest as ::protobuf::Message>::default_instance()
    }
}

impl UndeleteClusterRequest {
    pub fn new() -> UndeleteClusterRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UndeleteClusterRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UndeleteClusterRequest {
        UndeleteClusterRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &UndeleteClusterRequest| { &m.name },
                    |m: &mut UndeleteClusterRequest| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UndeleteClusterRequest>(
                    "UndeleteClusterRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UndeleteClusterRequest {
        static mut instance: ::protobuf::lazy::Lazy<UndeleteClusterRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UndeleteClusterRequest,
        };
        unsafe {
            instance.get(UndeleteClusterRequest::new)
        }
    }
}

impl ::protobuf::Clear for UndeleteClusterRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UndeleteClusterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UndeleteClusterRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UndeleteClusterMetadata {
    // message fields
    pub request_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub finish_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UndeleteClusterMetadata {
    fn default() -> &'a UndeleteClusterMetadata {
        <UndeleteClusterMetadata as ::protobuf::Message>::default_instance()
    }
}

impl UndeleteClusterMetadata {
    pub fn new() -> UndeleteClusterMetadata {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp request_time = 1;


    pub fn get_request_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.request_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_request_time(&mut self) {
        self.request_time.clear();
    }

    pub fn has_request_time(&self) -> bool {
        self.request_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.request_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.request_time.is_none() {
            self.request_time.set_default();
        }
        self.request_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_request_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.request_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp finish_time = 2;


    pub fn get_finish_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.finish_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_finish_time(&mut self) {
        self.finish_time.clear();
    }

    pub fn has_finish_time(&self) -> bool {
        self.finish_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_finish_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.finish_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_finish_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.finish_time.is_none() {
            self.finish_time.set_default();
        }
        self.finish_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_finish_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.finish_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for UndeleteClusterMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.request_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.finish_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.request_time)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.finish_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.request_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.finish_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.request_time.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.finish_time.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UndeleteClusterMetadata {
        UndeleteClusterMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "request_time",
                    |m: &UndeleteClusterMetadata| { &m.request_time },
                    |m: &mut UndeleteClusterMetadata| { &mut m.request_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "finish_time",
                    |m: &UndeleteClusterMetadata| { &m.finish_time },
                    |m: &mut UndeleteClusterMetadata| { &mut m.finish_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UndeleteClusterMetadata>(
                    "UndeleteClusterMetadata",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UndeleteClusterMetadata {
        static mut instance: ::protobuf::lazy::Lazy<UndeleteClusterMetadata> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UndeleteClusterMetadata,
        };
        unsafe {
            instance.get(UndeleteClusterMetadata::new)
        }
    }
}

impl ::protobuf::Clear for UndeleteClusterMetadata {
    fn clear(&mut self) {
        self.request_time.clear();
        self.finish_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UndeleteClusterMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UndeleteClusterMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct V2OperationMetadata {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a V2OperationMetadata {
    fn default() -> &'a V2OperationMetadata {
        <V2OperationMetadata as ::protobuf::Message>::default_instance()
    }
}

impl V2OperationMetadata {
    pub fn new() -> V2OperationMetadata {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for V2OperationMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> V2OperationMetadata {
        V2OperationMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<V2OperationMetadata>(
                    "V2OperationMetadata",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static V2OperationMetadata {
        static mut instance: ::protobuf::lazy::Lazy<V2OperationMetadata> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const V2OperationMetadata,
        };
        unsafe {
            instance.get(V2OperationMetadata::new)
        }
    }
}

impl ::protobuf::Clear for V2OperationMetadata {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for V2OperationMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for V2OperationMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \nHgoogle/bigtable/admin/cluster/v1/bigtable_cluster_service_messages.pr\
    oto\x12\x20google.bigtable.admin.cluster.v1\x1a<google/bigtable/admin/cl\
    uster/v1/bigtable_cluster_data.proto\x1a\x1fgoogle/protobuf/timestamp.pr\
    oto\"&\n\x10ListZonesRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04na\
    me\"Q\n\x11ListZonesResponse\x12<\n\x05zones\x18\x01\x20\x03(\x0b2&.goog\
    le.bigtable.admin.cluster.v1.ZoneR\x05zones\"'\n\x11GetClusterRequest\
    \x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\")\n\x13ListClustersReque\
    st\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"\xa8\x01\n\x14ListClus\
    tersResponse\x12E\n\x08clusters\x18\x01\x20\x03(\x0b2).google.bigtable.a\
    dmin.cluster.v1.ClusterR\x08clusters\x12I\n\x0cfailed_zones\x18\x02\x20\
    \x03(\x0b2&.google.bigtable.admin.cluster.v1.ZoneR\x0bfailedZones\"\x8e\
    \x01\n\x14CreateClusterRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04\
    name\x12\x1d\n\ncluster_id\x18\x02\x20\x01(\tR\tclusterId\x12C\n\x07clus\
    ter\x18\x03\x20\x01(\x0b2).google.bigtable.admin.cluster.v1.ClusterR\x07\
    cluster\"\xf6\x01\n\x15CreateClusterMetadata\x12a\n\x10original_request\
    \x18\x01\x20\x01(\x0b26.google.bigtable.admin.cluster.v1.CreateClusterRe\
    questR\x0foriginalRequest\x12=\n\x0crequest_time\x18\x02\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\x0brequestTime\x12;\n\x0bfinish_time\x18\
    \x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nfinishTime\"\xa6\x02\
    \n\x15UpdateClusterMetadata\x12T\n\x10original_request\x18\x01\x20\x01(\
    \x0b2).google.bigtable.admin.cluster.v1.ClusterR\x0foriginalRequest\x12=\
    \n\x0crequest_time\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \x0brequestTime\x12;\n\x0bcancel_time\x18\x03\x20\x01(\x0b2\x1a.google.p\
    rotobuf.TimestampR\ncancelTime\x12;\n\x0bfinish_time\x18\x04\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\nfinishTime\"*\n\x14DeleteClusterRe\
    quest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\",\n\x16UndeleteClus\
    terRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"\x95\x01\n\x17\
    UndeleteClusterMetadata\x12=\n\x0crequest_time\x18\x01\x20\x01(\x0b2\x1a\
    .google.protobuf.TimestampR\x0brequestTime\x12;\n\x0bfinish_time\x18\x02\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nfinishTime\"\x15\n\x13V2O\
    perationMetadataB\x96\x01\n$com.google.bigtable.admin.cluster.v1B#Bigtab\
    leClusterServiceMessagesProtoP\x01ZGgoogle.golang.org/genproto/googleapi\
    s/bigtable/admin/cluster/v1;clusterJ\x94(\n\x07\x12\x05\x0e\0\x8c\x01\
    \x01\n\xbd\x04\n\x01\x0c\x12\x03\x0e\0\x122\xb2\x04\x20Copyright\x202017\
    \x20Google\x20Inc.\n\n\x20Licensed\x20under\x20the\x20Apache\x20License,\
    \x20Version\x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20not\x20us\
    e\x20this\x20file\x20except\x20in\x20compliance\x20with\x20the\x20Licens\
    e.\n\x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\
    \n\n\x20\x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-2.0\n\n\
    \x20Unless\x20required\x20by\x20applicable\x20law\x20or\x20agreed\x20to\
    \x20in\x20writing,\x20software\n\x20distributed\x20under\x20the\x20Licen\
    se\x20is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHO\
    UT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20\
    express\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20sp\
    ecific\x20language\x20governing\x20permissions\x20and\n\x20limitations\
    \x20under\x20the\x20License.\n\n\x08\n\x01\x02\x12\x03\x10\0)\n\t\n\x02\
    \x03\0\x12\x03\x12\0F\n\t\n\x02\x03\x01\x12\x03\x13\0)\n\x08\n\x01\x08\
    \x12\x03\x15\0^\n\t\n\x02\x08\x0b\x12\x03\x15\0^\n\x08\n\x01\x08\x12\x03\
    \x16\0\"\n\t\n\x02\x08\n\x12\x03\x16\0\"\n\x08\n\x01\x08\x12\x03\x17\0D\
    \n\t\n\x02\x08\x08\x12\x03\x17\0D\n\x08\n\x01\x08\x12\x03\x18\0=\n\t\n\
    \x02\x08\x01\x12\x03\x18\0=\nC\n\x02\x04\0\x12\x04\x1c\0!\x01\x1a7\x20Re\
    quest\x20message\x20for\x20BigtableClusterService.ListZones.\n\n\n\n\x03\
    \x04\0\x01\x12\x03\x1c\x08\x18\n\x8b\x01\n\x04\x04\0\x02\0\x12\x03\x20\
    \x02\x12\x1a~\x20The\x20unique\x20name\x20of\x20the\x20project\x20for\
    \x20which\x20a\x20list\x20of\x20supported\x20zones\x20is\n\x20requested.\
    \n\x20Values\x20are\x20of\x20the\x20form\x20projects/<project>\n\n\r\n\
    \x05\x04\0\x02\0\x04\x12\x04\x20\x02\x1c\x1a\n\x0c\n\x05\x04\0\x02\0\x05\
    \x12\x03\x20\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x20\t\r\n\x0c\n\
    \x05\x04\0\x02\0\x03\x12\x03\x20\x10\x11\nD\n\x02\x04\x01\x12\x04$\0'\
    \x01\x1a8\x20Response\x20message\x20for\x20BigtableClusterService.ListZo\
    nes.\n\n\n\n\x03\x04\x01\x01\x12\x03$\x08\x19\n+\n\x04\x04\x01\x02\0\x12\
    \x03&\x02\x1a\x1a\x1e\x20The\x20list\x20of\x20requested\x20zones.\n\n\
    \x0c\n\x05\x04\x01\x02\0\x04\x12\x03&\x02\n\n\x0c\n\x05\x04\x01\x02\0\
    \x06\x12\x03&\x0b\x0f\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03&\x10\x15\n\
    \x0c\n\x05\x04\x01\x02\0\x03\x12\x03&\x18\x19\nD\n\x02\x04\x02\x12\x04*\
    \0.\x01\x1a8\x20Request\x20message\x20for\x20BigtableClusterService.GetC\
    luster.\n\n\n\n\x03\x04\x02\x01\x12\x03*\x08\x19\n\x83\x01\n\x04\x04\x02\
    \x02\0\x12\x03-\x02\x12\x1av\x20The\x20unique\x20name\x20of\x20the\x20re\
    quested\x20cluster.\n\x20Values\x20are\x20of\x20the\x20form\x20projects/\
    <project>/zones/<zone>/clusters/<cluster>\n\n\r\n\x05\x04\x02\x02\0\x04\
    \x12\x04-\x02*\x1b\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03-\x02\x08\n\x0c\
    \n\x05\x04\x02\x02\0\x01\x12\x03-\t\r\n\x0c\n\x05\x04\x02\x02\0\x03\x12\
    \x03-\x10\x11\nF\n\x02\x04\x03\x12\x041\05\x01\x1a:\x20Request\x20messag\
    e\x20for\x20BigtableClusterService.ListClusters.\n\n\n\n\x03\x04\x03\x01\
    \x12\x031\x08\x1b\n\x83\x01\n\x04\x04\x03\x02\0\x12\x034\x02\x12\x1av\
    \x20The\x20unique\x20name\x20of\x20the\x20project\x20for\x20which\x20a\
    \x20list\x20of\x20clusters\x20is\x20requested.\n\x20Values\x20are\x20of\
    \x20the\x20form\x20projects/<project>\n\n\r\n\x05\x04\x03\x02\0\x04\x12\
    \x044\x021\x1d\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x034\x02\x08\n\x0c\n\
    \x05\x04\x03\x02\0\x01\x12\x034\t\r\n\x0c\n\x05\x04\x03\x02\0\x03\x12\
    \x034\x10\x11\nG\n\x02\x04\x04\x12\x048\0>\x01\x1a;\x20Response\x20messa\
    ge\x20for\x20BigtableClusterService.ListClusters.\n\n\n\n\x03\x04\x04\
    \x01\x12\x038\x08\x1c\n.\n\x04\x04\x04\x02\0\x12\x03:\x02\x20\x1a!\x20Th\
    e\x20list\x20of\x20requested\x20Clusters.\n\n\x0c\n\x05\x04\x04\x02\0\
    \x04\x12\x03:\x02\n\n\x0c\n\x05\x04\x04\x02\0\x06\x12\x03:\x0b\x12\n\x0c\
    \n\x05\x04\x04\x02\0\x01\x12\x03:\x13\x1b\n\x0c\n\x05\x04\x04\x02\0\x03\
    \x12\x03:\x1e\x1f\nC\n\x04\x04\x04\x02\x01\x12\x03=\x02!\x1a6\x20The\x20\
    zones\x20for\x20which\x20clusters\x20could\x20not\x20be\x20retrieved.\n\
    \n\x0c\n\x05\x04\x04\x02\x01\x04\x12\x03=\x02\n\n\x0c\n\x05\x04\x04\x02\
    \x01\x06\x12\x03=\x0b\x0f\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03=\x10\
    \x1c\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03=\x1f\x20\nG\n\x02\x04\x05\
    \x12\x04A\0O\x01\x1a;\x20Request\x20message\x20for\x20BigtableClusterSer\
    vice.CreateCluster.\n\n\n\n\x03\x04\x05\x01\x12\x03A\x08\x1c\n\x82\x01\n\
    \x04\x04\x05\x02\0\x12\x03D\x02\x12\x1au\x20The\x20unique\x20name\x20of\
    \x20the\x20zone\x20in\x20which\x20to\x20create\x20the\x20cluster.\n\x20V\
    alues\x20are\x20of\x20the\x20form\x20projects/<project>/zones/<zone>\n\n\
    \r\n\x05\x04\x05\x02\0\x04\x12\x04D\x02A\x1e\n\x0c\n\x05\x04\x05\x02\0\
    \x05\x12\x03D\x02\x08\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03D\t\r\n\x0c\n\
    \x05\x04\x05\x02\0\x03\x12\x03D\x10\x11\n\xc5\x01\n\x04\x04\x05\x02\x01\
    \x12\x03I\x02\x18\x1a\xb7\x01\x20The\x20id\x20to\x20be\x20used\x20when\
    \x20referring\x20to\x20the\x20new\x20cluster\x20within\x20its\x20zone,\n\
    \x20e.g.\x20just\x20the\x20\"test-cluster\"\x20section\x20of\x20the\x20f\
    ull\x20name\n\x20\"projects/<project>/zones/<zone>/clusters/test-cluster\
    \".\n\n\r\n\x05\x04\x05\x02\x01\x04\x12\x04I\x02D\x12\n\x0c\n\x05\x04\
    \x05\x02\x01\x05\x12\x03I\x02\x08\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\
    \x03I\t\x13\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03I\x16\x17\nu\n\x04\
    \x04\x05\x02\x02\x12\x03N\x02\x16\x1ah\x20The\x20cluster\x20to\x20create\
    .\n\x20The\x20\"name\",\x20\"delete_time\",\x20and\x20\"current_operatio\
    n\"\x20fields\x20must\x20be\x20left\n\x20blank.\n\n\r\n\x05\x04\x05\x02\
    \x02\x04\x12\x04N\x02I\x18\n\x0c\n\x05\x04\x05\x02\x02\x06\x12\x03N\x02\
    \t\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03N\n\x11\n\x0c\n\x05\x04\x05\
    \x02\x02\x03\x12\x03N\x14\x15\n`\n\x02\x04\x06\x12\x04S\0\\\x01\x1aT\x20\
    Metadata\x20type\x20for\x20the\x20operation\x20returned\x20by\n\x20Bigta\
    bleClusterService.CreateCluster.\n\n\n\n\x03\x04\x06\x01\x12\x03S\x08\
    \x1d\nI\n\x04\x04\x06\x02\0\x12\x03U\x02,\x1a<\x20The\x20request\x20whic\
    h\x20prompted\x20the\x20creation\x20of\x20this\x20operation.\n\n\r\n\x05\
    \x04\x06\x02\0\x04\x12\x04U\x02S\x1f\n\x0c\n\x05\x04\x06\x02\0\x06\x12\
    \x03U\x02\x16\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03U\x17'\n\x0c\n\x05\
    \x04\x06\x02\0\x03\x12\x03U*+\n?\n\x04\x04\x06\x02\x01\x12\x03X\x02-\x1a\
    2\x20The\x20time\x20at\x20which\x20original_request\x20was\x20received.\
    \n\n\r\n\x05\x04\x06\x02\x01\x04\x12\x04X\x02U,\n\x0c\n\x05\x04\x06\x02\
    \x01\x06\x12\x03X\x02\x1b\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03X\x1c(\
    \n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03X+,\nU\n\x04\x04\x06\x02\x02\x12\
    \x03[\x02,\x1aH\x20The\x20time\x20at\x20which\x20this\x20operation\x20fa\
    iled\x20or\x20was\x20completed\x20successfully.\n\n\r\n\x05\x04\x06\x02\
    \x02\x04\x12\x04[\x02X-\n\x0c\n\x05\x04\x06\x02\x02\x06\x12\x03[\x02\x1b\
    \n\x0c\n\x05\x04\x06\x02\x02\x01\x12\x03[\x1c'\n\x0c\n\x05\x04\x06\x02\
    \x02\x03\x12\x03[*+\n`\n\x02\x04\x07\x12\x04`\0n\x01\x1aT\x20Metadata\
    \x20type\x20for\x20the\x20operation\x20returned\x20by\n\x20BigtableClust\
    erService.UpdateCluster.\n\n\n\n\x03\x04\x07\x01\x12\x03`\x08\x1d\nI\n\
    \x04\x04\x07\x02\0\x12\x03b\x02\x1f\x1a<\x20The\x20request\x20which\x20p\
    rompted\x20the\x20creation\x20of\x20this\x20operation.\n\n\r\n\x05\x04\
    \x07\x02\0\x04\x12\x04b\x02`\x1f\n\x0c\n\x05\x04\x07\x02\0\x06\x12\x03b\
    \x02\t\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03b\n\x1a\n\x0c\n\x05\x04\x07\
    \x02\0\x03\x12\x03b\x1d\x1e\n?\n\x04\x04\x07\x02\x01\x12\x03e\x02-\x1a2\
    \x20The\x20time\x20at\x20which\x20original_request\x20was\x20received.\n\
    \n\r\n\x05\x04\x07\x02\x01\x04\x12\x04e\x02b\x1f\n\x0c\n\x05\x04\x07\x02\
    \x01\x06\x12\x03e\x02\x1b\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03e\x1c(\
    \n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03e+,\n\xbc\x01\n\x04\x04\x07\x02\
    \x02\x12\x03j\x02,\x1a\xae\x01\x20The\x20time\x20at\x20which\x20this\x20\
    operation\x20was\x20cancelled.\x20If\x20set,\x20this\x20operation\x20is\
    \n\x20in\x20the\x20process\x20of\x20undoing\x20itself\x20(which\x20is\
    \x20guaranteed\x20to\x20succeed)\x20and\n\x20cannot\x20be\x20cancelled\
    \x20again.\n\n\r\n\x05\x04\x07\x02\x02\x04\x12\x04j\x02e-\n\x0c\n\x05\
    \x04\x07\x02\x02\x06\x12\x03j\x02\x1b\n\x0c\n\x05\x04\x07\x02\x02\x01\
    \x12\x03j\x1c'\n\x0c\n\x05\x04\x07\x02\x02\x03\x12\x03j*+\nU\n\x04\x04\
    \x07\x02\x03\x12\x03m\x02,\x1aH\x20The\x20time\x20at\x20which\x20this\
    \x20operation\x20failed\x20or\x20was\x20completed\x20successfully.\n\n\r\
    \n\x05\x04\x07\x02\x03\x04\x12\x04m\x02j,\n\x0c\n\x05\x04\x07\x02\x03\
    \x06\x12\x03m\x02\x1b\n\x0c\n\x05\x04\x07\x02\x03\x01\x12\x03m\x1c'\n\
    \x0c\n\x05\x04\x07\x02\x03\x03\x12\x03m*+\nG\n\x02\x04\x08\x12\x04q\0u\
    \x01\x1a;\x20Request\x20message\x20for\x20BigtableClusterService.DeleteC\
    luster.\n\n\n\n\x03\x04\x08\x01\x12\x03q\x08\x1c\n\x87\x01\n\x04\x04\x08\
    \x02\0\x12\x03t\x02\x12\x1az\x20The\x20unique\x20name\x20of\x20the\x20cl\
    uster\x20to\x20be\x20deleted.\n\x20Values\x20are\x20of\x20the\x20form\
    \x20projects/<project>/zones/<zone>/clusters/<cluster>\n\n\r\n\x05\x04\
    \x08\x02\0\x04\x12\x04t\x02q\x1e\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03t\
    \x02\x08\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03t\t\r\n\x0c\n\x05\x04\x08\
    \x02\0\x03\x12\x03t\x10\x11\nI\n\x02\x04\t\x12\x04x\0|\x01\x1a=\x20Reque\
    st\x20message\x20for\x20BigtableClusterService.UndeleteCluster.\n\n\n\n\
    \x03\x04\t\x01\x12\x03x\x08\x1e\n\x8a\x01\n\x04\x04\t\x02\0\x12\x03{\x02\
    \x12\x1a}\x20The\x20unique\x20name\x20of\x20the\x20cluster\x20to\x20be\
    \x20un-deleted.\n\x20Values\x20are\x20of\x20the\x20form\x20projects/<pro\
    ject>/zones/<zone>/clusters/<cluster>\n\n\r\n\x05\x04\t\x02\0\x04\x12\
    \x04{\x02x\x20\n\x0c\n\x05\x04\t\x02\0\x05\x12\x03{\x02\x08\n\x0c\n\x05\
    \x04\t\x02\0\x01\x12\x03{\t\r\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03{\x10\
    \x11\nd\n\x02\x04\n\x12\x06\x80\x01\0\x86\x01\x01\x1aV\x20Metadata\x20ty\
    pe\x20for\x20the\x20operation\x20returned\x20by\n\x20BigtableClusterServ\
    ice.UndeleteCluster.\n\n\x0b\n\x03\x04\n\x01\x12\x04\x80\x01\x08\x1f\nD\
    \n\x04\x04\n\x02\0\x12\x04\x82\x01\x02-\x1a6\x20The\x20time\x20at\x20whi\
    ch\x20the\x20original\x20request\x20was\x20received.\n\n\x0f\n\x05\x04\n\
    \x02\0\x04\x12\x06\x82\x01\x02\x80\x01!\n\r\n\x05\x04\n\x02\0\x06\x12\
    \x04\x82\x01\x02\x1b\n\r\n\x05\x04\n\x02\0\x01\x12\x04\x82\x01\x1c(\n\r\
    \n\x05\x04\n\x02\0\x03\x12\x04\x82\x01+,\nV\n\x04\x04\n\x02\x01\x12\x04\
    \x85\x01\x02,\x1aH\x20The\x20time\x20at\x20which\x20this\x20operation\
    \x20failed\x20or\x20was\x20completed\x20successfully.\n\n\x0f\n\x05\x04\
    \n\x02\x01\x04\x12\x06\x85\x01\x02\x82\x01-\n\r\n\x05\x04\n\x02\x01\x06\
    \x12\x04\x85\x01\x02\x1b\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\x85\x01\x1c\
    '\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\x85\x01*+\n\xa4\x01\n\x02\x04\x0b\
    \x12\x06\x8a\x01\0\x8c\x01\x01\x1a\x95\x01\x20Metadata\x20type\x20for\
    \x20operations\x20initiated\x20by\x20the\x20V2\x20BigtableAdmin\x20servi\
    ce.\n\x20More\x20complete\x20information\x20for\x20such\x20operations\
    \x20is\x20available\x20via\x20the\x20V2\x20API.\n\n\x0b\n\x03\x04\x0b\
    \x01\x12\x04\x8a\x01\x08\x1bb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
