// This file is generated by rust-protobuf 2.22.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/bigtable/admin/cluster/v1/bigtable_cluster_service_messages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_22_0;

#[derive(PartialEq,Clone,Default)]
pub struct ListZonesRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListZonesRequest {
    fn default() -> &'a ListZonesRequest {
        <ListZonesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListZonesRequest {
    pub fn new() -> ListZonesRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListZonesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListZonesRequest {
        ListZonesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListZonesRequest| { &m.name },
                |m: &mut ListZonesRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListZonesRequest>(
                "ListZonesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListZonesRequest {
        static instance: ::protobuf::rt::LazyV2<ListZonesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListZonesRequest::new)
    }
}

impl ::protobuf::Clear for ListZonesRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListZonesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListZonesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListZonesResponse {
    // message fields
    pub zones: ::protobuf::RepeatedField<super::bigtable_cluster_data::Zone>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListZonesResponse {
    fn default() -> &'a ListZonesResponse {
        <ListZonesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListZonesResponse {
    pub fn new() -> ListZonesResponse {
        ::std::default::Default::default()
    }

    // repeated .google.bigtable.admin.cluster.v1.Zone zones = 1;


    pub fn get_zones(&self) -> &[super::bigtable_cluster_data::Zone] {
        &self.zones
    }
    pub fn clear_zones(&mut self) {
        self.zones.clear();
    }

    // Param is passed by value, moved
    pub fn set_zones(&mut self, v: ::protobuf::RepeatedField<super::bigtable_cluster_data::Zone>) {
        self.zones = v;
    }

    // Mutable pointer to the field.
    pub fn mut_zones(&mut self) -> &mut ::protobuf::RepeatedField<super::bigtable_cluster_data::Zone> {
        &mut self.zones
    }

    // Take field
    pub fn take_zones(&mut self) -> ::protobuf::RepeatedField<super::bigtable_cluster_data::Zone> {
        ::std::mem::replace(&mut self.zones, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListZonesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.zones {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.zones)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.zones {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.zones {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListZonesResponse {
        ListZonesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bigtable_cluster_data::Zone>>(
                "zones",
                |m: &ListZonesResponse| { &m.zones },
                |m: &mut ListZonesResponse| { &mut m.zones },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListZonesResponse>(
                "ListZonesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListZonesResponse {
        static instance: ::protobuf::rt::LazyV2<ListZonesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListZonesResponse::new)
    }
}

impl ::protobuf::Clear for ListZonesResponse {
    fn clear(&mut self) {
        self.zones.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListZonesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListZonesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetClusterRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetClusterRequest {
    fn default() -> &'a GetClusterRequest {
        <GetClusterRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetClusterRequest {
    pub fn new() -> GetClusterRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetClusterRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetClusterRequest {
        GetClusterRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetClusterRequest| { &m.name },
                |m: &mut GetClusterRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetClusterRequest>(
                "GetClusterRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetClusterRequest {
        static instance: ::protobuf::rt::LazyV2<GetClusterRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetClusterRequest::new)
    }
}

impl ::protobuf::Clear for GetClusterRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetClusterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetClusterRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListClustersRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListClustersRequest {
    fn default() -> &'a ListClustersRequest {
        <ListClustersRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListClustersRequest {
    pub fn new() -> ListClustersRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListClustersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListClustersRequest {
        ListClustersRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListClustersRequest| { &m.name },
                |m: &mut ListClustersRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListClustersRequest>(
                "ListClustersRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListClustersRequest {
        static instance: ::protobuf::rt::LazyV2<ListClustersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListClustersRequest::new)
    }
}

impl ::protobuf::Clear for ListClustersRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListClustersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListClustersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListClustersResponse {
    // message fields
    pub clusters: ::protobuf::RepeatedField<super::bigtable_cluster_data::Cluster>,
    pub failed_zones: ::protobuf::RepeatedField<super::bigtable_cluster_data::Zone>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListClustersResponse {
    fn default() -> &'a ListClustersResponse {
        <ListClustersResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListClustersResponse {
    pub fn new() -> ListClustersResponse {
        ::std::default::Default::default()
    }

    // repeated .google.bigtable.admin.cluster.v1.Cluster clusters = 1;


    pub fn get_clusters(&self) -> &[super::bigtable_cluster_data::Cluster] {
        &self.clusters
    }
    pub fn clear_clusters(&mut self) {
        self.clusters.clear();
    }

    // Param is passed by value, moved
    pub fn set_clusters(&mut self, v: ::protobuf::RepeatedField<super::bigtable_cluster_data::Cluster>) {
        self.clusters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_clusters(&mut self) -> &mut ::protobuf::RepeatedField<super::bigtable_cluster_data::Cluster> {
        &mut self.clusters
    }

    // Take field
    pub fn take_clusters(&mut self) -> ::protobuf::RepeatedField<super::bigtable_cluster_data::Cluster> {
        ::std::mem::replace(&mut self.clusters, ::protobuf::RepeatedField::new())
    }

    // repeated .google.bigtable.admin.cluster.v1.Zone failed_zones = 2;


    pub fn get_failed_zones(&self) -> &[super::bigtable_cluster_data::Zone] {
        &self.failed_zones
    }
    pub fn clear_failed_zones(&mut self) {
        self.failed_zones.clear();
    }

    // Param is passed by value, moved
    pub fn set_failed_zones(&mut self, v: ::protobuf::RepeatedField<super::bigtable_cluster_data::Zone>) {
        self.failed_zones = v;
    }

    // Mutable pointer to the field.
    pub fn mut_failed_zones(&mut self) -> &mut ::protobuf::RepeatedField<super::bigtable_cluster_data::Zone> {
        &mut self.failed_zones
    }

    // Take field
    pub fn take_failed_zones(&mut self) -> ::protobuf::RepeatedField<super::bigtable_cluster_data::Zone> {
        ::std::mem::replace(&mut self.failed_zones, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListClustersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.clusters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.failed_zones {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.clusters)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.failed_zones)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.clusters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.failed_zones {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.clusters {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.failed_zones {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListClustersResponse {
        ListClustersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bigtable_cluster_data::Cluster>>(
                "clusters",
                |m: &ListClustersResponse| { &m.clusters },
                |m: &mut ListClustersResponse| { &mut m.clusters },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bigtable_cluster_data::Zone>>(
                "failed_zones",
                |m: &ListClustersResponse| { &m.failed_zones },
                |m: &mut ListClustersResponse| { &mut m.failed_zones },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListClustersResponse>(
                "ListClustersResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListClustersResponse {
        static instance: ::protobuf::rt::LazyV2<ListClustersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListClustersResponse::new)
    }
}

impl ::protobuf::Clear for ListClustersResponse {
    fn clear(&mut self) {
        self.clusters.clear();
        self.failed_zones.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListClustersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListClustersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateClusterRequest {
    // message fields
    pub name: ::std::string::String,
    pub cluster_id: ::std::string::String,
    pub cluster: ::protobuf::SingularPtrField<super::bigtable_cluster_data::Cluster>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateClusterRequest {
    fn default() -> &'a CreateClusterRequest {
        <CreateClusterRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateClusterRequest {
    pub fn new() -> CreateClusterRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string cluster_id = 2;


    pub fn get_cluster_id(&self) -> &str {
        &self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: ::std::string::String) {
        self.cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_id
    }

    // Take field
    pub fn take_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_id, ::std::string::String::new())
    }

    // .google.bigtable.admin.cluster.v1.Cluster cluster = 3;


    pub fn get_cluster(&self) -> &super::bigtable_cluster_data::Cluster {
        self.cluster.as_ref().unwrap_or_else(|| <super::bigtable_cluster_data::Cluster as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cluster(&mut self) {
        self.cluster.clear();
    }

    pub fn has_cluster(&self) -> bool {
        self.cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cluster(&mut self, v: super::bigtable_cluster_data::Cluster) {
        self.cluster = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster(&mut self) -> &mut super::bigtable_cluster_data::Cluster {
        if self.cluster.is_none() {
            self.cluster.set_default();
        }
        self.cluster.as_mut().unwrap()
    }

    // Take field
    pub fn take_cluster(&mut self) -> super::bigtable_cluster_data::Cluster {
        self.cluster.take().unwrap_or_else(|| super::bigtable_cluster_data::Cluster::new())
    }
}

impl ::protobuf::Message for CreateClusterRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.cluster {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cluster)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cluster_id);
        }
        if let Some(ref v) = self.cluster.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.cluster_id.is_empty() {
            os.write_string(2, &self.cluster_id)?;
        }
        if let Some(ref v) = self.cluster.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateClusterRequest {
        CreateClusterRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CreateClusterRequest| { &m.name },
                |m: &mut CreateClusterRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_id",
                |m: &CreateClusterRequest| { &m.cluster_id },
                |m: &mut CreateClusterRequest| { &mut m.cluster_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bigtable_cluster_data::Cluster>>(
                "cluster",
                |m: &CreateClusterRequest| { &m.cluster },
                |m: &mut CreateClusterRequest| { &mut m.cluster },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateClusterRequest>(
                "CreateClusterRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateClusterRequest {
        static instance: ::protobuf::rt::LazyV2<CreateClusterRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateClusterRequest::new)
    }
}

impl ::protobuf::Clear for CreateClusterRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.cluster_id.clear();
        self.cluster.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateClusterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateClusterRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateClusterMetadata {
    // message fields
    pub original_request: ::protobuf::SingularPtrField<CreateClusterRequest>,
    pub request_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub finish_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateClusterMetadata {
    fn default() -> &'a CreateClusterMetadata {
        <CreateClusterMetadata as ::protobuf::Message>::default_instance()
    }
}

impl CreateClusterMetadata {
    pub fn new() -> CreateClusterMetadata {
        ::std::default::Default::default()
    }

    // .google.bigtable.admin.cluster.v1.CreateClusterRequest original_request = 1;


    pub fn get_original_request(&self) -> &CreateClusterRequest {
        self.original_request.as_ref().unwrap_or_else(|| <CreateClusterRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_original_request(&mut self) {
        self.original_request.clear();
    }

    pub fn has_original_request(&self) -> bool {
        self.original_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_request(&mut self, v: CreateClusterRequest) {
        self.original_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_request(&mut self) -> &mut CreateClusterRequest {
        if self.original_request.is_none() {
            self.original_request.set_default();
        }
        self.original_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_request(&mut self) -> CreateClusterRequest {
        self.original_request.take().unwrap_or_else(|| CreateClusterRequest::new())
    }

    // .google.protobuf.Timestamp request_time = 2;


    pub fn get_request_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.request_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_request_time(&mut self) {
        self.request_time.clear();
    }

    pub fn has_request_time(&self) -> bool {
        self.request_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.request_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.request_time.is_none() {
            self.request_time.set_default();
        }
        self.request_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_request_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.request_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp finish_time = 3;


    pub fn get_finish_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.finish_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_finish_time(&mut self) {
        self.finish_time.clear();
    }

    pub fn has_finish_time(&self) -> bool {
        self.finish_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_finish_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.finish_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_finish_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.finish_time.is_none() {
            self.finish_time.set_default();
        }
        self.finish_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_finish_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.finish_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for CreateClusterMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.original_request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.request_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.finish_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.original_request)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.request_time)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.finish_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.original_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.request_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.finish_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.original_request.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.request_time.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.finish_time.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateClusterMetadata {
        CreateClusterMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CreateClusterRequest>>(
                "original_request",
                |m: &CreateClusterMetadata| { &m.original_request },
                |m: &mut CreateClusterMetadata| { &mut m.original_request },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "request_time",
                |m: &CreateClusterMetadata| { &m.request_time },
                |m: &mut CreateClusterMetadata| { &mut m.request_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "finish_time",
                |m: &CreateClusterMetadata| { &m.finish_time },
                |m: &mut CreateClusterMetadata| { &mut m.finish_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateClusterMetadata>(
                "CreateClusterMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateClusterMetadata {
        static instance: ::protobuf::rt::LazyV2<CreateClusterMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateClusterMetadata::new)
    }
}

impl ::protobuf::Clear for CreateClusterMetadata {
    fn clear(&mut self) {
        self.original_request.clear();
        self.request_time.clear();
        self.finish_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateClusterMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateClusterMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateClusterMetadata {
    // message fields
    pub original_request: ::protobuf::SingularPtrField<super::bigtable_cluster_data::Cluster>,
    pub request_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub cancel_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub finish_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateClusterMetadata {
    fn default() -> &'a UpdateClusterMetadata {
        <UpdateClusterMetadata as ::protobuf::Message>::default_instance()
    }
}

impl UpdateClusterMetadata {
    pub fn new() -> UpdateClusterMetadata {
        ::std::default::Default::default()
    }

    // .google.bigtable.admin.cluster.v1.Cluster original_request = 1;


    pub fn get_original_request(&self) -> &super::bigtable_cluster_data::Cluster {
        self.original_request.as_ref().unwrap_or_else(|| <super::bigtable_cluster_data::Cluster as ::protobuf::Message>::default_instance())
    }
    pub fn clear_original_request(&mut self) {
        self.original_request.clear();
    }

    pub fn has_original_request(&self) -> bool {
        self.original_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_request(&mut self, v: super::bigtable_cluster_data::Cluster) {
        self.original_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_request(&mut self) -> &mut super::bigtable_cluster_data::Cluster {
        if self.original_request.is_none() {
            self.original_request.set_default();
        }
        self.original_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_request(&mut self) -> super::bigtable_cluster_data::Cluster {
        self.original_request.take().unwrap_or_else(|| super::bigtable_cluster_data::Cluster::new())
    }

    // .google.protobuf.Timestamp request_time = 2;


    pub fn get_request_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.request_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_request_time(&mut self) {
        self.request_time.clear();
    }

    pub fn has_request_time(&self) -> bool {
        self.request_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.request_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.request_time.is_none() {
            self.request_time.set_default();
        }
        self.request_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_request_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.request_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp cancel_time = 3;


    pub fn get_cancel_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.cancel_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cancel_time(&mut self) {
        self.cancel_time.clear();
    }

    pub fn has_cancel_time(&self) -> bool {
        self.cancel_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cancel_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.cancel_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cancel_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.cancel_time.is_none() {
            self.cancel_time.set_default();
        }
        self.cancel_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_cancel_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.cancel_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp finish_time = 4;


    pub fn get_finish_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.finish_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_finish_time(&mut self) {
        self.finish_time.clear();
    }

    pub fn has_finish_time(&self) -> bool {
        self.finish_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_finish_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.finish_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_finish_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.finish_time.is_none() {
            self.finish_time.set_default();
        }
        self.finish_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_finish_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.finish_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for UpdateClusterMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.original_request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.request_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cancel_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.finish_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.original_request)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.request_time)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cancel_time)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.finish_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.original_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.request_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cancel_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.finish_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.original_request.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.request_time.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cancel_time.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.finish_time.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateClusterMetadata {
        UpdateClusterMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bigtable_cluster_data::Cluster>>(
                "original_request",
                |m: &UpdateClusterMetadata| { &m.original_request },
                |m: &mut UpdateClusterMetadata| { &mut m.original_request },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "request_time",
                |m: &UpdateClusterMetadata| { &m.request_time },
                |m: &mut UpdateClusterMetadata| { &mut m.request_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "cancel_time",
                |m: &UpdateClusterMetadata| { &m.cancel_time },
                |m: &mut UpdateClusterMetadata| { &mut m.cancel_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "finish_time",
                |m: &UpdateClusterMetadata| { &m.finish_time },
                |m: &mut UpdateClusterMetadata| { &mut m.finish_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateClusterMetadata>(
                "UpdateClusterMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateClusterMetadata {
        static instance: ::protobuf::rt::LazyV2<UpdateClusterMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateClusterMetadata::new)
    }
}

impl ::protobuf::Clear for UpdateClusterMetadata {
    fn clear(&mut self) {
        self.original_request.clear();
        self.request_time.clear();
        self.cancel_time.clear();
        self.finish_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateClusterMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateClusterMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteClusterRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteClusterRequest {
    fn default() -> &'a DeleteClusterRequest {
        <DeleteClusterRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteClusterRequest {
    pub fn new() -> DeleteClusterRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteClusterRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteClusterRequest {
        DeleteClusterRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DeleteClusterRequest| { &m.name },
                |m: &mut DeleteClusterRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteClusterRequest>(
                "DeleteClusterRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteClusterRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteClusterRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteClusterRequest::new)
    }
}

impl ::protobuf::Clear for DeleteClusterRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteClusterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteClusterRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UndeleteClusterRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UndeleteClusterRequest {
    fn default() -> &'a UndeleteClusterRequest {
        <UndeleteClusterRequest as ::protobuf::Message>::default_instance()
    }
}

impl UndeleteClusterRequest {
    pub fn new() -> UndeleteClusterRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UndeleteClusterRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UndeleteClusterRequest {
        UndeleteClusterRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &UndeleteClusterRequest| { &m.name },
                |m: &mut UndeleteClusterRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UndeleteClusterRequest>(
                "UndeleteClusterRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UndeleteClusterRequest {
        static instance: ::protobuf::rt::LazyV2<UndeleteClusterRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UndeleteClusterRequest::new)
    }
}

impl ::protobuf::Clear for UndeleteClusterRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UndeleteClusterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UndeleteClusterRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UndeleteClusterMetadata {
    // message fields
    pub request_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub finish_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UndeleteClusterMetadata {
    fn default() -> &'a UndeleteClusterMetadata {
        <UndeleteClusterMetadata as ::protobuf::Message>::default_instance()
    }
}

impl UndeleteClusterMetadata {
    pub fn new() -> UndeleteClusterMetadata {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp request_time = 1;


    pub fn get_request_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.request_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_request_time(&mut self) {
        self.request_time.clear();
    }

    pub fn has_request_time(&self) -> bool {
        self.request_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.request_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.request_time.is_none() {
            self.request_time.set_default();
        }
        self.request_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_request_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.request_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp finish_time = 2;


    pub fn get_finish_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.finish_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_finish_time(&mut self) {
        self.finish_time.clear();
    }

    pub fn has_finish_time(&self) -> bool {
        self.finish_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_finish_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.finish_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_finish_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.finish_time.is_none() {
            self.finish_time.set_default();
        }
        self.finish_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_finish_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.finish_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for UndeleteClusterMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.request_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.finish_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.request_time)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.finish_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.request_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.finish_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.request_time.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.finish_time.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UndeleteClusterMetadata {
        UndeleteClusterMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "request_time",
                |m: &UndeleteClusterMetadata| { &m.request_time },
                |m: &mut UndeleteClusterMetadata| { &mut m.request_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "finish_time",
                |m: &UndeleteClusterMetadata| { &m.finish_time },
                |m: &mut UndeleteClusterMetadata| { &mut m.finish_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UndeleteClusterMetadata>(
                "UndeleteClusterMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UndeleteClusterMetadata {
        static instance: ::protobuf::rt::LazyV2<UndeleteClusterMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UndeleteClusterMetadata::new)
    }
}

impl ::protobuf::Clear for UndeleteClusterMetadata {
    fn clear(&mut self) {
        self.request_time.clear();
        self.finish_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UndeleteClusterMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UndeleteClusterMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct V2OperationMetadata {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a V2OperationMetadata {
    fn default() -> &'a V2OperationMetadata {
        <V2OperationMetadata as ::protobuf::Message>::default_instance()
    }
}

impl V2OperationMetadata {
    pub fn new() -> V2OperationMetadata {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for V2OperationMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> V2OperationMetadata {
        V2OperationMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<V2OperationMetadata>(
                "V2OperationMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static V2OperationMetadata {
        static instance: ::protobuf::rt::LazyV2<V2OperationMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(V2OperationMetadata::new)
    }
}

impl ::protobuf::Clear for V2OperationMetadata {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for V2OperationMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for V2OperationMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \nHgoogle/bigtable/admin/cluster/v1/bigtable_cluster_service_messages.pr\
    oto\x12\x20google.bigtable.admin.cluster.v1\x1a<google/bigtable/admin/cl\
    uster/v1/bigtable_cluster_data.proto\x1a\x1fgoogle/protobuf/timestamp.pr\
    oto\"&\n\x10ListZonesRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04na\
    me\"Q\n\x11ListZonesResponse\x12<\n\x05zones\x18\x01\x20\x03(\x0b2&.goog\
    le.bigtable.admin.cluster.v1.ZoneR\x05zones\"'\n\x11GetClusterRequest\
    \x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\")\n\x13ListClustersReque\
    st\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"\xa8\x01\n\x14ListClus\
    tersResponse\x12E\n\x08clusters\x18\x01\x20\x03(\x0b2).google.bigtable.a\
    dmin.cluster.v1.ClusterR\x08clusters\x12I\n\x0cfailed_zones\x18\x02\x20\
    \x03(\x0b2&.google.bigtable.admin.cluster.v1.ZoneR\x0bfailedZones\"\x8e\
    \x01\n\x14CreateClusterRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04\
    name\x12\x1d\n\ncluster_id\x18\x02\x20\x01(\tR\tclusterId\x12C\n\x07clus\
    ter\x18\x03\x20\x01(\x0b2).google.bigtable.admin.cluster.v1.ClusterR\x07\
    cluster\"\xf6\x01\n\x15CreateClusterMetadata\x12a\n\x10original_request\
    \x18\x01\x20\x01(\x0b26.google.bigtable.admin.cluster.v1.CreateClusterRe\
    questR\x0foriginalRequest\x12=\n\x0crequest_time\x18\x02\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\x0brequestTime\x12;\n\x0bfinish_time\x18\
    \x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nfinishTime\"\xa6\x02\
    \n\x15UpdateClusterMetadata\x12T\n\x10original_request\x18\x01\x20\x01(\
    \x0b2).google.bigtable.admin.cluster.v1.ClusterR\x0foriginalRequest\x12=\
    \n\x0crequest_time\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \x0brequestTime\x12;\n\x0bcancel_time\x18\x03\x20\x01(\x0b2\x1a.google.p\
    rotobuf.TimestampR\ncancelTime\x12;\n\x0bfinish_time\x18\x04\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\nfinishTime\"*\n\x14DeleteClusterRe\
    quest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\",\n\x16UndeleteClus\
    terRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"\x95\x01\n\x17\
    UndeleteClusterMetadata\x12=\n\x0crequest_time\x18\x01\x20\x01(\x0b2\x1a\
    .google.protobuf.TimestampR\x0brequestTime\x12;\n\x0bfinish_time\x18\x02\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nfinishTime\"\x15\n\x13V2O\
    perationMetadataB\x96\x01\n$com.google.bigtable.admin.cluster.v1B#Bigtab\
    leClusterServiceMessagesProtoP\x01ZGgoogle.golang.org/genproto/googleapi\
    s/bigtable/admin/cluster/v1;clusterJ\x8f(\n\x07\x12\x05\x0e\0\x89\x01\
    \x1e\n\xbd\x04\n\x01\x0c\x12\x03\x0e\0\x122\xb2\x04\x20Copyright\x202017\
    \x20Google\x20Inc.\n\n\x20Licensed\x20under\x20the\x20Apache\x20License,\
    \x20Version\x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20not\x20us\
    e\x20this\x20file\x20except\x20in\x20compliance\x20with\x20the\x20Licens\
    e.\n\x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\
    \n\n\x20\x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-2.0\n\n\
    \x20Unless\x20required\x20by\x20applicable\x20law\x20or\x20agreed\x20to\
    \x20in\x20writing,\x20software\n\x20distributed\x20under\x20the\x20Licen\
    se\x20is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHO\
    UT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20\
    express\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20sp\
    ecific\x20language\x20governing\x20permissions\x20and\n\x20limitations\
    \x20under\x20the\x20License.\n\n\x08\n\x01\x02\x12\x03\x10\0)\n\t\n\x02\
    \x03\0\x12\x03\x12\0F\n\t\n\x02\x03\x01\x12\x03\x13\0)\n\x08\n\x01\x08\
    \x12\x03\x15\0^\n\t\n\x02\x08\x0b\x12\x03\x15\0^\n\x08\n\x01\x08\x12\x03\
    \x16\0\"\n\t\n\x02\x08\n\x12\x03\x16\0\"\n\x08\n\x01\x08\x12\x03\x17\0D\
    \n\t\n\x02\x08\x08\x12\x03\x17\0D\n\x08\n\x01\x08\x12\x03\x18\0=\n\t\n\
    \x02\x08\x01\x12\x03\x18\0=\nC\n\x02\x04\0\x12\x04\x1b\0\x20\x01\x1a7\
    \x20Request\x20message\x20for\x20BigtableClusterService.ListZones.\n\n\n\
    \n\x03\x04\0\x01\x12\x03\x1b\x08\x18\n\x8b\x01\n\x04\x04\0\x02\0\x12\x03\
    \x1f\x02\x12\x1a~\x20The\x20unique\x20name\x20of\x20the\x20project\x20fo\
    r\x20which\x20a\x20list\x20of\x20supported\x20zones\x20is\n\x20requested\
    .\n\x20Values\x20are\x20of\x20the\x20form\x20projects/<project>\n\n\r\n\
    \x05\x04\0\x02\0\x04\x12\x04\x1f\x02\x1b\x1a\n\x0c\n\x05\x04\0\x02\0\x05\
    \x12\x03\x1f\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x1f\t\r\n\x0c\n\
    \x05\x04\0\x02\0\x03\x12\x03\x1f\x10\x11\nD\n\x02\x04\x01\x12\x04#\0&\
    \x01\x1a8\x20Response\x20message\x20for\x20BigtableClusterService.ListZo\
    nes.\n\n\n\n\x03\x04\x01\x01\x12\x03#\x08\x19\n+\n\x04\x04\x01\x02\0\x12\
    \x03%\x02\x1a\x1a\x1e\x20The\x20list\x20of\x20requested\x20zones.\n\n\
    \x0c\n\x05\x04\x01\x02\0\x04\x12\x03%\x02\n\n\x0c\n\x05\x04\x01\x02\0\
    \x06\x12\x03%\x0b\x0f\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03%\x10\x15\n\
    \x0c\n\x05\x04\x01\x02\0\x03\x12\x03%\x18\x19\nD\n\x02\x04\x02\x12\x04)\
    \0-\x01\x1a8\x20Request\x20message\x20for\x20BigtableClusterService.GetC\
    luster.\n\n\n\n\x03\x04\x02\x01\x12\x03)\x08\x19\n\x83\x01\n\x04\x04\x02\
    \x02\0\x12\x03,\x02\x12\x1av\x20The\x20unique\x20name\x20of\x20the\x20re\
    quested\x20cluster.\n\x20Values\x20are\x20of\x20the\x20form\x20projects/\
    <project>/zones/<zone>/clusters/<cluster>\n\n\r\n\x05\x04\x02\x02\0\x04\
    \x12\x04,\x02)\x1b\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03,\x02\x08\n\x0c\
    \n\x05\x04\x02\x02\0\x01\x12\x03,\t\r\n\x0c\n\x05\x04\x02\x02\0\x03\x12\
    \x03,\x10\x11\nF\n\x02\x04\x03\x12\x040\04\x01\x1a:\x20Request\x20messag\
    e\x20for\x20BigtableClusterService.ListClusters.\n\n\n\n\x03\x04\x03\x01\
    \x12\x030\x08\x1b\n\x83\x01\n\x04\x04\x03\x02\0\x12\x033\x02\x12\x1av\
    \x20The\x20unique\x20name\x20of\x20the\x20project\x20for\x20which\x20a\
    \x20list\x20of\x20clusters\x20is\x20requested.\n\x20Values\x20are\x20of\
    \x20the\x20form\x20projects/<project>\n\n\r\n\x05\x04\x03\x02\0\x04\x12\
    \x043\x020\x1d\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x033\x02\x08\n\x0c\n\
    \x05\x04\x03\x02\0\x01\x12\x033\t\r\n\x0c\n\x05\x04\x03\x02\0\x03\x12\
    \x033\x10\x11\nG\n\x02\x04\x04\x12\x047\0=\x01\x1a;\x20Response\x20messa\
    ge\x20for\x20BigtableClusterService.ListClusters.\n\n\n\n\x03\x04\x04\
    \x01\x12\x037\x08\x1c\n.\n\x04\x04\x04\x02\0\x12\x039\x02\x20\x1a!\x20Th\
    e\x20list\x20of\x20requested\x20Clusters.\n\n\x0c\n\x05\x04\x04\x02\0\
    \x04\x12\x039\x02\n\n\x0c\n\x05\x04\x04\x02\0\x06\x12\x039\x0b\x12\n\x0c\
    \n\x05\x04\x04\x02\0\x01\x12\x039\x13\x1b\n\x0c\n\x05\x04\x04\x02\0\x03\
    \x12\x039\x1e\x1f\nC\n\x04\x04\x04\x02\x01\x12\x03<\x02!\x1a6\x20The\x20\
    zones\x20for\x20which\x20clusters\x20could\x20not\x20be\x20retrieved.\n\
    \n\x0c\n\x05\x04\x04\x02\x01\x04\x12\x03<\x02\n\n\x0c\n\x05\x04\x04\x02\
    \x01\x06\x12\x03<\x0b\x0f\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03<\x10\
    \x1c\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03<\x1f\x20\nG\n\x02\x04\x05\
    \x12\x04@\0N\x01\x1a;\x20Request\x20message\x20for\x20BigtableClusterSer\
    vice.CreateCluster.\n\n\n\n\x03\x04\x05\x01\x12\x03@\x08\x1c\n\x82\x01\n\
    \x04\x04\x05\x02\0\x12\x03C\x02\x12\x1au\x20The\x20unique\x20name\x20of\
    \x20the\x20zone\x20in\x20which\x20to\x20create\x20the\x20cluster.\n\x20V\
    alues\x20are\x20of\x20the\x20form\x20projects/<project>/zones/<zone>\n\n\
    \r\n\x05\x04\x05\x02\0\x04\x12\x04C\x02@\x1e\n\x0c\n\x05\x04\x05\x02\0\
    \x05\x12\x03C\x02\x08\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03C\t\r\n\x0c\n\
    \x05\x04\x05\x02\0\x03\x12\x03C\x10\x11\n\xc5\x01\n\x04\x04\x05\x02\x01\
    \x12\x03H\x02\x18\x1a\xb7\x01\x20The\x20id\x20to\x20be\x20used\x20when\
    \x20referring\x20to\x20the\x20new\x20cluster\x20within\x20its\x20zone,\n\
    \x20e.g.\x20just\x20the\x20\"test-cluster\"\x20section\x20of\x20the\x20f\
    ull\x20name\n\x20\"projects/<project>/zones/<zone>/clusters/test-cluster\
    \".\n\n\r\n\x05\x04\x05\x02\x01\x04\x12\x04H\x02C\x12\n\x0c\n\x05\x04\
    \x05\x02\x01\x05\x12\x03H\x02\x08\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\
    \x03H\t\x13\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03H\x16\x17\nu\n\x04\
    \x04\x05\x02\x02\x12\x03M\x02\x16\x1ah\x20The\x20cluster\x20to\x20create\
    .\n\x20The\x20\"name\",\x20\"delete_time\",\x20and\x20\"current_operatio\
    n\"\x20fields\x20must\x20be\x20left\n\x20blank.\n\n\r\n\x05\x04\x05\x02\
    \x02\x04\x12\x04M\x02H\x18\n\x0c\n\x05\x04\x05\x02\x02\x06\x12\x03M\x02\
    \t\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03M\n\x11\n\x0c\n\x05\x04\x05\
    \x02\x02\x03\x12\x03M\x14\x15\n`\n\x02\x04\x06\x12\x04R\0[\x01\x1aT\x20M\
    etadata\x20type\x20for\x20the\x20operation\x20returned\x20by\n\x20Bigtab\
    leClusterService.CreateCluster.\n\n\n\n\x03\x04\x06\x01\x12\x03R\x08\x1d\
    \nI\n\x04\x04\x06\x02\0\x12\x03T\x02,\x1a<\x20The\x20request\x20which\
    \x20prompted\x20the\x20creation\x20of\x20this\x20operation.\n\n\r\n\x05\
    \x04\x06\x02\0\x04\x12\x04T\x02R\x1f\n\x0c\n\x05\x04\x06\x02\0\x06\x12\
    \x03T\x02\x16\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03T\x17'\n\x0c\n\x05\
    \x04\x06\x02\0\x03\x12\x03T*+\n?\n\x04\x04\x06\x02\x01\x12\x03W\x02-\x1a\
    2\x20The\x20time\x20at\x20which\x20original_request\x20was\x20received.\
    \n\n\r\n\x05\x04\x06\x02\x01\x04\x12\x04W\x02T,\n\x0c\n\x05\x04\x06\x02\
    \x01\x06\x12\x03W\x02\x1b\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03W\x1c(\
    \n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03W+,\nU\n\x04\x04\x06\x02\x02\x12\
    \x03Z\x02,\x1aH\x20The\x20time\x20at\x20which\x20this\x20operation\x20fa\
    iled\x20or\x20was\x20completed\x20successfully.\n\n\r\n\x05\x04\x06\x02\
    \x02\x04\x12\x04Z\x02W-\n\x0c\n\x05\x04\x06\x02\x02\x06\x12\x03Z\x02\x1b\
    \n\x0c\n\x05\x04\x06\x02\x02\x01\x12\x03Z\x1c'\n\x0c\n\x05\x04\x06\x02\
    \x02\x03\x12\x03Z*+\n`\n\x02\x04\x07\x12\x04_\0m\x01\x1aT\x20Metadata\
    \x20type\x20for\x20the\x20operation\x20returned\x20by\n\x20BigtableClust\
    erService.UpdateCluster.\n\n\n\n\x03\x04\x07\x01\x12\x03_\x08\x1d\nI\n\
    \x04\x04\x07\x02\0\x12\x03a\x02\x1f\x1a<\x20The\x20request\x20which\x20p\
    rompted\x20the\x20creation\x20of\x20this\x20operation.\n\n\r\n\x05\x04\
    \x07\x02\0\x04\x12\x04a\x02_\x1f\n\x0c\n\x05\x04\x07\x02\0\x06\x12\x03a\
    \x02\t\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03a\n\x1a\n\x0c\n\x05\x04\x07\
    \x02\0\x03\x12\x03a\x1d\x1e\n?\n\x04\x04\x07\x02\x01\x12\x03d\x02-\x1a2\
    \x20The\x20time\x20at\x20which\x20original_request\x20was\x20received.\n\
    \n\r\n\x05\x04\x07\x02\x01\x04\x12\x04d\x02a\x1f\n\x0c\n\x05\x04\x07\x02\
    \x01\x06\x12\x03d\x02\x1b\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03d\x1c(\
    \n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03d+,\n\xbc\x01\n\x04\x04\x07\x02\
    \x02\x12\x03i\x02,\x1a\xae\x01\x20The\x20time\x20at\x20which\x20this\x20\
    operation\x20was\x20cancelled.\x20If\x20set,\x20this\x20operation\x20is\
    \n\x20in\x20the\x20process\x20of\x20undoing\x20itself\x20(which\x20is\
    \x20guaranteed\x20to\x20succeed)\x20and\n\x20cannot\x20be\x20cancelled\
    \x20again.\n\n\r\n\x05\x04\x07\x02\x02\x04\x12\x04i\x02d-\n\x0c\n\x05\
    \x04\x07\x02\x02\x06\x12\x03i\x02\x1b\n\x0c\n\x05\x04\x07\x02\x02\x01\
    \x12\x03i\x1c'\n\x0c\n\x05\x04\x07\x02\x02\x03\x12\x03i*+\nU\n\x04\x04\
    \x07\x02\x03\x12\x03l\x02,\x1aH\x20The\x20time\x20at\x20which\x20this\
    \x20operation\x20failed\x20or\x20was\x20completed\x20successfully.\n\n\r\
    \n\x05\x04\x07\x02\x03\x04\x12\x04l\x02i,\n\x0c\n\x05\x04\x07\x02\x03\
    \x06\x12\x03l\x02\x1b\n\x0c\n\x05\x04\x07\x02\x03\x01\x12\x03l\x1c'\n\
    \x0c\n\x05\x04\x07\x02\x03\x03\x12\x03l*+\nG\n\x02\x04\x08\x12\x04p\0t\
    \x01\x1a;\x20Request\x20message\x20for\x20BigtableClusterService.DeleteC\
    luster.\n\n\n\n\x03\x04\x08\x01\x12\x03p\x08\x1c\n\x87\x01\n\x04\x04\x08\
    \x02\0\x12\x03s\x02\x12\x1az\x20The\x20unique\x20name\x20of\x20the\x20cl\
    uster\x20to\x20be\x20deleted.\n\x20Values\x20are\x20of\x20the\x20form\
    \x20projects/<project>/zones/<zone>/clusters/<cluster>\n\n\r\n\x05\x04\
    \x08\x02\0\x04\x12\x04s\x02p\x1e\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03s\
    \x02\x08\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03s\t\r\n\x0c\n\x05\x04\x08\
    \x02\0\x03\x12\x03s\x10\x11\nI\n\x02\x04\t\x12\x04w\0{\x01\x1a=\x20Reque\
    st\x20message\x20for\x20BigtableClusterService.UndeleteCluster.\n\n\n\n\
    \x03\x04\t\x01\x12\x03w\x08\x1e\n\x8a\x01\n\x04\x04\t\x02\0\x12\x03z\x02\
    \x12\x1a}\x20The\x20unique\x20name\x20of\x20the\x20cluster\x20to\x20be\
    \x20un-deleted.\n\x20Values\x20are\x20of\x20the\x20form\x20projects/<pro\
    ject>/zones/<zone>/clusters/<cluster>\n\n\r\n\x05\x04\t\x02\0\x04\x12\
    \x04z\x02w\x20\n\x0c\n\x05\x04\t\x02\0\x05\x12\x03z\x02\x08\n\x0c\n\x05\
    \x04\t\x02\0\x01\x12\x03z\t\r\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03z\x10\
    \x11\nc\n\x02\x04\n\x12\x05\x7f\0\x85\x01\x01\x1aV\x20Metadata\x20type\
    \x20for\x20the\x20operation\x20returned\x20by\n\x20BigtableClusterServic\
    e.UndeleteCluster.\n\n\n\n\x03\x04\n\x01\x12\x03\x7f\x08\x1f\nD\n\x04\
    \x04\n\x02\0\x12\x04\x81\x01\x02-\x1a6\x20The\x20time\x20at\x20which\x20\
    the\x20original\x20request\x20was\x20received.\n\n\x0e\n\x05\x04\n\x02\0\
    \x04\x12\x05\x81\x01\x02\x7f!\n\r\n\x05\x04\n\x02\0\x06\x12\x04\x81\x01\
    \x02\x1b\n\r\n\x05\x04\n\x02\0\x01\x12\x04\x81\x01\x1c(\n\r\n\x05\x04\n\
    \x02\0\x03\x12\x04\x81\x01+,\nV\n\x04\x04\n\x02\x01\x12\x04\x84\x01\x02,\
    \x1aH\x20The\x20time\x20at\x20which\x20this\x20operation\x20failed\x20or\
    \x20was\x20completed\x20successfully.\n\n\x0f\n\x05\x04\n\x02\x01\x04\
    \x12\x06\x84\x01\x02\x81\x01-\n\r\n\x05\x04\n\x02\x01\x06\x12\x04\x84\
    \x01\x02\x1b\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\x84\x01\x1c'\n\r\n\x05\
    \x04\n\x02\x01\x03\x12\x04\x84\x01*+\n\xa2\x01\n\x02\x04\x0b\x12\x04\x89\
    \x01\0\x1e\x1a\x95\x01\x20Metadata\x20type\x20for\x20operations\x20initi\
    ated\x20by\x20the\x20V2\x20BigtableAdmin\x20service.\n\x20More\x20comple\
    te\x20information\x20for\x20such\x20operations\x20is\x20available\x20via\
    \x20the\x20V2\x20API.\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\x89\x01\x08\x1bb\
    \x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
