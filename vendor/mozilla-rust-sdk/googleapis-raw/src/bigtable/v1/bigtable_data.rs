// This file is generated by rust-protobuf 2.22.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/bigtable/v1/bigtable_data.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_22_0;

#[derive(PartialEq,Clone,Default)]
pub struct Row {
    // message fields
    pub key: ::std::vec::Vec<u8>,
    pub families: ::protobuf::RepeatedField<Family>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Row {
    fn default() -> &'a Row {
        <Row as ::protobuf::Message>::default_instance()
    }
}

impl Row {
    pub fn new() -> Row {
        ::std::default::Default::default()
    }

    // bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // repeated .google.bigtable.v1.Family families = 2;


    pub fn get_families(&self) -> &[Family] {
        &self.families
    }
    pub fn clear_families(&mut self) {
        self.families.clear();
    }

    // Param is passed by value, moved
    pub fn set_families(&mut self, v: ::protobuf::RepeatedField<Family>) {
        self.families = v;
    }

    // Mutable pointer to the field.
    pub fn mut_families(&mut self) -> &mut ::protobuf::RepeatedField<Family> {
        &mut self.families
    }

    // Take field
    pub fn take_families(&mut self) -> ::protobuf::RepeatedField<Family> {
        ::std::mem::replace(&mut self.families, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Row {
    fn is_initialized(&self) -> bool {
        for v in &self.families {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.families)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        for value in &self.families {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        for v in &self.families {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Row {
        Row::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key",
                |m: &Row| { &m.key },
                |m: &mut Row| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Family>>(
                "families",
                |m: &Row| { &m.families },
                |m: &mut Row| { &mut m.families },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Row>(
                "Row",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Row {
        static instance: ::protobuf::rt::LazyV2<Row> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Row::new)
    }
}

impl ::protobuf::Clear for Row {
    fn clear(&mut self) {
        self.key.clear();
        self.families.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Row {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Row {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Family {
    // message fields
    pub name: ::std::string::String,
    pub columns: ::protobuf::RepeatedField<Column>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Family {
    fn default() -> &'a Family {
        <Family as ::protobuf::Message>::default_instance()
    }
}

impl Family {
    pub fn new() -> Family {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .google.bigtable.v1.Column columns = 2;


    pub fn get_columns(&self) -> &[Column] {
        &self.columns
    }
    pub fn clear_columns(&mut self) {
        self.columns.clear();
    }

    // Param is passed by value, moved
    pub fn set_columns(&mut self, v: ::protobuf::RepeatedField<Column>) {
        self.columns = v;
    }

    // Mutable pointer to the field.
    pub fn mut_columns(&mut self) -> &mut ::protobuf::RepeatedField<Column> {
        &mut self.columns
    }

    // Take field
    pub fn take_columns(&mut self) -> ::protobuf::RepeatedField<Column> {
        ::std::mem::replace(&mut self.columns, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Family {
    fn is_initialized(&self) -> bool {
        for v in &self.columns {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.columns)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.columns {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.columns {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Family {
        Family::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Family| { &m.name },
                |m: &mut Family| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Column>>(
                "columns",
                |m: &Family| { &m.columns },
                |m: &mut Family| { &mut m.columns },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Family>(
                "Family",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Family {
        static instance: ::protobuf::rt::LazyV2<Family> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Family::new)
    }
}

impl ::protobuf::Clear for Family {
    fn clear(&mut self) {
        self.name.clear();
        self.columns.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Family {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Family {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Column {
    // message fields
    pub qualifier: ::std::vec::Vec<u8>,
    pub cells: ::protobuf::RepeatedField<Cell>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Column {
    fn default() -> &'a Column {
        <Column as ::protobuf::Message>::default_instance()
    }
}

impl Column {
    pub fn new() -> Column {
        ::std::default::Default::default()
    }

    // bytes qualifier = 1;


    pub fn get_qualifier(&self) -> &[u8] {
        &self.qualifier
    }
    pub fn clear_qualifier(&mut self) {
        self.qualifier.clear();
    }

    // Param is passed by value, moved
    pub fn set_qualifier(&mut self, v: ::std::vec::Vec<u8>) {
        self.qualifier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_qualifier(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.qualifier
    }

    // Take field
    pub fn take_qualifier(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.qualifier, ::std::vec::Vec::new())
    }

    // repeated .google.bigtable.v1.Cell cells = 2;


    pub fn get_cells(&self) -> &[Cell] {
        &self.cells
    }
    pub fn clear_cells(&mut self) {
        self.cells.clear();
    }

    // Param is passed by value, moved
    pub fn set_cells(&mut self, v: ::protobuf::RepeatedField<Cell>) {
        self.cells = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cells(&mut self) -> &mut ::protobuf::RepeatedField<Cell> {
        &mut self.cells
    }

    // Take field
    pub fn take_cells(&mut self) -> ::protobuf::RepeatedField<Cell> {
        ::std::mem::replace(&mut self.cells, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Column {
    fn is_initialized(&self) -> bool {
        for v in &self.cells {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.qualifier)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cells)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.qualifier.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.qualifier);
        }
        for value in &self.cells {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.qualifier.is_empty() {
            os.write_bytes(1, &self.qualifier)?;
        }
        for v in &self.cells {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Column {
        Column::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "qualifier",
                |m: &Column| { &m.qualifier },
                |m: &mut Column| { &mut m.qualifier },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Cell>>(
                "cells",
                |m: &Column| { &m.cells },
                |m: &mut Column| { &mut m.cells },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Column>(
                "Column",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Column {
        static instance: ::protobuf::rt::LazyV2<Column> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Column::new)
    }
}

impl ::protobuf::Clear for Column {
    fn clear(&mut self) {
        self.qualifier.clear();
        self.cells.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Column {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Column {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Cell {
    // message fields
    pub timestamp_micros: i64,
    pub value: ::std::vec::Vec<u8>,
    pub labels: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Cell {
    fn default() -> &'a Cell {
        <Cell as ::protobuf::Message>::default_instance()
    }
}

impl Cell {
    pub fn new() -> Cell {
        ::std::default::Default::default()
    }

    // int64 timestamp_micros = 1;


    pub fn get_timestamp_micros(&self) -> i64 {
        self.timestamp_micros
    }
    pub fn clear_timestamp_micros(&mut self) {
        self.timestamp_micros = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp_micros(&mut self, v: i64) {
        self.timestamp_micros = v;
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // repeated string labels = 3;


    pub fn get_labels(&self) -> &[::std::string::String] {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Cell {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp_micros = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.timestamp_micros != 0 {
            my_size += ::protobuf::rt::value_size(1, self.timestamp_micros, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        for value in &self.labels {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.timestamp_micros != 0 {
            os.write_int64(1, self.timestamp_micros)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        for v in &self.labels {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Cell {
        Cell::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp_micros",
                |m: &Cell| { &m.timestamp_micros },
                |m: &mut Cell| { &mut m.timestamp_micros },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &Cell| { &m.value },
                |m: &mut Cell| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "labels",
                |m: &Cell| { &m.labels },
                |m: &mut Cell| { &mut m.labels },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Cell>(
                "Cell",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Cell {
        static instance: ::protobuf::rt::LazyV2<Cell> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Cell::new)
    }
}

impl ::protobuf::Clear for Cell {
    fn clear(&mut self) {
        self.timestamp_micros = 0;
        self.value.clear();
        self.labels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Cell {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cell {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RowRange {
    // message fields
    pub start_key: ::std::vec::Vec<u8>,
    pub end_key: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RowRange {
    fn default() -> &'a RowRange {
        <RowRange as ::protobuf::Message>::default_instance()
    }
}

impl RowRange {
    pub fn new() -> RowRange {
        ::std::default::Default::default()
    }

    // bytes start_key = 2;


    pub fn get_start_key(&self) -> &[u8] {
        &self.start_key
    }
    pub fn clear_start_key(&mut self) {
        self.start_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_start_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.start_key
    }

    // Take field
    pub fn take_start_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.start_key, ::std::vec::Vec::new())
    }

    // bytes end_key = 3;


    pub fn get_end_key(&self) -> &[u8] {
        &self.end_key
    }
    pub fn clear_end_key(&mut self) {
        self.end_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_end_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.end_key
    }

    // Take field
    pub fn take_end_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.end_key, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for RowRange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.start_key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.end_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.start_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.start_key);
        }
        if !self.end_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.end_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.start_key.is_empty() {
            os.write_bytes(2, &self.start_key)?;
        }
        if !self.end_key.is_empty() {
            os.write_bytes(3, &self.end_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RowRange {
        RowRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "start_key",
                |m: &RowRange| { &m.start_key },
                |m: &mut RowRange| { &mut m.start_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "end_key",
                |m: &RowRange| { &m.end_key },
                |m: &mut RowRange| { &mut m.end_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RowRange>(
                "RowRange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RowRange {
        static instance: ::protobuf::rt::LazyV2<RowRange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RowRange::new)
    }
}

impl ::protobuf::Clear for RowRange {
    fn clear(&mut self) {
        self.start_key.clear();
        self.end_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RowRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RowRange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RowSet {
    // message fields
    pub row_keys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub row_ranges: ::protobuf::RepeatedField<RowRange>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RowSet {
    fn default() -> &'a RowSet {
        <RowSet as ::protobuf::Message>::default_instance()
    }
}

impl RowSet {
    pub fn new() -> RowSet {
        ::std::default::Default::default()
    }

    // repeated bytes row_keys = 1;


    pub fn get_row_keys(&self) -> &[::std::vec::Vec<u8>] {
        &self.row_keys
    }
    pub fn clear_row_keys(&mut self) {
        self.row_keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_row_keys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.row_keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_row_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.row_keys
    }

    // Take field
    pub fn take_row_keys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.row_keys, ::protobuf::RepeatedField::new())
    }

    // repeated .google.bigtable.v1.RowRange row_ranges = 2;


    pub fn get_row_ranges(&self) -> &[RowRange] {
        &self.row_ranges
    }
    pub fn clear_row_ranges(&mut self) {
        self.row_ranges.clear();
    }

    // Param is passed by value, moved
    pub fn set_row_ranges(&mut self, v: ::protobuf::RepeatedField<RowRange>) {
        self.row_ranges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_row_ranges(&mut self) -> &mut ::protobuf::RepeatedField<RowRange> {
        &mut self.row_ranges
    }

    // Take field
    pub fn take_row_ranges(&mut self) -> ::protobuf::RepeatedField<RowRange> {
        ::std::mem::replace(&mut self.row_ranges, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RowSet {
    fn is_initialized(&self) -> bool {
        for v in &self.row_ranges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.row_keys)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.row_ranges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.row_keys {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        for value in &self.row_ranges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.row_keys {
            os.write_bytes(1, &v)?;
        };
        for v in &self.row_ranges {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RowSet {
        RowSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "row_keys",
                |m: &RowSet| { &m.row_keys },
                |m: &mut RowSet| { &mut m.row_keys },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RowRange>>(
                "row_ranges",
                |m: &RowSet| { &m.row_ranges },
                |m: &mut RowSet| { &mut m.row_ranges },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RowSet>(
                "RowSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RowSet {
        static instance: ::protobuf::rt::LazyV2<RowSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RowSet::new)
    }
}

impl ::protobuf::Clear for RowSet {
    fn clear(&mut self) {
        self.row_keys.clear();
        self.row_ranges.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RowSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RowSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ColumnRange {
    // message fields
    pub family_name: ::std::string::String,
    // message oneof groups
    pub start_qualifier: ::std::option::Option<ColumnRange_oneof_start_qualifier>,
    pub end_qualifier: ::std::option::Option<ColumnRange_oneof_end_qualifier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ColumnRange {
    fn default() -> &'a ColumnRange {
        <ColumnRange as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ColumnRange_oneof_start_qualifier {
    start_qualifier_inclusive(::std::vec::Vec<u8>),
    start_qualifier_exclusive(::std::vec::Vec<u8>),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ColumnRange_oneof_end_qualifier {
    end_qualifier_inclusive(::std::vec::Vec<u8>),
    end_qualifier_exclusive(::std::vec::Vec<u8>),
}

impl ColumnRange {
    pub fn new() -> ColumnRange {
        ::std::default::Default::default()
    }

    // string family_name = 1;


    pub fn get_family_name(&self) -> &str {
        &self.family_name
    }
    pub fn clear_family_name(&mut self) {
        self.family_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_family_name(&mut self, v: ::std::string::String) {
        self.family_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_family_name(&mut self) -> &mut ::std::string::String {
        &mut self.family_name
    }

    // Take field
    pub fn take_family_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.family_name, ::std::string::String::new())
    }

    // bytes start_qualifier_inclusive = 2;


    pub fn get_start_qualifier_inclusive(&self) -> &[u8] {
        match self.start_qualifier {
            ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_inclusive(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_start_qualifier_inclusive(&mut self) {
        self.start_qualifier = ::std::option::Option::None;
    }

    pub fn has_start_qualifier_inclusive(&self) -> bool {
        match self.start_qualifier {
            ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_inclusive(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start_qualifier_inclusive(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_qualifier = ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_inclusive(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start_qualifier_inclusive(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_inclusive(_)) = self.start_qualifier {
        } else {
            self.start_qualifier = ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_inclusive(::std::vec::Vec::new()));
        }
        match self.start_qualifier {
            ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_inclusive(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start_qualifier_inclusive(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_start_qualifier_inclusive() {
            match self.start_qualifier.take() {
                ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_inclusive(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bytes start_qualifier_exclusive = 3;


    pub fn get_start_qualifier_exclusive(&self) -> &[u8] {
        match self.start_qualifier {
            ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_exclusive(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_start_qualifier_exclusive(&mut self) {
        self.start_qualifier = ::std::option::Option::None;
    }

    pub fn has_start_qualifier_exclusive(&self) -> bool {
        match self.start_qualifier {
            ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_exclusive(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start_qualifier_exclusive(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_qualifier = ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_exclusive(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start_qualifier_exclusive(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_exclusive(_)) = self.start_qualifier {
        } else {
            self.start_qualifier = ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_exclusive(::std::vec::Vec::new()));
        }
        match self.start_qualifier {
            ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_exclusive(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start_qualifier_exclusive(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_start_qualifier_exclusive() {
            match self.start_qualifier.take() {
                ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_exclusive(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bytes end_qualifier_inclusive = 4;


    pub fn get_end_qualifier_inclusive(&self) -> &[u8] {
        match self.end_qualifier {
            ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_inclusive(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_end_qualifier_inclusive(&mut self) {
        self.end_qualifier = ::std::option::Option::None;
    }

    pub fn has_end_qualifier_inclusive(&self) -> bool {
        match self.end_qualifier {
            ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_inclusive(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_end_qualifier_inclusive(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_qualifier = ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_inclusive(v))
    }

    // Mutable pointer to the field.
    pub fn mut_end_qualifier_inclusive(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_inclusive(_)) = self.end_qualifier {
        } else {
            self.end_qualifier = ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_inclusive(::std::vec::Vec::new()));
        }
        match self.end_qualifier {
            ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_inclusive(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_end_qualifier_inclusive(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_end_qualifier_inclusive() {
            match self.end_qualifier.take() {
                ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_inclusive(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bytes end_qualifier_exclusive = 5;


    pub fn get_end_qualifier_exclusive(&self) -> &[u8] {
        match self.end_qualifier {
            ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_exclusive(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_end_qualifier_exclusive(&mut self) {
        self.end_qualifier = ::std::option::Option::None;
    }

    pub fn has_end_qualifier_exclusive(&self) -> bool {
        match self.end_qualifier {
            ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_exclusive(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_end_qualifier_exclusive(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_qualifier = ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_exclusive(v))
    }

    // Mutable pointer to the field.
    pub fn mut_end_qualifier_exclusive(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_exclusive(_)) = self.end_qualifier {
        } else {
            self.end_qualifier = ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_exclusive(::std::vec::Vec::new()));
        }
        match self.end_qualifier {
            ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_exclusive(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_end_qualifier_exclusive(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_end_qualifier_exclusive() {
            match self.end_qualifier.take() {
                ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_exclusive(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }
}

impl ::protobuf::Message for ColumnRange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.family_name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.start_qualifier = ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_inclusive(is.read_bytes()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.start_qualifier = ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_exclusive(is.read_bytes()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.end_qualifier = ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_inclusive(is.read_bytes()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.end_qualifier = ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_exclusive(is.read_bytes()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.family_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.family_name);
        }
        if let ::std::option::Option::Some(ref v) = self.start_qualifier {
            match v {
                &ColumnRange_oneof_start_qualifier::start_qualifier_inclusive(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
                &ColumnRange_oneof_start_qualifier::start_qualifier_exclusive(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(3, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.end_qualifier {
            match v {
                &ColumnRange_oneof_end_qualifier::end_qualifier_inclusive(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(4, &v);
                },
                &ColumnRange_oneof_end_qualifier::end_qualifier_exclusive(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(5, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.family_name.is_empty() {
            os.write_string(1, &self.family_name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.start_qualifier {
            match v {
                &ColumnRange_oneof_start_qualifier::start_qualifier_inclusive(ref v) => {
                    os.write_bytes(2, v)?;
                },
                &ColumnRange_oneof_start_qualifier::start_qualifier_exclusive(ref v) => {
                    os.write_bytes(3, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.end_qualifier {
            match v {
                &ColumnRange_oneof_end_qualifier::end_qualifier_inclusive(ref v) => {
                    os.write_bytes(4, v)?;
                },
                &ColumnRange_oneof_end_qualifier::end_qualifier_exclusive(ref v) => {
                    os.write_bytes(5, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ColumnRange {
        ColumnRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "family_name",
                |m: &ColumnRange| { &m.family_name },
                |m: &mut ColumnRange| { &mut m.family_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "start_qualifier_inclusive",
                ColumnRange::has_start_qualifier_inclusive,
                ColumnRange::get_start_qualifier_inclusive,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "start_qualifier_exclusive",
                ColumnRange::has_start_qualifier_exclusive,
                ColumnRange::get_start_qualifier_exclusive,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "end_qualifier_inclusive",
                ColumnRange::has_end_qualifier_inclusive,
                ColumnRange::get_end_qualifier_inclusive,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "end_qualifier_exclusive",
                ColumnRange::has_end_qualifier_exclusive,
                ColumnRange::get_end_qualifier_exclusive,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ColumnRange>(
                "ColumnRange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ColumnRange {
        static instance: ::protobuf::rt::LazyV2<ColumnRange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ColumnRange::new)
    }
}

impl ::protobuf::Clear for ColumnRange {
    fn clear(&mut self) {
        self.family_name.clear();
        self.start_qualifier = ::std::option::Option::None;
        self.start_qualifier = ::std::option::Option::None;
        self.end_qualifier = ::std::option::Option::None;
        self.end_qualifier = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ColumnRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColumnRange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimestampRange {
    // message fields
    pub start_timestamp_micros: i64,
    pub end_timestamp_micros: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimestampRange {
    fn default() -> &'a TimestampRange {
        <TimestampRange as ::protobuf::Message>::default_instance()
    }
}

impl TimestampRange {
    pub fn new() -> TimestampRange {
        ::std::default::Default::default()
    }

    // int64 start_timestamp_micros = 1;


    pub fn get_start_timestamp_micros(&self) -> i64 {
        self.start_timestamp_micros
    }
    pub fn clear_start_timestamp_micros(&mut self) {
        self.start_timestamp_micros = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_timestamp_micros(&mut self, v: i64) {
        self.start_timestamp_micros = v;
    }

    // int64 end_timestamp_micros = 2;


    pub fn get_end_timestamp_micros(&self) -> i64 {
        self.end_timestamp_micros
    }
    pub fn clear_end_timestamp_micros(&mut self) {
        self.end_timestamp_micros = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_timestamp_micros(&mut self, v: i64) {
        self.end_timestamp_micros = v;
    }
}

impl ::protobuf::Message for TimestampRange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.start_timestamp_micros = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.end_timestamp_micros = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start_timestamp_micros != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start_timestamp_micros, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.end_timestamp_micros != 0 {
            my_size += ::protobuf::rt::value_size(2, self.end_timestamp_micros, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.start_timestamp_micros != 0 {
            os.write_int64(1, self.start_timestamp_micros)?;
        }
        if self.end_timestamp_micros != 0 {
            os.write_int64(2, self.end_timestamp_micros)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimestampRange {
        TimestampRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "start_timestamp_micros",
                |m: &TimestampRange| { &m.start_timestamp_micros },
                |m: &mut TimestampRange| { &mut m.start_timestamp_micros },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "end_timestamp_micros",
                |m: &TimestampRange| { &m.end_timestamp_micros },
                |m: &mut TimestampRange| { &mut m.end_timestamp_micros },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TimestampRange>(
                "TimestampRange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TimestampRange {
        static instance: ::protobuf::rt::LazyV2<TimestampRange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TimestampRange::new)
    }
}

impl ::protobuf::Clear for TimestampRange {
    fn clear(&mut self) {
        self.start_timestamp_micros = 0;
        self.end_timestamp_micros = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimestampRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimestampRange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ValueRange {
    // message oneof groups
    pub start_value: ::std::option::Option<ValueRange_oneof_start_value>,
    pub end_value: ::std::option::Option<ValueRange_oneof_end_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ValueRange {
    fn default() -> &'a ValueRange {
        <ValueRange as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ValueRange_oneof_start_value {
    start_value_inclusive(::std::vec::Vec<u8>),
    start_value_exclusive(::std::vec::Vec<u8>),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ValueRange_oneof_end_value {
    end_value_inclusive(::std::vec::Vec<u8>),
    end_value_exclusive(::std::vec::Vec<u8>),
}

impl ValueRange {
    pub fn new() -> ValueRange {
        ::std::default::Default::default()
    }

    // bytes start_value_inclusive = 1;


    pub fn get_start_value_inclusive(&self) -> &[u8] {
        match self.start_value {
            ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_inclusive(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_start_value_inclusive(&mut self) {
        self.start_value = ::std::option::Option::None;
    }

    pub fn has_start_value_inclusive(&self) -> bool {
        match self.start_value {
            ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_inclusive(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start_value_inclusive(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_value = ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_inclusive(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start_value_inclusive(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_inclusive(_)) = self.start_value {
        } else {
            self.start_value = ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_inclusive(::std::vec::Vec::new()));
        }
        match self.start_value {
            ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_inclusive(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start_value_inclusive(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_start_value_inclusive() {
            match self.start_value.take() {
                ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_inclusive(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bytes start_value_exclusive = 2;


    pub fn get_start_value_exclusive(&self) -> &[u8] {
        match self.start_value {
            ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_exclusive(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_start_value_exclusive(&mut self) {
        self.start_value = ::std::option::Option::None;
    }

    pub fn has_start_value_exclusive(&self) -> bool {
        match self.start_value {
            ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_exclusive(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start_value_exclusive(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_value = ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_exclusive(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start_value_exclusive(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_exclusive(_)) = self.start_value {
        } else {
            self.start_value = ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_exclusive(::std::vec::Vec::new()));
        }
        match self.start_value {
            ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_exclusive(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start_value_exclusive(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_start_value_exclusive() {
            match self.start_value.take() {
                ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_exclusive(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bytes end_value_inclusive = 3;


    pub fn get_end_value_inclusive(&self) -> &[u8] {
        match self.end_value {
            ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_inclusive(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_end_value_inclusive(&mut self) {
        self.end_value = ::std::option::Option::None;
    }

    pub fn has_end_value_inclusive(&self) -> bool {
        match self.end_value {
            ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_inclusive(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_end_value_inclusive(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_value = ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_inclusive(v))
    }

    // Mutable pointer to the field.
    pub fn mut_end_value_inclusive(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_inclusive(_)) = self.end_value {
        } else {
            self.end_value = ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_inclusive(::std::vec::Vec::new()));
        }
        match self.end_value {
            ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_inclusive(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_end_value_inclusive(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_end_value_inclusive() {
            match self.end_value.take() {
                ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_inclusive(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bytes end_value_exclusive = 4;


    pub fn get_end_value_exclusive(&self) -> &[u8] {
        match self.end_value {
            ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_exclusive(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_end_value_exclusive(&mut self) {
        self.end_value = ::std::option::Option::None;
    }

    pub fn has_end_value_exclusive(&self) -> bool {
        match self.end_value {
            ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_exclusive(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_end_value_exclusive(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_value = ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_exclusive(v))
    }

    // Mutable pointer to the field.
    pub fn mut_end_value_exclusive(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_exclusive(_)) = self.end_value {
        } else {
            self.end_value = ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_exclusive(::std::vec::Vec::new()));
        }
        match self.end_value {
            ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_exclusive(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_end_value_exclusive(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_end_value_exclusive() {
            match self.end_value.take() {
                ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_exclusive(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }
}

impl ::protobuf::Message for ValueRange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.start_value = ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_inclusive(is.read_bytes()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.start_value = ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_exclusive(is.read_bytes()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.end_value = ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_inclusive(is.read_bytes()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.end_value = ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_exclusive(is.read_bytes()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.start_value {
            match v {
                &ValueRange_oneof_start_value::start_value_inclusive(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(1, &v);
                },
                &ValueRange_oneof_start_value::start_value_exclusive(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.end_value {
            match v {
                &ValueRange_oneof_end_value::end_value_inclusive(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(3, &v);
                },
                &ValueRange_oneof_end_value::end_value_exclusive(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(4, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.start_value {
            match v {
                &ValueRange_oneof_start_value::start_value_inclusive(ref v) => {
                    os.write_bytes(1, v)?;
                },
                &ValueRange_oneof_start_value::start_value_exclusive(ref v) => {
                    os.write_bytes(2, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.end_value {
            match v {
                &ValueRange_oneof_end_value::end_value_inclusive(ref v) => {
                    os.write_bytes(3, v)?;
                },
                &ValueRange_oneof_end_value::end_value_exclusive(ref v) => {
                    os.write_bytes(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ValueRange {
        ValueRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "start_value_inclusive",
                ValueRange::has_start_value_inclusive,
                ValueRange::get_start_value_inclusive,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "start_value_exclusive",
                ValueRange::has_start_value_exclusive,
                ValueRange::get_start_value_exclusive,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "end_value_inclusive",
                ValueRange::has_end_value_inclusive,
                ValueRange::get_end_value_inclusive,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "end_value_exclusive",
                ValueRange::has_end_value_exclusive,
                ValueRange::get_end_value_exclusive,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ValueRange>(
                "ValueRange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ValueRange {
        static instance: ::protobuf::rt::LazyV2<ValueRange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ValueRange::new)
    }
}

impl ::protobuf::Clear for ValueRange {
    fn clear(&mut self) {
        self.start_value = ::std::option::Option::None;
        self.start_value = ::std::option::Option::None;
        self.end_value = ::std::option::Option::None;
        self.end_value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ValueRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValueRange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RowFilter {
    // message oneof groups
    pub filter: ::std::option::Option<RowFilter_oneof_filter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RowFilter {
    fn default() -> &'a RowFilter {
        <RowFilter as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RowFilter_oneof_filter {
    chain(RowFilter_Chain),
    interleave(RowFilter_Interleave),
    condition(RowFilter_Condition),
    sink(bool),
    pass_all_filter(bool),
    block_all_filter(bool),
    row_key_regex_filter(::std::vec::Vec<u8>),
    row_sample_filter(f64),
    family_name_regex_filter(::std::string::String),
    column_qualifier_regex_filter(::std::vec::Vec<u8>),
    column_range_filter(ColumnRange),
    timestamp_range_filter(TimestampRange),
    value_regex_filter(::std::vec::Vec<u8>),
    value_range_filter(ValueRange),
    cells_per_row_offset_filter(i32),
    cells_per_row_limit_filter(i32),
    cells_per_column_limit_filter(i32),
    strip_value_transformer(bool),
    apply_label_transformer(::std::string::String),
}

impl RowFilter {
    pub fn new() -> RowFilter {
        ::std::default::Default::default()
    }

    // .google.bigtable.v1.RowFilter.Chain chain = 1;


    pub fn get_chain(&self) -> &RowFilter_Chain {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::chain(ref v)) => v,
            _ => <RowFilter_Chain as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_chain(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_chain(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::chain(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chain(&mut self, v: RowFilter_Chain) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::chain(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chain(&mut self) -> &mut RowFilter_Chain {
        if let ::std::option::Option::Some(RowFilter_oneof_filter::chain(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::chain(RowFilter_Chain::new()));
        }
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::chain(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chain(&mut self) -> RowFilter_Chain {
        if self.has_chain() {
            match self.filter.take() {
                ::std::option::Option::Some(RowFilter_oneof_filter::chain(v)) => v,
                _ => panic!(),
            }
        } else {
            RowFilter_Chain::new()
        }
    }

    // .google.bigtable.v1.RowFilter.Interleave interleave = 2;


    pub fn get_interleave(&self) -> &RowFilter_Interleave {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::interleave(ref v)) => v,
            _ => <RowFilter_Interleave as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_interleave(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_interleave(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::interleave(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_interleave(&mut self, v: RowFilter_Interleave) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::interleave(v))
    }

    // Mutable pointer to the field.
    pub fn mut_interleave(&mut self) -> &mut RowFilter_Interleave {
        if let ::std::option::Option::Some(RowFilter_oneof_filter::interleave(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::interleave(RowFilter_Interleave::new()));
        }
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::interleave(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_interleave(&mut self) -> RowFilter_Interleave {
        if self.has_interleave() {
            match self.filter.take() {
                ::std::option::Option::Some(RowFilter_oneof_filter::interleave(v)) => v,
                _ => panic!(),
            }
        } else {
            RowFilter_Interleave::new()
        }
    }

    // .google.bigtable.v1.RowFilter.Condition condition = 3;


    pub fn get_condition(&self) -> &RowFilter_Condition {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::condition(ref v)) => v,
            _ => <RowFilter_Condition as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_condition(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_condition(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::condition(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_condition(&mut self, v: RowFilter_Condition) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::condition(v))
    }

    // Mutable pointer to the field.
    pub fn mut_condition(&mut self) -> &mut RowFilter_Condition {
        if let ::std::option::Option::Some(RowFilter_oneof_filter::condition(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::condition(RowFilter_Condition::new()));
        }
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::condition(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_condition(&mut self) -> RowFilter_Condition {
        if self.has_condition() {
            match self.filter.take() {
                ::std::option::Option::Some(RowFilter_oneof_filter::condition(v)) => v,
                _ => panic!(),
            }
        } else {
            RowFilter_Condition::new()
        }
    }

    // bool sink = 16;


    pub fn get_sink(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::sink(v)) => v,
            _ => false,
        }
    }
    pub fn clear_sink(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_sink(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::sink(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sink(&mut self, v: bool) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::sink(v))
    }

    // bool pass_all_filter = 17;


    pub fn get_pass_all_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::pass_all_filter(v)) => v,
            _ => false,
        }
    }
    pub fn clear_pass_all_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_pass_all_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::pass_all_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pass_all_filter(&mut self, v: bool) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::pass_all_filter(v))
    }

    // bool block_all_filter = 18;


    pub fn get_block_all_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::block_all_filter(v)) => v,
            _ => false,
        }
    }
    pub fn clear_block_all_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_block_all_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::block_all_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_block_all_filter(&mut self, v: bool) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::block_all_filter(v))
    }

    // bytes row_key_regex_filter = 4;


    pub fn get_row_key_regex_filter(&self) -> &[u8] {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::row_key_regex_filter(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_row_key_regex_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_row_key_regex_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::row_key_regex_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_row_key_regex_filter(&mut self, v: ::std::vec::Vec<u8>) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::row_key_regex_filter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_row_key_regex_filter(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(RowFilter_oneof_filter::row_key_regex_filter(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::row_key_regex_filter(::std::vec::Vec::new()));
        }
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::row_key_regex_filter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_row_key_regex_filter(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_row_key_regex_filter() {
            match self.filter.take() {
                ::std::option::Option::Some(RowFilter_oneof_filter::row_key_regex_filter(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // double row_sample_filter = 14;


    pub fn get_row_sample_filter(&self) -> f64 {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::row_sample_filter(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_row_sample_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_row_sample_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::row_sample_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_row_sample_filter(&mut self, v: f64) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::row_sample_filter(v))
    }

    // string family_name_regex_filter = 5;


    pub fn get_family_name_regex_filter(&self) -> &str {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::family_name_regex_filter(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_family_name_regex_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_family_name_regex_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::family_name_regex_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_family_name_regex_filter(&mut self, v: ::std::string::String) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::family_name_regex_filter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_family_name_regex_filter(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RowFilter_oneof_filter::family_name_regex_filter(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::family_name_regex_filter(::std::string::String::new()));
        }
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::family_name_regex_filter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_family_name_regex_filter(&mut self) -> ::std::string::String {
        if self.has_family_name_regex_filter() {
            match self.filter.take() {
                ::std::option::Option::Some(RowFilter_oneof_filter::family_name_regex_filter(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // bytes column_qualifier_regex_filter = 6;


    pub fn get_column_qualifier_regex_filter(&self) -> &[u8] {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::column_qualifier_regex_filter(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_column_qualifier_regex_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_column_qualifier_regex_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::column_qualifier_regex_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_column_qualifier_regex_filter(&mut self, v: ::std::vec::Vec<u8>) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::column_qualifier_regex_filter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_column_qualifier_regex_filter(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(RowFilter_oneof_filter::column_qualifier_regex_filter(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::column_qualifier_regex_filter(::std::vec::Vec::new()));
        }
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::column_qualifier_regex_filter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_column_qualifier_regex_filter(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_column_qualifier_regex_filter() {
            match self.filter.take() {
                ::std::option::Option::Some(RowFilter_oneof_filter::column_qualifier_regex_filter(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // .google.bigtable.v1.ColumnRange column_range_filter = 7;


    pub fn get_column_range_filter(&self) -> &ColumnRange {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::column_range_filter(ref v)) => v,
            _ => <ColumnRange as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_column_range_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_column_range_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::column_range_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_column_range_filter(&mut self, v: ColumnRange) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::column_range_filter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_column_range_filter(&mut self) -> &mut ColumnRange {
        if let ::std::option::Option::Some(RowFilter_oneof_filter::column_range_filter(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::column_range_filter(ColumnRange::new()));
        }
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::column_range_filter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_column_range_filter(&mut self) -> ColumnRange {
        if self.has_column_range_filter() {
            match self.filter.take() {
                ::std::option::Option::Some(RowFilter_oneof_filter::column_range_filter(v)) => v,
                _ => panic!(),
            }
        } else {
            ColumnRange::new()
        }
    }

    // .google.bigtable.v1.TimestampRange timestamp_range_filter = 8;


    pub fn get_timestamp_range_filter(&self) -> &TimestampRange {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::timestamp_range_filter(ref v)) => v,
            _ => <TimestampRange as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_timestamp_range_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_timestamp_range_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::timestamp_range_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_timestamp_range_filter(&mut self, v: TimestampRange) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::timestamp_range_filter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_timestamp_range_filter(&mut self) -> &mut TimestampRange {
        if let ::std::option::Option::Some(RowFilter_oneof_filter::timestamp_range_filter(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::timestamp_range_filter(TimestampRange::new()));
        }
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::timestamp_range_filter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_timestamp_range_filter(&mut self) -> TimestampRange {
        if self.has_timestamp_range_filter() {
            match self.filter.take() {
                ::std::option::Option::Some(RowFilter_oneof_filter::timestamp_range_filter(v)) => v,
                _ => panic!(),
            }
        } else {
            TimestampRange::new()
        }
    }

    // bytes value_regex_filter = 9;


    pub fn get_value_regex_filter(&self) -> &[u8] {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::value_regex_filter(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_value_regex_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_value_regex_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::value_regex_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_value_regex_filter(&mut self, v: ::std::vec::Vec<u8>) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::value_regex_filter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_value_regex_filter(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(RowFilter_oneof_filter::value_regex_filter(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::value_regex_filter(::std::vec::Vec::new()));
        }
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::value_regex_filter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_value_regex_filter(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_value_regex_filter() {
            match self.filter.take() {
                ::std::option::Option::Some(RowFilter_oneof_filter::value_regex_filter(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // .google.bigtable.v1.ValueRange value_range_filter = 15;


    pub fn get_value_range_filter(&self) -> &ValueRange {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::value_range_filter(ref v)) => v,
            _ => <ValueRange as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_value_range_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_value_range_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::value_range_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_value_range_filter(&mut self, v: ValueRange) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::value_range_filter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_value_range_filter(&mut self) -> &mut ValueRange {
        if let ::std::option::Option::Some(RowFilter_oneof_filter::value_range_filter(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::value_range_filter(ValueRange::new()));
        }
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::value_range_filter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_value_range_filter(&mut self) -> ValueRange {
        if self.has_value_range_filter() {
            match self.filter.take() {
                ::std::option::Option::Some(RowFilter_oneof_filter::value_range_filter(v)) => v,
                _ => panic!(),
            }
        } else {
            ValueRange::new()
        }
    }

    // int32 cells_per_row_offset_filter = 10;


    pub fn get_cells_per_row_offset_filter(&self) -> i32 {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::cells_per_row_offset_filter(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_cells_per_row_offset_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_cells_per_row_offset_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::cells_per_row_offset_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cells_per_row_offset_filter(&mut self, v: i32) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::cells_per_row_offset_filter(v))
    }

    // int32 cells_per_row_limit_filter = 11;


    pub fn get_cells_per_row_limit_filter(&self) -> i32 {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::cells_per_row_limit_filter(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_cells_per_row_limit_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_cells_per_row_limit_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::cells_per_row_limit_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cells_per_row_limit_filter(&mut self, v: i32) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::cells_per_row_limit_filter(v))
    }

    // int32 cells_per_column_limit_filter = 12;


    pub fn get_cells_per_column_limit_filter(&self) -> i32 {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::cells_per_column_limit_filter(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_cells_per_column_limit_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_cells_per_column_limit_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::cells_per_column_limit_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cells_per_column_limit_filter(&mut self, v: i32) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::cells_per_column_limit_filter(v))
    }

    // bool strip_value_transformer = 13;


    pub fn get_strip_value_transformer(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::strip_value_transformer(v)) => v,
            _ => false,
        }
    }
    pub fn clear_strip_value_transformer(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_strip_value_transformer(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::strip_value_transformer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_strip_value_transformer(&mut self, v: bool) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::strip_value_transformer(v))
    }

    // string apply_label_transformer = 19;


    pub fn get_apply_label_transformer(&self) -> &str {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::apply_label_transformer(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_apply_label_transformer(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_apply_label_transformer(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::apply_label_transformer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_apply_label_transformer(&mut self, v: ::std::string::String) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::apply_label_transformer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_apply_label_transformer(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RowFilter_oneof_filter::apply_label_transformer(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::apply_label_transformer(::std::string::String::new()));
        }
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::apply_label_transformer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_apply_label_transformer(&mut self) -> ::std::string::String {
        if self.has_apply_label_transformer() {
            match self.filter.take() {
                ::std::option::Option::Some(RowFilter_oneof_filter::apply_label_transformer(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for RowFilter {
    fn is_initialized(&self) -> bool {
        if let Some(RowFilter_oneof_filter::chain(ref v)) = self.filter {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RowFilter_oneof_filter::interleave(ref v)) = self.filter {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RowFilter_oneof_filter::condition(ref v)) = self.filter {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RowFilter_oneof_filter::column_range_filter(ref v)) = self.filter {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RowFilter_oneof_filter::timestamp_range_filter(ref v)) = self.filter {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RowFilter_oneof_filter::value_range_filter(ref v)) = self.filter {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::chain(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::interleave(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::condition(is.read_message()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::sink(is.read_bool()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::pass_all_filter(is.read_bool()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::block_all_filter(is.read_bool()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::row_key_regex_filter(is.read_bytes()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::row_sample_filter(is.read_double()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::family_name_regex_filter(is.read_string()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::column_qualifier_regex_filter(is.read_bytes()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::column_range_filter(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::timestamp_range_filter(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::value_regex_filter(is.read_bytes()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::value_range_filter(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::cells_per_row_offset_filter(is.read_int32()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::cells_per_row_limit_filter(is.read_int32()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::cells_per_column_limit_filter(is.read_int32()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::strip_value_transformer(is.read_bool()?));
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::apply_label_transformer(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.filter {
            match v {
                &RowFilter_oneof_filter::chain(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RowFilter_oneof_filter::interleave(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RowFilter_oneof_filter::condition(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RowFilter_oneof_filter::sink(v) => {
                    my_size += 3;
                },
                &RowFilter_oneof_filter::pass_all_filter(v) => {
                    my_size += 3;
                },
                &RowFilter_oneof_filter::block_all_filter(v) => {
                    my_size += 3;
                },
                &RowFilter_oneof_filter::row_key_regex_filter(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(4, &v);
                },
                &RowFilter_oneof_filter::row_sample_filter(v) => {
                    my_size += 9;
                },
                &RowFilter_oneof_filter::family_name_regex_filter(ref v) => {
                    my_size += ::protobuf::rt::string_size(5, &v);
                },
                &RowFilter_oneof_filter::column_qualifier_regex_filter(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(6, &v);
                },
                &RowFilter_oneof_filter::column_range_filter(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RowFilter_oneof_filter::timestamp_range_filter(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RowFilter_oneof_filter::value_regex_filter(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(9, &v);
                },
                &RowFilter_oneof_filter::value_range_filter(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RowFilter_oneof_filter::cells_per_row_offset_filter(v) => {
                    my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &RowFilter_oneof_filter::cells_per_row_limit_filter(v) => {
                    my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &RowFilter_oneof_filter::cells_per_column_limit_filter(v) => {
                    my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &RowFilter_oneof_filter::strip_value_transformer(v) => {
                    my_size += 2;
                },
                &RowFilter_oneof_filter::apply_label_transformer(ref v) => {
                    my_size += ::protobuf::rt::string_size(19, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.filter {
            match v {
                &RowFilter_oneof_filter::chain(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RowFilter_oneof_filter::interleave(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RowFilter_oneof_filter::condition(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RowFilter_oneof_filter::sink(v) => {
                    os.write_bool(16, v)?;
                },
                &RowFilter_oneof_filter::pass_all_filter(v) => {
                    os.write_bool(17, v)?;
                },
                &RowFilter_oneof_filter::block_all_filter(v) => {
                    os.write_bool(18, v)?;
                },
                &RowFilter_oneof_filter::row_key_regex_filter(ref v) => {
                    os.write_bytes(4, v)?;
                },
                &RowFilter_oneof_filter::row_sample_filter(v) => {
                    os.write_double(14, v)?;
                },
                &RowFilter_oneof_filter::family_name_regex_filter(ref v) => {
                    os.write_string(5, v)?;
                },
                &RowFilter_oneof_filter::column_qualifier_regex_filter(ref v) => {
                    os.write_bytes(6, v)?;
                },
                &RowFilter_oneof_filter::column_range_filter(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RowFilter_oneof_filter::timestamp_range_filter(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RowFilter_oneof_filter::value_regex_filter(ref v) => {
                    os.write_bytes(9, v)?;
                },
                &RowFilter_oneof_filter::value_range_filter(ref v) => {
                    os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RowFilter_oneof_filter::cells_per_row_offset_filter(v) => {
                    os.write_int32(10, v)?;
                },
                &RowFilter_oneof_filter::cells_per_row_limit_filter(v) => {
                    os.write_int32(11, v)?;
                },
                &RowFilter_oneof_filter::cells_per_column_limit_filter(v) => {
                    os.write_int32(12, v)?;
                },
                &RowFilter_oneof_filter::strip_value_transformer(v) => {
                    os.write_bool(13, v)?;
                },
                &RowFilter_oneof_filter::apply_label_transformer(ref v) => {
                    os.write_string(19, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RowFilter {
        RowFilter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RowFilter_Chain>(
                "chain",
                RowFilter::has_chain,
                RowFilter::get_chain,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RowFilter_Interleave>(
                "interleave",
                RowFilter::has_interleave,
                RowFilter::get_interleave,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RowFilter_Condition>(
                "condition",
                RowFilter::has_condition,
                RowFilter::get_condition,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "sink",
                RowFilter::has_sink,
                RowFilter::get_sink,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "pass_all_filter",
                RowFilter::has_pass_all_filter,
                RowFilter::get_pass_all_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "block_all_filter",
                RowFilter::has_block_all_filter,
                RowFilter::get_block_all_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "row_key_regex_filter",
                RowFilter::has_row_key_regex_filter,
                RowFilter::get_row_key_regex_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor::<_>(
                "row_sample_filter",
                RowFilter::has_row_sample_filter,
                RowFilter::get_row_sample_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "family_name_regex_filter",
                RowFilter::has_family_name_regex_filter,
                RowFilter::get_family_name_regex_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "column_qualifier_regex_filter",
                RowFilter::has_column_qualifier_regex_filter,
                RowFilter::get_column_qualifier_regex_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ColumnRange>(
                "column_range_filter",
                RowFilter::has_column_range_filter,
                RowFilter::get_column_range_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TimestampRange>(
                "timestamp_range_filter",
                RowFilter::has_timestamp_range_filter,
                RowFilter::get_timestamp_range_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "value_regex_filter",
                RowFilter::has_value_regex_filter,
                RowFilter::get_value_regex_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ValueRange>(
                "value_range_filter",
                RowFilter::has_value_range_filter,
                RowFilter::get_value_range_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                "cells_per_row_offset_filter",
                RowFilter::has_cells_per_row_offset_filter,
                RowFilter::get_cells_per_row_offset_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                "cells_per_row_limit_filter",
                RowFilter::has_cells_per_row_limit_filter,
                RowFilter::get_cells_per_row_limit_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                "cells_per_column_limit_filter",
                RowFilter::has_cells_per_column_limit_filter,
                RowFilter::get_cells_per_column_limit_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "strip_value_transformer",
                RowFilter::has_strip_value_transformer,
                RowFilter::get_strip_value_transformer,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "apply_label_transformer",
                RowFilter::has_apply_label_transformer,
                RowFilter::get_apply_label_transformer,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RowFilter>(
                "RowFilter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RowFilter {
        static instance: ::protobuf::rt::LazyV2<RowFilter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RowFilter::new)
    }
}

impl ::protobuf::Clear for RowFilter {
    fn clear(&mut self) {
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RowFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RowFilter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RowFilter_Chain {
    // message fields
    pub filters: ::protobuf::RepeatedField<RowFilter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RowFilter_Chain {
    fn default() -> &'a RowFilter_Chain {
        <RowFilter_Chain as ::protobuf::Message>::default_instance()
    }
}

impl RowFilter_Chain {
    pub fn new() -> RowFilter_Chain {
        ::std::default::Default::default()
    }

    // repeated .google.bigtable.v1.RowFilter filters = 1;


    pub fn get_filters(&self) -> &[RowFilter] {
        &self.filters
    }
    pub fn clear_filters(&mut self) {
        self.filters.clear();
    }

    // Param is passed by value, moved
    pub fn set_filters(&mut self, v: ::protobuf::RepeatedField<RowFilter>) {
        self.filters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_filters(&mut self) -> &mut ::protobuf::RepeatedField<RowFilter> {
        &mut self.filters
    }

    // Take field
    pub fn take_filters(&mut self) -> ::protobuf::RepeatedField<RowFilter> {
        ::std::mem::replace(&mut self.filters, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RowFilter_Chain {
    fn is_initialized(&self) -> bool {
        for v in &self.filters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.filters)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.filters {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RowFilter_Chain {
        RowFilter_Chain::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RowFilter>>(
                "filters",
                |m: &RowFilter_Chain| { &m.filters },
                |m: &mut RowFilter_Chain| { &mut m.filters },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RowFilter_Chain>(
                "RowFilter.Chain",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RowFilter_Chain {
        static instance: ::protobuf::rt::LazyV2<RowFilter_Chain> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RowFilter_Chain::new)
    }
}

impl ::protobuf::Clear for RowFilter_Chain {
    fn clear(&mut self) {
        self.filters.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RowFilter_Chain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RowFilter_Chain {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RowFilter_Interleave {
    // message fields
    pub filters: ::protobuf::RepeatedField<RowFilter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RowFilter_Interleave {
    fn default() -> &'a RowFilter_Interleave {
        <RowFilter_Interleave as ::protobuf::Message>::default_instance()
    }
}

impl RowFilter_Interleave {
    pub fn new() -> RowFilter_Interleave {
        ::std::default::Default::default()
    }

    // repeated .google.bigtable.v1.RowFilter filters = 1;


    pub fn get_filters(&self) -> &[RowFilter] {
        &self.filters
    }
    pub fn clear_filters(&mut self) {
        self.filters.clear();
    }

    // Param is passed by value, moved
    pub fn set_filters(&mut self, v: ::protobuf::RepeatedField<RowFilter>) {
        self.filters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_filters(&mut self) -> &mut ::protobuf::RepeatedField<RowFilter> {
        &mut self.filters
    }

    // Take field
    pub fn take_filters(&mut self) -> ::protobuf::RepeatedField<RowFilter> {
        ::std::mem::replace(&mut self.filters, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RowFilter_Interleave {
    fn is_initialized(&self) -> bool {
        for v in &self.filters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.filters)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.filters {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RowFilter_Interleave {
        RowFilter_Interleave::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RowFilter>>(
                "filters",
                |m: &RowFilter_Interleave| { &m.filters },
                |m: &mut RowFilter_Interleave| { &mut m.filters },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RowFilter_Interleave>(
                "RowFilter.Interleave",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RowFilter_Interleave {
        static instance: ::protobuf::rt::LazyV2<RowFilter_Interleave> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RowFilter_Interleave::new)
    }
}

impl ::protobuf::Clear for RowFilter_Interleave {
    fn clear(&mut self) {
        self.filters.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RowFilter_Interleave {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RowFilter_Interleave {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RowFilter_Condition {
    // message fields
    pub predicate_filter: ::protobuf::SingularPtrField<RowFilter>,
    pub true_filter: ::protobuf::SingularPtrField<RowFilter>,
    pub false_filter: ::protobuf::SingularPtrField<RowFilter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RowFilter_Condition {
    fn default() -> &'a RowFilter_Condition {
        <RowFilter_Condition as ::protobuf::Message>::default_instance()
    }
}

impl RowFilter_Condition {
    pub fn new() -> RowFilter_Condition {
        ::std::default::Default::default()
    }

    // .google.bigtable.v1.RowFilter predicate_filter = 1;


    pub fn get_predicate_filter(&self) -> &RowFilter {
        self.predicate_filter.as_ref().unwrap_or_else(|| <RowFilter as ::protobuf::Message>::default_instance())
    }
    pub fn clear_predicate_filter(&mut self) {
        self.predicate_filter.clear();
    }

    pub fn has_predicate_filter(&self) -> bool {
        self.predicate_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_predicate_filter(&mut self, v: RowFilter) {
        self.predicate_filter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_predicate_filter(&mut self) -> &mut RowFilter {
        if self.predicate_filter.is_none() {
            self.predicate_filter.set_default();
        }
        self.predicate_filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_predicate_filter(&mut self) -> RowFilter {
        self.predicate_filter.take().unwrap_or_else(|| RowFilter::new())
    }

    // .google.bigtable.v1.RowFilter true_filter = 2;


    pub fn get_true_filter(&self) -> &RowFilter {
        self.true_filter.as_ref().unwrap_or_else(|| <RowFilter as ::protobuf::Message>::default_instance())
    }
    pub fn clear_true_filter(&mut self) {
        self.true_filter.clear();
    }

    pub fn has_true_filter(&self) -> bool {
        self.true_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_true_filter(&mut self, v: RowFilter) {
        self.true_filter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_true_filter(&mut self) -> &mut RowFilter {
        if self.true_filter.is_none() {
            self.true_filter.set_default();
        }
        self.true_filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_true_filter(&mut self) -> RowFilter {
        self.true_filter.take().unwrap_or_else(|| RowFilter::new())
    }

    // .google.bigtable.v1.RowFilter false_filter = 3;


    pub fn get_false_filter(&self) -> &RowFilter {
        self.false_filter.as_ref().unwrap_or_else(|| <RowFilter as ::protobuf::Message>::default_instance())
    }
    pub fn clear_false_filter(&mut self) {
        self.false_filter.clear();
    }

    pub fn has_false_filter(&self) -> bool {
        self.false_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_false_filter(&mut self, v: RowFilter) {
        self.false_filter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_false_filter(&mut self) -> &mut RowFilter {
        if self.false_filter.is_none() {
            self.false_filter.set_default();
        }
        self.false_filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_false_filter(&mut self) -> RowFilter {
        self.false_filter.take().unwrap_or_else(|| RowFilter::new())
    }
}

impl ::protobuf::Message for RowFilter_Condition {
    fn is_initialized(&self) -> bool {
        for v in &self.predicate_filter {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.true_filter {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.false_filter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.predicate_filter)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.true_filter)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.false_filter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.predicate_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.true_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.false_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.predicate_filter.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.true_filter.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.false_filter.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RowFilter_Condition {
        RowFilter_Condition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RowFilter>>(
                "predicate_filter",
                |m: &RowFilter_Condition| { &m.predicate_filter },
                |m: &mut RowFilter_Condition| { &mut m.predicate_filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RowFilter>>(
                "true_filter",
                |m: &RowFilter_Condition| { &m.true_filter },
                |m: &mut RowFilter_Condition| { &mut m.true_filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RowFilter>>(
                "false_filter",
                |m: &RowFilter_Condition| { &m.false_filter },
                |m: &mut RowFilter_Condition| { &mut m.false_filter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RowFilter_Condition>(
                "RowFilter.Condition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RowFilter_Condition {
        static instance: ::protobuf::rt::LazyV2<RowFilter_Condition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RowFilter_Condition::new)
    }
}

impl ::protobuf::Clear for RowFilter_Condition {
    fn clear(&mut self) {
        self.predicate_filter.clear();
        self.true_filter.clear();
        self.false_filter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RowFilter_Condition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RowFilter_Condition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Mutation {
    // message oneof groups
    pub mutation: ::std::option::Option<Mutation_oneof_mutation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Mutation {
    fn default() -> &'a Mutation {
        <Mutation as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Mutation_oneof_mutation {
    set_cell(Mutation_SetCell),
    delete_from_column(Mutation_DeleteFromColumn),
    delete_from_family(Mutation_DeleteFromFamily),
    delete_from_row(Mutation_DeleteFromRow),
}

impl Mutation {
    pub fn new() -> Mutation {
        ::std::default::Default::default()
    }

    // .google.bigtable.v1.Mutation.SetCell set_cell = 1;


    pub fn get_set_cell(&self) -> &Mutation_SetCell {
        match self.mutation {
            ::std::option::Option::Some(Mutation_oneof_mutation::set_cell(ref v)) => v,
            _ => <Mutation_SetCell as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_set_cell(&mut self) {
        self.mutation = ::std::option::Option::None;
    }

    pub fn has_set_cell(&self) -> bool {
        match self.mutation {
            ::std::option::Option::Some(Mutation_oneof_mutation::set_cell(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_cell(&mut self, v: Mutation_SetCell) {
        self.mutation = ::std::option::Option::Some(Mutation_oneof_mutation::set_cell(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_cell(&mut self) -> &mut Mutation_SetCell {
        if let ::std::option::Option::Some(Mutation_oneof_mutation::set_cell(_)) = self.mutation {
        } else {
            self.mutation = ::std::option::Option::Some(Mutation_oneof_mutation::set_cell(Mutation_SetCell::new()));
        }
        match self.mutation {
            ::std::option::Option::Some(Mutation_oneof_mutation::set_cell(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_cell(&mut self) -> Mutation_SetCell {
        if self.has_set_cell() {
            match self.mutation.take() {
                ::std::option::Option::Some(Mutation_oneof_mutation::set_cell(v)) => v,
                _ => panic!(),
            }
        } else {
            Mutation_SetCell::new()
        }
    }

    // .google.bigtable.v1.Mutation.DeleteFromColumn delete_from_column = 2;


    pub fn get_delete_from_column(&self) -> &Mutation_DeleteFromColumn {
        match self.mutation {
            ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_column(ref v)) => v,
            _ => <Mutation_DeleteFromColumn as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_delete_from_column(&mut self) {
        self.mutation = ::std::option::Option::None;
    }

    pub fn has_delete_from_column(&self) -> bool {
        match self.mutation {
            ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_column(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delete_from_column(&mut self, v: Mutation_DeleteFromColumn) {
        self.mutation = ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_column(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delete_from_column(&mut self) -> &mut Mutation_DeleteFromColumn {
        if let ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_column(_)) = self.mutation {
        } else {
            self.mutation = ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_column(Mutation_DeleteFromColumn::new()));
        }
        match self.mutation {
            ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_column(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delete_from_column(&mut self) -> Mutation_DeleteFromColumn {
        if self.has_delete_from_column() {
            match self.mutation.take() {
                ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_column(v)) => v,
                _ => panic!(),
            }
        } else {
            Mutation_DeleteFromColumn::new()
        }
    }

    // .google.bigtable.v1.Mutation.DeleteFromFamily delete_from_family = 3;


    pub fn get_delete_from_family(&self) -> &Mutation_DeleteFromFamily {
        match self.mutation {
            ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_family(ref v)) => v,
            _ => <Mutation_DeleteFromFamily as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_delete_from_family(&mut self) {
        self.mutation = ::std::option::Option::None;
    }

    pub fn has_delete_from_family(&self) -> bool {
        match self.mutation {
            ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_family(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delete_from_family(&mut self, v: Mutation_DeleteFromFamily) {
        self.mutation = ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_family(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delete_from_family(&mut self) -> &mut Mutation_DeleteFromFamily {
        if let ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_family(_)) = self.mutation {
        } else {
            self.mutation = ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_family(Mutation_DeleteFromFamily::new()));
        }
        match self.mutation {
            ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_family(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delete_from_family(&mut self) -> Mutation_DeleteFromFamily {
        if self.has_delete_from_family() {
            match self.mutation.take() {
                ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_family(v)) => v,
                _ => panic!(),
            }
        } else {
            Mutation_DeleteFromFamily::new()
        }
    }

    // .google.bigtable.v1.Mutation.DeleteFromRow delete_from_row = 4;


    pub fn get_delete_from_row(&self) -> &Mutation_DeleteFromRow {
        match self.mutation {
            ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_row(ref v)) => v,
            _ => <Mutation_DeleteFromRow as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_delete_from_row(&mut self) {
        self.mutation = ::std::option::Option::None;
    }

    pub fn has_delete_from_row(&self) -> bool {
        match self.mutation {
            ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_row(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delete_from_row(&mut self, v: Mutation_DeleteFromRow) {
        self.mutation = ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_row(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delete_from_row(&mut self) -> &mut Mutation_DeleteFromRow {
        if let ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_row(_)) = self.mutation {
        } else {
            self.mutation = ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_row(Mutation_DeleteFromRow::new()));
        }
        match self.mutation {
            ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_row(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delete_from_row(&mut self) -> Mutation_DeleteFromRow {
        if self.has_delete_from_row() {
            match self.mutation.take() {
                ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_row(v)) => v,
                _ => panic!(),
            }
        } else {
            Mutation_DeleteFromRow::new()
        }
    }
}

impl ::protobuf::Message for Mutation {
    fn is_initialized(&self) -> bool {
        if let Some(Mutation_oneof_mutation::set_cell(ref v)) = self.mutation {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Mutation_oneof_mutation::delete_from_column(ref v)) = self.mutation {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Mutation_oneof_mutation::delete_from_family(ref v)) = self.mutation {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Mutation_oneof_mutation::delete_from_row(ref v)) = self.mutation {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mutation = ::std::option::Option::Some(Mutation_oneof_mutation::set_cell(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mutation = ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_column(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mutation = ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_family(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mutation = ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_row(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.mutation {
            match v {
                &Mutation_oneof_mutation::set_cell(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Mutation_oneof_mutation::delete_from_column(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Mutation_oneof_mutation::delete_from_family(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Mutation_oneof_mutation::delete_from_row(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.mutation {
            match v {
                &Mutation_oneof_mutation::set_cell(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Mutation_oneof_mutation::delete_from_column(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Mutation_oneof_mutation::delete_from_family(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Mutation_oneof_mutation::delete_from_row(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Mutation {
        Mutation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Mutation_SetCell>(
                "set_cell",
                Mutation::has_set_cell,
                Mutation::get_set_cell,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Mutation_DeleteFromColumn>(
                "delete_from_column",
                Mutation::has_delete_from_column,
                Mutation::get_delete_from_column,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Mutation_DeleteFromFamily>(
                "delete_from_family",
                Mutation::has_delete_from_family,
                Mutation::get_delete_from_family,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Mutation_DeleteFromRow>(
                "delete_from_row",
                Mutation::has_delete_from_row,
                Mutation::get_delete_from_row,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Mutation>(
                "Mutation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Mutation {
        static instance: ::protobuf::rt::LazyV2<Mutation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Mutation::new)
    }
}

impl ::protobuf::Clear for Mutation {
    fn clear(&mut self) {
        self.mutation = ::std::option::Option::None;
        self.mutation = ::std::option::Option::None;
        self.mutation = ::std::option::Option::None;
        self.mutation = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Mutation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Mutation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Mutation_SetCell {
    // message fields
    pub family_name: ::std::string::String,
    pub column_qualifier: ::std::vec::Vec<u8>,
    pub timestamp_micros: i64,
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Mutation_SetCell {
    fn default() -> &'a Mutation_SetCell {
        <Mutation_SetCell as ::protobuf::Message>::default_instance()
    }
}

impl Mutation_SetCell {
    pub fn new() -> Mutation_SetCell {
        ::std::default::Default::default()
    }

    // string family_name = 1;


    pub fn get_family_name(&self) -> &str {
        &self.family_name
    }
    pub fn clear_family_name(&mut self) {
        self.family_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_family_name(&mut self, v: ::std::string::String) {
        self.family_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_family_name(&mut self) -> &mut ::std::string::String {
        &mut self.family_name
    }

    // Take field
    pub fn take_family_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.family_name, ::std::string::String::new())
    }

    // bytes column_qualifier = 2;


    pub fn get_column_qualifier(&self) -> &[u8] {
        &self.column_qualifier
    }
    pub fn clear_column_qualifier(&mut self) {
        self.column_qualifier.clear();
    }

    // Param is passed by value, moved
    pub fn set_column_qualifier(&mut self, v: ::std::vec::Vec<u8>) {
        self.column_qualifier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_column_qualifier(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.column_qualifier
    }

    // Take field
    pub fn take_column_qualifier(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.column_qualifier, ::std::vec::Vec::new())
    }

    // int64 timestamp_micros = 3;


    pub fn get_timestamp_micros(&self) -> i64 {
        self.timestamp_micros
    }
    pub fn clear_timestamp_micros(&mut self) {
        self.timestamp_micros = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp_micros(&mut self, v: i64) {
        self.timestamp_micros = v;
    }

    // bytes value = 4;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Mutation_SetCell {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.family_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.column_qualifier)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp_micros = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.family_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.family_name);
        }
        if !self.column_qualifier.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.column_qualifier);
        }
        if self.timestamp_micros != 0 {
            my_size += ::protobuf::rt::value_size(3, self.timestamp_micros, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.family_name.is_empty() {
            os.write_string(1, &self.family_name)?;
        }
        if !self.column_qualifier.is_empty() {
            os.write_bytes(2, &self.column_qualifier)?;
        }
        if self.timestamp_micros != 0 {
            os.write_int64(3, self.timestamp_micros)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(4, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Mutation_SetCell {
        Mutation_SetCell::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "family_name",
                |m: &Mutation_SetCell| { &m.family_name },
                |m: &mut Mutation_SetCell| { &mut m.family_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "column_qualifier",
                |m: &Mutation_SetCell| { &m.column_qualifier },
                |m: &mut Mutation_SetCell| { &mut m.column_qualifier },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp_micros",
                |m: &Mutation_SetCell| { &m.timestamp_micros },
                |m: &mut Mutation_SetCell| { &mut m.timestamp_micros },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &Mutation_SetCell| { &m.value },
                |m: &mut Mutation_SetCell| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Mutation_SetCell>(
                "Mutation.SetCell",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Mutation_SetCell {
        static instance: ::protobuf::rt::LazyV2<Mutation_SetCell> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Mutation_SetCell::new)
    }
}

impl ::protobuf::Clear for Mutation_SetCell {
    fn clear(&mut self) {
        self.family_name.clear();
        self.column_qualifier.clear();
        self.timestamp_micros = 0;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Mutation_SetCell {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Mutation_SetCell {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Mutation_DeleteFromColumn {
    // message fields
    pub family_name: ::std::string::String,
    pub column_qualifier: ::std::vec::Vec<u8>,
    pub time_range: ::protobuf::SingularPtrField<TimestampRange>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Mutation_DeleteFromColumn {
    fn default() -> &'a Mutation_DeleteFromColumn {
        <Mutation_DeleteFromColumn as ::protobuf::Message>::default_instance()
    }
}

impl Mutation_DeleteFromColumn {
    pub fn new() -> Mutation_DeleteFromColumn {
        ::std::default::Default::default()
    }

    // string family_name = 1;


    pub fn get_family_name(&self) -> &str {
        &self.family_name
    }
    pub fn clear_family_name(&mut self) {
        self.family_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_family_name(&mut self, v: ::std::string::String) {
        self.family_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_family_name(&mut self) -> &mut ::std::string::String {
        &mut self.family_name
    }

    // Take field
    pub fn take_family_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.family_name, ::std::string::String::new())
    }

    // bytes column_qualifier = 2;


    pub fn get_column_qualifier(&self) -> &[u8] {
        &self.column_qualifier
    }
    pub fn clear_column_qualifier(&mut self) {
        self.column_qualifier.clear();
    }

    // Param is passed by value, moved
    pub fn set_column_qualifier(&mut self, v: ::std::vec::Vec<u8>) {
        self.column_qualifier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_column_qualifier(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.column_qualifier
    }

    // Take field
    pub fn take_column_qualifier(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.column_qualifier, ::std::vec::Vec::new())
    }

    // .google.bigtable.v1.TimestampRange time_range = 3;


    pub fn get_time_range(&self) -> &TimestampRange {
        self.time_range.as_ref().unwrap_or_else(|| <TimestampRange as ::protobuf::Message>::default_instance())
    }
    pub fn clear_time_range(&mut self) {
        self.time_range.clear();
    }

    pub fn has_time_range(&self) -> bool {
        self.time_range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_range(&mut self, v: TimestampRange) {
        self.time_range = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time_range(&mut self) -> &mut TimestampRange {
        if self.time_range.is_none() {
            self.time_range.set_default();
        }
        self.time_range.as_mut().unwrap()
    }

    // Take field
    pub fn take_time_range(&mut self) -> TimestampRange {
        self.time_range.take().unwrap_or_else(|| TimestampRange::new())
    }
}

impl ::protobuf::Message for Mutation_DeleteFromColumn {
    fn is_initialized(&self) -> bool {
        for v in &self.time_range {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.family_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.column_qualifier)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time_range)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.family_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.family_name);
        }
        if !self.column_qualifier.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.column_qualifier);
        }
        if let Some(ref v) = self.time_range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.family_name.is_empty() {
            os.write_string(1, &self.family_name)?;
        }
        if !self.column_qualifier.is_empty() {
            os.write_bytes(2, &self.column_qualifier)?;
        }
        if let Some(ref v) = self.time_range.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Mutation_DeleteFromColumn {
        Mutation_DeleteFromColumn::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "family_name",
                |m: &Mutation_DeleteFromColumn| { &m.family_name },
                |m: &mut Mutation_DeleteFromColumn| { &mut m.family_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "column_qualifier",
                |m: &Mutation_DeleteFromColumn| { &m.column_qualifier },
                |m: &mut Mutation_DeleteFromColumn| { &mut m.column_qualifier },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimestampRange>>(
                "time_range",
                |m: &Mutation_DeleteFromColumn| { &m.time_range },
                |m: &mut Mutation_DeleteFromColumn| { &mut m.time_range },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Mutation_DeleteFromColumn>(
                "Mutation.DeleteFromColumn",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Mutation_DeleteFromColumn {
        static instance: ::protobuf::rt::LazyV2<Mutation_DeleteFromColumn> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Mutation_DeleteFromColumn::new)
    }
}

impl ::protobuf::Clear for Mutation_DeleteFromColumn {
    fn clear(&mut self) {
        self.family_name.clear();
        self.column_qualifier.clear();
        self.time_range.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Mutation_DeleteFromColumn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Mutation_DeleteFromColumn {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Mutation_DeleteFromFamily {
    // message fields
    pub family_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Mutation_DeleteFromFamily {
    fn default() -> &'a Mutation_DeleteFromFamily {
        <Mutation_DeleteFromFamily as ::protobuf::Message>::default_instance()
    }
}

impl Mutation_DeleteFromFamily {
    pub fn new() -> Mutation_DeleteFromFamily {
        ::std::default::Default::default()
    }

    // string family_name = 1;


    pub fn get_family_name(&self) -> &str {
        &self.family_name
    }
    pub fn clear_family_name(&mut self) {
        self.family_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_family_name(&mut self, v: ::std::string::String) {
        self.family_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_family_name(&mut self) -> &mut ::std::string::String {
        &mut self.family_name
    }

    // Take field
    pub fn take_family_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.family_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Mutation_DeleteFromFamily {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.family_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.family_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.family_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.family_name.is_empty() {
            os.write_string(1, &self.family_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Mutation_DeleteFromFamily {
        Mutation_DeleteFromFamily::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "family_name",
                |m: &Mutation_DeleteFromFamily| { &m.family_name },
                |m: &mut Mutation_DeleteFromFamily| { &mut m.family_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Mutation_DeleteFromFamily>(
                "Mutation.DeleteFromFamily",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Mutation_DeleteFromFamily {
        static instance: ::protobuf::rt::LazyV2<Mutation_DeleteFromFamily> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Mutation_DeleteFromFamily::new)
    }
}

impl ::protobuf::Clear for Mutation_DeleteFromFamily {
    fn clear(&mut self) {
        self.family_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Mutation_DeleteFromFamily {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Mutation_DeleteFromFamily {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Mutation_DeleteFromRow {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Mutation_DeleteFromRow {
    fn default() -> &'a Mutation_DeleteFromRow {
        <Mutation_DeleteFromRow as ::protobuf::Message>::default_instance()
    }
}

impl Mutation_DeleteFromRow {
    pub fn new() -> Mutation_DeleteFromRow {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Mutation_DeleteFromRow {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Mutation_DeleteFromRow {
        Mutation_DeleteFromRow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Mutation_DeleteFromRow>(
                "Mutation.DeleteFromRow",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Mutation_DeleteFromRow {
        static instance: ::protobuf::rt::LazyV2<Mutation_DeleteFromRow> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Mutation_DeleteFromRow::new)
    }
}

impl ::protobuf::Clear for Mutation_DeleteFromRow {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Mutation_DeleteFromRow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Mutation_DeleteFromRow {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadModifyWriteRule {
    // message fields
    pub family_name: ::std::string::String,
    pub column_qualifier: ::std::vec::Vec<u8>,
    // message oneof groups
    pub rule: ::std::option::Option<ReadModifyWriteRule_oneof_rule>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadModifyWriteRule {
    fn default() -> &'a ReadModifyWriteRule {
        <ReadModifyWriteRule as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ReadModifyWriteRule_oneof_rule {
    append_value(::std::vec::Vec<u8>),
    increment_amount(i64),
}

impl ReadModifyWriteRule {
    pub fn new() -> ReadModifyWriteRule {
        ::std::default::Default::default()
    }

    // string family_name = 1;


    pub fn get_family_name(&self) -> &str {
        &self.family_name
    }
    pub fn clear_family_name(&mut self) {
        self.family_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_family_name(&mut self, v: ::std::string::String) {
        self.family_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_family_name(&mut self) -> &mut ::std::string::String {
        &mut self.family_name
    }

    // Take field
    pub fn take_family_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.family_name, ::std::string::String::new())
    }

    // bytes column_qualifier = 2;


    pub fn get_column_qualifier(&self) -> &[u8] {
        &self.column_qualifier
    }
    pub fn clear_column_qualifier(&mut self) {
        self.column_qualifier.clear();
    }

    // Param is passed by value, moved
    pub fn set_column_qualifier(&mut self, v: ::std::vec::Vec<u8>) {
        self.column_qualifier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_column_qualifier(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.column_qualifier
    }

    // Take field
    pub fn take_column_qualifier(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.column_qualifier, ::std::vec::Vec::new())
    }

    // bytes append_value = 3;


    pub fn get_append_value(&self) -> &[u8] {
        match self.rule {
            ::std::option::Option::Some(ReadModifyWriteRule_oneof_rule::append_value(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_append_value(&mut self) {
        self.rule = ::std::option::Option::None;
    }

    pub fn has_append_value(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(ReadModifyWriteRule_oneof_rule::append_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_append_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.rule = ::std::option::Option::Some(ReadModifyWriteRule_oneof_rule::append_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_append_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(ReadModifyWriteRule_oneof_rule::append_value(_)) = self.rule {
        } else {
            self.rule = ::std::option::Option::Some(ReadModifyWriteRule_oneof_rule::append_value(::std::vec::Vec::new()));
        }
        match self.rule {
            ::std::option::Option::Some(ReadModifyWriteRule_oneof_rule::append_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_append_value(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_append_value() {
            match self.rule.take() {
                ::std::option::Option::Some(ReadModifyWriteRule_oneof_rule::append_value(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // int64 increment_amount = 4;


    pub fn get_increment_amount(&self) -> i64 {
        match self.rule {
            ::std::option::Option::Some(ReadModifyWriteRule_oneof_rule::increment_amount(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_increment_amount(&mut self) {
        self.rule = ::std::option::Option::None;
    }

    pub fn has_increment_amount(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(ReadModifyWriteRule_oneof_rule::increment_amount(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_increment_amount(&mut self, v: i64) {
        self.rule = ::std::option::Option::Some(ReadModifyWriteRule_oneof_rule::increment_amount(v))
    }
}

impl ::protobuf::Message for ReadModifyWriteRule {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.family_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.column_qualifier)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rule = ::std::option::Option::Some(ReadModifyWriteRule_oneof_rule::append_value(is.read_bytes()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rule = ::std::option::Option::Some(ReadModifyWriteRule_oneof_rule::increment_amount(is.read_int64()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.family_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.family_name);
        }
        if !self.column_qualifier.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.column_qualifier);
        }
        if let ::std::option::Option::Some(ref v) = self.rule {
            match v {
                &ReadModifyWriteRule_oneof_rule::append_value(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(3, &v);
                },
                &ReadModifyWriteRule_oneof_rule::increment_amount(v) => {
                    my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.family_name.is_empty() {
            os.write_string(1, &self.family_name)?;
        }
        if !self.column_qualifier.is_empty() {
            os.write_bytes(2, &self.column_qualifier)?;
        }
        if let ::std::option::Option::Some(ref v) = self.rule {
            match v {
                &ReadModifyWriteRule_oneof_rule::append_value(ref v) => {
                    os.write_bytes(3, v)?;
                },
                &ReadModifyWriteRule_oneof_rule::increment_amount(v) => {
                    os.write_int64(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadModifyWriteRule {
        ReadModifyWriteRule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "family_name",
                |m: &ReadModifyWriteRule| { &m.family_name },
                |m: &mut ReadModifyWriteRule| { &mut m.family_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "column_qualifier",
                |m: &ReadModifyWriteRule| { &m.column_qualifier },
                |m: &mut ReadModifyWriteRule| { &mut m.column_qualifier },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "append_value",
                ReadModifyWriteRule::has_append_value,
                ReadModifyWriteRule::get_append_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                "increment_amount",
                ReadModifyWriteRule::has_increment_amount,
                ReadModifyWriteRule::get_increment_amount,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReadModifyWriteRule>(
                "ReadModifyWriteRule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReadModifyWriteRule {
        static instance: ::protobuf::rt::LazyV2<ReadModifyWriteRule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReadModifyWriteRule::new)
    }
}

impl ::protobuf::Clear for ReadModifyWriteRule {
    fn clear(&mut self) {
        self.family_name.clear();
        self.column_qualifier.clear();
        self.rule = ::std::option::Option::None;
        self.rule = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadModifyWriteRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadModifyWriteRule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n&google/bigtable/v1/bigtable_data.proto\x12\x12google.bigtable.v1\"O\n\
    \x03Row\x12\x10\n\x03key\x18\x01\x20\x01(\x0cR\x03key\x126\n\x08families\
    \x18\x02\x20\x03(\x0b2\x1a.google.bigtable.v1.FamilyR\x08families\"R\n\
    \x06Family\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x124\n\x07colum\
    ns\x18\x02\x20\x03(\x0b2\x1a.google.bigtable.v1.ColumnR\x07columns\"V\n\
    \x06Column\x12\x1c\n\tqualifier\x18\x01\x20\x01(\x0cR\tqualifier\x12.\n\
    \x05cells\x18\x02\x20\x03(\x0b2\x18.google.bigtable.v1.CellR\x05cells\"_\
    \n\x04Cell\x12)\n\x10timestamp_micros\x18\x01\x20\x01(\x03R\x0ftimestamp\
    Micros\x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\x05value\x12\x16\n\x06la\
    bels\x18\x03\x20\x03(\tR\x06labels\"@\n\x08RowRange\x12\x1b\n\tstart_key\
    \x18\x02\x20\x01(\x0cR\x08startKey\x12\x17\n\x07end_key\x18\x03\x20\x01(\
    \x0cR\x06endKey\"`\n\x06RowSet\x12\x19\n\x08row_keys\x18\x01\x20\x03(\
    \x0cR\x07rowKeys\x12;\n\nrow_ranges\x18\x02\x20\x03(\x0b2\x1c.google.big\
    table.v1.RowRangeR\trowRanges\"\xc2\x02\n\x0bColumnRange\x12\x1f\n\x0bfa\
    mily_name\x18\x01\x20\x01(\tR\nfamilyName\x12<\n\x19start_qualifier_incl\
    usive\x18\x02\x20\x01(\x0cH\0R\x17startQualifierInclusive\x12<\n\x19star\
    t_qualifier_exclusive\x18\x03\x20\x01(\x0cH\0R\x17startQualifierExclusiv\
    e\x128\n\x17end_qualifier_inclusive\x18\x04\x20\x01(\x0cH\x01R\x15endQua\
    lifierInclusive\x128\n\x17end_qualifier_exclusive\x18\x05\x20\x01(\x0cH\
    \x01R\x15endQualifierExclusiveB\x11\n\x0fstart_qualifierB\x0f\n\rend_qua\
    lifier\"x\n\x0eTimestampRange\x124\n\x16start_timestamp_micros\x18\x01\
    \x20\x01(\x03R\x14startTimestampMicros\x120\n\x14end_timestamp_micros\
    \x18\x02\x20\x01(\x03R\x12endTimestampMicros\"\xf8\x01\n\nValueRange\x12\
    4\n\x15start_value_inclusive\x18\x01\x20\x01(\x0cH\0R\x13startValueInclu\
    sive\x124\n\x15start_value_exclusive\x18\x02\x20\x01(\x0cH\0R\x13startVa\
    lueExclusive\x120\n\x13end_value_inclusive\x18\x03\x20\x01(\x0cH\x01R\
    \x11endValueInclusive\x120\n\x13end_value_exclusive\x18\x04\x20\x01(\x0c\
    H\x01R\x11endValueExclusiveB\r\n\x0bstart_valueB\x0b\n\tend_value\"\xfc\
    \x0b\n\tRowFilter\x12;\n\x05chain\x18\x01\x20\x01(\x0b2#.google.bigtable\
    .v1.RowFilter.ChainH\0R\x05chain\x12J\n\ninterleave\x18\x02\x20\x01(\x0b\
    2(.google.bigtable.v1.RowFilter.InterleaveH\0R\ninterleave\x12G\n\tcondi\
    tion\x18\x03\x20\x01(\x0b2'.google.bigtable.v1.RowFilter.ConditionH\0R\t\
    condition\x12\x14\n\x04sink\x18\x10\x20\x01(\x08H\0R\x04sink\x12(\n\x0fp\
    ass_all_filter\x18\x11\x20\x01(\x08H\0R\rpassAllFilter\x12*\n\x10block_a\
    ll_filter\x18\x12\x20\x01(\x08H\0R\x0eblockAllFilter\x121\n\x14row_key_r\
    egex_filter\x18\x04\x20\x01(\x0cH\0R\x11rowKeyRegexFilter\x12,\n\x11row_\
    sample_filter\x18\x0e\x20\x01(\x01H\0R\x0frowSampleFilter\x129\n\x18fami\
    ly_name_regex_filter\x18\x05\x20\x01(\tH\0R\x15familyNameRegexFilter\x12\
    C\n\x1dcolumn_qualifier_regex_filter\x18\x06\x20\x01(\x0cH\0R\x1acolumnQ\
    ualifierRegexFilter\x12Q\n\x13column_range_filter\x18\x07\x20\x01(\x0b2\
    \x1f.google.bigtable.v1.ColumnRangeH\0R\x11columnRangeFilter\x12Z\n\x16t\
    imestamp_range_filter\x18\x08\x20\x01(\x0b2\".google.bigtable.v1.Timesta\
    mpRangeH\0R\x14timestampRangeFilter\x12.\n\x12value_regex_filter\x18\t\
    \x20\x01(\x0cH\0R\x10valueRegexFilter\x12N\n\x12value_range_filter\x18\
    \x0f\x20\x01(\x0b2\x1e.google.bigtable.v1.ValueRangeH\0R\x10valueRangeFi\
    lter\x12>\n\x1bcells_per_row_offset_filter\x18\n\x20\x01(\x05H\0R\x17cel\
    lsPerRowOffsetFilter\x12<\n\x1acells_per_row_limit_filter\x18\x0b\x20\
    \x01(\x05H\0R\x16cellsPerRowLimitFilter\x12B\n\x1dcells_per_column_limit\
    _filter\x18\x0c\x20\x01(\x05H\0R\x19cellsPerColumnLimitFilter\x128\n\x17\
    strip_value_transformer\x18\r\x20\x01(\x08H\0R\x15stripValueTransformer\
    \x128\n\x17apply_label_transformer\x18\x13\x20\x01(\tH\0R\x15applyLabelT\
    ransformer\x1a@\n\x05Chain\x127\n\x07filters\x18\x01\x20\x03(\x0b2\x1d.g\
    oogle.bigtable.v1.RowFilterR\x07filters\x1aE\n\nInterleave\x127\n\x07fil\
    ters\x18\x01\x20\x03(\x0b2\x1d.google.bigtable.v1.RowFilterR\x07filters\
    \x1a\xd7\x01\n\tCondition\x12H\n\x10predicate_filter\x18\x01\x20\x01(\
    \x0b2\x1d.google.bigtable.v1.RowFilterR\x0fpredicateFilter\x12>\n\x0btru\
    e_filter\x18\x02\x20\x01(\x0b2\x1d.google.bigtable.v1.RowFilterR\ntrueFi\
    lter\x12@\n\x0cfalse_filter\x18\x03\x20\x01(\x0b2\x1d.google.bigtable.v1\
    .RowFilterR\x0bfalseFilterB\x08\n\x06filter\"\xf0\x05\n\x08Mutation\x12A\
    \n\x08set_cell\x18\x01\x20\x01(\x0b2$.google.bigtable.v1.Mutation.SetCel\
    lH\0R\x07setCell\x12]\n\x12delete_from_column\x18\x02\x20\x01(\x0b2-.goo\
    gle.bigtable.v1.Mutation.DeleteFromColumnH\0R\x10deleteFromColumn\x12]\n\
    \x12delete_from_family\x18\x03\x20\x01(\x0b2-.google.bigtable.v1.Mutatio\
    n.DeleteFromFamilyH\0R\x10deleteFromFamily\x12T\n\x0fdelete_from_row\x18\
    \x04\x20\x01(\x0b2*.google.bigtable.v1.Mutation.DeleteFromRowH\0R\rdelet\
    eFromRow\x1a\x96\x01\n\x07SetCell\x12\x1f\n\x0bfamily_name\x18\x01\x20\
    \x01(\tR\nfamilyName\x12)\n\x10column_qualifier\x18\x02\x20\x01(\x0cR\
    \x0fcolumnQualifier\x12)\n\x10timestamp_micros\x18\x03\x20\x01(\x03R\x0f\
    timestampMicros\x12\x14\n\x05value\x18\x04\x20\x01(\x0cR\x05value\x1a\
    \xa1\x01\n\x10DeleteFromColumn\x12\x1f\n\x0bfamily_name\x18\x01\x20\x01(\
    \tR\nfamilyName\x12)\n\x10column_qualifier\x18\x02\x20\x01(\x0cR\x0fcolu\
    mnQualifier\x12A\n\ntime_range\x18\x03\x20\x01(\x0b2\".google.bigtable.v\
    1.TimestampRangeR\ttimeRange\x1a3\n\x10DeleteFromFamily\x12\x1f\n\x0bfam\
    ily_name\x18\x01\x20\x01(\tR\nfamilyName\x1a\x0f\n\rDeleteFromRowB\n\n\
    \x08mutation\"\xbb\x01\n\x13ReadModifyWriteRule\x12\x1f\n\x0bfamily_name\
    \x18\x01\x20\x01(\tR\nfamilyName\x12)\n\x10column_qualifier\x18\x02\x20\
    \x01(\x0cR\x0fcolumnQualifier\x12#\n\x0cappend_value\x18\x03\x20\x01(\
    \x0cH\0R\x0bappendValue\x12+\n\x10increment_amount\x18\x04\x20\x01(\x03H\
    \0R\x0fincrementAmountB\x06\n\x04ruleBi\n\x16com.google.bigtable.v1B\x11\
    BigtableDataProtoP\x01Z:google.golang.org/genproto/googleapis/bigtable/v\
    1;bigtableJ\xf4\xb2\x01\n\x07\x12\x05\x0e\0\x80\x04\x01\n\xbd\x04\n\x01\
    \x0c\x12\x03\x0e\0\x122\xb2\x04\x20Copyright\x202018\x20Google\x20Inc.\n\
    \n\x20Licensed\x20under\x20the\x20Apache\x20License,\x20Version\x202.0\
    \x20(the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\x20file\
    \x20except\x20in\x20compliance\x20with\x20the\x20License.\n\x20You\x20ma\
    y\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\
    \x20\x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\x20requ\
    ired\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\
    \x20software\n\x20distributed\x20under\x20the\x20License\x20is\x20distri\
    buted\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\
    \x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\
    \x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20specific\x20lan\
    guage\x20governing\x20permissions\x20and\n\x20limitations\x20under\x20th\
    e\x20License.\n\n\x08\n\x01\x02\x12\x03\x10\0\x1b\n\x08\n\x01\x08\x12\
    \x03\x12\0Q\n\t\n\x02\x08\x0b\x12\x03\x12\0Q\n\x08\n\x01\x08\x12\x03\x13\
    \0\"\n\t\n\x02\x08\n\x12\x03\x13\0\"\n\x08\n\x01\x08\x12\x03\x14\02\n\t\
    \n\x02\x08\x08\x12\x03\x14\02\n\x08\n\x01\x08\x12\x03\x15\0/\n\t\n\x02\
    \x08\x01\x12\x03\x15\0/\n\x90\x01\n\x02\x04\0\x12\x04\x19\0\"\x01\x1a\
    \x83\x01\x20Specifies\x20the\x20complete\x20(requested)\x20contents\x20o\
    f\x20a\x20single\x20row\x20of\x20a\x20table.\n\x20Rows\x20which\x20excee\
    d\x20256MiB\x20in\x20size\x20cannot\x20be\x20read\x20in\x20full.\n\n\n\n\
    \x03\x04\0\x01\x12\x03\x19\x08\x0b\n\xe2\x01\n\x04\x04\0\x02\0\x12\x03\
    \x1d\x02\x10\x1a\xd4\x01\x20The\x20unique\x20key\x20which\x20identifies\
    \x20this\x20row\x20within\x20its\x20table.\x20This\x20is\x20the\x20same\
    \n\x20key\x20that's\x20used\x20to\x20identify\x20the\x20row\x20in,\x20fo\
    r\x20example,\x20a\x20MutateRowRequest.\n\x20May\x20contain\x20any\x20no\
    n-empty\x20byte\x20string\x20up\x20to\x204KiB\x20in\x20length.\n\n\r\n\
    \x05\x04\0\x02\0\x04\x12\x04\x1d\x02\x19\r\n\x0c\n\x05\x04\0\x02\0\x05\
    \x12\x03\x1d\x02\x07\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x1d\x08\x0b\n\
    \x0c\n\x05\x04\0\x02\0\x03\x12\x03\x1d\x0e\x0f\n{\n\x04\x04\0\x02\x01\
    \x12\x03!\x02\x1f\x1an\x20May\x20be\x20empty,\x20but\x20only\x20if\x20th\
    e\x20entire\x20row\x20is\x20empty.\n\x20The\x20mutual\x20ordering\x20of\
    \x20column\x20families\x20is\x20not\x20specified.\n\n\x0c\n\x05\x04\0\
    \x02\x01\x04\x12\x03!\x02\n\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x03!\x0b\
    \x11\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03!\x12\x1a\n\x0c\n\x05\x04\0\
    \x02\x01\x03\x12\x03!\x1d\x1e\nX\n\x02\x04\x01\x12\x04%\00\x01\x1aL\x20S\
    pecifies\x20(some\x20of)\x20the\x20contents\x20of\x20a\x20single\x20row/\
    column\x20family\x20of\x20a\x20table.\n\n\n\n\x03\x04\x01\x01\x12\x03%\
    \x08\x0e\n\x83\x03\n\x04\x04\x01\x02\0\x12\x03,\x02\x12\x1a\xf5\x02\x20T\
    he\x20unique\x20key\x20which\x20identifies\x20this\x20family\x20within\
    \x20its\x20row.\x20This\x20is\x20the\n\x20same\x20key\x20that's\x20used\
    \x20to\x20identify\x20the\x20family\x20in,\x20for\x20example,\x20a\x20Ro\
    wFilter\n\x20which\x20sets\x20its\x20\"family_name_regex_filter\"\x20fie\
    ld.\n\x20Must\x20match\x20[-_.a-zA-Z0-9]+,\x20except\x20that\x20Aggregat\
    ingRowProcessors\x20may\n\x20produce\x20cells\x20in\x20a\x20sentinel\x20\
    family\x20with\x20an\x20empty\x20name.\n\x20Must\x20be\x20no\x20greater\
    \x20than\x2064\x20characters\x20in\x20length.\n\n\r\n\x05\x04\x01\x02\0\
    \x04\x12\x04,\x02%\x10\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03,\x02\x08\n\
    \x0c\n\x05\x04\x01\x02\0\x01\x12\x03,\t\r\n\x0c\n\x05\x04\x01\x02\0\x03\
    \x12\x03,\x10\x11\nL\n\x04\x04\x01\x02\x01\x12\x03/\x02\x1e\x1a?\x20Must\
    \x20not\x20be\x20empty.\x20Sorted\x20in\x20order\x20of\x20increasing\x20\
    \"qualifier\".\n\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03/\x02\n\n\x0c\n\
    \x05\x04\x01\x02\x01\x06\x12\x03/\x0b\x11\n\x0c\n\x05\x04\x01\x02\x01\
    \x01\x12\x03/\x12\x19\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03/\x1c\x1d\n\
    Q\n\x02\x04\x02\x12\x043\0=\x01\x1aE\x20Specifies\x20(some\x20of)\x20the\
    \x20contents\x20of\x20a\x20single\x20row/column\x20of\x20a\x20table.\n\n\
    \n\n\x03\x04\x02\x01\x12\x033\x08\x0e\n\xad\x02\n\x04\x04\x02\x02\0\x12\
    \x039\x02\x16\x1a\x9f\x02\x20The\x20unique\x20key\x20which\x20identifies\
    \x20this\x20column\x20within\x20its\x20family.\x20This\x20is\x20the\n\
    \x20same\x20key\x20that's\x20used\x20to\x20identify\x20the\x20column\x20\
    in,\x20for\x20example,\x20a\x20RowFilter\n\x20which\x20sets\x20its\x20\"\
    column_qualifier_regex_filter\"\x20field.\n\x20May\x20contain\x20any\x20\
    byte\x20string,\x20including\x20the\x20empty\x20string,\x20up\x20to\x201\
    6kiB\x20in\n\x20length.\n\n\r\n\x05\x04\x02\x02\0\x04\x12\x049\x023\x10\
    \n\x0c\n\x05\x04\x02\x02\0\x05\x12\x039\x02\x07\n\x0c\n\x05\x04\x02\x02\
    \0\x01\x12\x039\x08\x11\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x039\x14\x15\n\
    S\n\x04\x04\x02\x02\x01\x12\x03<\x02\x1a\x1aF\x20Must\x20not\x20be\x20em\
    pty.\x20Sorted\x20in\x20order\x20of\x20decreasing\x20\"timestamp_micros\
    \".\n\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03<\x02\n\n\x0c\n\x05\x04\x02\
    \x02\x01\x06\x12\x03<\x0b\x0f\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03<\
    \x10\x15\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03<\x18\x19\n[\n\x02\x04\
    \x03\x12\x04@\0P\x01\x1aO\x20Specifies\x20(some\x20of)\x20the\x20content\
    s\x20of\x20a\x20single\x20row/column/timestamp\x20of\x20a\x20table.\n\n\
    \n\n\x03\x04\x03\x01\x12\x03@\x08\x0c\n\xf8\x02\n\x04\x04\x03\x02\0\x12\
    \x03G\x02\x1d\x1a\xea\x02\x20The\x20cell's\x20stored\x20timestamp,\x20wh\
    ich\x20also\x20uniquely\x20identifies\x20it\x20within\n\x20its\x20column\
    .\n\x20Values\x20are\x20always\x20expressed\x20in\x20microseconds,\x20bu\
    t\x20individual\x20tables\x20may\x20set\n\x20a\x20coarser\x20\"granulari\
    ty\"\x20to\x20further\x20restrict\x20the\x20allowed\x20values.\x20For\n\
    \x20example,\x20a\x20table\x20which\x20specifies\x20millisecond\x20granu\
    larity\x20will\x20only\x20allow\n\x20values\x20of\x20\"timestamp_micros\
    \"\x20which\x20are\x20multiples\x20of\x201000.\n\n\r\n\x05\x04\x03\x02\0\
    \x04\x12\x04G\x02@\x0e\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03G\x02\x07\n\
    \x0c\n\x05\x04\x03\x02\0\x01\x12\x03G\x08\x18\n\x0c\n\x05\x04\x03\x02\0\
    \x03\x12\x03G\x1b\x1c\n\x7f\n\x04\x04\x03\x02\x01\x12\x03L\x02\x12\x1ar\
    \x20The\x20value\x20stored\x20in\x20the\x20cell.\n\x20May\x20contain\x20\
    any\x20byte\x20string,\x20including\x20the\x20empty\x20string,\x20up\x20\
    to\x20100MiB\x20in\n\x20length.\n\n\r\n\x05\x04\x03\x02\x01\x04\x12\x04L\
    \x02G\x1d\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03L\x02\x07\n\x0c\n\x05\
    \x04\x03\x02\x01\x01\x12\x03L\x08\r\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\
    \x03L\x10\x11\nY\n\x04\x04\x03\x02\x02\x12\x03O\x02\x1d\x1aL\x20Labels\
    \x20applied\x20to\x20the\x20cell\x20by\x20a\x20[RowFilter][google.bigtab\
    le.v1.RowFilter].\n\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\x03O\x02\n\n\x0c\
    \n\x05\x04\x03\x02\x02\x05\x12\x03O\x0b\x11\n\x0c\n\x05\x04\x03\x02\x02\
    \x01\x12\x03O\x12\x18\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03O\x1b\x1c\n\
    3\n\x02\x04\x04\x12\x04S\0Y\x01\x1a'\x20Specifies\x20a\x20contiguous\x20\
    range\x20of\x20rows.\n\n\n\n\x03\x04\x04\x01\x12\x03S\x08\x10\nU\n\x04\
    \x04\x04\x02\0\x12\x03U\x02\x16\x1aH\x20Inclusive\x20lower\x20bound.\x20\
    If\x20left\x20empty,\x20interpreted\x20as\x20the\x20empty\x20string.\n\n\
    \r\n\x05\x04\x04\x02\0\x04\x12\x04U\x02S\x12\n\x0c\n\x05\x04\x04\x02\0\
    \x05\x12\x03U\x02\x07\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03U\x08\x11\n\
    \x0c\n\x05\x04\x04\x02\0\x03\x12\x03U\x14\x15\nM\n\x04\x04\x04\x02\x01\
    \x12\x03X\x02\x14\x1a@\x20Exclusive\x20upper\x20bound.\x20If\x20left\x20\
    empty,\x20interpreted\x20as\x20infinity.\n\n\r\n\x05\x04\x04\x02\x01\x04\
    \x12\x04X\x02U\x16\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03X\x02\x07\n\
    \x0c\n\x05\x04\x04\x02\x01\x01\x12\x03X\x08\x0f\n\x0c\n\x05\x04\x04\x02\
    \x01\x03\x12\x03X\x12\x13\n5\n\x02\x04\x05\x12\x04\\\0b\x01\x1a)\x20Spec\
    ifies\x20a\x20non-contiguous\x20set\x20of\x20rows.\n\n\n\n\x03\x04\x05\
    \x01\x12\x03\\\x08\x0e\n/\n\x04\x04\x05\x02\0\x12\x03^\x02\x1e\x1a\"\x20\
    Single\x20rows\x20included\x20in\x20the\x20set.\n\n\x0c\n\x05\x04\x05\
    \x02\0\x04\x12\x03^\x02\n\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03^\x0b\x10\
    \n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03^\x11\x19\n\x0c\n\x05\x04\x05\x02\
    \0\x03\x12\x03^\x1c\x1d\n9\n\x04\x04\x05\x02\x01\x12\x03a\x02#\x1a,\x20C\
    ontiguous\x20row\x20ranges\x20included\x20in\x20the\x20set.\n\n\x0c\n\
    \x05\x04\x05\x02\x01\x04\x12\x03a\x02\n\n\x0c\n\x05\x04\x05\x02\x01\x06\
    \x12\x03a\x0b\x13\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03a\x14\x1e\n\x0c\
    \n\x05\x04\x05\x02\x01\x03\x12\x03a!\"\n\xeb\x01\n\x02\x04\x06\x12\x04h\
    \0\x7f\x01\x1a\xde\x01\x20Specifies\x20a\x20contiguous\x20range\x20of\
    \x20columns\x20within\x20a\x20single\x20column\x20family.\n\x20The\x20ra\
    nge\x20spans\x20from\x20<column_family>:<start_qualifier>\x20to\n\x20<co\
    lumn_family>:<end_qualifier>,\x20where\x20both\x20bounds\x20can\x20be\
    \x20either\x20inclusive\x20or\n\x20exclusive.\n\n\n\n\x03\x04\x06\x01\
    \x12\x03h\x08\x13\nK\n\x04\x04\x06\x02\0\x12\x03j\x02\x19\x1a>\x20The\
    \x20name\x20of\x20the\x20column\x20family\x20within\x20which\x20this\x20\
    range\x20falls.\n\n\r\n\x05\x04\x06\x02\0\x04\x12\x04j\x02h\x15\n\x0c\n\
    \x05\x04\x06\x02\0\x05\x12\x03j\x02\x08\n\x0c\n\x05\x04\x06\x02\0\x01\
    \x12\x03j\t\x14\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03j\x17\x18\n\xa1\x01\
    \n\x04\x04\x06\x08\0\x12\x04n\x02t\x03\x1a\x92\x01\x20The\x20column\x20q\
    ualifier\x20at\x20which\x20to\x20start\x20the\x20range\x20(within\x20'co\
    lumn_family').\n\x20If\x20neither\x20field\x20is\x20set,\x20interpreted\
    \x20as\x20the\x20empty\x20string,\x20inclusive.\n\n\x0c\n\x05\x04\x06\
    \x08\0\x01\x12\x03n\x08\x17\nG\n\x04\x04\x06\x02\x01\x12\x03p\x04(\x1a:\
    \x20Used\x20when\x20giving\x20an\x20inclusive\x20lower\x20bound\x20for\
    \x20the\x20range.\n\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03p\x04\t\n\x0c\
    \n\x05\x04\x06\x02\x01\x01\x12\x03p\n#\n\x0c\n\x05\x04\x06\x02\x01\x03\
    \x12\x03p&'\nG\n\x04\x04\x06\x02\x02\x12\x03s\x04(\x1a:\x20Used\x20when\
    \x20giving\x20an\x20exclusive\x20lower\x20bound\x20for\x20the\x20range.\
    \n\n\x0c\n\x05\x04\x06\x02\x02\x05\x12\x03s\x04\t\n\x0c\n\x05\x04\x06\
    \x02\x02\x01\x12\x03s\n#\n\x0c\n\x05\x04\x06\x02\x02\x03\x12\x03s&'\n\
    \xa2\x01\n\x04\x04\x06\x08\x01\x12\x04x\x02~\x03\x1a\x93\x01\x20The\x20c\
    olumn\x20qualifier\x20at\x20which\x20to\x20end\x20the\x20range\x20(withi\
    n\x20'column_family').\n\x20If\x20neither\x20field\x20is\x20set,\x20inte\
    rpreted\x20as\x20the\x20infinite\x20string,\x20exclusive.\n\n\x0c\n\x05\
    \x04\x06\x08\x01\x01\x12\x03x\x08\x15\nG\n\x04\x04\x06\x02\x03\x12\x03z\
    \x04&\x1a:\x20Used\x20when\x20giving\x20an\x20inclusive\x20upper\x20boun\
    d\x20for\x20the\x20range.\n\n\x0c\n\x05\x04\x06\x02\x03\x05\x12\x03z\x04\
    \t\n\x0c\n\x05\x04\x06\x02\x03\x01\x12\x03z\n!\n\x0c\n\x05\x04\x06\x02\
    \x03\x03\x12\x03z$%\nG\n\x04\x04\x06\x02\x04\x12\x03}\x04&\x1a:\x20Used\
    \x20when\x20giving\x20an\x20exclusive\x20upper\x20bound\x20for\x20the\
    \x20range.\n\n\x0c\n\x05\x04\x06\x02\x04\x05\x12\x03}\x04\t\n\x0c\n\x05\
    \x04\x06\x02\x04\x01\x12\x03}\n!\n\x0c\n\x05\x04\x06\x02\x04\x03\x12\x03\
    }$%\nG\n\x02\x04\x07\x12\x06\x82\x01\0\x88\x01\x01\x1a9\x20Specified\x20\
    a\x20contiguous\x20range\x20of\x20microsecond\x20timestamps.\n\n\x0b\n\
    \x03\x04\x07\x01\x12\x04\x82\x01\x08\x16\nG\n\x04\x04\x07\x02\0\x12\x04\
    \x84\x01\x02#\x1a9\x20Inclusive\x20lower\x20bound.\x20If\x20left\x20empt\
    y,\x20interpreted\x20as\x200.\n\n\x0f\n\x05\x04\x07\x02\0\x04\x12\x06\
    \x84\x01\x02\x82\x01\x18\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\x84\x01\x02\
    \x07\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\x84\x01\x08\x1e\n\r\n\x05\x04\
    \x07\x02\0\x03\x12\x04\x84\x01!\"\nN\n\x04\x04\x07\x02\x01\x12\x04\x87\
    \x01\x02!\x1a@\x20Exclusive\x20upper\x20bound.\x20If\x20left\x20empty,\
    \x20interpreted\x20as\x20infinity.\n\n\x0f\n\x05\x04\x07\x02\x01\x04\x12\
    \x06\x87\x01\x02\x84\x01#\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\x87\x01\
    \x02\x07\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\x87\x01\x08\x1c\n\r\n\x05\
    \x04\x07\x02\x01\x03\x12\x04\x87\x01\x1f\x20\n@\n\x02\x04\x08\x12\x06\
    \x8b\x01\0\x9f\x01\x01\x1a2\x20Specifies\x20a\x20contiguous\x20range\x20\
    of\x20raw\x20byte\x20values.\n\n\x0b\n\x03\x04\x08\x01\x12\x04\x8b\x01\
    \x08\x12\n~\n\x04\x04\x08\x08\0\x12\x06\x8e\x01\x02\x94\x01\x03\x1an\x20\
    The\x20value\x20at\x20which\x20to\x20start\x20the\x20range.\n\x20If\x20n\
    either\x20field\x20is\x20set,\x20interpreted\x20as\x20the\x20empty\x20st\
    ring,\x20inclusive.\n\n\r\n\x05\x04\x08\x08\0\x01\x12\x04\x8e\x01\x08\
    \x13\nH\n\x04\x04\x08\x02\0\x12\x04\x90\x01\x04$\x1a:\x20Used\x20when\
    \x20giving\x20an\x20inclusive\x20lower\x20bound\x20for\x20the\x20range.\
    \n\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\x90\x01\x04\t\n\r\n\x05\x04\x08\
    \x02\0\x01\x12\x04\x90\x01\n\x1f\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\x90\
    \x01\"#\nH\n\x04\x04\x08\x02\x01\x12\x04\x93\x01\x04$\x1a:\x20Used\x20wh\
    en\x20giving\x20an\x20exclusive\x20lower\x20bound\x20for\x20the\x20range\
    .\n\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\x93\x01\x04\t\n\r\n\x05\x04\
    \x08\x02\x01\x01\x12\x04\x93\x01\n\x1f\n\r\n\x05\x04\x08\x02\x01\x03\x12\
    \x04\x93\x01\"#\n\x7f\n\x04\x04\x08\x08\x01\x12\x06\x98\x01\x02\x9e\x01\
    \x03\x1ao\x20The\x20value\x20at\x20which\x20to\x20end\x20the\x20range.\n\
    \x20If\x20neither\x20field\x20is\x20set,\x20interpreted\x20as\x20the\x20\
    infinite\x20string,\x20exclusive.\n\n\r\n\x05\x04\x08\x08\x01\x01\x12\
    \x04\x98\x01\x08\x11\nH\n\x04\x04\x08\x02\x02\x12\x04\x9a\x01\x04\"\x1a:\
    \x20Used\x20when\x20giving\x20an\x20inclusive\x20upper\x20bound\x20for\
    \x20the\x20range.\n\n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\x9a\x01\x04\t\
    \n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\x9a\x01\n\x1d\n\r\n\x05\x04\x08\
    \x02\x02\x03\x12\x04\x9a\x01\x20!\nH\n\x04\x04\x08\x02\x03\x12\x04\x9d\
    \x01\x04\"\x1a:\x20Used\x20when\x20giving\x20an\x20exclusive\x20upper\
    \x20bound\x20for\x20the\x20range.\n\n\r\n\x05\x04\x08\x02\x03\x05\x12\
    \x04\x9d\x01\x04\t\n\r\n\x05\x04\x08\x02\x03\x01\x12\x04\x9d\x01\n\x1d\n\
    \r\n\x05\x04\x08\x02\x03\x03\x12\x04\x9d\x01\x20!\n\xa5\x0f\n\x02\x04\t\
    \x12\x06\xc2\x01\0\xa4\x03\x01\x1a\x96\x0f\x20Takes\x20a\x20row\x20as\
    \x20input\x20and\x20produces\x20an\x20alternate\x20view\x20of\x20the\x20\
    row\x20based\x20on\n\x20specified\x20rules.\x20For\x20example,\x20a\x20R\
    owFilter\x20might\x20trim\x20down\x20a\x20row\x20to\x20include\n\x20just\
    \x20the\x20cells\x20from\x20columns\x20matching\x20a\x20given\x20regular\
    \x20expression,\x20or\x20might\n\x20return\x20all\x20the\x20cells\x20of\
    \x20a\x20row\x20but\x20not\x20their\x20values.\x20More\x20complicated\
    \x20filters\n\x20can\x20be\x20composed\x20out\x20of\x20these\x20componen\
    ts\x20to\x20express\x20requests\x20such\x20as,\x20\"within\n\x20every\
    \x20column\x20of\x20a\x20particular\x20family,\x20give\x20just\x20the\
    \x20two\x20most\x20recent\x20cells\n\x20which\x20are\x20older\x20than\
    \x20timestamp\x20X.\"\n\n\x20There\x20are\x20two\x20broad\x20categories\
    \x20of\x20RowFilters\x20(true\x20filters\x20and\x20transformers),\n\x20a\
    s\x20well\x20as\x20two\x20ways\x20to\x20compose\x20simple\x20filters\x20\
    into\x20more\x20complex\x20ones\n\x20(chains\x20and\x20interleaves).\x20\
    They\x20work\x20as\x20follows:\n\n\x20*\x20True\x20filters\x20alter\x20t\
    he\x20input\x20row\x20by\x20excluding\x20some\x20of\x20its\x20cells\x20w\
    holesale\n\x20from\x20the\x20output\x20row.\x20An\x20example\x20of\x20a\
    \x20true\x20filter\x20is\x20the\x20\"value_regex_filter\",\n\x20which\
    \x20excludes\x20cells\x20whose\x20values\x20don't\x20match\x20the\x20spe\
    cified\x20pattern.\x20All\n\x20regex\x20true\x20filters\x20use\x20RE2\
    \x20syntax\x20(https://github.com/google/re2/wiki/Syntax)\n\x20in\x20raw\
    \x20byte\x20mode\x20(RE2::Latin1),\x20and\x20are\x20evaluated\x20as\x20f\
    ull\x20matches.\x20An\n\x20important\x20point\x20to\x20keep\x20in\x20min\
    d\x20is\x20that\x20RE2(.)\x20is\x20equivalent\x20by\x20default\x20to\n\
    \x20RE2([^\\n]),\x20meaning\x20that\x20it\x20does\x20not\x20match\x20new\
    lines.\x20When\x20attempting\x20to\x20match\n\x20an\x20arbitrary\x20byte\
    ,\x20you\x20should\x20therefore\x20use\x20the\x20escape\x20sequence\x20'\
    \\C',\x20which\n\x20may\x20need\x20to\x20be\x20further\x20escaped\x20as\
    \x20'\\\\C'\x20in\x20your\x20client\x20language.\n\n\x20*\x20Transformer\
    s\x20alter\x20the\x20input\x20row\x20by\x20changing\x20the\x20values\x20\
    of\x20some\x20of\x20its\n\x20cells\x20in\x20the\x20output,\x20without\
    \x20excluding\x20them\x20completely.\x20Currently,\x20the\x20only\n\x20s\
    upported\x20transformer\x20is\x20the\x20\"strip_value_transformer\",\x20\
    which\x20replaces\x20every\n\x20cell's\x20value\x20with\x20the\x20empty\
    \x20string.\n\n\x20*\x20Chains\x20and\x20interleaves\x20are\x20described\
    \x20in\x20more\x20detail\x20in\x20the\n\x20RowFilter.Chain\x20and\x20Row\
    Filter.Interleave\x20documentation.\n\n\x20The\x20total\x20serialized\
    \x20size\x20of\x20a\x20RowFilter\x20message\x20must\x20not\n\x20exceed\
    \x204096\x20bytes,\x20and\x20RowFilters\x20may\x20not\x20be\x20nested\
    \x20within\x20each\x20other\n\x20(in\x20Chains\x20or\x20Interleaves)\x20\
    to\x20a\x20depth\x20of\x20more\x20than\x2020.\n\n\x0b\n\x03\x04\t\x01\
    \x12\x04\xc2\x01\x08\x11\nV\n\x04\x04\t\x03\0\x12\x06\xc4\x01\x02\xc9\
    \x01\x03\x1aF\x20A\x20RowFilter\x20which\x20sends\x20rows\x20through\x20\
    several\x20RowFilters\x20in\x20sequence.\n\n\r\n\x05\x04\t\x03\0\x01\x12\
    \x04\xc4\x01\n\x0f\n\xc9\x01\n\x06\x04\t\x03\0\x02\0\x12\x04\xc8\x01\x04\
    #\x1a\xb8\x01\x20The\x20elements\x20of\x20\"filters\"\x20are\x20chained\
    \x20together\x20to\x20process\x20the\x20input\x20row:\n\x20in\x20row\x20\
    ->\x20f(0)\x20->\x20intermediate\x20row\x20->\x20f(1)\x20->\x20...\x20->\
    \x20f(N)\x20->\x20out\x20row\n\x20The\x20full\x20chain\x20is\x20executed\
    \x20atomically.\n\n\x0f\n\x07\x04\t\x03\0\x02\0\x04\x12\x04\xc8\x01\x04\
    \x0c\n\x0f\n\x07\x04\t\x03\0\x02\0\x06\x12\x04\xc8\x01\r\x16\n\x0f\n\x07\
    \x04\t\x03\0\x02\0\x01\x12\x04\xc8\x01\x17\x1e\n\x0f\n\x07\x04\t\x03\0\
    \x02\0\x03\x12\x04\xc8\x01!\"\nx\n\x04\x04\t\x03\x01\x12\x06\xcd\x01\x02\
    \xe7\x01\x03\x1ah\x20A\x20RowFilter\x20which\x20sends\x20each\x20row\x20\
    to\x20each\x20of\x20several\x20component\n\x20RowFilters\x20and\x20inter\
    leaves\x20the\x20results.\n\n\r\n\x05\x04\t\x03\x01\x01\x12\x04\xcd\x01\
    \n\x14\n\xe2\n\n\x06\x04\t\x03\x01\x02\0\x12\x04\xe6\x01\x04#\x1a\xd1\n\
    \x20The\x20elements\x20of\x20\"filters\"\x20all\x20process\x20a\x20copy\
    \x20of\x20the\x20input\x20row,\x20and\x20the\n\x20results\x20are\x20pool\
    ed,\x20sorted,\x20and\x20combined\x20into\x20a\x20single\x20output\x20ro\
    w.\n\x20If\x20multiple\x20cells\x20are\x20produced\x20with\x20the\x20sam\
    e\x20column\x20and\x20timestamp,\n\x20they\x20will\x20all\x20appear\x20i\
    n\x20the\x20output\x20row\x20in\x20an\x20unspecified\x20mutual\x20order.\
    \n\x20Consider\x20the\x20following\x20example,\x20with\x20three\x20filte\
    rs:\n\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20input\x20row\n\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\
    \x20\x20\x20\x20\x20\x20\x20--------------------------------------------\
    ---------\n\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    |\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x20\x20\x20f(0)\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20f(1)\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20f(2)\n\x20\x20\x20\x20\x20\x20\x20\x20|\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x201:\
    \x20foo,bar,10,x\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20foo,\
    bar,10,z\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20far,bar,\
    7,a\n\x202:\x20foo,blah,11,z\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20far,blah,5,x\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    far,blah,5,x\n\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x20\x20\x20\x20-\
    ----------------------------------------------------\n\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x201:\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20foo,bar,10,z\x20\x20\x20\x20\x20//\x20could\x20have\x20switc\
    hed\x20with\x20#2\n\x202:\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20foo,bar,10,x\x20\x20\
    \x20\x20\x20//\x20could\x20have\x20switched\x20with\x20#1\n\x203:\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20foo,blah,11,z\n\x204:\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20far,\
    bar,7,a\n\x205:\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20far,blah,5,x\x20\x20\x20\x20\x20\
    //\x20identical\x20to\x20#6\n\x206:\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20far,blah,5,x\
    \x20\x20\x20\x20\x20//\x20identical\x20to\x20#5\n\x20All\x20interleaved\
    \x20filters\x20are\x20executed\x20atomically.\n\n\x0f\n\x07\x04\t\x03\
    \x01\x02\0\x04\x12\x04\xe6\x01\x04\x0c\n\x0f\n\x07\x04\t\x03\x01\x02\0\
    \x06\x12\x04\xe6\x01\r\x16\n\x0f\n\x07\x04\t\x03\x01\x02\0\x01\x12\x04\
    \xe6\x01\x17\x1e\n\x0f\n\x07\x04\t\x03\x01\x02\0\x03\x12\x04\xe6\x01!\"\
    \n\xb4\x03\n\x04\x04\t\x03\x02\x12\x06\xf0\x01\x02\xfd\x01\x03\x1a\xa3\
    \x03\x20A\x20RowFilter\x20which\x20evaluates\x20one\x20of\x20two\x20poss\
    ible\x20RowFilters,\x20depending\x20on\n\x20whether\x20or\x20not\x20a\
    \x20predicate\x20RowFilter\x20outputs\x20any\x20cells\x20from\x20the\x20\
    input\x20row.\n\n\x20IMPORTANT\x20NOTE:\x20The\x20predicate\x20filter\
    \x20does\x20not\x20execute\x20atomically\x20with\x20the\n\x20true\x20and\
    \x20false\x20filters,\x20which\x20may\x20lead\x20to\x20inconsistent\x20o\
    r\x20unexpected\n\x20results.\x20Additionally,\x20Condition\x20filters\
    \x20have\x20poor\x20performance,\x20especially\n\x20when\x20filters\x20a\
    re\x20set\x20for\x20the\x20false\x20condition.\n\n\r\n\x05\x04\t\x03\x02\
    \x01\x12\x04\xf0\x01\n\x13\n\xa0\x01\n\x06\x04\t\x03\x02\x02\0\x12\x04\
    \xf3\x01\x04#\x1a\x8f\x01\x20If\x20\"predicate_filter\"\x20outputs\x20an\
    y\x20cells,\x20then\x20\"true_filter\"\x20will\x20be\n\x20evaluated\x20o\
    n\x20the\x20input\x20row.\x20Otherwise,\x20\"false_filter\"\x20will\x20b\
    e\x20evaluated.\n\n\x11\n\x07\x04\t\x03\x02\x02\0\x04\x12\x06\xf3\x01\
    \x04\xf0\x01\x15\n\x0f\n\x07\x04\t\x03\x02\x02\0\x06\x12\x04\xf3\x01\x04\
    \r\n\x0f\n\x07\x04\t\x03\x02\x02\0\x01\x12\x04\xf3\x01\x0e\x1e\n\x0f\n\
    \x07\x04\t\x03\x02\x02\0\x03\x12\x04\xf3\x01!\"\n\xa2\x01\n\x06\x04\t\
    \x03\x02\x02\x01\x12\x04\xf7\x01\x04\x1e\x1a\x91\x01\x20The\x20filter\
    \x20to\x20apply\x20to\x20the\x20input\x20row\x20if\x20\"predicate_filter\
    \"\x20returns\x20any\n\x20results.\x20If\x20not\x20provided,\x20no\x20re\
    sults\x20will\x20be\x20returned\x20in\x20the\x20true\x20case.\n\n\x11\n\
    \x07\x04\t\x03\x02\x02\x01\x04\x12\x06\xf7\x01\x04\xf3\x01#\n\x0f\n\x07\
    \x04\t\x03\x02\x02\x01\x06\x12\x04\xf7\x01\x04\r\n\x0f\n\x07\x04\t\x03\
    \x02\x02\x01\x01\x12\x04\xf7\x01\x0e\x19\n\x0f\n\x07\x04\t\x03\x02\x02\
    \x01\x03\x12\x04\xf7\x01\x1c\x1d\n\xac\x01\n\x06\x04\t\x03\x02\x02\x02\
    \x12\x04\xfc\x01\x04\x1f\x1a\x9b\x01\x20The\x20filter\x20to\x20apply\x20\
    to\x20the\x20input\x20row\x20if\x20\"predicate_filter\"\x20does\x20not\n\
    \x20return\x20any\x20results.\x20If\x20not\x20provided,\x20no\x20results\
    \x20will\x20be\x20returned\x20in\x20the\n\x20false\x20case.\n\n\x11\n\
    \x07\x04\t\x03\x02\x02\x02\x04\x12\x06\xfc\x01\x04\xf7\x01\x1e\n\x0f\n\
    \x07\x04\t\x03\x02\x02\x02\x06\x12\x04\xfc\x01\x04\r\n\x0f\n\x07\x04\t\
    \x03\x02\x02\x02\x01\x12\x04\xfc\x01\x0e\x1a\n\x0f\n\x07\x04\t\x03\x02\
    \x02\x02\x03\x12\x04\xfc\x01\x1d\x1e\n\x86\x01\n\x04\x04\t\x08\0\x12\x06\
    \x81\x02\x02\xa3\x03\x03\x1av\x20Which\x20of\x20the\x20possible\x20RowFi\
    lter\x20types\x20to\x20apply.\x20If\x20none\x20are\x20set,\x20this\n\x20\
    RowFilter\x20returns\x20all\x20cells\x20in\x20the\x20input\x20row.\n\n\r\
    \n\x05\x04\t\x08\0\x01\x12\x04\x81\x02\x08\x0e\ni\n\x04\x04\t\x02\0\x12\
    \x04\x84\x02\x04\x14\x1a[\x20Applies\x20several\x20RowFilters\x20to\x20t\
    he\x20data\x20in\x20sequence,\x20progressively\n\x20narrowing\x20the\x20\
    results.\n\n\r\n\x05\x04\t\x02\0\x06\x12\x04\x84\x02\x04\t\n\r\n\x05\x04\
    \t\x02\0\x01\x12\x04\x84\x02\n\x0f\n\r\n\x05\x04\t\x02\0\x03\x12\x04\x84\
    \x02\x12\x13\n]\n\x04\x04\t\x02\x01\x12\x04\x88\x02\x04\x1e\x1aO\x20Appl\
    ies\x20several\x20RowFilters\x20to\x20the\x20data\x20in\x20parallel\x20a\
    nd\x20combines\x20the\n\x20results.\n\n\r\n\x05\x04\t\x02\x01\x06\x12\
    \x04\x88\x02\x04\x0e\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\x88\x02\x0f\x19\
    \n\r\n\x05\x04\t\x02\x01\x03\x12\x04\x88\x02\x1c\x1d\nq\n\x04\x04\t\x02\
    \x02\x12\x04\x8c\x02\x04\x1c\x1ac\x20Applies\x20one\x20of\x20two\x20poss\
    ible\x20RowFilters\x20to\x20the\x20data\x20based\x20on\x20the\x20output\
    \x20of\n\x20a\x20predicate\x20RowFilter.\n\n\r\n\x05\x04\t\x02\x02\x06\
    \x12\x04\x8c\x02\x04\r\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\x8c\x02\x0e\
    \x17\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\x8c\x02\x1a\x1b\n\x97\x14\n\x04\
    \x04\t\x02\x03\x12\x04\xc9\x02\x04\x13\x1a\x88\x14\x20ADVANCED\x20USE\
    \x20ONLY.\n\x20Hook\x20for\x20introspection\x20into\x20the\x20RowFilter.\
    \x20Outputs\x20all\x20cells\x20directly\x20to\n\x20the\x20output\x20of\
    \x20the\x20read\x20rather\x20than\x20to\x20any\x20parent\x20filter.\x20C\
    onsider\x20the\n\x20following\x20example:\n\n\x20Chain(\n\x20\x20\x20Fam\
    ilyRegex(\"A\"),\n\x20\x20\x20Interleave(\n\x20\x20\x20\x20\x20All(),\n\
    \x20\x20\x20\x20\x20Chain(Label(\"foo\"),\x20Sink())\n\x20\x20\x20),\n\
    \x20\x20\x20QualifierRegex(\"B\")\n\x20)\n\n\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    A,A,1,w\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20A,B,2,x\n\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20B,B,4,z\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20FamilyRegex(\"A\")\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20A,A,1,w\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20A,B,2,x\
    \n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20+------------+-------------+\n\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20All()\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20Label(foo)\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20A,A,1,w\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20A,A,1,w,labels:[foo]\n\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20A,B,2,x\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20A,B,2,x,labels:[foo]\n\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20Sink()\x20--------------+\n\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    |\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20+--------\
    ----+\x20\x20\x20\x20\x20\x20x------+\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20A,A,1,w,labels:[foo]\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    |\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20A,B,2,x,labels:[foo]\n\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20A,A,1,w\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20A,B,2,x\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    |\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20QualifierRegex(\"B\")\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20|\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20A,B,2,x\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20|\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20+-----------\
    ---------------------+\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20A,A,1,w,labels:[foo]\n\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20A,B,2,x,labels:[foo]\x20\x20//\x20could\x20be\x20switched\n\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20A,B,2,x\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20//\x20could\x20be\x20switched\n\n\x20Despite\x20being\
    \x20excluded\x20by\x20the\x20qualifier\x20filter,\x20a\x20copy\x20of\x20\
    every\x20cell\n\x20that\x20reaches\x20the\x20sink\x20is\x20present\x20in\
    \x20the\x20final\x20result.\n\n\x20As\x20with\x20an\x20[Interleave][goog\
    le.bigtable.v1.RowFilter.Interleave],\n\x20duplicate\x20cells\x20are\x20\
    possible,\x20and\x20appear\x20in\x20an\x20unspecified\x20mutual\x20order\
    .\n\x20In\x20this\x20case\x20we\x20have\x20a\x20duplicate\x20with\x20col\
    umn\x20\"A:B\"\x20and\x20timestamp\x202,\n\x20because\x20one\x20copy\x20\
    passed\x20through\x20the\x20all\x20filter\x20while\x20the\x20other\x20wa\
    s\n\x20passed\x20through\x20the\x20label\x20and\x20sink.\x20Note\x20that\
    \x20one\x20copy\x20has\x20label\x20\"foo\",\n\x20while\x20the\x20other\
    \x20does\x20not.\n\n\x20Cannot\x20be\x20used\x20within\x20the\x20`predic\
    ate_filter`,\x20`true_filter`,\x20or\n\x20`false_filter`\x20of\x20a\x20[\
    Condition][google.bigtable.v1.RowFilter.Condition].\n\n\r\n\x05\x04\t\
    \x02\x03\x05\x12\x04\xc9\x02\x04\x08\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\
    \xc9\x02\t\r\n\r\n\x05\x04\t\x02\x03\x03\x12\x04\xc9\x02\x10\x12\n\x8a\
    \x01\n\x04\x04\t\x02\x04\x12\x04\xcd\x02\x04\x1e\x1a|\x20Matches\x20all\
    \x20cells,\x20regardless\x20of\x20input.\x20Functionally\x20equivalent\
    \x20to\n\x20leaving\x20`filter`\x20unset,\x20but\x20included\x20for\x20c\
    ompleteness.\n\n\r\n\x05\x04\t\x02\x04\x05\x12\x04\xcd\x02\x04\x08\n\r\n\
    \x05\x04\t\x02\x04\x01\x12\x04\xcd\x02\t\x18\n\r\n\x05\x04\t\x02\x04\x03\
    \x12\x04\xcd\x02\x1b\x1d\nw\n\x04\x04\t\x02\x05\x12\x04\xd1\x02\x04\x1f\
    \x1ai\x20Does\x20not\x20match\x20any\x20cells,\x20regardless\x20of\x20in\
    put.\x20Useful\x20for\x20temporarily\n\x20disabling\x20just\x20part\x20o\
    f\x20a\x20filter.\n\n\r\n\x05\x04\t\x02\x05\x05\x12\x04\xd1\x02\x04\x08\
    \n\r\n\x05\x04\t\x02\x05\x01\x12\x04\xd1\x02\t\x19\n\r\n\x05\x04\t\x02\
    \x05\x03\x12\x04\xd1\x02\x1c\x1e\n\xa4\x03\n\x04\x04\t\x02\x06\x12\x04\
    \xda\x02\x04#\x1a\x95\x03\x20Matches\x20only\x20cells\x20from\x20rows\
    \x20whose\x20keys\x20satisfy\x20the\x20given\x20RE2\x20regex.\x20In\n\
    \x20other\x20words,\x20passes\x20through\x20the\x20entire\x20row\x20when\
    \x20the\x20key\x20matches,\x20and\n\x20otherwise\x20produces\x20an\x20em\
    pty\x20row.\n\x20Note\x20that,\x20since\x20row\x20keys\x20can\x20contain\
    \x20arbitrary\x20bytes,\x20the\x20'\\C'\x20escape\n\x20sequence\x20must\
    \x20be\x20used\x20if\x20a\x20true\x20wildcard\x20is\x20desired.\x20The\
    \x20'.'\x20character\n\x20will\x20not\x20match\x20the\x20new\x20line\x20\
    character\x20'\\n',\x20which\x20may\x20be\x20present\x20in\x20a\n\x20bin\
    ary\x20key.\n\n\r\n\x05\x04\t\x02\x06\x05\x12\x04\xda\x02\x04\t\n\r\n\
    \x05\x04\t\x02\x06\x01\x12\x04\xda\x02\n\x1e\n\r\n\x05\x04\t\x02\x06\x03\
    \x12\x04\xda\x02!\"\ny\n\x04\x04\t\x02\x07\x12\x04\xde\x02\x04\"\x1ak\
    \x20Matches\x20all\x20cells\x20from\x20a\x20row\x20with\x20probability\
    \x20p,\x20and\x20matches\x20no\x20cells\n\x20from\x20the\x20row\x20with\
    \x20probability\x201-p.\n\n\r\n\x05\x04\t\x02\x07\x05\x12\x04\xde\x02\
    \x04\n\n\r\n\x05\x04\t\x02\x07\x01\x12\x04\xde\x02\x0b\x1c\n\r\n\x05\x04\
    \t\x02\x07\x03\x12\x04\xde\x02\x1f!\n\xf0\x02\n\x04\x04\t\x02\x08\x12\
    \x04\xe6\x02\x04(\x1a\xe1\x02\x20Matches\x20only\x20cells\x20from\x20col\
    umns\x20whose\x20families\x20satisfy\x20the\x20given\x20RE2\n\x20regex.\
    \x20For\x20technical\x20reasons,\x20the\x20regex\x20must\x20not\x20conta\
    in\x20the\x20':'\n\x20character,\x20even\x20if\x20it\x20is\x20not\x20bei\
    ng\x20used\x20as\x20a\x20literal.\n\x20Note\x20that,\x20since\x20column\
    \x20families\x20cannot\x20contain\x20the\x20new\x20line\x20character\n\
    \x20'\\n',\x20it\x20is\x20sufficient\x20to\x20use\x20'.'\x20as\x20a\x20f\
    ull\x20wildcard\x20when\x20matching\n\x20column\x20family\x20names.\n\n\
    \r\n\x05\x04\t\x02\x08\x05\x12\x04\xe6\x02\x04\n\n\r\n\x05\x04\t\x02\x08\
    \x01\x12\x04\xe6\x02\x0b#\n\r\n\x05\x04\t\x02\x08\x03\x12\x04\xe6\x02&'\
    \n\xd2\x02\n\x04\x04\t\x02\t\x12\x04\xee\x02\x04,\x1a\xc3\x02\x20Matches\
    \x20only\x20cells\x20from\x20columns\x20whose\x20qualifiers\x20satisfy\
    \x20the\x20given\x20RE2\n\x20regex.\n\x20Note\x20that,\x20since\x20colum\
    n\x20qualifiers\x20can\x20contain\x20arbitrary\x20bytes,\x20the\x20'\\C'\
    \n\x20escape\x20sequence\x20must\x20be\x20used\x20if\x20a\x20true\x20wil\
    dcard\x20is\x20desired.\x20The\x20'.'\n\x20character\x20will\x20not\x20m\
    atch\x20the\x20new\x20line\x20character\x20'\\n',\x20which\x20may\x20be\
    \n\x20present\x20in\x20a\x20binary\x20qualifier.\n\n\r\n\x05\x04\t\x02\t\
    \x05\x12\x04\xee\x02\x04\t\n\r\n\x05\x04\t\x02\t\x01\x12\x04\xee\x02\n'\
    \n\r\n\x05\x04\t\x02\t\x03\x12\x04\xee\x02*+\nG\n\x04\x04\t\x02\n\x12\
    \x04\xf1\x02\x04(\x1a9\x20Matches\x20only\x20cells\x20from\x20columns\
    \x20within\x20the\x20given\x20range.\n\n\r\n\x05\x04\t\x02\n\x06\x12\x04\
    \xf1\x02\x04\x0f\n\r\n\x05\x04\t\x02\n\x01\x12\x04\xf1\x02\x10#\n\r\n\
    \x05\x04\t\x02\n\x03\x12\x04\xf1\x02&'\nJ\n\x04\x04\t\x02\x0b\x12\x04\
    \xf4\x02\x04.\x1a<\x20Matches\x20only\x20cells\x20with\x20timestamps\x20\
    within\x20the\x20given\x20range.\n\n\r\n\x05\x04\t\x02\x0b\x06\x12\x04\
    \xf4\x02\x04\x12\n\r\n\x05\x04\t\x02\x0b\x01\x12\x04\xf4\x02\x13)\n\r\n\
    \x05\x04\t\x02\x0b\x03\x12\x04\xf4\x02,-\n\xc3\x02\n\x04\x04\t\x02\x0c\
    \x12\x04\xfb\x02\x04!\x1a\xb4\x02\x20Matches\x20only\x20cells\x20with\
    \x20values\x20that\x20satisfy\x20the\x20given\x20regular\x20expression.\
    \n\x20Note\x20that,\x20since\x20cell\x20values\x20can\x20contain\x20arbi\
    trary\x20bytes,\x20the\x20'\\C'\x20escape\n\x20sequence\x20must\x20be\
    \x20used\x20if\x20a\x20true\x20wildcard\x20is\x20desired.\x20The\x20'.'\
    \x20character\n\x20will\x20not\x20match\x20the\x20new\x20line\x20charact\
    er\x20'\\n',\x20which\x20may\x20be\x20present\x20in\x20a\n\x20binary\x20\
    value.\n\n\r\n\x05\x04\t\x02\x0c\x05\x12\x04\xfb\x02\x04\t\n\r\n\x05\x04\
    \t\x02\x0c\x01\x12\x04\xfb\x02\n\x1c\n\r\n\x05\x04\t\x02\x0c\x03\x12\x04\
    \xfb\x02\x1f\x20\nP\n\x04\x04\t\x02\r\x12\x04\xfe\x02\x04'\x1aB\x20Match\
    es\x20only\x20cells\x20with\x20values\x20that\x20fall\x20within\x20the\
    \x20given\x20range.\n\n\r\n\x05\x04\t\x02\r\x06\x12\x04\xfe\x02\x04\x0e\
    \n\r\n\x05\x04\t\x02\r\x01\x12\x04\xfe\x02\x0f!\n\r\n\x05\x04\t\x02\r\
    \x03\x12\x04\xfe\x02$&\n\xcc\x01\n\x04\x04\t\x02\x0e\x12\x04\x83\x03\x04\
    +\x1a\xbd\x01\x20Skips\x20the\x20first\x20N\x20cells\x20of\x20each\x20ro\
    w,\x20matching\x20all\x20subsequent\x20cells.\n\x20If\x20duplicate\x20ce\
    lls\x20are\x20present,\x20as\x20is\x20possible\x20when\x20using\x20an\
    \x20Interleave,\n\x20each\x20copy\x20of\x20the\x20cell\x20is\x20counted\
    \x20separately.\n\n\r\n\x05\x04\t\x02\x0e\x05\x12\x04\x83\x03\x04\t\n\r\
    \n\x05\x04\t\x02\x0e\x01\x12\x04\x83\x03\n%\n\r\n\x05\x04\t\x02\x0e\x03\
    \x12\x04\x83\x03(*\n\xb4\x01\n\x04\x04\t\x02\x0f\x12\x04\x88\x03\x04*\
    \x1a\xa5\x01\x20Matches\x20only\x20the\x20first\x20N\x20cells\x20of\x20e\
    ach\x20row.\n\x20If\x20duplicate\x20cells\x20are\x20present,\x20as\x20is\
    \x20possible\x20when\x20using\x20an\x20Interleave,\n\x20each\x20copy\x20\
    of\x20the\x20cell\x20is\x20counted\x20separately.\n\n\r\n\x05\x04\t\x02\
    \x0f\x05\x12\x04\x88\x03\x04\t\n\r\n\x05\x04\t\x02\x0f\x01\x12\x04\x88\
    \x03\n$\n\r\n\x05\x04\t\x02\x0f\x03\x12\x04\x88\x03')\n\xf3\x02\n\x04\
    \x04\t\x02\x10\x12\x04\x90\x03\x04-\x1a\xe4\x02\x20Matches\x20only\x20th\
    e\x20most\x20recent\x20N\x20cells\x20within\x20each\x20column.\x20For\
    \x20example,\n\x20if\x20N=2,\x20this\x20filter\x20would\x20match\x20colu\
    mn\x20\"foo:bar\"\x20at\x20timestamps\x2010\x20and\x209,\n\x20skip\x20al\
    l\x20earlier\x20cells\x20in\x20\"foo:bar\",\x20and\x20then\x20begin\x20m\
    atching\x20again\x20in\n\x20column\x20\"foo:bar2\".\n\x20If\x20duplicate\
    \x20cells\x20are\x20present,\x20as\x20is\x20possible\x20when\x20using\
    \x20an\x20Interleave,\n\x20each\x20copy\x20of\x20the\x20cell\x20is\x20co\
    unted\x20separately.\n\n\r\n\x05\x04\t\x02\x10\x05\x12\x04\x90\x03\x04\t\
    \n\r\n\x05\x04\t\x02\x10\x01\x12\x04\x90\x03\n'\n\r\n\x05\x04\t\x02\x10\
    \x03\x12\x04\x90\x03*,\nA\n\x04\x04\t\x02\x11\x12\x04\x93\x03\x04&\x1a3\
    \x20Replaces\x20each\x20cell's\x20value\x20with\x20the\x20empty\x20strin\
    g.\n\n\r\n\x05\x04\t\x02\x11\x05\x12\x04\x93\x03\x04\x08\n\r\n\x05\x04\t\
    \x02\x11\x01\x12\x04\x93\x03\t\x20\n\r\n\x05\x04\t\x02\x11\x03\x12\x04\
    \x93\x03#%\n\xf5\x04\n\x04\x04\t\x02\x12\x12\x04\xa2\x03\x04(\x1a\xe6\
    \x04\x20Applies\x20the\x20given\x20label\x20to\x20all\x20cells\x20in\x20\
    the\x20output\x20row.\x20This\x20allows\n\x20the\x20client\x20to\x20dete\
    rmine\x20which\x20results\x20were\x20produced\x20from\x20which\x20part\
    \x20of\n\x20the\x20filter.\n\n\x20Values\x20must\x20be\x20at\x20most\x20\
    15\x20characters\x20in\x20length,\x20and\x20match\x20the\x20RE2\n\x20pat\
    tern\x20[a-z0-9\\\\-]+\n\n\x20Due\x20to\x20a\x20technical\x20limitation,\
    \x20it\x20is\x20not\x20currently\x20possible\x20to\x20apply\n\x20multipl\
    e\x20labels\x20to\x20a\x20cell.\x20As\x20a\x20result,\x20a\x20Chain\x20m\
    ay\x20have\x20no\x20more\x20than\n\x20one\x20sub-filter\x20which\x20cont\
    ains\x20a\x20apply_label_transformer.\x20It\x20is\x20okay\x20for\n\x20an\
    \x20Interleave\x20to\x20contain\x20multiple\x20apply_label_transformers,\
    \x20as\x20they\x20will\n\x20be\x20applied\x20to\x20separate\x20copies\
    \x20of\x20the\x20input.\x20This\x20may\x20be\x20relaxed\x20in\x20the\n\
    \x20future.\n\n\r\n\x05\x04\t\x02\x12\x05\x12\x04\xa2\x03\x04\n\n\r\n\
    \x05\x04\t\x02\x12\x01\x12\x04\xa2\x03\x0b\"\n\r\n\x05\x04\t\x02\x12\x03\
    \x12\x04\xa2\x03%'\nR\n\x02\x04\n\x12\x06\xa7\x03\0\xe4\x03\x01\x1aD\x20\
    Specifies\x20a\x20particular\x20change\x20to\x20be\x20made\x20to\x20the\
    \x20contents\x20of\x20a\x20row.\n\n\x0b\n\x03\x04\n\x01\x12\x04\xa7\x03\
    \x08\x10\nH\n\x04\x04\n\x03\0\x12\x06\xa9\x03\x02\xbb\x03\x03\x1a8\x20A\
    \x20Mutation\x20which\x20sets\x20the\x20value\x20of\x20the\x20specified\
    \x20cell.\n\n\r\n\x05\x04\n\x03\0\x01\x12\x04\xa9\x03\n\x11\nk\n\x06\x04\
    \n\x03\0\x02\0\x12\x04\xac\x03\x04\x1b\x1a[\x20The\x20name\x20of\x20the\
    \x20family\x20into\x20which\x20new\x20data\x20should\x20be\x20written.\n\
    \x20Must\x20match\x20[-_.a-zA-Z0-9]+\n\n\x11\n\x07\x04\n\x03\0\x02\0\x04\
    \x12\x06\xac\x03\x04\xa9\x03\x13\n\x0f\n\x07\x04\n\x03\0\x02\0\x05\x12\
    \x04\xac\x03\x04\n\n\x0f\n\x07\x04\n\x03\0\x02\0\x01\x12\x04\xac\x03\x0b\
    \x16\n\x0f\n\x07\x04\n\x03\0\x02\0\x03\x12\x04\xac\x03\x19\x1a\n\x89\x01\
    \n\x06\x04\n\x03\0\x02\x01\x12\x04\xb0\x03\x04\x1f\x1ay\x20The\x20qualif\
    ier\x20of\x20the\x20column\x20into\x20which\x20new\x20data\x20should\x20\
    be\x20written.\n\x20Can\x20be\x20any\x20byte\x20string,\x20including\x20\
    the\x20empty\x20string.\n\n\x11\n\x07\x04\n\x03\0\x02\x01\x04\x12\x06\
    \xb0\x03\x04\xac\x03\x1b\n\x0f\n\x07\x04\n\x03\0\x02\x01\x05\x12\x04\xb0\
    \x03\x04\t\n\x0f\n\x07\x04\n\x03\0\x02\x01\x01\x12\x04\xb0\x03\n\x1a\n\
    \x0f\n\x07\x04\n\x03\0\x02\x01\x03\x12\x04\xb0\x03\x1d\x1e\n\xd3\x02\n\
    \x06\x04\n\x03\0\x02\x02\x12\x04\xb7\x03\x04\x1f\x1a\xc2\x02\x20The\x20t\
    imestamp\x20of\x20the\x20cell\x20into\x20which\x20new\x20data\x20should\
    \x20be\x20written.\n\x20Use\x20-1\x20for\x20current\x20Bigtable\x20serve\
    r\x20time.\n\x20Otherwise,\x20the\x20client\x20should\x20set\x20this\x20\
    value\x20itself,\x20noting\x20that\x20the\n\x20default\x20value\x20is\
    \x20a\x20timestamp\x20of\x20zero\x20if\x20the\x20field\x20is\x20left\x20\
    unspecified.\n\x20Values\x20must\x20match\x20the\x20\"granularity\"\x20o\
    f\x20the\x20table\x20(e.g.\x20micros,\x20millis).\n\n\x11\n\x07\x04\n\
    \x03\0\x02\x02\x04\x12\x06\xb7\x03\x04\xb0\x03\x1f\n\x0f\n\x07\x04\n\x03\
    \0\x02\x02\x05\x12\x04\xb7\x03\x04\t\n\x0f\n\x07\x04\n\x03\0\x02\x02\x01\
    \x12\x04\xb7\x03\n\x1a\n\x0f\n\x07\x04\n\x03\0\x02\x02\x03\x12\x04\xb7\
    \x03\x1d\x1e\nB\n\x06\x04\n\x03\0\x02\x03\x12\x04\xba\x03\x04\x14\x1a2\
    \x20The\x20value\x20to\x20be\x20written\x20into\x20the\x20specified\x20c\
    ell.\n\n\x11\n\x07\x04\n\x03\0\x02\x03\x04\x12\x06\xba\x03\x04\xb7\x03\
    \x1f\n\x0f\n\x07\x04\n\x03\0\x02\x03\x05\x12\x04\xba\x03\x04\t\n\x0f\n\
    \x07\x04\n\x03\0\x02\x03\x01\x12\x04\xba\x03\n\x0f\n\x0f\n\x07\x04\n\x03\
    \0\x02\x03\x03\x12\x04\xba\x03\x12\x13\n\x8d\x01\n\x04\x04\n\x03\x01\x12\
    \x06\xbf\x03\x02\xca\x03\x03\x1a}\x20A\x20Mutation\x20which\x20deletes\
    \x20cells\x20from\x20the\x20specified\x20column,\x20optionally\n\x20rest\
    ricting\x20the\x20deletions\x20to\x20a\x20given\x20timestamp\x20range.\n\
    \n\r\n\x05\x04\n\x03\x01\x01\x12\x04\xbf\x03\n\x1a\nh\n\x06\x04\n\x03\
    \x01\x02\0\x12\x04\xc2\x03\x04\x1b\x1aX\x20The\x20name\x20of\x20the\x20f\
    amily\x20from\x20which\x20cells\x20should\x20be\x20deleted.\n\x20Must\
    \x20match\x20[-_.a-zA-Z0-9]+\n\n\x11\n\x07\x04\n\x03\x01\x02\0\x04\x12\
    \x06\xc2\x03\x04\xbf\x03\x1c\n\x0f\n\x07\x04\n\x03\x01\x02\0\x05\x12\x04\
    \xc2\x03\x04\n\n\x0f\n\x07\x04\n\x03\x01\x02\0\x01\x12\x04\xc2\x03\x0b\
    \x16\n\x0f\n\x07\x04\n\x03\x01\x02\0\x03\x12\x04\xc2\x03\x19\x1a\n\x86\
    \x01\n\x06\x04\n\x03\x01\x02\x01\x12\x04\xc6\x03\x04\x1f\x1av\x20The\x20\
    qualifier\x20of\x20the\x20column\x20from\x20which\x20cells\x20should\x20\
    be\x20deleted.\n\x20Can\x20be\x20any\x20byte\x20string,\x20including\x20\
    the\x20empty\x20string.\n\n\x11\n\x07\x04\n\x03\x01\x02\x01\x04\x12\x06\
    \xc6\x03\x04\xc2\x03\x1b\n\x0f\n\x07\x04\n\x03\x01\x02\x01\x05\x12\x04\
    \xc6\x03\x04\t\n\x0f\n\x07\x04\n\x03\x01\x02\x01\x01\x12\x04\xc6\x03\n\
    \x1a\n\x0f\n\x07\x04\n\x03\x01\x02\x01\x03\x12\x04\xc6\x03\x1d\x1e\nO\n\
    \x06\x04\n\x03\x01\x02\x02\x12\x04\xc9\x03\x04\"\x1a?\x20The\x20range\
    \x20of\x20timestamps\x20within\x20which\x20cells\x20should\x20be\x20dele\
    ted.\n\n\x11\n\x07\x04\n\x03\x01\x02\x02\x04\x12\x06\xc9\x03\x04\xc6\x03\
    \x1f\n\x0f\n\x07\x04\n\x03\x01\x02\x02\x06\x12\x04\xc9\x03\x04\x12\n\x0f\
    \n\x07\x04\n\x03\x01\x02\x02\x01\x12\x04\xc9\x03\x13\x1d\n\x0f\n\x07\x04\
    \n\x03\x01\x02\x02\x03\x12\x04\xc9\x03\x20!\nV\n\x04\x04\n\x03\x02\x12\
    \x06\xcd\x03\x02\xd1\x03\x03\x1aF\x20A\x20Mutation\x20which\x20deletes\
    \x20all\x20cells\x20from\x20the\x20specified\x20column\x20family.\n\n\r\
    \n\x05\x04\n\x03\x02\x01\x12\x04\xcd\x03\n\x1a\nh\n\x06\x04\n\x03\x02\
    \x02\0\x12\x04\xd0\x03\x04\x1b\x1aX\x20The\x20name\x20of\x20the\x20famil\
    y\x20from\x20which\x20cells\x20should\x20be\x20deleted.\n\x20Must\x20mat\
    ch\x20[-_.a-zA-Z0-9]+\n\n\x11\n\x07\x04\n\x03\x02\x02\0\x04\x12\x06\xd0\
    \x03\x04\xcd\x03\x1c\n\x0f\n\x07\x04\n\x03\x02\x02\0\x05\x12\x04\xd0\x03\
    \x04\n\n\x0f\n\x07\x04\n\x03\x02\x02\0\x01\x12\x04\xd0\x03\x0b\x16\n\x0f\
    \n\x07\x04\n\x03\x02\x02\0\x03\x12\x04\xd0\x03\x19\x1a\nK\n\x04\x04\n\
    \x03\x03\x12\x04\xd4\x03\x02\x1a\x1a=\x20A\x20Mutation\x20which\x20delet\
    es\x20all\x20cells\x20from\x20the\x20containing\x20row.\n\n\r\n\x05\x04\
    \n\x03\x03\x01\x12\x04\xd4\x03\n\x17\n@\n\x04\x04\n\x08\0\x12\x06\xd7\
    \x03\x02\xe3\x03\x03\x1a0\x20Which\x20of\x20the\x20possible\x20Mutation\
    \x20types\x20to\x20apply.\n\n\r\n\x05\x04\n\x08\0\x01\x12\x04\xd7\x03\
    \x08\x10\n#\n\x04\x04\n\x02\0\x12\x04\xd9\x03\x04\x19\x1a\x15\x20Set\x20\
    a\x20cell's\x20value.\n\n\r\n\x05\x04\n\x02\0\x06\x12\x04\xd9\x03\x04\
    \x0b\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xd9\x03\x0c\x14\n\r\n\x05\x04\n\
    \x02\0\x03\x12\x04\xd9\x03\x17\x18\n,\n\x04\x04\n\x02\x01\x12\x04\xdc\
    \x03\x04,\x1a\x1e\x20Deletes\x20cells\x20from\x20a\x20column.\n\n\r\n\
    \x05\x04\n\x02\x01\x06\x12\x04\xdc\x03\x04\x14\n\r\n\x05\x04\n\x02\x01\
    \x01\x12\x04\xdc\x03\x15'\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xdc\x03*+\
    \n3\n\x04\x04\n\x02\x02\x12\x04\xdf\x03\x04,\x1a%\x20Deletes\x20cells\
    \x20from\x20a\x20column\x20family.\n\n\r\n\x05\x04\n\x02\x02\x06\x12\x04\
    \xdf\x03\x04\x14\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\xdf\x03\x15'\n\r\n\
    \x05\x04\n\x02\x02\x03\x12\x04\xdf\x03*+\n2\n\x04\x04\n\x02\x03\x12\x04\
    \xe2\x03\x04&\x1a$\x20Deletes\x20cells\x20from\x20the\x20entire\x20row.\
    \n\n\r\n\x05\x04\n\x02\x03\x06\x12\x04\xe2\x03\x04\x11\n\r\n\x05\x04\n\
    \x02\x03\x01\x12\x04\xe2\x03\x12!\n\r\n\x05\x04\n\x02\x03\x03\x12\x04\
    \xe2\x03$%\nm\n\x02\x04\x0b\x12\x06\xe8\x03\0\x80\x04\x01\x1a_\x20Specif\
    ies\x20an\x20atomic\x20read/modify/write\x20operation\x20on\x20the\x20la\
    test\x20value\x20of\x20the\n\x20specified\x20column.\n\n\x0b\n\x03\x04\
    \x0b\x01\x12\x04\xe8\x03\x08\x1b\nt\n\x04\x04\x0b\x02\0\x12\x04\xeb\x03\
    \x02\x19\x1af\x20The\x20name\x20of\x20the\x20family\x20to\x20which\x20th\
    e\x20read/modify/write\x20should\x20be\x20applied.\n\x20Must\x20match\
    \x20[-_.a-zA-Z0-9]+\n\n\x0f\n\x05\x04\x0b\x02\0\x04\x12\x06\xeb\x03\x02\
    \xe8\x03\x1d\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\xeb\x03\x02\x08\n\r\n\
    \x05\x04\x0b\x02\0\x01\x12\x04\xeb\x03\t\x14\n\r\n\x05\x04\x0b\x02\0\x03\
    \x12\x04\xeb\x03\x17\x18\n\x94\x01\n\x04\x04\x0b\x02\x01\x12\x04\xf0\x03\
    \x02\x1d\x1a\x85\x01\x20The\x20qualifier\x20of\x20the\x20column\x20to\
    \x20which\x20the\x20read/modify/write\x20should\x20be\n\x20applied.\n\
    \x20Can\x20be\x20any\x20byte\x20string,\x20including\x20the\x20empty\x20\
    string.\n\n\x0f\n\x05\x04\x0b\x02\x01\x04\x12\x06\xf0\x03\x02\xeb\x03\
    \x19\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\xf0\x03\x02\x07\n\r\n\x05\x04\
    \x0b\x02\x01\x01\x12\x04\xf0\x03\x08\x18\n\r\n\x05\x04\x0b\x02\x01\x03\
    \x12\x04\xf0\x03\x1b\x1c\nj\n\x04\x04\x0b\x08\0\x12\x06\xf4\x03\x02\xff\
    \x03\x03\x1aZ\x20The\x20rule\x20used\x20to\x20determine\x20the\x20column\
    's\x20new\x20latest\x20value\x20from\x20its\x20current\n\x20latest\x20va\
    lue.\n\n\r\n\x05\x04\x0b\x08\0\x01\x12\x04\xf4\x03\x08\x0c\n\xab\x01\n\
    \x04\x04\x0b\x02\x02\x12\x04\xf8\x03\x04\x1b\x1a\x9c\x01\x20Rule\x20spec\
    ifying\x20that\x20\"append_value\"\x20be\x20appended\x20to\x20the\x20exi\
    sting\x20value.\n\x20If\x20the\x20targeted\x20cell\x20is\x20unset,\x20it\
    \x20will\x20be\x20treated\x20as\x20containing\x20the\n\x20empty\x20strin\
    g.\n\n\r\n\x05\x04\x0b\x02\x02\x05\x12\x04\xf8\x03\x04\t\n\r\n\x05\x04\
    \x0b\x02\x02\x01\x12\x04\xf8\x03\n\x16\n\r\n\x05\x04\x0b\x02\x02\x03\x12\
    \x04\xf8\x03\x19\x1a\n\xb3\x02\n\x04\x04\x0b\x02\x03\x12\x04\xfe\x03\x04\
    \x1f\x1a\xa4\x02\x20Rule\x20specifying\x20that\x20\"increment_amount\"\
    \x20be\x20added\x20to\x20the\x20existing\x20value.\n\x20If\x20the\x20tar\
    geted\x20cell\x20is\x20unset,\x20it\x20will\x20be\x20treated\x20as\x20co\
    ntaining\x20a\x20zero.\n\x20Otherwise,\x20the\x20targeted\x20cell\x20mus\
    t\x20contain\x20an\x208-byte\x20value\x20(interpreted\n\x20as\x20a\x2064\
    -bit\x20big-endian\x20signed\x20integer),\x20or\x20the\x20entire\x20requ\
    est\x20will\x20fail.\n\n\r\n\x05\x04\x0b\x02\x03\x05\x12\x04\xfe\x03\x04\
    \t\n\r\n\x05\x04\x0b\x02\x03\x01\x12\x04\xfe\x03\n\x1a\n\r\n\x05\x04\x0b\
    \x02\x03\x03\x12\x04\xfe\x03\x1d\x1eb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
