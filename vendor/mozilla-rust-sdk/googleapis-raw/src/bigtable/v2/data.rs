// This file is generated by rust-protobuf 2.22.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/bigtable/v2/data.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_22_0;

#[derive(PartialEq,Clone,Default)]
pub struct Row {
    // message fields
    pub key: ::std::vec::Vec<u8>,
    pub families: ::protobuf::RepeatedField<Family>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Row {
    fn default() -> &'a Row {
        <Row as ::protobuf::Message>::default_instance()
    }
}

impl Row {
    pub fn new() -> Row {
        ::std::default::Default::default()
    }

    // bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // repeated .google.bigtable.v2.Family families = 2;


    pub fn get_families(&self) -> &[Family] {
        &self.families
    }
    pub fn clear_families(&mut self) {
        self.families.clear();
    }

    // Param is passed by value, moved
    pub fn set_families(&mut self, v: ::protobuf::RepeatedField<Family>) {
        self.families = v;
    }

    // Mutable pointer to the field.
    pub fn mut_families(&mut self) -> &mut ::protobuf::RepeatedField<Family> {
        &mut self.families
    }

    // Take field
    pub fn take_families(&mut self) -> ::protobuf::RepeatedField<Family> {
        ::std::mem::replace(&mut self.families, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Row {
    fn is_initialized(&self) -> bool {
        for v in &self.families {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.families)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        for value in &self.families {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        for v in &self.families {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Row {
        Row::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key",
                |m: &Row| { &m.key },
                |m: &mut Row| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Family>>(
                "families",
                |m: &Row| { &m.families },
                |m: &mut Row| { &mut m.families },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Row>(
                "Row",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Row {
        static instance: ::protobuf::rt::LazyV2<Row> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Row::new)
    }
}

impl ::protobuf::Clear for Row {
    fn clear(&mut self) {
        self.key.clear();
        self.families.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Row {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Row {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Family {
    // message fields
    pub name: ::std::string::String,
    pub columns: ::protobuf::RepeatedField<Column>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Family {
    fn default() -> &'a Family {
        <Family as ::protobuf::Message>::default_instance()
    }
}

impl Family {
    pub fn new() -> Family {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .google.bigtable.v2.Column columns = 2;


    pub fn get_columns(&self) -> &[Column] {
        &self.columns
    }
    pub fn clear_columns(&mut self) {
        self.columns.clear();
    }

    // Param is passed by value, moved
    pub fn set_columns(&mut self, v: ::protobuf::RepeatedField<Column>) {
        self.columns = v;
    }

    // Mutable pointer to the field.
    pub fn mut_columns(&mut self) -> &mut ::protobuf::RepeatedField<Column> {
        &mut self.columns
    }

    // Take field
    pub fn take_columns(&mut self) -> ::protobuf::RepeatedField<Column> {
        ::std::mem::replace(&mut self.columns, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Family {
    fn is_initialized(&self) -> bool {
        for v in &self.columns {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.columns)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.columns {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.columns {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Family {
        Family::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Family| { &m.name },
                |m: &mut Family| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Column>>(
                "columns",
                |m: &Family| { &m.columns },
                |m: &mut Family| { &mut m.columns },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Family>(
                "Family",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Family {
        static instance: ::protobuf::rt::LazyV2<Family> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Family::new)
    }
}

impl ::protobuf::Clear for Family {
    fn clear(&mut self) {
        self.name.clear();
        self.columns.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Family {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Family {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Column {
    // message fields
    pub qualifier: ::std::vec::Vec<u8>,
    pub cells: ::protobuf::RepeatedField<Cell>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Column {
    fn default() -> &'a Column {
        <Column as ::protobuf::Message>::default_instance()
    }
}

impl Column {
    pub fn new() -> Column {
        ::std::default::Default::default()
    }

    // bytes qualifier = 1;


    pub fn get_qualifier(&self) -> &[u8] {
        &self.qualifier
    }
    pub fn clear_qualifier(&mut self) {
        self.qualifier.clear();
    }

    // Param is passed by value, moved
    pub fn set_qualifier(&mut self, v: ::std::vec::Vec<u8>) {
        self.qualifier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_qualifier(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.qualifier
    }

    // Take field
    pub fn take_qualifier(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.qualifier, ::std::vec::Vec::new())
    }

    // repeated .google.bigtable.v2.Cell cells = 2;


    pub fn get_cells(&self) -> &[Cell] {
        &self.cells
    }
    pub fn clear_cells(&mut self) {
        self.cells.clear();
    }

    // Param is passed by value, moved
    pub fn set_cells(&mut self, v: ::protobuf::RepeatedField<Cell>) {
        self.cells = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cells(&mut self) -> &mut ::protobuf::RepeatedField<Cell> {
        &mut self.cells
    }

    // Take field
    pub fn take_cells(&mut self) -> ::protobuf::RepeatedField<Cell> {
        ::std::mem::replace(&mut self.cells, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Column {
    fn is_initialized(&self) -> bool {
        for v in &self.cells {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.qualifier)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cells)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.qualifier.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.qualifier);
        }
        for value in &self.cells {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.qualifier.is_empty() {
            os.write_bytes(1, &self.qualifier)?;
        }
        for v in &self.cells {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Column {
        Column::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "qualifier",
                |m: &Column| { &m.qualifier },
                |m: &mut Column| { &mut m.qualifier },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Cell>>(
                "cells",
                |m: &Column| { &m.cells },
                |m: &mut Column| { &mut m.cells },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Column>(
                "Column",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Column {
        static instance: ::protobuf::rt::LazyV2<Column> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Column::new)
    }
}

impl ::protobuf::Clear for Column {
    fn clear(&mut self) {
        self.qualifier.clear();
        self.cells.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Column {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Column {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Cell {
    // message fields
    pub timestamp_micros: i64,
    pub value: ::std::vec::Vec<u8>,
    pub labels: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Cell {
    fn default() -> &'a Cell {
        <Cell as ::protobuf::Message>::default_instance()
    }
}

impl Cell {
    pub fn new() -> Cell {
        ::std::default::Default::default()
    }

    // int64 timestamp_micros = 1;


    pub fn get_timestamp_micros(&self) -> i64 {
        self.timestamp_micros
    }
    pub fn clear_timestamp_micros(&mut self) {
        self.timestamp_micros = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp_micros(&mut self, v: i64) {
        self.timestamp_micros = v;
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // repeated string labels = 3;


    pub fn get_labels(&self) -> &[::std::string::String] {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Cell {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp_micros = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.timestamp_micros != 0 {
            my_size += ::protobuf::rt::value_size(1, self.timestamp_micros, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        for value in &self.labels {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.timestamp_micros != 0 {
            os.write_int64(1, self.timestamp_micros)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        for v in &self.labels {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Cell {
        Cell::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp_micros",
                |m: &Cell| { &m.timestamp_micros },
                |m: &mut Cell| { &mut m.timestamp_micros },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &Cell| { &m.value },
                |m: &mut Cell| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "labels",
                |m: &Cell| { &m.labels },
                |m: &mut Cell| { &mut m.labels },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Cell>(
                "Cell",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Cell {
        static instance: ::protobuf::rt::LazyV2<Cell> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Cell::new)
    }
}

impl ::protobuf::Clear for Cell {
    fn clear(&mut self) {
        self.timestamp_micros = 0;
        self.value.clear();
        self.labels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Cell {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cell {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RowRange {
    // message oneof groups
    pub start_key: ::std::option::Option<RowRange_oneof_start_key>,
    pub end_key: ::std::option::Option<RowRange_oneof_end_key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RowRange {
    fn default() -> &'a RowRange {
        <RowRange as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RowRange_oneof_start_key {
    start_key_closed(::std::vec::Vec<u8>),
    start_key_open(::std::vec::Vec<u8>),
}

#[derive(Clone,PartialEq,Debug)]
pub enum RowRange_oneof_end_key {
    end_key_open(::std::vec::Vec<u8>),
    end_key_closed(::std::vec::Vec<u8>),
}

impl RowRange {
    pub fn new() -> RowRange {
        ::std::default::Default::default()
    }

    // bytes start_key_closed = 1;


    pub fn get_start_key_closed(&self) -> &[u8] {
        match self.start_key {
            ::std::option::Option::Some(RowRange_oneof_start_key::start_key_closed(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_start_key_closed(&mut self) {
        self.start_key = ::std::option::Option::None;
    }

    pub fn has_start_key_closed(&self) -> bool {
        match self.start_key {
            ::std::option::Option::Some(RowRange_oneof_start_key::start_key_closed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start_key_closed(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_key = ::std::option::Option::Some(RowRange_oneof_start_key::start_key_closed(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start_key_closed(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(RowRange_oneof_start_key::start_key_closed(_)) = self.start_key {
        } else {
            self.start_key = ::std::option::Option::Some(RowRange_oneof_start_key::start_key_closed(::std::vec::Vec::new()));
        }
        match self.start_key {
            ::std::option::Option::Some(RowRange_oneof_start_key::start_key_closed(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start_key_closed(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_start_key_closed() {
            match self.start_key.take() {
                ::std::option::Option::Some(RowRange_oneof_start_key::start_key_closed(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bytes start_key_open = 2;


    pub fn get_start_key_open(&self) -> &[u8] {
        match self.start_key {
            ::std::option::Option::Some(RowRange_oneof_start_key::start_key_open(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_start_key_open(&mut self) {
        self.start_key = ::std::option::Option::None;
    }

    pub fn has_start_key_open(&self) -> bool {
        match self.start_key {
            ::std::option::Option::Some(RowRange_oneof_start_key::start_key_open(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start_key_open(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_key = ::std::option::Option::Some(RowRange_oneof_start_key::start_key_open(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start_key_open(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(RowRange_oneof_start_key::start_key_open(_)) = self.start_key {
        } else {
            self.start_key = ::std::option::Option::Some(RowRange_oneof_start_key::start_key_open(::std::vec::Vec::new()));
        }
        match self.start_key {
            ::std::option::Option::Some(RowRange_oneof_start_key::start_key_open(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start_key_open(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_start_key_open() {
            match self.start_key.take() {
                ::std::option::Option::Some(RowRange_oneof_start_key::start_key_open(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bytes end_key_open = 3;


    pub fn get_end_key_open(&self) -> &[u8] {
        match self.end_key {
            ::std::option::Option::Some(RowRange_oneof_end_key::end_key_open(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_end_key_open(&mut self) {
        self.end_key = ::std::option::Option::None;
    }

    pub fn has_end_key_open(&self) -> bool {
        match self.end_key {
            ::std::option::Option::Some(RowRange_oneof_end_key::end_key_open(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_end_key_open(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_key = ::std::option::Option::Some(RowRange_oneof_end_key::end_key_open(v))
    }

    // Mutable pointer to the field.
    pub fn mut_end_key_open(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(RowRange_oneof_end_key::end_key_open(_)) = self.end_key {
        } else {
            self.end_key = ::std::option::Option::Some(RowRange_oneof_end_key::end_key_open(::std::vec::Vec::new()));
        }
        match self.end_key {
            ::std::option::Option::Some(RowRange_oneof_end_key::end_key_open(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_end_key_open(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_end_key_open() {
            match self.end_key.take() {
                ::std::option::Option::Some(RowRange_oneof_end_key::end_key_open(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bytes end_key_closed = 4;


    pub fn get_end_key_closed(&self) -> &[u8] {
        match self.end_key {
            ::std::option::Option::Some(RowRange_oneof_end_key::end_key_closed(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_end_key_closed(&mut self) {
        self.end_key = ::std::option::Option::None;
    }

    pub fn has_end_key_closed(&self) -> bool {
        match self.end_key {
            ::std::option::Option::Some(RowRange_oneof_end_key::end_key_closed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_end_key_closed(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_key = ::std::option::Option::Some(RowRange_oneof_end_key::end_key_closed(v))
    }

    // Mutable pointer to the field.
    pub fn mut_end_key_closed(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(RowRange_oneof_end_key::end_key_closed(_)) = self.end_key {
        } else {
            self.end_key = ::std::option::Option::Some(RowRange_oneof_end_key::end_key_closed(::std::vec::Vec::new()));
        }
        match self.end_key {
            ::std::option::Option::Some(RowRange_oneof_end_key::end_key_closed(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_end_key_closed(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_end_key_closed() {
            match self.end_key.take() {
                ::std::option::Option::Some(RowRange_oneof_end_key::end_key_closed(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }
}

impl ::protobuf::Message for RowRange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.start_key = ::std::option::Option::Some(RowRange_oneof_start_key::start_key_closed(is.read_bytes()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.start_key = ::std::option::Option::Some(RowRange_oneof_start_key::start_key_open(is.read_bytes()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.end_key = ::std::option::Option::Some(RowRange_oneof_end_key::end_key_open(is.read_bytes()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.end_key = ::std::option::Option::Some(RowRange_oneof_end_key::end_key_closed(is.read_bytes()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.start_key {
            match v {
                &RowRange_oneof_start_key::start_key_closed(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(1, &v);
                },
                &RowRange_oneof_start_key::start_key_open(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.end_key {
            match v {
                &RowRange_oneof_end_key::end_key_open(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(3, &v);
                },
                &RowRange_oneof_end_key::end_key_closed(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(4, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.start_key {
            match v {
                &RowRange_oneof_start_key::start_key_closed(ref v) => {
                    os.write_bytes(1, v)?;
                },
                &RowRange_oneof_start_key::start_key_open(ref v) => {
                    os.write_bytes(2, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.end_key {
            match v {
                &RowRange_oneof_end_key::end_key_open(ref v) => {
                    os.write_bytes(3, v)?;
                },
                &RowRange_oneof_end_key::end_key_closed(ref v) => {
                    os.write_bytes(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RowRange {
        RowRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "start_key_closed",
                RowRange::has_start_key_closed,
                RowRange::get_start_key_closed,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "start_key_open",
                RowRange::has_start_key_open,
                RowRange::get_start_key_open,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "end_key_open",
                RowRange::has_end_key_open,
                RowRange::get_end_key_open,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "end_key_closed",
                RowRange::has_end_key_closed,
                RowRange::get_end_key_closed,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RowRange>(
                "RowRange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RowRange {
        static instance: ::protobuf::rt::LazyV2<RowRange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RowRange::new)
    }
}

impl ::protobuf::Clear for RowRange {
    fn clear(&mut self) {
        self.start_key = ::std::option::Option::None;
        self.start_key = ::std::option::Option::None;
        self.end_key = ::std::option::Option::None;
        self.end_key = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RowRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RowRange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RowSet {
    // message fields
    pub row_keys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub row_ranges: ::protobuf::RepeatedField<RowRange>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RowSet {
    fn default() -> &'a RowSet {
        <RowSet as ::protobuf::Message>::default_instance()
    }
}

impl RowSet {
    pub fn new() -> RowSet {
        ::std::default::Default::default()
    }

    // repeated bytes row_keys = 1;


    pub fn get_row_keys(&self) -> &[::std::vec::Vec<u8>] {
        &self.row_keys
    }
    pub fn clear_row_keys(&mut self) {
        self.row_keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_row_keys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.row_keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_row_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.row_keys
    }

    // Take field
    pub fn take_row_keys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.row_keys, ::protobuf::RepeatedField::new())
    }

    // repeated .google.bigtable.v2.RowRange row_ranges = 2;


    pub fn get_row_ranges(&self) -> &[RowRange] {
        &self.row_ranges
    }
    pub fn clear_row_ranges(&mut self) {
        self.row_ranges.clear();
    }

    // Param is passed by value, moved
    pub fn set_row_ranges(&mut self, v: ::protobuf::RepeatedField<RowRange>) {
        self.row_ranges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_row_ranges(&mut self) -> &mut ::protobuf::RepeatedField<RowRange> {
        &mut self.row_ranges
    }

    // Take field
    pub fn take_row_ranges(&mut self) -> ::protobuf::RepeatedField<RowRange> {
        ::std::mem::replace(&mut self.row_ranges, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RowSet {
    fn is_initialized(&self) -> bool {
        for v in &self.row_ranges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.row_keys)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.row_ranges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.row_keys {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        for value in &self.row_ranges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.row_keys {
            os.write_bytes(1, &v)?;
        };
        for v in &self.row_ranges {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RowSet {
        RowSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "row_keys",
                |m: &RowSet| { &m.row_keys },
                |m: &mut RowSet| { &mut m.row_keys },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RowRange>>(
                "row_ranges",
                |m: &RowSet| { &m.row_ranges },
                |m: &mut RowSet| { &mut m.row_ranges },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RowSet>(
                "RowSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RowSet {
        static instance: ::protobuf::rt::LazyV2<RowSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RowSet::new)
    }
}

impl ::protobuf::Clear for RowSet {
    fn clear(&mut self) {
        self.row_keys.clear();
        self.row_ranges.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RowSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RowSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ColumnRange {
    // message fields
    pub family_name: ::std::string::String,
    // message oneof groups
    pub start_qualifier: ::std::option::Option<ColumnRange_oneof_start_qualifier>,
    pub end_qualifier: ::std::option::Option<ColumnRange_oneof_end_qualifier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ColumnRange {
    fn default() -> &'a ColumnRange {
        <ColumnRange as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ColumnRange_oneof_start_qualifier {
    start_qualifier_closed(::std::vec::Vec<u8>),
    start_qualifier_open(::std::vec::Vec<u8>),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ColumnRange_oneof_end_qualifier {
    end_qualifier_closed(::std::vec::Vec<u8>),
    end_qualifier_open(::std::vec::Vec<u8>),
}

impl ColumnRange {
    pub fn new() -> ColumnRange {
        ::std::default::Default::default()
    }

    // string family_name = 1;


    pub fn get_family_name(&self) -> &str {
        &self.family_name
    }
    pub fn clear_family_name(&mut self) {
        self.family_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_family_name(&mut self, v: ::std::string::String) {
        self.family_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_family_name(&mut self) -> &mut ::std::string::String {
        &mut self.family_name
    }

    // Take field
    pub fn take_family_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.family_name, ::std::string::String::new())
    }

    // bytes start_qualifier_closed = 2;


    pub fn get_start_qualifier_closed(&self) -> &[u8] {
        match self.start_qualifier {
            ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_closed(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_start_qualifier_closed(&mut self) {
        self.start_qualifier = ::std::option::Option::None;
    }

    pub fn has_start_qualifier_closed(&self) -> bool {
        match self.start_qualifier {
            ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_closed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start_qualifier_closed(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_qualifier = ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_closed(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start_qualifier_closed(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_closed(_)) = self.start_qualifier {
        } else {
            self.start_qualifier = ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_closed(::std::vec::Vec::new()));
        }
        match self.start_qualifier {
            ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_closed(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start_qualifier_closed(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_start_qualifier_closed() {
            match self.start_qualifier.take() {
                ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_closed(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bytes start_qualifier_open = 3;


    pub fn get_start_qualifier_open(&self) -> &[u8] {
        match self.start_qualifier {
            ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_open(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_start_qualifier_open(&mut self) {
        self.start_qualifier = ::std::option::Option::None;
    }

    pub fn has_start_qualifier_open(&self) -> bool {
        match self.start_qualifier {
            ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_open(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start_qualifier_open(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_qualifier = ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_open(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start_qualifier_open(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_open(_)) = self.start_qualifier {
        } else {
            self.start_qualifier = ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_open(::std::vec::Vec::new()));
        }
        match self.start_qualifier {
            ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_open(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start_qualifier_open(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_start_qualifier_open() {
            match self.start_qualifier.take() {
                ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_open(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bytes end_qualifier_closed = 4;


    pub fn get_end_qualifier_closed(&self) -> &[u8] {
        match self.end_qualifier {
            ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_closed(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_end_qualifier_closed(&mut self) {
        self.end_qualifier = ::std::option::Option::None;
    }

    pub fn has_end_qualifier_closed(&self) -> bool {
        match self.end_qualifier {
            ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_closed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_end_qualifier_closed(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_qualifier = ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_closed(v))
    }

    // Mutable pointer to the field.
    pub fn mut_end_qualifier_closed(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_closed(_)) = self.end_qualifier {
        } else {
            self.end_qualifier = ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_closed(::std::vec::Vec::new()));
        }
        match self.end_qualifier {
            ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_closed(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_end_qualifier_closed(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_end_qualifier_closed() {
            match self.end_qualifier.take() {
                ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_closed(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bytes end_qualifier_open = 5;


    pub fn get_end_qualifier_open(&self) -> &[u8] {
        match self.end_qualifier {
            ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_open(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_end_qualifier_open(&mut self) {
        self.end_qualifier = ::std::option::Option::None;
    }

    pub fn has_end_qualifier_open(&self) -> bool {
        match self.end_qualifier {
            ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_open(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_end_qualifier_open(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_qualifier = ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_open(v))
    }

    // Mutable pointer to the field.
    pub fn mut_end_qualifier_open(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_open(_)) = self.end_qualifier {
        } else {
            self.end_qualifier = ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_open(::std::vec::Vec::new()));
        }
        match self.end_qualifier {
            ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_open(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_end_qualifier_open(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_end_qualifier_open() {
            match self.end_qualifier.take() {
                ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_open(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }
}

impl ::protobuf::Message for ColumnRange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.family_name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.start_qualifier = ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_closed(is.read_bytes()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.start_qualifier = ::std::option::Option::Some(ColumnRange_oneof_start_qualifier::start_qualifier_open(is.read_bytes()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.end_qualifier = ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_closed(is.read_bytes()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.end_qualifier = ::std::option::Option::Some(ColumnRange_oneof_end_qualifier::end_qualifier_open(is.read_bytes()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.family_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.family_name);
        }
        if let ::std::option::Option::Some(ref v) = self.start_qualifier {
            match v {
                &ColumnRange_oneof_start_qualifier::start_qualifier_closed(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
                &ColumnRange_oneof_start_qualifier::start_qualifier_open(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(3, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.end_qualifier {
            match v {
                &ColumnRange_oneof_end_qualifier::end_qualifier_closed(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(4, &v);
                },
                &ColumnRange_oneof_end_qualifier::end_qualifier_open(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(5, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.family_name.is_empty() {
            os.write_string(1, &self.family_name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.start_qualifier {
            match v {
                &ColumnRange_oneof_start_qualifier::start_qualifier_closed(ref v) => {
                    os.write_bytes(2, v)?;
                },
                &ColumnRange_oneof_start_qualifier::start_qualifier_open(ref v) => {
                    os.write_bytes(3, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.end_qualifier {
            match v {
                &ColumnRange_oneof_end_qualifier::end_qualifier_closed(ref v) => {
                    os.write_bytes(4, v)?;
                },
                &ColumnRange_oneof_end_qualifier::end_qualifier_open(ref v) => {
                    os.write_bytes(5, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ColumnRange {
        ColumnRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "family_name",
                |m: &ColumnRange| { &m.family_name },
                |m: &mut ColumnRange| { &mut m.family_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "start_qualifier_closed",
                ColumnRange::has_start_qualifier_closed,
                ColumnRange::get_start_qualifier_closed,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "start_qualifier_open",
                ColumnRange::has_start_qualifier_open,
                ColumnRange::get_start_qualifier_open,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "end_qualifier_closed",
                ColumnRange::has_end_qualifier_closed,
                ColumnRange::get_end_qualifier_closed,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "end_qualifier_open",
                ColumnRange::has_end_qualifier_open,
                ColumnRange::get_end_qualifier_open,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ColumnRange>(
                "ColumnRange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ColumnRange {
        static instance: ::protobuf::rt::LazyV2<ColumnRange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ColumnRange::new)
    }
}

impl ::protobuf::Clear for ColumnRange {
    fn clear(&mut self) {
        self.family_name.clear();
        self.start_qualifier = ::std::option::Option::None;
        self.start_qualifier = ::std::option::Option::None;
        self.end_qualifier = ::std::option::Option::None;
        self.end_qualifier = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ColumnRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColumnRange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimestampRange {
    // message fields
    pub start_timestamp_micros: i64,
    pub end_timestamp_micros: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimestampRange {
    fn default() -> &'a TimestampRange {
        <TimestampRange as ::protobuf::Message>::default_instance()
    }
}

impl TimestampRange {
    pub fn new() -> TimestampRange {
        ::std::default::Default::default()
    }

    // int64 start_timestamp_micros = 1;


    pub fn get_start_timestamp_micros(&self) -> i64 {
        self.start_timestamp_micros
    }
    pub fn clear_start_timestamp_micros(&mut self) {
        self.start_timestamp_micros = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_timestamp_micros(&mut self, v: i64) {
        self.start_timestamp_micros = v;
    }

    // int64 end_timestamp_micros = 2;


    pub fn get_end_timestamp_micros(&self) -> i64 {
        self.end_timestamp_micros
    }
    pub fn clear_end_timestamp_micros(&mut self) {
        self.end_timestamp_micros = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_timestamp_micros(&mut self, v: i64) {
        self.end_timestamp_micros = v;
    }
}

impl ::protobuf::Message for TimestampRange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.start_timestamp_micros = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.end_timestamp_micros = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start_timestamp_micros != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start_timestamp_micros, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.end_timestamp_micros != 0 {
            my_size += ::protobuf::rt::value_size(2, self.end_timestamp_micros, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.start_timestamp_micros != 0 {
            os.write_int64(1, self.start_timestamp_micros)?;
        }
        if self.end_timestamp_micros != 0 {
            os.write_int64(2, self.end_timestamp_micros)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimestampRange {
        TimestampRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "start_timestamp_micros",
                |m: &TimestampRange| { &m.start_timestamp_micros },
                |m: &mut TimestampRange| { &mut m.start_timestamp_micros },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "end_timestamp_micros",
                |m: &TimestampRange| { &m.end_timestamp_micros },
                |m: &mut TimestampRange| { &mut m.end_timestamp_micros },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TimestampRange>(
                "TimestampRange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TimestampRange {
        static instance: ::protobuf::rt::LazyV2<TimestampRange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TimestampRange::new)
    }
}

impl ::protobuf::Clear for TimestampRange {
    fn clear(&mut self) {
        self.start_timestamp_micros = 0;
        self.end_timestamp_micros = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimestampRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimestampRange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ValueRange {
    // message oneof groups
    pub start_value: ::std::option::Option<ValueRange_oneof_start_value>,
    pub end_value: ::std::option::Option<ValueRange_oneof_end_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ValueRange {
    fn default() -> &'a ValueRange {
        <ValueRange as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ValueRange_oneof_start_value {
    start_value_closed(::std::vec::Vec<u8>),
    start_value_open(::std::vec::Vec<u8>),
}

#[derive(Clone,PartialEq,Debug)]
pub enum ValueRange_oneof_end_value {
    end_value_closed(::std::vec::Vec<u8>),
    end_value_open(::std::vec::Vec<u8>),
}

impl ValueRange {
    pub fn new() -> ValueRange {
        ::std::default::Default::default()
    }

    // bytes start_value_closed = 1;


    pub fn get_start_value_closed(&self) -> &[u8] {
        match self.start_value {
            ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_closed(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_start_value_closed(&mut self) {
        self.start_value = ::std::option::Option::None;
    }

    pub fn has_start_value_closed(&self) -> bool {
        match self.start_value {
            ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_closed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start_value_closed(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_value = ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_closed(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start_value_closed(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_closed(_)) = self.start_value {
        } else {
            self.start_value = ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_closed(::std::vec::Vec::new()));
        }
        match self.start_value {
            ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_closed(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start_value_closed(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_start_value_closed() {
            match self.start_value.take() {
                ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_closed(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bytes start_value_open = 2;


    pub fn get_start_value_open(&self) -> &[u8] {
        match self.start_value {
            ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_open(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_start_value_open(&mut self) {
        self.start_value = ::std::option::Option::None;
    }

    pub fn has_start_value_open(&self) -> bool {
        match self.start_value {
            ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_open(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start_value_open(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_value = ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_open(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start_value_open(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_open(_)) = self.start_value {
        } else {
            self.start_value = ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_open(::std::vec::Vec::new()));
        }
        match self.start_value {
            ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_open(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start_value_open(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_start_value_open() {
            match self.start_value.take() {
                ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_open(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bytes end_value_closed = 3;


    pub fn get_end_value_closed(&self) -> &[u8] {
        match self.end_value {
            ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_closed(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_end_value_closed(&mut self) {
        self.end_value = ::std::option::Option::None;
    }

    pub fn has_end_value_closed(&self) -> bool {
        match self.end_value {
            ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_closed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_end_value_closed(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_value = ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_closed(v))
    }

    // Mutable pointer to the field.
    pub fn mut_end_value_closed(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_closed(_)) = self.end_value {
        } else {
            self.end_value = ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_closed(::std::vec::Vec::new()));
        }
        match self.end_value {
            ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_closed(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_end_value_closed(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_end_value_closed() {
            match self.end_value.take() {
                ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_closed(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bytes end_value_open = 4;


    pub fn get_end_value_open(&self) -> &[u8] {
        match self.end_value {
            ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_open(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_end_value_open(&mut self) {
        self.end_value = ::std::option::Option::None;
    }

    pub fn has_end_value_open(&self) -> bool {
        match self.end_value {
            ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_open(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_end_value_open(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_value = ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_open(v))
    }

    // Mutable pointer to the field.
    pub fn mut_end_value_open(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_open(_)) = self.end_value {
        } else {
            self.end_value = ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_open(::std::vec::Vec::new()));
        }
        match self.end_value {
            ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_open(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_end_value_open(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_end_value_open() {
            match self.end_value.take() {
                ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_open(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }
}

impl ::protobuf::Message for ValueRange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.start_value = ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_closed(is.read_bytes()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.start_value = ::std::option::Option::Some(ValueRange_oneof_start_value::start_value_open(is.read_bytes()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.end_value = ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_closed(is.read_bytes()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.end_value = ::std::option::Option::Some(ValueRange_oneof_end_value::end_value_open(is.read_bytes()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.start_value {
            match v {
                &ValueRange_oneof_start_value::start_value_closed(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(1, &v);
                },
                &ValueRange_oneof_start_value::start_value_open(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.end_value {
            match v {
                &ValueRange_oneof_end_value::end_value_closed(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(3, &v);
                },
                &ValueRange_oneof_end_value::end_value_open(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(4, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.start_value {
            match v {
                &ValueRange_oneof_start_value::start_value_closed(ref v) => {
                    os.write_bytes(1, v)?;
                },
                &ValueRange_oneof_start_value::start_value_open(ref v) => {
                    os.write_bytes(2, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.end_value {
            match v {
                &ValueRange_oneof_end_value::end_value_closed(ref v) => {
                    os.write_bytes(3, v)?;
                },
                &ValueRange_oneof_end_value::end_value_open(ref v) => {
                    os.write_bytes(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ValueRange {
        ValueRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "start_value_closed",
                ValueRange::has_start_value_closed,
                ValueRange::get_start_value_closed,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "start_value_open",
                ValueRange::has_start_value_open,
                ValueRange::get_start_value_open,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "end_value_closed",
                ValueRange::has_end_value_closed,
                ValueRange::get_end_value_closed,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "end_value_open",
                ValueRange::has_end_value_open,
                ValueRange::get_end_value_open,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ValueRange>(
                "ValueRange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ValueRange {
        static instance: ::protobuf::rt::LazyV2<ValueRange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ValueRange::new)
    }
}

impl ::protobuf::Clear for ValueRange {
    fn clear(&mut self) {
        self.start_value = ::std::option::Option::None;
        self.start_value = ::std::option::Option::None;
        self.end_value = ::std::option::Option::None;
        self.end_value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ValueRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValueRange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RowFilter {
    // message oneof groups
    pub filter: ::std::option::Option<RowFilter_oneof_filter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RowFilter {
    fn default() -> &'a RowFilter {
        <RowFilter as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RowFilter_oneof_filter {
    chain(RowFilter_Chain),
    interleave(RowFilter_Interleave),
    condition(RowFilter_Condition),
    sink(bool),
    pass_all_filter(bool),
    block_all_filter(bool),
    row_key_regex_filter(::std::vec::Vec<u8>),
    row_sample_filter(f64),
    family_name_regex_filter(::std::string::String),
    column_qualifier_regex_filter(::std::vec::Vec<u8>),
    column_range_filter(ColumnRange),
    timestamp_range_filter(TimestampRange),
    value_regex_filter(::std::vec::Vec<u8>),
    value_range_filter(ValueRange),
    cells_per_row_offset_filter(i32),
    cells_per_row_limit_filter(i32),
    cells_per_column_limit_filter(i32),
    strip_value_transformer(bool),
    apply_label_transformer(::std::string::String),
}

impl RowFilter {
    pub fn new() -> RowFilter {
        ::std::default::Default::default()
    }

    // .google.bigtable.v2.RowFilter.Chain chain = 1;


    pub fn get_chain(&self) -> &RowFilter_Chain {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::chain(ref v)) => v,
            _ => <RowFilter_Chain as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_chain(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_chain(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::chain(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chain(&mut self, v: RowFilter_Chain) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::chain(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chain(&mut self) -> &mut RowFilter_Chain {
        if let ::std::option::Option::Some(RowFilter_oneof_filter::chain(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::chain(RowFilter_Chain::new()));
        }
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::chain(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chain(&mut self) -> RowFilter_Chain {
        if self.has_chain() {
            match self.filter.take() {
                ::std::option::Option::Some(RowFilter_oneof_filter::chain(v)) => v,
                _ => panic!(),
            }
        } else {
            RowFilter_Chain::new()
        }
    }

    // .google.bigtable.v2.RowFilter.Interleave interleave = 2;


    pub fn get_interleave(&self) -> &RowFilter_Interleave {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::interleave(ref v)) => v,
            _ => <RowFilter_Interleave as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_interleave(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_interleave(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::interleave(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_interleave(&mut self, v: RowFilter_Interleave) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::interleave(v))
    }

    // Mutable pointer to the field.
    pub fn mut_interleave(&mut self) -> &mut RowFilter_Interleave {
        if let ::std::option::Option::Some(RowFilter_oneof_filter::interleave(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::interleave(RowFilter_Interleave::new()));
        }
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::interleave(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_interleave(&mut self) -> RowFilter_Interleave {
        if self.has_interleave() {
            match self.filter.take() {
                ::std::option::Option::Some(RowFilter_oneof_filter::interleave(v)) => v,
                _ => panic!(),
            }
        } else {
            RowFilter_Interleave::new()
        }
    }

    // .google.bigtable.v2.RowFilter.Condition condition = 3;


    pub fn get_condition(&self) -> &RowFilter_Condition {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::condition(ref v)) => v,
            _ => <RowFilter_Condition as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_condition(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_condition(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::condition(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_condition(&mut self, v: RowFilter_Condition) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::condition(v))
    }

    // Mutable pointer to the field.
    pub fn mut_condition(&mut self) -> &mut RowFilter_Condition {
        if let ::std::option::Option::Some(RowFilter_oneof_filter::condition(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::condition(RowFilter_Condition::new()));
        }
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::condition(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_condition(&mut self) -> RowFilter_Condition {
        if self.has_condition() {
            match self.filter.take() {
                ::std::option::Option::Some(RowFilter_oneof_filter::condition(v)) => v,
                _ => panic!(),
            }
        } else {
            RowFilter_Condition::new()
        }
    }

    // bool sink = 16;


    pub fn get_sink(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::sink(v)) => v,
            _ => false,
        }
    }
    pub fn clear_sink(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_sink(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::sink(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sink(&mut self, v: bool) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::sink(v))
    }

    // bool pass_all_filter = 17;


    pub fn get_pass_all_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::pass_all_filter(v)) => v,
            _ => false,
        }
    }
    pub fn clear_pass_all_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_pass_all_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::pass_all_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pass_all_filter(&mut self, v: bool) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::pass_all_filter(v))
    }

    // bool block_all_filter = 18;


    pub fn get_block_all_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::block_all_filter(v)) => v,
            _ => false,
        }
    }
    pub fn clear_block_all_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_block_all_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::block_all_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_block_all_filter(&mut self, v: bool) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::block_all_filter(v))
    }

    // bytes row_key_regex_filter = 4;


    pub fn get_row_key_regex_filter(&self) -> &[u8] {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::row_key_regex_filter(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_row_key_regex_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_row_key_regex_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::row_key_regex_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_row_key_regex_filter(&mut self, v: ::std::vec::Vec<u8>) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::row_key_regex_filter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_row_key_regex_filter(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(RowFilter_oneof_filter::row_key_regex_filter(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::row_key_regex_filter(::std::vec::Vec::new()));
        }
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::row_key_regex_filter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_row_key_regex_filter(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_row_key_regex_filter() {
            match self.filter.take() {
                ::std::option::Option::Some(RowFilter_oneof_filter::row_key_regex_filter(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // double row_sample_filter = 14;


    pub fn get_row_sample_filter(&self) -> f64 {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::row_sample_filter(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_row_sample_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_row_sample_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::row_sample_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_row_sample_filter(&mut self, v: f64) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::row_sample_filter(v))
    }

    // string family_name_regex_filter = 5;


    pub fn get_family_name_regex_filter(&self) -> &str {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::family_name_regex_filter(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_family_name_regex_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_family_name_regex_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::family_name_regex_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_family_name_regex_filter(&mut self, v: ::std::string::String) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::family_name_regex_filter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_family_name_regex_filter(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RowFilter_oneof_filter::family_name_regex_filter(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::family_name_regex_filter(::std::string::String::new()));
        }
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::family_name_regex_filter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_family_name_regex_filter(&mut self) -> ::std::string::String {
        if self.has_family_name_regex_filter() {
            match self.filter.take() {
                ::std::option::Option::Some(RowFilter_oneof_filter::family_name_regex_filter(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // bytes column_qualifier_regex_filter = 6;


    pub fn get_column_qualifier_regex_filter(&self) -> &[u8] {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::column_qualifier_regex_filter(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_column_qualifier_regex_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_column_qualifier_regex_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::column_qualifier_regex_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_column_qualifier_regex_filter(&mut self, v: ::std::vec::Vec<u8>) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::column_qualifier_regex_filter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_column_qualifier_regex_filter(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(RowFilter_oneof_filter::column_qualifier_regex_filter(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::column_qualifier_regex_filter(::std::vec::Vec::new()));
        }
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::column_qualifier_regex_filter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_column_qualifier_regex_filter(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_column_qualifier_regex_filter() {
            match self.filter.take() {
                ::std::option::Option::Some(RowFilter_oneof_filter::column_qualifier_regex_filter(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // .google.bigtable.v2.ColumnRange column_range_filter = 7;


    pub fn get_column_range_filter(&self) -> &ColumnRange {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::column_range_filter(ref v)) => v,
            _ => <ColumnRange as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_column_range_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_column_range_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::column_range_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_column_range_filter(&mut self, v: ColumnRange) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::column_range_filter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_column_range_filter(&mut self) -> &mut ColumnRange {
        if let ::std::option::Option::Some(RowFilter_oneof_filter::column_range_filter(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::column_range_filter(ColumnRange::new()));
        }
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::column_range_filter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_column_range_filter(&mut self) -> ColumnRange {
        if self.has_column_range_filter() {
            match self.filter.take() {
                ::std::option::Option::Some(RowFilter_oneof_filter::column_range_filter(v)) => v,
                _ => panic!(),
            }
        } else {
            ColumnRange::new()
        }
    }

    // .google.bigtable.v2.TimestampRange timestamp_range_filter = 8;


    pub fn get_timestamp_range_filter(&self) -> &TimestampRange {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::timestamp_range_filter(ref v)) => v,
            _ => <TimestampRange as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_timestamp_range_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_timestamp_range_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::timestamp_range_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_timestamp_range_filter(&mut self, v: TimestampRange) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::timestamp_range_filter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_timestamp_range_filter(&mut self) -> &mut TimestampRange {
        if let ::std::option::Option::Some(RowFilter_oneof_filter::timestamp_range_filter(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::timestamp_range_filter(TimestampRange::new()));
        }
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::timestamp_range_filter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_timestamp_range_filter(&mut self) -> TimestampRange {
        if self.has_timestamp_range_filter() {
            match self.filter.take() {
                ::std::option::Option::Some(RowFilter_oneof_filter::timestamp_range_filter(v)) => v,
                _ => panic!(),
            }
        } else {
            TimestampRange::new()
        }
    }

    // bytes value_regex_filter = 9;


    pub fn get_value_regex_filter(&self) -> &[u8] {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::value_regex_filter(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_value_regex_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_value_regex_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::value_regex_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_value_regex_filter(&mut self, v: ::std::vec::Vec<u8>) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::value_regex_filter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_value_regex_filter(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(RowFilter_oneof_filter::value_regex_filter(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::value_regex_filter(::std::vec::Vec::new()));
        }
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::value_regex_filter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_value_regex_filter(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_value_regex_filter() {
            match self.filter.take() {
                ::std::option::Option::Some(RowFilter_oneof_filter::value_regex_filter(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // .google.bigtable.v2.ValueRange value_range_filter = 15;


    pub fn get_value_range_filter(&self) -> &ValueRange {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::value_range_filter(ref v)) => v,
            _ => <ValueRange as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_value_range_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_value_range_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::value_range_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_value_range_filter(&mut self, v: ValueRange) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::value_range_filter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_value_range_filter(&mut self) -> &mut ValueRange {
        if let ::std::option::Option::Some(RowFilter_oneof_filter::value_range_filter(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::value_range_filter(ValueRange::new()));
        }
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::value_range_filter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_value_range_filter(&mut self) -> ValueRange {
        if self.has_value_range_filter() {
            match self.filter.take() {
                ::std::option::Option::Some(RowFilter_oneof_filter::value_range_filter(v)) => v,
                _ => panic!(),
            }
        } else {
            ValueRange::new()
        }
    }

    // int32 cells_per_row_offset_filter = 10;


    pub fn get_cells_per_row_offset_filter(&self) -> i32 {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::cells_per_row_offset_filter(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_cells_per_row_offset_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_cells_per_row_offset_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::cells_per_row_offset_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cells_per_row_offset_filter(&mut self, v: i32) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::cells_per_row_offset_filter(v))
    }

    // int32 cells_per_row_limit_filter = 11;


    pub fn get_cells_per_row_limit_filter(&self) -> i32 {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::cells_per_row_limit_filter(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_cells_per_row_limit_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_cells_per_row_limit_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::cells_per_row_limit_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cells_per_row_limit_filter(&mut self, v: i32) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::cells_per_row_limit_filter(v))
    }

    // int32 cells_per_column_limit_filter = 12;


    pub fn get_cells_per_column_limit_filter(&self) -> i32 {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::cells_per_column_limit_filter(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_cells_per_column_limit_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_cells_per_column_limit_filter(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::cells_per_column_limit_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cells_per_column_limit_filter(&mut self, v: i32) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::cells_per_column_limit_filter(v))
    }

    // bool strip_value_transformer = 13;


    pub fn get_strip_value_transformer(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::strip_value_transformer(v)) => v,
            _ => false,
        }
    }
    pub fn clear_strip_value_transformer(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_strip_value_transformer(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::strip_value_transformer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_strip_value_transformer(&mut self, v: bool) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::strip_value_transformer(v))
    }

    // string apply_label_transformer = 19;


    pub fn get_apply_label_transformer(&self) -> &str {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::apply_label_transformer(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_apply_label_transformer(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_apply_label_transformer(&self) -> bool {
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::apply_label_transformer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_apply_label_transformer(&mut self, v: ::std::string::String) {
        self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::apply_label_transformer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_apply_label_transformer(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RowFilter_oneof_filter::apply_label_transformer(_)) = self.filter {
        } else {
            self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::apply_label_transformer(::std::string::String::new()));
        }
        match self.filter {
            ::std::option::Option::Some(RowFilter_oneof_filter::apply_label_transformer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_apply_label_transformer(&mut self) -> ::std::string::String {
        if self.has_apply_label_transformer() {
            match self.filter.take() {
                ::std::option::Option::Some(RowFilter_oneof_filter::apply_label_transformer(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for RowFilter {
    fn is_initialized(&self) -> bool {
        if let Some(RowFilter_oneof_filter::chain(ref v)) = self.filter {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RowFilter_oneof_filter::interleave(ref v)) = self.filter {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RowFilter_oneof_filter::condition(ref v)) = self.filter {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RowFilter_oneof_filter::column_range_filter(ref v)) = self.filter {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RowFilter_oneof_filter::timestamp_range_filter(ref v)) = self.filter {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RowFilter_oneof_filter::value_range_filter(ref v)) = self.filter {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::chain(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::interleave(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::condition(is.read_message()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::sink(is.read_bool()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::pass_all_filter(is.read_bool()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::block_all_filter(is.read_bool()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::row_key_regex_filter(is.read_bytes()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::row_sample_filter(is.read_double()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::family_name_regex_filter(is.read_string()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::column_qualifier_regex_filter(is.read_bytes()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::column_range_filter(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::timestamp_range_filter(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::value_regex_filter(is.read_bytes()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::value_range_filter(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::cells_per_row_offset_filter(is.read_int32()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::cells_per_row_limit_filter(is.read_int32()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::cells_per_column_limit_filter(is.read_int32()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::strip_value_transformer(is.read_bool()?));
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter = ::std::option::Option::Some(RowFilter_oneof_filter::apply_label_transformer(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.filter {
            match v {
                &RowFilter_oneof_filter::chain(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RowFilter_oneof_filter::interleave(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RowFilter_oneof_filter::condition(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RowFilter_oneof_filter::sink(v) => {
                    my_size += 3;
                },
                &RowFilter_oneof_filter::pass_all_filter(v) => {
                    my_size += 3;
                },
                &RowFilter_oneof_filter::block_all_filter(v) => {
                    my_size += 3;
                },
                &RowFilter_oneof_filter::row_key_regex_filter(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(4, &v);
                },
                &RowFilter_oneof_filter::row_sample_filter(v) => {
                    my_size += 9;
                },
                &RowFilter_oneof_filter::family_name_regex_filter(ref v) => {
                    my_size += ::protobuf::rt::string_size(5, &v);
                },
                &RowFilter_oneof_filter::column_qualifier_regex_filter(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(6, &v);
                },
                &RowFilter_oneof_filter::column_range_filter(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RowFilter_oneof_filter::timestamp_range_filter(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RowFilter_oneof_filter::value_regex_filter(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(9, &v);
                },
                &RowFilter_oneof_filter::value_range_filter(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RowFilter_oneof_filter::cells_per_row_offset_filter(v) => {
                    my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &RowFilter_oneof_filter::cells_per_row_limit_filter(v) => {
                    my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &RowFilter_oneof_filter::cells_per_column_limit_filter(v) => {
                    my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &RowFilter_oneof_filter::strip_value_transformer(v) => {
                    my_size += 2;
                },
                &RowFilter_oneof_filter::apply_label_transformer(ref v) => {
                    my_size += ::protobuf::rt::string_size(19, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.filter {
            match v {
                &RowFilter_oneof_filter::chain(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RowFilter_oneof_filter::interleave(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RowFilter_oneof_filter::condition(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RowFilter_oneof_filter::sink(v) => {
                    os.write_bool(16, v)?;
                },
                &RowFilter_oneof_filter::pass_all_filter(v) => {
                    os.write_bool(17, v)?;
                },
                &RowFilter_oneof_filter::block_all_filter(v) => {
                    os.write_bool(18, v)?;
                },
                &RowFilter_oneof_filter::row_key_regex_filter(ref v) => {
                    os.write_bytes(4, v)?;
                },
                &RowFilter_oneof_filter::row_sample_filter(v) => {
                    os.write_double(14, v)?;
                },
                &RowFilter_oneof_filter::family_name_regex_filter(ref v) => {
                    os.write_string(5, v)?;
                },
                &RowFilter_oneof_filter::column_qualifier_regex_filter(ref v) => {
                    os.write_bytes(6, v)?;
                },
                &RowFilter_oneof_filter::column_range_filter(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RowFilter_oneof_filter::timestamp_range_filter(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RowFilter_oneof_filter::value_regex_filter(ref v) => {
                    os.write_bytes(9, v)?;
                },
                &RowFilter_oneof_filter::value_range_filter(ref v) => {
                    os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RowFilter_oneof_filter::cells_per_row_offset_filter(v) => {
                    os.write_int32(10, v)?;
                },
                &RowFilter_oneof_filter::cells_per_row_limit_filter(v) => {
                    os.write_int32(11, v)?;
                },
                &RowFilter_oneof_filter::cells_per_column_limit_filter(v) => {
                    os.write_int32(12, v)?;
                },
                &RowFilter_oneof_filter::strip_value_transformer(v) => {
                    os.write_bool(13, v)?;
                },
                &RowFilter_oneof_filter::apply_label_transformer(ref v) => {
                    os.write_string(19, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RowFilter {
        RowFilter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RowFilter_Chain>(
                "chain",
                RowFilter::has_chain,
                RowFilter::get_chain,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RowFilter_Interleave>(
                "interleave",
                RowFilter::has_interleave,
                RowFilter::get_interleave,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RowFilter_Condition>(
                "condition",
                RowFilter::has_condition,
                RowFilter::get_condition,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "sink",
                RowFilter::has_sink,
                RowFilter::get_sink,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "pass_all_filter",
                RowFilter::has_pass_all_filter,
                RowFilter::get_pass_all_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "block_all_filter",
                RowFilter::has_block_all_filter,
                RowFilter::get_block_all_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "row_key_regex_filter",
                RowFilter::has_row_key_regex_filter,
                RowFilter::get_row_key_regex_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor::<_>(
                "row_sample_filter",
                RowFilter::has_row_sample_filter,
                RowFilter::get_row_sample_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "family_name_regex_filter",
                RowFilter::has_family_name_regex_filter,
                RowFilter::get_family_name_regex_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "column_qualifier_regex_filter",
                RowFilter::has_column_qualifier_regex_filter,
                RowFilter::get_column_qualifier_regex_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ColumnRange>(
                "column_range_filter",
                RowFilter::has_column_range_filter,
                RowFilter::get_column_range_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TimestampRange>(
                "timestamp_range_filter",
                RowFilter::has_timestamp_range_filter,
                RowFilter::get_timestamp_range_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "value_regex_filter",
                RowFilter::has_value_regex_filter,
                RowFilter::get_value_regex_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ValueRange>(
                "value_range_filter",
                RowFilter::has_value_range_filter,
                RowFilter::get_value_range_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                "cells_per_row_offset_filter",
                RowFilter::has_cells_per_row_offset_filter,
                RowFilter::get_cells_per_row_offset_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                "cells_per_row_limit_filter",
                RowFilter::has_cells_per_row_limit_filter,
                RowFilter::get_cells_per_row_limit_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                "cells_per_column_limit_filter",
                RowFilter::has_cells_per_column_limit_filter,
                RowFilter::get_cells_per_column_limit_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "strip_value_transformer",
                RowFilter::has_strip_value_transformer,
                RowFilter::get_strip_value_transformer,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "apply_label_transformer",
                RowFilter::has_apply_label_transformer,
                RowFilter::get_apply_label_transformer,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RowFilter>(
                "RowFilter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RowFilter {
        static instance: ::protobuf::rt::LazyV2<RowFilter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RowFilter::new)
    }
}

impl ::protobuf::Clear for RowFilter {
    fn clear(&mut self) {
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.filter = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RowFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RowFilter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RowFilter_Chain {
    // message fields
    pub filters: ::protobuf::RepeatedField<RowFilter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RowFilter_Chain {
    fn default() -> &'a RowFilter_Chain {
        <RowFilter_Chain as ::protobuf::Message>::default_instance()
    }
}

impl RowFilter_Chain {
    pub fn new() -> RowFilter_Chain {
        ::std::default::Default::default()
    }

    // repeated .google.bigtable.v2.RowFilter filters = 1;


    pub fn get_filters(&self) -> &[RowFilter] {
        &self.filters
    }
    pub fn clear_filters(&mut self) {
        self.filters.clear();
    }

    // Param is passed by value, moved
    pub fn set_filters(&mut self, v: ::protobuf::RepeatedField<RowFilter>) {
        self.filters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_filters(&mut self) -> &mut ::protobuf::RepeatedField<RowFilter> {
        &mut self.filters
    }

    // Take field
    pub fn take_filters(&mut self) -> ::protobuf::RepeatedField<RowFilter> {
        ::std::mem::replace(&mut self.filters, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RowFilter_Chain {
    fn is_initialized(&self) -> bool {
        for v in &self.filters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.filters)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.filters {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RowFilter_Chain {
        RowFilter_Chain::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RowFilter>>(
                "filters",
                |m: &RowFilter_Chain| { &m.filters },
                |m: &mut RowFilter_Chain| { &mut m.filters },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RowFilter_Chain>(
                "RowFilter.Chain",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RowFilter_Chain {
        static instance: ::protobuf::rt::LazyV2<RowFilter_Chain> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RowFilter_Chain::new)
    }
}

impl ::protobuf::Clear for RowFilter_Chain {
    fn clear(&mut self) {
        self.filters.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RowFilter_Chain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RowFilter_Chain {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RowFilter_Interleave {
    // message fields
    pub filters: ::protobuf::RepeatedField<RowFilter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RowFilter_Interleave {
    fn default() -> &'a RowFilter_Interleave {
        <RowFilter_Interleave as ::protobuf::Message>::default_instance()
    }
}

impl RowFilter_Interleave {
    pub fn new() -> RowFilter_Interleave {
        ::std::default::Default::default()
    }

    // repeated .google.bigtable.v2.RowFilter filters = 1;


    pub fn get_filters(&self) -> &[RowFilter] {
        &self.filters
    }
    pub fn clear_filters(&mut self) {
        self.filters.clear();
    }

    // Param is passed by value, moved
    pub fn set_filters(&mut self, v: ::protobuf::RepeatedField<RowFilter>) {
        self.filters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_filters(&mut self) -> &mut ::protobuf::RepeatedField<RowFilter> {
        &mut self.filters
    }

    // Take field
    pub fn take_filters(&mut self) -> ::protobuf::RepeatedField<RowFilter> {
        ::std::mem::replace(&mut self.filters, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RowFilter_Interleave {
    fn is_initialized(&self) -> bool {
        for v in &self.filters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.filters)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.filters {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RowFilter_Interleave {
        RowFilter_Interleave::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RowFilter>>(
                "filters",
                |m: &RowFilter_Interleave| { &m.filters },
                |m: &mut RowFilter_Interleave| { &mut m.filters },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RowFilter_Interleave>(
                "RowFilter.Interleave",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RowFilter_Interleave {
        static instance: ::protobuf::rt::LazyV2<RowFilter_Interleave> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RowFilter_Interleave::new)
    }
}

impl ::protobuf::Clear for RowFilter_Interleave {
    fn clear(&mut self) {
        self.filters.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RowFilter_Interleave {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RowFilter_Interleave {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RowFilter_Condition {
    // message fields
    pub predicate_filter: ::protobuf::SingularPtrField<RowFilter>,
    pub true_filter: ::protobuf::SingularPtrField<RowFilter>,
    pub false_filter: ::protobuf::SingularPtrField<RowFilter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RowFilter_Condition {
    fn default() -> &'a RowFilter_Condition {
        <RowFilter_Condition as ::protobuf::Message>::default_instance()
    }
}

impl RowFilter_Condition {
    pub fn new() -> RowFilter_Condition {
        ::std::default::Default::default()
    }

    // .google.bigtable.v2.RowFilter predicate_filter = 1;


    pub fn get_predicate_filter(&self) -> &RowFilter {
        self.predicate_filter.as_ref().unwrap_or_else(|| <RowFilter as ::protobuf::Message>::default_instance())
    }
    pub fn clear_predicate_filter(&mut self) {
        self.predicate_filter.clear();
    }

    pub fn has_predicate_filter(&self) -> bool {
        self.predicate_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_predicate_filter(&mut self, v: RowFilter) {
        self.predicate_filter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_predicate_filter(&mut self) -> &mut RowFilter {
        if self.predicate_filter.is_none() {
            self.predicate_filter.set_default();
        }
        self.predicate_filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_predicate_filter(&mut self) -> RowFilter {
        self.predicate_filter.take().unwrap_or_else(|| RowFilter::new())
    }

    // .google.bigtable.v2.RowFilter true_filter = 2;


    pub fn get_true_filter(&self) -> &RowFilter {
        self.true_filter.as_ref().unwrap_or_else(|| <RowFilter as ::protobuf::Message>::default_instance())
    }
    pub fn clear_true_filter(&mut self) {
        self.true_filter.clear();
    }

    pub fn has_true_filter(&self) -> bool {
        self.true_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_true_filter(&mut self, v: RowFilter) {
        self.true_filter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_true_filter(&mut self) -> &mut RowFilter {
        if self.true_filter.is_none() {
            self.true_filter.set_default();
        }
        self.true_filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_true_filter(&mut self) -> RowFilter {
        self.true_filter.take().unwrap_or_else(|| RowFilter::new())
    }

    // .google.bigtable.v2.RowFilter false_filter = 3;


    pub fn get_false_filter(&self) -> &RowFilter {
        self.false_filter.as_ref().unwrap_or_else(|| <RowFilter as ::protobuf::Message>::default_instance())
    }
    pub fn clear_false_filter(&mut self) {
        self.false_filter.clear();
    }

    pub fn has_false_filter(&self) -> bool {
        self.false_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_false_filter(&mut self, v: RowFilter) {
        self.false_filter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_false_filter(&mut self) -> &mut RowFilter {
        if self.false_filter.is_none() {
            self.false_filter.set_default();
        }
        self.false_filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_false_filter(&mut self) -> RowFilter {
        self.false_filter.take().unwrap_or_else(|| RowFilter::new())
    }
}

impl ::protobuf::Message for RowFilter_Condition {
    fn is_initialized(&self) -> bool {
        for v in &self.predicate_filter {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.true_filter {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.false_filter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.predicate_filter)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.true_filter)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.false_filter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.predicate_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.true_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.false_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.predicate_filter.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.true_filter.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.false_filter.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RowFilter_Condition {
        RowFilter_Condition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RowFilter>>(
                "predicate_filter",
                |m: &RowFilter_Condition| { &m.predicate_filter },
                |m: &mut RowFilter_Condition| { &mut m.predicate_filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RowFilter>>(
                "true_filter",
                |m: &RowFilter_Condition| { &m.true_filter },
                |m: &mut RowFilter_Condition| { &mut m.true_filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RowFilter>>(
                "false_filter",
                |m: &RowFilter_Condition| { &m.false_filter },
                |m: &mut RowFilter_Condition| { &mut m.false_filter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RowFilter_Condition>(
                "RowFilter.Condition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RowFilter_Condition {
        static instance: ::protobuf::rt::LazyV2<RowFilter_Condition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RowFilter_Condition::new)
    }
}

impl ::protobuf::Clear for RowFilter_Condition {
    fn clear(&mut self) {
        self.predicate_filter.clear();
        self.true_filter.clear();
        self.false_filter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RowFilter_Condition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RowFilter_Condition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Mutation {
    // message oneof groups
    pub mutation: ::std::option::Option<Mutation_oneof_mutation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Mutation {
    fn default() -> &'a Mutation {
        <Mutation as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Mutation_oneof_mutation {
    set_cell(Mutation_SetCell),
    delete_from_column(Mutation_DeleteFromColumn),
    delete_from_family(Mutation_DeleteFromFamily),
    delete_from_row(Mutation_DeleteFromRow),
}

impl Mutation {
    pub fn new() -> Mutation {
        ::std::default::Default::default()
    }

    // .google.bigtable.v2.Mutation.SetCell set_cell = 1;


    pub fn get_set_cell(&self) -> &Mutation_SetCell {
        match self.mutation {
            ::std::option::Option::Some(Mutation_oneof_mutation::set_cell(ref v)) => v,
            _ => <Mutation_SetCell as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_set_cell(&mut self) {
        self.mutation = ::std::option::Option::None;
    }

    pub fn has_set_cell(&self) -> bool {
        match self.mutation {
            ::std::option::Option::Some(Mutation_oneof_mutation::set_cell(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_cell(&mut self, v: Mutation_SetCell) {
        self.mutation = ::std::option::Option::Some(Mutation_oneof_mutation::set_cell(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_cell(&mut self) -> &mut Mutation_SetCell {
        if let ::std::option::Option::Some(Mutation_oneof_mutation::set_cell(_)) = self.mutation {
        } else {
            self.mutation = ::std::option::Option::Some(Mutation_oneof_mutation::set_cell(Mutation_SetCell::new()));
        }
        match self.mutation {
            ::std::option::Option::Some(Mutation_oneof_mutation::set_cell(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_cell(&mut self) -> Mutation_SetCell {
        if self.has_set_cell() {
            match self.mutation.take() {
                ::std::option::Option::Some(Mutation_oneof_mutation::set_cell(v)) => v,
                _ => panic!(),
            }
        } else {
            Mutation_SetCell::new()
        }
    }

    // .google.bigtable.v2.Mutation.DeleteFromColumn delete_from_column = 2;


    pub fn get_delete_from_column(&self) -> &Mutation_DeleteFromColumn {
        match self.mutation {
            ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_column(ref v)) => v,
            _ => <Mutation_DeleteFromColumn as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_delete_from_column(&mut self) {
        self.mutation = ::std::option::Option::None;
    }

    pub fn has_delete_from_column(&self) -> bool {
        match self.mutation {
            ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_column(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delete_from_column(&mut self, v: Mutation_DeleteFromColumn) {
        self.mutation = ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_column(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delete_from_column(&mut self) -> &mut Mutation_DeleteFromColumn {
        if let ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_column(_)) = self.mutation {
        } else {
            self.mutation = ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_column(Mutation_DeleteFromColumn::new()));
        }
        match self.mutation {
            ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_column(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delete_from_column(&mut self) -> Mutation_DeleteFromColumn {
        if self.has_delete_from_column() {
            match self.mutation.take() {
                ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_column(v)) => v,
                _ => panic!(),
            }
        } else {
            Mutation_DeleteFromColumn::new()
        }
    }

    // .google.bigtable.v2.Mutation.DeleteFromFamily delete_from_family = 3;


    pub fn get_delete_from_family(&self) -> &Mutation_DeleteFromFamily {
        match self.mutation {
            ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_family(ref v)) => v,
            _ => <Mutation_DeleteFromFamily as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_delete_from_family(&mut self) {
        self.mutation = ::std::option::Option::None;
    }

    pub fn has_delete_from_family(&self) -> bool {
        match self.mutation {
            ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_family(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delete_from_family(&mut self, v: Mutation_DeleteFromFamily) {
        self.mutation = ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_family(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delete_from_family(&mut self) -> &mut Mutation_DeleteFromFamily {
        if let ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_family(_)) = self.mutation {
        } else {
            self.mutation = ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_family(Mutation_DeleteFromFamily::new()));
        }
        match self.mutation {
            ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_family(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delete_from_family(&mut self) -> Mutation_DeleteFromFamily {
        if self.has_delete_from_family() {
            match self.mutation.take() {
                ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_family(v)) => v,
                _ => panic!(),
            }
        } else {
            Mutation_DeleteFromFamily::new()
        }
    }

    // .google.bigtable.v2.Mutation.DeleteFromRow delete_from_row = 4;


    pub fn get_delete_from_row(&self) -> &Mutation_DeleteFromRow {
        match self.mutation {
            ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_row(ref v)) => v,
            _ => <Mutation_DeleteFromRow as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_delete_from_row(&mut self) {
        self.mutation = ::std::option::Option::None;
    }

    pub fn has_delete_from_row(&self) -> bool {
        match self.mutation {
            ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_row(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delete_from_row(&mut self, v: Mutation_DeleteFromRow) {
        self.mutation = ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_row(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delete_from_row(&mut self) -> &mut Mutation_DeleteFromRow {
        if let ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_row(_)) = self.mutation {
        } else {
            self.mutation = ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_row(Mutation_DeleteFromRow::new()));
        }
        match self.mutation {
            ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_row(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delete_from_row(&mut self) -> Mutation_DeleteFromRow {
        if self.has_delete_from_row() {
            match self.mutation.take() {
                ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_row(v)) => v,
                _ => panic!(),
            }
        } else {
            Mutation_DeleteFromRow::new()
        }
    }
}

impl ::protobuf::Message for Mutation {
    fn is_initialized(&self) -> bool {
        if let Some(Mutation_oneof_mutation::set_cell(ref v)) = self.mutation {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Mutation_oneof_mutation::delete_from_column(ref v)) = self.mutation {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Mutation_oneof_mutation::delete_from_family(ref v)) = self.mutation {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Mutation_oneof_mutation::delete_from_row(ref v)) = self.mutation {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mutation = ::std::option::Option::Some(Mutation_oneof_mutation::set_cell(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mutation = ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_column(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mutation = ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_family(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mutation = ::std::option::Option::Some(Mutation_oneof_mutation::delete_from_row(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.mutation {
            match v {
                &Mutation_oneof_mutation::set_cell(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Mutation_oneof_mutation::delete_from_column(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Mutation_oneof_mutation::delete_from_family(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Mutation_oneof_mutation::delete_from_row(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.mutation {
            match v {
                &Mutation_oneof_mutation::set_cell(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Mutation_oneof_mutation::delete_from_column(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Mutation_oneof_mutation::delete_from_family(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Mutation_oneof_mutation::delete_from_row(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Mutation {
        Mutation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Mutation_SetCell>(
                "set_cell",
                Mutation::has_set_cell,
                Mutation::get_set_cell,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Mutation_DeleteFromColumn>(
                "delete_from_column",
                Mutation::has_delete_from_column,
                Mutation::get_delete_from_column,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Mutation_DeleteFromFamily>(
                "delete_from_family",
                Mutation::has_delete_from_family,
                Mutation::get_delete_from_family,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Mutation_DeleteFromRow>(
                "delete_from_row",
                Mutation::has_delete_from_row,
                Mutation::get_delete_from_row,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Mutation>(
                "Mutation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Mutation {
        static instance: ::protobuf::rt::LazyV2<Mutation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Mutation::new)
    }
}

impl ::protobuf::Clear for Mutation {
    fn clear(&mut self) {
        self.mutation = ::std::option::Option::None;
        self.mutation = ::std::option::Option::None;
        self.mutation = ::std::option::Option::None;
        self.mutation = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Mutation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Mutation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Mutation_SetCell {
    // message fields
    pub family_name: ::std::string::String,
    pub column_qualifier: ::std::vec::Vec<u8>,
    pub timestamp_micros: i64,
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Mutation_SetCell {
    fn default() -> &'a Mutation_SetCell {
        <Mutation_SetCell as ::protobuf::Message>::default_instance()
    }
}

impl Mutation_SetCell {
    pub fn new() -> Mutation_SetCell {
        ::std::default::Default::default()
    }

    // string family_name = 1;


    pub fn get_family_name(&self) -> &str {
        &self.family_name
    }
    pub fn clear_family_name(&mut self) {
        self.family_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_family_name(&mut self, v: ::std::string::String) {
        self.family_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_family_name(&mut self) -> &mut ::std::string::String {
        &mut self.family_name
    }

    // Take field
    pub fn take_family_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.family_name, ::std::string::String::new())
    }

    // bytes column_qualifier = 2;


    pub fn get_column_qualifier(&self) -> &[u8] {
        &self.column_qualifier
    }
    pub fn clear_column_qualifier(&mut self) {
        self.column_qualifier.clear();
    }

    // Param is passed by value, moved
    pub fn set_column_qualifier(&mut self, v: ::std::vec::Vec<u8>) {
        self.column_qualifier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_column_qualifier(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.column_qualifier
    }

    // Take field
    pub fn take_column_qualifier(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.column_qualifier, ::std::vec::Vec::new())
    }

    // int64 timestamp_micros = 3;


    pub fn get_timestamp_micros(&self) -> i64 {
        self.timestamp_micros
    }
    pub fn clear_timestamp_micros(&mut self) {
        self.timestamp_micros = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp_micros(&mut self, v: i64) {
        self.timestamp_micros = v;
    }

    // bytes value = 4;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Mutation_SetCell {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.family_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.column_qualifier)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp_micros = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.family_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.family_name);
        }
        if !self.column_qualifier.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.column_qualifier);
        }
        if self.timestamp_micros != 0 {
            my_size += ::protobuf::rt::value_size(3, self.timestamp_micros, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.family_name.is_empty() {
            os.write_string(1, &self.family_name)?;
        }
        if !self.column_qualifier.is_empty() {
            os.write_bytes(2, &self.column_qualifier)?;
        }
        if self.timestamp_micros != 0 {
            os.write_int64(3, self.timestamp_micros)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(4, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Mutation_SetCell {
        Mutation_SetCell::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "family_name",
                |m: &Mutation_SetCell| { &m.family_name },
                |m: &mut Mutation_SetCell| { &mut m.family_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "column_qualifier",
                |m: &Mutation_SetCell| { &m.column_qualifier },
                |m: &mut Mutation_SetCell| { &mut m.column_qualifier },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp_micros",
                |m: &Mutation_SetCell| { &m.timestamp_micros },
                |m: &mut Mutation_SetCell| { &mut m.timestamp_micros },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &Mutation_SetCell| { &m.value },
                |m: &mut Mutation_SetCell| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Mutation_SetCell>(
                "Mutation.SetCell",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Mutation_SetCell {
        static instance: ::protobuf::rt::LazyV2<Mutation_SetCell> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Mutation_SetCell::new)
    }
}

impl ::protobuf::Clear for Mutation_SetCell {
    fn clear(&mut self) {
        self.family_name.clear();
        self.column_qualifier.clear();
        self.timestamp_micros = 0;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Mutation_SetCell {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Mutation_SetCell {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Mutation_DeleteFromColumn {
    // message fields
    pub family_name: ::std::string::String,
    pub column_qualifier: ::std::vec::Vec<u8>,
    pub time_range: ::protobuf::SingularPtrField<TimestampRange>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Mutation_DeleteFromColumn {
    fn default() -> &'a Mutation_DeleteFromColumn {
        <Mutation_DeleteFromColumn as ::protobuf::Message>::default_instance()
    }
}

impl Mutation_DeleteFromColumn {
    pub fn new() -> Mutation_DeleteFromColumn {
        ::std::default::Default::default()
    }

    // string family_name = 1;


    pub fn get_family_name(&self) -> &str {
        &self.family_name
    }
    pub fn clear_family_name(&mut self) {
        self.family_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_family_name(&mut self, v: ::std::string::String) {
        self.family_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_family_name(&mut self) -> &mut ::std::string::String {
        &mut self.family_name
    }

    // Take field
    pub fn take_family_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.family_name, ::std::string::String::new())
    }

    // bytes column_qualifier = 2;


    pub fn get_column_qualifier(&self) -> &[u8] {
        &self.column_qualifier
    }
    pub fn clear_column_qualifier(&mut self) {
        self.column_qualifier.clear();
    }

    // Param is passed by value, moved
    pub fn set_column_qualifier(&mut self, v: ::std::vec::Vec<u8>) {
        self.column_qualifier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_column_qualifier(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.column_qualifier
    }

    // Take field
    pub fn take_column_qualifier(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.column_qualifier, ::std::vec::Vec::new())
    }

    // .google.bigtable.v2.TimestampRange time_range = 3;


    pub fn get_time_range(&self) -> &TimestampRange {
        self.time_range.as_ref().unwrap_or_else(|| <TimestampRange as ::protobuf::Message>::default_instance())
    }
    pub fn clear_time_range(&mut self) {
        self.time_range.clear();
    }

    pub fn has_time_range(&self) -> bool {
        self.time_range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_range(&mut self, v: TimestampRange) {
        self.time_range = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time_range(&mut self) -> &mut TimestampRange {
        if self.time_range.is_none() {
            self.time_range.set_default();
        }
        self.time_range.as_mut().unwrap()
    }

    // Take field
    pub fn take_time_range(&mut self) -> TimestampRange {
        self.time_range.take().unwrap_or_else(|| TimestampRange::new())
    }
}

impl ::protobuf::Message for Mutation_DeleteFromColumn {
    fn is_initialized(&self) -> bool {
        for v in &self.time_range {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.family_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.column_qualifier)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time_range)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.family_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.family_name);
        }
        if !self.column_qualifier.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.column_qualifier);
        }
        if let Some(ref v) = self.time_range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.family_name.is_empty() {
            os.write_string(1, &self.family_name)?;
        }
        if !self.column_qualifier.is_empty() {
            os.write_bytes(2, &self.column_qualifier)?;
        }
        if let Some(ref v) = self.time_range.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Mutation_DeleteFromColumn {
        Mutation_DeleteFromColumn::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "family_name",
                |m: &Mutation_DeleteFromColumn| { &m.family_name },
                |m: &mut Mutation_DeleteFromColumn| { &mut m.family_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "column_qualifier",
                |m: &Mutation_DeleteFromColumn| { &m.column_qualifier },
                |m: &mut Mutation_DeleteFromColumn| { &mut m.column_qualifier },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimestampRange>>(
                "time_range",
                |m: &Mutation_DeleteFromColumn| { &m.time_range },
                |m: &mut Mutation_DeleteFromColumn| { &mut m.time_range },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Mutation_DeleteFromColumn>(
                "Mutation.DeleteFromColumn",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Mutation_DeleteFromColumn {
        static instance: ::protobuf::rt::LazyV2<Mutation_DeleteFromColumn> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Mutation_DeleteFromColumn::new)
    }
}

impl ::protobuf::Clear for Mutation_DeleteFromColumn {
    fn clear(&mut self) {
        self.family_name.clear();
        self.column_qualifier.clear();
        self.time_range.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Mutation_DeleteFromColumn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Mutation_DeleteFromColumn {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Mutation_DeleteFromFamily {
    // message fields
    pub family_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Mutation_DeleteFromFamily {
    fn default() -> &'a Mutation_DeleteFromFamily {
        <Mutation_DeleteFromFamily as ::protobuf::Message>::default_instance()
    }
}

impl Mutation_DeleteFromFamily {
    pub fn new() -> Mutation_DeleteFromFamily {
        ::std::default::Default::default()
    }

    // string family_name = 1;


    pub fn get_family_name(&self) -> &str {
        &self.family_name
    }
    pub fn clear_family_name(&mut self) {
        self.family_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_family_name(&mut self, v: ::std::string::String) {
        self.family_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_family_name(&mut self) -> &mut ::std::string::String {
        &mut self.family_name
    }

    // Take field
    pub fn take_family_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.family_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Mutation_DeleteFromFamily {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.family_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.family_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.family_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.family_name.is_empty() {
            os.write_string(1, &self.family_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Mutation_DeleteFromFamily {
        Mutation_DeleteFromFamily::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "family_name",
                |m: &Mutation_DeleteFromFamily| { &m.family_name },
                |m: &mut Mutation_DeleteFromFamily| { &mut m.family_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Mutation_DeleteFromFamily>(
                "Mutation.DeleteFromFamily",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Mutation_DeleteFromFamily {
        static instance: ::protobuf::rt::LazyV2<Mutation_DeleteFromFamily> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Mutation_DeleteFromFamily::new)
    }
}

impl ::protobuf::Clear for Mutation_DeleteFromFamily {
    fn clear(&mut self) {
        self.family_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Mutation_DeleteFromFamily {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Mutation_DeleteFromFamily {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Mutation_DeleteFromRow {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Mutation_DeleteFromRow {
    fn default() -> &'a Mutation_DeleteFromRow {
        <Mutation_DeleteFromRow as ::protobuf::Message>::default_instance()
    }
}

impl Mutation_DeleteFromRow {
    pub fn new() -> Mutation_DeleteFromRow {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Mutation_DeleteFromRow {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Mutation_DeleteFromRow {
        Mutation_DeleteFromRow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Mutation_DeleteFromRow>(
                "Mutation.DeleteFromRow",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Mutation_DeleteFromRow {
        static instance: ::protobuf::rt::LazyV2<Mutation_DeleteFromRow> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Mutation_DeleteFromRow::new)
    }
}

impl ::protobuf::Clear for Mutation_DeleteFromRow {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Mutation_DeleteFromRow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Mutation_DeleteFromRow {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadModifyWriteRule {
    // message fields
    pub family_name: ::std::string::String,
    pub column_qualifier: ::std::vec::Vec<u8>,
    // message oneof groups
    pub rule: ::std::option::Option<ReadModifyWriteRule_oneof_rule>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadModifyWriteRule {
    fn default() -> &'a ReadModifyWriteRule {
        <ReadModifyWriteRule as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ReadModifyWriteRule_oneof_rule {
    append_value(::std::vec::Vec<u8>),
    increment_amount(i64),
}

impl ReadModifyWriteRule {
    pub fn new() -> ReadModifyWriteRule {
        ::std::default::Default::default()
    }

    // string family_name = 1;


    pub fn get_family_name(&self) -> &str {
        &self.family_name
    }
    pub fn clear_family_name(&mut self) {
        self.family_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_family_name(&mut self, v: ::std::string::String) {
        self.family_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_family_name(&mut self) -> &mut ::std::string::String {
        &mut self.family_name
    }

    // Take field
    pub fn take_family_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.family_name, ::std::string::String::new())
    }

    // bytes column_qualifier = 2;


    pub fn get_column_qualifier(&self) -> &[u8] {
        &self.column_qualifier
    }
    pub fn clear_column_qualifier(&mut self) {
        self.column_qualifier.clear();
    }

    // Param is passed by value, moved
    pub fn set_column_qualifier(&mut self, v: ::std::vec::Vec<u8>) {
        self.column_qualifier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_column_qualifier(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.column_qualifier
    }

    // Take field
    pub fn take_column_qualifier(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.column_qualifier, ::std::vec::Vec::new())
    }

    // bytes append_value = 3;


    pub fn get_append_value(&self) -> &[u8] {
        match self.rule {
            ::std::option::Option::Some(ReadModifyWriteRule_oneof_rule::append_value(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_append_value(&mut self) {
        self.rule = ::std::option::Option::None;
    }

    pub fn has_append_value(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(ReadModifyWriteRule_oneof_rule::append_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_append_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.rule = ::std::option::Option::Some(ReadModifyWriteRule_oneof_rule::append_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_append_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(ReadModifyWriteRule_oneof_rule::append_value(_)) = self.rule {
        } else {
            self.rule = ::std::option::Option::Some(ReadModifyWriteRule_oneof_rule::append_value(::std::vec::Vec::new()));
        }
        match self.rule {
            ::std::option::Option::Some(ReadModifyWriteRule_oneof_rule::append_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_append_value(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_append_value() {
            match self.rule.take() {
                ::std::option::Option::Some(ReadModifyWriteRule_oneof_rule::append_value(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // int64 increment_amount = 4;


    pub fn get_increment_amount(&self) -> i64 {
        match self.rule {
            ::std::option::Option::Some(ReadModifyWriteRule_oneof_rule::increment_amount(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_increment_amount(&mut self) {
        self.rule = ::std::option::Option::None;
    }

    pub fn has_increment_amount(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(ReadModifyWriteRule_oneof_rule::increment_amount(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_increment_amount(&mut self, v: i64) {
        self.rule = ::std::option::Option::Some(ReadModifyWriteRule_oneof_rule::increment_amount(v))
    }
}

impl ::protobuf::Message for ReadModifyWriteRule {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.family_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.column_qualifier)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rule = ::std::option::Option::Some(ReadModifyWriteRule_oneof_rule::append_value(is.read_bytes()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rule = ::std::option::Option::Some(ReadModifyWriteRule_oneof_rule::increment_amount(is.read_int64()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.family_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.family_name);
        }
        if !self.column_qualifier.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.column_qualifier);
        }
        if let ::std::option::Option::Some(ref v) = self.rule {
            match v {
                &ReadModifyWriteRule_oneof_rule::append_value(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(3, &v);
                },
                &ReadModifyWriteRule_oneof_rule::increment_amount(v) => {
                    my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.family_name.is_empty() {
            os.write_string(1, &self.family_name)?;
        }
        if !self.column_qualifier.is_empty() {
            os.write_bytes(2, &self.column_qualifier)?;
        }
        if let ::std::option::Option::Some(ref v) = self.rule {
            match v {
                &ReadModifyWriteRule_oneof_rule::append_value(ref v) => {
                    os.write_bytes(3, v)?;
                },
                &ReadModifyWriteRule_oneof_rule::increment_amount(v) => {
                    os.write_int64(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadModifyWriteRule {
        ReadModifyWriteRule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "family_name",
                |m: &ReadModifyWriteRule| { &m.family_name },
                |m: &mut ReadModifyWriteRule| { &mut m.family_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "column_qualifier",
                |m: &ReadModifyWriteRule| { &m.column_qualifier },
                |m: &mut ReadModifyWriteRule| { &mut m.column_qualifier },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "append_value",
                ReadModifyWriteRule::has_append_value,
                ReadModifyWriteRule::get_append_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                "increment_amount",
                ReadModifyWriteRule::has_increment_amount,
                ReadModifyWriteRule::get_increment_amount,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReadModifyWriteRule>(
                "ReadModifyWriteRule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReadModifyWriteRule {
        static instance: ::protobuf::rt::LazyV2<ReadModifyWriteRule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReadModifyWriteRule::new)
    }
}

impl ::protobuf::Clear for ReadModifyWriteRule {
    fn clear(&mut self) {
        self.family_name.clear();
        self.column_qualifier.clear();
        self.rule = ::std::option::Option::None;
        self.rule = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadModifyWriteRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadModifyWriteRule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1dgoogle/bigtable/v2/data.proto\x12\x12google.bigtable.v2\"O\n\x03Ro\
    w\x12\x10\n\x03key\x18\x01\x20\x01(\x0cR\x03key\x126\n\x08families\x18\
    \x02\x20\x03(\x0b2\x1a.google.bigtable.v2.FamilyR\x08families\"R\n\x06Fa\
    mily\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x124\n\x07columns\x18\
    \x02\x20\x03(\x0b2\x1a.google.bigtable.v2.ColumnR\x07columns\"V\n\x06Col\
    umn\x12\x1c\n\tqualifier\x18\x01\x20\x01(\x0cR\tqualifier\x12.\n\x05cell\
    s\x18\x02\x20\x03(\x0b2\x18.google.bigtable.v2.CellR\x05cells\"_\n\x04Ce\
    ll\x12)\n\x10timestamp_micros\x18\x01\x20\x01(\x03R\x0ftimestampMicros\
    \x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\x05value\x12\x16\n\x06labels\
    \x18\x03\x20\x03(\tR\x06labels\"\xc2\x01\n\x08RowRange\x12*\n\x10start_k\
    ey_closed\x18\x01\x20\x01(\x0cH\0R\x0estartKeyClosed\x12&\n\x0estart_key\
    _open\x18\x02\x20\x01(\x0cH\0R\x0cstartKeyOpen\x12\"\n\x0cend_key_open\
    \x18\x03\x20\x01(\x0cH\x01R\nendKeyOpen\x12&\n\x0eend_key_closed\x18\x04\
    \x20\x01(\x0cH\x01R\x0cendKeyClosedB\x0b\n\tstart_keyB\t\n\x07end_key\"`\
    \n\x06RowSet\x12\x19\n\x08row_keys\x18\x01\x20\x03(\x0cR\x07rowKeys\x12;\
    \n\nrow_ranges\x18\x02\x20\x03(\x0b2\x1c.google.bigtable.v2.RowRangeR\tr\
    owRanges\"\xa2\x02\n\x0bColumnRange\x12\x1f\n\x0bfamily_name\x18\x01\x20\
    \x01(\tR\nfamilyName\x126\n\x16start_qualifier_closed\x18\x02\x20\x01(\
    \x0cH\0R\x14startQualifierClosed\x122\n\x14start_qualifier_open\x18\x03\
    \x20\x01(\x0cH\0R\x12startQualifierOpen\x122\n\x14end_qualifier_closed\
    \x18\x04\x20\x01(\x0cH\x01R\x12endQualifierClosed\x12.\n\x12end_qualifie\
    r_open\x18\x05\x20\x01(\x0cH\x01R\x10endQualifierOpenB\x11\n\x0fstart_qu\
    alifierB\x0f\n\rend_qualifier\"x\n\x0eTimestampRange\x124\n\x16start_tim\
    estamp_micros\x18\x01\x20\x01(\x03R\x14startTimestampMicros\x120\n\x14en\
    d_timestamp_micros\x18\x02\x20\x01(\x03R\x12endTimestampMicros\"\xd8\x01\
    \n\nValueRange\x12.\n\x12start_value_closed\x18\x01\x20\x01(\x0cH\0R\x10\
    startValueClosed\x12*\n\x10start_value_open\x18\x02\x20\x01(\x0cH\0R\x0e\
    startValueOpen\x12*\n\x10end_value_closed\x18\x03\x20\x01(\x0cH\x01R\x0e\
    endValueClosed\x12&\n\x0eend_value_open\x18\x04\x20\x01(\x0cH\x01R\x0cen\
    dValueOpenB\r\n\x0bstart_valueB\x0b\n\tend_value\"\xfc\x0b\n\tRowFilter\
    \x12;\n\x05chain\x18\x01\x20\x01(\x0b2#.google.bigtable.v2.RowFilter.Cha\
    inH\0R\x05chain\x12J\n\ninterleave\x18\x02\x20\x01(\x0b2(.google.bigtabl\
    e.v2.RowFilter.InterleaveH\0R\ninterleave\x12G\n\tcondition\x18\x03\x20\
    \x01(\x0b2'.google.bigtable.v2.RowFilter.ConditionH\0R\tcondition\x12\
    \x14\n\x04sink\x18\x10\x20\x01(\x08H\0R\x04sink\x12(\n\x0fpass_all_filte\
    r\x18\x11\x20\x01(\x08H\0R\rpassAllFilter\x12*\n\x10block_all_filter\x18\
    \x12\x20\x01(\x08H\0R\x0eblockAllFilter\x121\n\x14row_key_regex_filter\
    \x18\x04\x20\x01(\x0cH\0R\x11rowKeyRegexFilter\x12,\n\x11row_sample_filt\
    er\x18\x0e\x20\x01(\x01H\0R\x0frowSampleFilter\x129\n\x18family_name_reg\
    ex_filter\x18\x05\x20\x01(\tH\0R\x15familyNameRegexFilter\x12C\n\x1dcolu\
    mn_qualifier_regex_filter\x18\x06\x20\x01(\x0cH\0R\x1acolumnQualifierReg\
    exFilter\x12Q\n\x13column_range_filter\x18\x07\x20\x01(\x0b2\x1f.google.\
    bigtable.v2.ColumnRangeH\0R\x11columnRangeFilter\x12Z\n\x16timestamp_ran\
    ge_filter\x18\x08\x20\x01(\x0b2\".google.bigtable.v2.TimestampRangeH\0R\
    \x14timestampRangeFilter\x12.\n\x12value_regex_filter\x18\t\x20\x01(\x0c\
    H\0R\x10valueRegexFilter\x12N\n\x12value_range_filter\x18\x0f\x20\x01(\
    \x0b2\x1e.google.bigtable.v2.ValueRangeH\0R\x10valueRangeFilter\x12>\n\
    \x1bcells_per_row_offset_filter\x18\n\x20\x01(\x05H\0R\x17cellsPerRowOff\
    setFilter\x12<\n\x1acells_per_row_limit_filter\x18\x0b\x20\x01(\x05H\0R\
    \x16cellsPerRowLimitFilter\x12B\n\x1dcells_per_column_limit_filter\x18\
    \x0c\x20\x01(\x05H\0R\x19cellsPerColumnLimitFilter\x128\n\x17strip_value\
    _transformer\x18\r\x20\x01(\x08H\0R\x15stripValueTransformer\x128\n\x17a\
    pply_label_transformer\x18\x13\x20\x01(\tH\0R\x15applyLabelTransformer\
    \x1a@\n\x05Chain\x127\n\x07filters\x18\x01\x20\x03(\x0b2\x1d.google.bigt\
    able.v2.RowFilterR\x07filters\x1aE\n\nInterleave\x127\n\x07filters\x18\
    \x01\x20\x03(\x0b2\x1d.google.bigtable.v2.RowFilterR\x07filters\x1a\xd7\
    \x01\n\tCondition\x12H\n\x10predicate_filter\x18\x01\x20\x01(\x0b2\x1d.g\
    oogle.bigtable.v2.RowFilterR\x0fpredicateFilter\x12>\n\x0btrue_filter\
    \x18\x02\x20\x01(\x0b2\x1d.google.bigtable.v2.RowFilterR\ntrueFilter\x12\
    @\n\x0cfalse_filter\x18\x03\x20\x01(\x0b2\x1d.google.bigtable.v2.RowFilt\
    erR\x0bfalseFilterB\x08\n\x06filter\"\xf0\x05\n\x08Mutation\x12A\n\x08se\
    t_cell\x18\x01\x20\x01(\x0b2$.google.bigtable.v2.Mutation.SetCellH\0R\
    \x07setCell\x12]\n\x12delete_from_column\x18\x02\x20\x01(\x0b2-.google.b\
    igtable.v2.Mutation.DeleteFromColumnH\0R\x10deleteFromColumn\x12]\n\x12d\
    elete_from_family\x18\x03\x20\x01(\x0b2-.google.bigtable.v2.Mutation.Del\
    eteFromFamilyH\0R\x10deleteFromFamily\x12T\n\x0fdelete_from_row\x18\x04\
    \x20\x01(\x0b2*.google.bigtable.v2.Mutation.DeleteFromRowH\0R\rdeleteFro\
    mRow\x1a\x96\x01\n\x07SetCell\x12\x1f\n\x0bfamily_name\x18\x01\x20\x01(\
    \tR\nfamilyName\x12)\n\x10column_qualifier\x18\x02\x20\x01(\x0cR\x0fcolu\
    mnQualifier\x12)\n\x10timestamp_micros\x18\x03\x20\x01(\x03R\x0ftimestam\
    pMicros\x12\x14\n\x05value\x18\x04\x20\x01(\x0cR\x05value\x1a\xa1\x01\n\
    \x10DeleteFromColumn\x12\x1f\n\x0bfamily_name\x18\x01\x20\x01(\tR\nfamil\
    yName\x12)\n\x10column_qualifier\x18\x02\x20\x01(\x0cR\x0fcolumnQualifie\
    r\x12A\n\ntime_range\x18\x03\x20\x01(\x0b2\".google.bigtable.v2.Timestam\
    pRangeR\ttimeRange\x1a3\n\x10DeleteFromFamily\x12\x1f\n\x0bfamily_name\
    \x18\x01\x20\x01(\tR\nfamilyName\x1a\x0f\n\rDeleteFromRowB\n\n\x08mutati\
    on\"\xbb\x01\n\x13ReadModifyWriteRule\x12\x1f\n\x0bfamily_name\x18\x01\
    \x20\x01(\tR\nfamilyName\x12)\n\x10column_qualifier\x18\x02\x20\x01(\x0c\
    R\x0fcolumnQualifier\x12#\n\x0cappend_value\x18\x03\x20\x01(\x0cH\0R\x0b\
    appendValue\x12+\n\x10increment_amount\x18\x04\x20\x01(\x03H\0R\x0fincre\
    mentAmountB\x06\n\x04ruleB\xb5\x01\n\x16com.google.bigtable.v2B\tDataPro\
    toP\x01Z:google.golang.org/genproto/googleapis/bigtable/v2;bigtable\xaa\
    \x02\x18Google.Cloud.Bigtable.V2\xca\x02\x18Google\\Cloud\\Bigtable\\V2\
    \xea\x02\x1bGoogle::Cloud::Bigtable::V2J\xb5\xb8\x01\n\x07\x12\x05\x0f\0\
    \x97\x04\x01\n\xbe\x04\n\x01\x0c\x12\x03\x0f\0\x122\xb3\x04\x20Copyright\
    \x202019\x20Google\x20LLC.\n\n\x20Licensed\x20under\x20the\x20Apache\x20\
    License,\x20Version\x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20n\
    ot\x20use\x20this\x20file\x20except\x20in\x20compliance\x20with\x20the\
    \x20License.\n\x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20Lice\
    nse\x20at\n\n\x20\x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-\
    2.0\n\n\x20Unless\x20required\x20by\x20applicable\x20law\x20or\x20agreed\
    \x20to\x20in\x20writing,\x20software\n\x20distributed\x20under\x20the\
    \x20License\x20is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\
    \x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20e\
    ither\x20express\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20\
    the\x20specific\x20language\x20governing\x20permissions\x20and\n\x20limi\
    tations\x20under\x20the\x20License.\n\n\n\x08\n\x01\x02\x12\x03\x11\0\
    \x1b\n\x08\n\x01\x08\x12\x03\x13\05\n\t\n\x02\x08%\x12\x03\x13\05\n\x08\
    \n\x01\x08\x12\x03\x14\0Q\n\t\n\x02\x08\x0b\x12\x03\x14\0Q\n\x08\n\x01\
    \x08\x12\x03\x15\0\"\n\t\n\x02\x08\n\x12\x03\x15\0\"\n\x08\n\x01\x08\x12\
    \x03\x16\0*\n\t\n\x02\x08\x08\x12\x03\x16\0*\n\x08\n\x01\x08\x12\x03\x17\
    \0/\n\t\n\x02\x08\x01\x12\x03\x17\0/\n\x08\n\x01\x08\x12\x03\x18\05\n\t\
    \n\x02\x08)\x12\x03\x18\05\n\x08\n\x01\x08\x12\x03\x19\04\n\t\n\x02\x08-\
    \x12\x03\x19\04\n\x90\x01\n\x02\x04\0\x12\x04\x1d\0&\x01\x1a\x83\x01\x20\
    Specifies\x20the\x20complete\x20(requested)\x20contents\x20of\x20a\x20si\
    ngle\x20row\x20of\x20a\x20table.\n\x20Rows\x20which\x20exceed\x20256MiB\
    \x20in\x20size\x20cannot\x20be\x20read\x20in\x20full.\n\n\n\n\x03\x04\0\
    \x01\x12\x03\x1d\x08\x0b\n\xe2\x01\n\x04\x04\0\x02\0\x12\x03!\x02\x10\
    \x1a\xd4\x01\x20The\x20unique\x20key\x20which\x20identifies\x20this\x20r\
    ow\x20within\x20its\x20table.\x20This\x20is\x20the\x20same\n\x20key\x20t\
    hat's\x20used\x20to\x20identify\x20the\x20row\x20in,\x20for\x20example,\
    \x20a\x20MutateRowRequest.\n\x20May\x20contain\x20any\x20non-empty\x20by\
    te\x20string\x20up\x20to\x204KiB\x20in\x20length.\n\n\r\n\x05\x04\0\x02\
    \0\x04\x12\x04!\x02\x1d\r\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03!\x02\x07\n\
    \x0c\n\x05\x04\0\x02\0\x01\x12\x03!\x08\x0b\n\x0c\n\x05\x04\0\x02\0\x03\
    \x12\x03!\x0e\x0f\n{\n\x04\x04\0\x02\x01\x12\x03%\x02\x1f\x1an\x20May\
    \x20be\x20empty,\x20but\x20only\x20if\x20the\x20entire\x20row\x20is\x20e\
    mpty.\n\x20The\x20mutual\x20ordering\x20of\x20column\x20families\x20is\
    \x20not\x20specified.\n\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03%\x02\n\n\
    \x0c\n\x05\x04\0\x02\x01\x06\x12\x03%\x0b\x11\n\x0c\n\x05\x04\0\x02\x01\
    \x01\x12\x03%\x12\x1a\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03%\x1d\x1e\nf\
    \n\x02\x04\x01\x12\x04*\05\x01\x1aZ\x20Specifies\x20(some\x20of)\x20the\
    \x20contents\x20of\x20a\x20single\x20row/column\x20family\x20intersectio\
    n\n\x20of\x20a\x20table.\n\n\n\n\x03\x04\x01\x01\x12\x03*\x08\x0e\n\x85\
    \x03\n\x04\x04\x01\x02\0\x12\x031\x02\x12\x1a\xf7\x02\x20The\x20unique\
    \x20key\x20which\x20identifies\x20this\x20family\x20within\x20its\x20row\
    .\x20This\x20is\x20the\n\x20same\x20key\x20that's\x20used\x20to\x20ident\
    ify\x20the\x20family\x20in,\x20for\x20example,\x20a\x20RowFilter\n\x20wh\
    ich\x20sets\x20its\x20\"family_name_regex_filter\"\x20field.\n\x20Must\
    \x20match\x20`[-_.a-zA-Z0-9]+`,\x20except\x20that\x20AggregatingRowProce\
    ssors\x20may\n\x20produce\x20cells\x20in\x20a\x20sentinel\x20family\x20w\
    ith\x20an\x20empty\x20name.\n\x20Must\x20be\x20no\x20greater\x20than\x20\
    64\x20characters\x20in\x20length.\n\n\r\n\x05\x04\x01\x02\0\x04\x12\x041\
    \x02*\x10\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x031\x02\x08\n\x0c\n\x05\x04\
    \x01\x02\0\x01\x12\x031\t\r\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x031\x10\
    \x11\nL\n\x04\x04\x01\x02\x01\x12\x034\x02\x1e\x1a?\x20Must\x20not\x20be\
    \x20empty.\x20Sorted\x20in\x20order\x20of\x20increasing\x20\"qualifier\"\
    .\n\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x034\x02\n\n\x0c\n\x05\x04\x01\
    \x02\x01\x06\x12\x034\x0b\x11\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x034\
    \x12\x19\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x034\x1c\x1d\n_\n\x02\x04\
    \x02\x12\x049\0C\x01\x1aS\x20Specifies\x20(some\x20of)\x20the\x20content\
    s\x20of\x20a\x20single\x20row/column\x20intersection\x20of\x20a\n\x20tab\
    le.\n\n\n\n\x03\x04\x02\x01\x12\x039\x08\x0e\n\xad\x02\n\x04\x04\x02\x02\
    \0\x12\x03?\x02\x16\x1a\x9f\x02\x20The\x20unique\x20key\x20which\x20iden\
    tifies\x20this\x20column\x20within\x20its\x20family.\x20This\x20is\x20th\
    e\n\x20same\x20key\x20that's\x20used\x20to\x20identify\x20the\x20column\
    \x20in,\x20for\x20example,\x20a\x20RowFilter\n\x20which\x20sets\x20its\
    \x20`column_qualifier_regex_filter`\x20field.\n\x20May\x20contain\x20any\
    \x20byte\x20string,\x20including\x20the\x20empty\x20string,\x20up\x20to\
    \x2016kiB\x20in\n\x20length.\n\n\r\n\x05\x04\x02\x02\0\x04\x12\x04?\x029\
    \x10\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03?\x02\x07\n\x0c\n\x05\x04\x02\
    \x02\0\x01\x12\x03?\x08\x11\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03?\x14\
    \x15\nS\n\x04\x04\x02\x02\x01\x12\x03B\x02\x1a\x1aF\x20Must\x20not\x20be\
    \x20empty.\x20Sorted\x20in\x20order\x20of\x20decreasing\x20\"timestamp_m\
    icros\".\n\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03B\x02\n\n\x0c\n\x05\
    \x04\x02\x02\x01\x06\x12\x03B\x0b\x0f\n\x0c\n\x05\x04\x02\x02\x01\x01\
    \x12\x03B\x10\x15\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03B\x18\x19\n[\n\
    \x02\x04\x03\x12\x04F\0V\x01\x1aO\x20Specifies\x20(some\x20of)\x20the\
    \x20contents\x20of\x20a\x20single\x20row/column/timestamp\x20of\x20a\x20\
    table.\n\n\n\n\x03\x04\x03\x01\x12\x03F\x08\x0c\n\xf6\x02\n\x04\x04\x03\
    \x02\0\x12\x03M\x02\x1d\x1a\xe8\x02\x20The\x20cell's\x20stored\x20timest\
    amp,\x20which\x20also\x20uniquely\x20identifies\x20it\x20within\n\x20its\
    \x20column.\n\x20Values\x20are\x20always\x20expressed\x20in\x20microseco\
    nds,\x20but\x20individual\x20tables\x20may\x20set\n\x20a\x20coarser\x20g\
    ranularity\x20to\x20further\x20restrict\x20the\x20allowed\x20values.\x20\
    For\n\x20example,\x20a\x20table\x20which\x20specifies\x20millisecond\x20\
    granularity\x20will\x20only\x20allow\n\x20values\x20of\x20`timestamp_mic\
    ros`\x20which\x20are\x20multiples\x20of\x201000.\n\n\r\n\x05\x04\x03\x02\
    \0\x04\x12\x04M\x02F\x0e\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03M\x02\x07\
    \n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03M\x08\x18\n\x0c\n\x05\x04\x03\x02\
    \0\x03\x12\x03M\x1b\x1c\n\x7f\n\x04\x04\x03\x02\x01\x12\x03R\x02\x12\x1a\
    r\x20The\x20value\x20stored\x20in\x20the\x20cell.\n\x20May\x20contain\
    \x20any\x20byte\x20string,\x20including\x20the\x20empty\x20string,\x20up\
    \x20to\x20100MiB\x20in\n\x20length.\n\n\r\n\x05\x04\x03\x02\x01\x04\x12\
    \x04R\x02M\x1d\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03R\x02\x07\n\x0c\n\
    \x05\x04\x03\x02\x01\x01\x12\x03R\x08\r\n\x0c\n\x05\x04\x03\x02\x01\x03\
    \x12\x03R\x10\x11\nY\n\x04\x04\x03\x02\x02\x12\x03U\x02\x1d\x1aL\x20Labe\
    ls\x20applied\x20to\x20the\x20cell\x20by\x20a\x20[RowFilter][google.bigt\
    able.v2.RowFilter].\n\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\x03U\x02\n\n\
    \x0c\n\x05\x04\x03\x02\x02\x05\x12\x03U\x0b\x11\n\x0c\n\x05\x04\x03\x02\
    \x02\x01\x12\x03U\x12\x18\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03U\x1b\
    \x1c\n3\n\x02\x04\x04\x12\x04Y\0m\x01\x1a'\x20Specifies\x20a\x20contiguo\
    us\x20range\x20of\x20rows.\n\n\n\n\x03\x04\x04\x01\x12\x03Y\x08\x10\n~\n\
    \x04\x04\x04\x08\0\x12\x04\\\x02b\x03\x1ap\x20The\x20row\x20key\x20at\
    \x20which\x20to\x20start\x20the\x20range.\n\x20If\x20neither\x20field\
    \x20is\x20set,\x20interpreted\x20as\x20the\x20empty\x20string,\x20inclus\
    ive.\n\n\x0c\n\x05\x04\x04\x08\0\x01\x12\x03\\\x08\x11\nG\n\x04\x04\x04\
    \x02\0\x12\x03^\x04\x1f\x1a:\x20Used\x20when\x20giving\x20an\x20inclusiv\
    e\x20lower\x20bound\x20for\x20the\x20range.\n\n\x0c\n\x05\x04\x04\x02\0\
    \x05\x12\x03^\x04\t\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03^\n\x1a\n\x0c\n\
    \x05\x04\x04\x02\0\x03\x12\x03^\x1d\x1e\nG\n\x04\x04\x04\x02\x01\x12\x03\
    a\x04\x1d\x1a:\x20Used\x20when\x20giving\x20an\x20exclusive\x20lower\x20\
    bound\x20for\x20the\x20range.\n\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03a\
    \x04\t\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03a\n\x18\n\x0c\n\x05\x04\
    \x04\x02\x01\x03\x12\x03a\x1b\x1c\n\x80\x01\n\x04\x04\x04\x08\x01\x12\
    \x04f\x02l\x03\x1ar\x20The\x20row\x20key\x20at\x20which\x20to\x20end\x20\
    the\x20range.\n\x20If\x20neither\x20field\x20is\x20set,\x20interpreted\
    \x20as\x20the\x20infinite\x20row\x20key,\x20exclusive.\n\n\x0c\n\x05\x04\
    \x04\x08\x01\x01\x12\x03f\x08\x0f\nG\n\x04\x04\x04\x02\x02\x12\x03h\x04\
    \x1b\x1a:\x20Used\x20when\x20giving\x20an\x20exclusive\x20upper\x20bound\
    \x20for\x20the\x20range.\n\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x03h\x04\
    \t\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03h\n\x16\n\x0c\n\x05\x04\x04\
    \x02\x02\x03\x12\x03h\x19\x1a\nG\n\x04\x04\x04\x02\x03\x12\x03k\x04\x1d\
    \x1a:\x20Used\x20when\x20giving\x20an\x20inclusive\x20upper\x20bound\x20\
    for\x20the\x20range.\n\n\x0c\n\x05\x04\x04\x02\x03\x05\x12\x03k\x04\t\n\
    \x0c\n\x05\x04\x04\x02\x03\x01\x12\x03k\n\x18\n\x0c\n\x05\x04\x04\x02\
    \x03\x03\x12\x03k\x1b\x1c\n5\n\x02\x04\x05\x12\x04p\0v\x01\x1a)\x20Speci\
    fies\x20a\x20non-contiguous\x20set\x20of\x20rows.\n\n\n\n\x03\x04\x05\
    \x01\x12\x03p\x08\x0e\n/\n\x04\x04\x05\x02\0\x12\x03r\x02\x1e\x1a\"\x20S\
    ingle\x20rows\x20included\x20in\x20the\x20set.\n\n\x0c\n\x05\x04\x05\x02\
    \0\x04\x12\x03r\x02\n\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03r\x0b\x10\n\
    \x0c\n\x05\x04\x05\x02\0\x01\x12\x03r\x11\x19\n\x0c\n\x05\x04\x05\x02\0\
    \x03\x12\x03r\x1c\x1d\n9\n\x04\x04\x05\x02\x01\x12\x03u\x02#\x1a,\x20Con\
    tiguous\x20row\x20ranges\x20included\x20in\x20the\x20set.\n\n\x0c\n\x05\
    \x04\x05\x02\x01\x04\x12\x03u\x02\n\n\x0c\n\x05\x04\x05\x02\x01\x06\x12\
    \x03u\x0b\x13\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03u\x14\x1e\n\x0c\n\
    \x05\x04\x05\x02\x01\x03\x12\x03u!\"\n\x84\x02\n\x02\x04\x06\x12\x05|\0\
    \x93\x01\x01\x1a\xf6\x01\x20Specifies\x20a\x20contiguous\x20range\x20of\
    \x20columns\x20within\x20a\x20single\x20column\x20family.\n\x20The\x20ra\
    nge\x20spans\x20from\x20&lt;column_family&gt;:&lt;start_qualifier&gt;\
    \x20to\n\x20&lt;column_family&gt;:&lt;end_qualifier&gt;,\x20where\x20bot\
    h\x20bounds\x20can\x20be\x20either\n\x20inclusive\x20or\x20exclusive.\n\
    \n\n\n\x03\x04\x06\x01\x12\x03|\x08\x13\nK\n\x04\x04\x06\x02\0\x12\x03~\
    \x02\x19\x1a>\x20The\x20name\x20of\x20the\x20column\x20family\x20within\
    \x20which\x20this\x20range\x20falls.\n\n\r\n\x05\x04\x06\x02\0\x04\x12\
    \x04~\x02|\x15\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03~\x02\x08\n\x0c\n\
    \x05\x04\x06\x02\0\x01\x12\x03~\t\x14\n\x0c\n\x05\x04\x06\x02\0\x03\x12\
    \x03~\x17\x18\n\xa3\x01\n\x04\x04\x06\x08\0\x12\x06\x82\x01\x02\x88\x01\
    \x03\x1a\x92\x01\x20The\x20column\x20qualifier\x20at\x20which\x20to\x20s\
    tart\x20the\x20range\x20(within\x20`column_family`).\n\x20If\x20neither\
    \x20field\x20is\x20set,\x20interpreted\x20as\x20the\x20empty\x20string,\
    \x20inclusive.\n\n\r\n\x05\x04\x06\x08\0\x01\x12\x04\x82\x01\x08\x17\nH\
    \n\x04\x04\x06\x02\x01\x12\x04\x84\x01\x04%\x1a:\x20Used\x20when\x20givi\
    ng\x20an\x20inclusive\x20lower\x20bound\x20for\x20the\x20range.\n\n\r\n\
    \x05\x04\x06\x02\x01\x05\x12\x04\x84\x01\x04\t\n\r\n\x05\x04\x06\x02\x01\
    \x01\x12\x04\x84\x01\n\x20\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\x84\x01\
    #$\nH\n\x04\x04\x06\x02\x02\x12\x04\x87\x01\x04#\x1a:\x20Used\x20when\
    \x20giving\x20an\x20exclusive\x20lower\x20bound\x20for\x20the\x20range.\
    \n\n\r\n\x05\x04\x06\x02\x02\x05\x12\x04\x87\x01\x04\t\n\r\n\x05\x04\x06\
    \x02\x02\x01\x12\x04\x87\x01\n\x1e\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\
    \x87\x01!\"\n\xa4\x01\n\x04\x04\x06\x08\x01\x12\x06\x8c\x01\x02\x92\x01\
    \x03\x1a\x93\x01\x20The\x20column\x20qualifier\x20at\x20which\x20to\x20e\
    nd\x20the\x20range\x20(within\x20`column_family`).\n\x20If\x20neither\
    \x20field\x20is\x20set,\x20interpreted\x20as\x20the\x20infinite\x20strin\
    g,\x20exclusive.\n\n\r\n\x05\x04\x06\x08\x01\x01\x12\x04\x8c\x01\x08\x15\
    \nH\n\x04\x04\x06\x02\x03\x12\x04\x8e\x01\x04#\x1a:\x20Used\x20when\x20g\
    iving\x20an\x20inclusive\x20upper\x20bound\x20for\x20the\x20range.\n\n\r\
    \n\x05\x04\x06\x02\x03\x05\x12\x04\x8e\x01\x04\t\n\r\n\x05\x04\x06\x02\
    \x03\x01\x12\x04\x8e\x01\n\x1e\n\r\n\x05\x04\x06\x02\x03\x03\x12\x04\x8e\
    \x01!\"\nH\n\x04\x04\x06\x02\x04\x12\x04\x91\x01\x04!\x1a:\x20Used\x20wh\
    en\x20giving\x20an\x20exclusive\x20upper\x20bound\x20for\x20the\x20range\
    .\n\n\r\n\x05\x04\x06\x02\x04\x05\x12\x04\x91\x01\x04\t\n\r\n\x05\x04\
    \x06\x02\x04\x01\x12\x04\x91\x01\n\x1c\n\r\n\x05\x04\x06\x02\x04\x03\x12\
    \x04\x91\x01\x1f\x20\nG\n\x02\x04\x07\x12\x06\x96\x01\0\x9c\x01\x01\x1a9\
    \x20Specified\x20a\x20contiguous\x20range\x20of\x20microsecond\x20timest\
    amps.\n\n\x0b\n\x03\x04\x07\x01\x12\x04\x96\x01\x08\x16\nG\n\x04\x04\x07\
    \x02\0\x12\x04\x98\x01\x02#\x1a9\x20Inclusive\x20lower\x20bound.\x20If\
    \x20left\x20empty,\x20interpreted\x20as\x200.\n\n\x0f\n\x05\x04\x07\x02\
    \0\x04\x12\x06\x98\x01\x02\x96\x01\x18\n\r\n\x05\x04\x07\x02\0\x05\x12\
    \x04\x98\x01\x02\x07\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\x98\x01\x08\x1e\
    \n\r\n\x05\x04\x07\x02\0\x03\x12\x04\x98\x01!\"\nN\n\x04\x04\x07\x02\x01\
    \x12\x04\x9b\x01\x02!\x1a@\x20Exclusive\x20upper\x20bound.\x20If\x20left\
    \x20empty,\x20interpreted\x20as\x20infinity.\n\n\x0f\n\x05\x04\x07\x02\
    \x01\x04\x12\x06\x9b\x01\x02\x98\x01#\n\r\n\x05\x04\x07\x02\x01\x05\x12\
    \x04\x9b\x01\x02\x07\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\x9b\x01\x08\
    \x1c\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\x9b\x01\x1f\x20\n@\n\x02\x04\
    \x08\x12\x06\x9f\x01\0\xb3\x01\x01\x1a2\x20Specifies\x20a\x20contiguous\
    \x20range\x20of\x20raw\x20byte\x20values.\n\n\x0b\n\x03\x04\x08\x01\x12\
    \x04\x9f\x01\x08\x12\n~\n\x04\x04\x08\x08\0\x12\x06\xa2\x01\x02\xa8\x01\
    \x03\x1an\x20The\x20value\x20at\x20which\x20to\x20start\x20the\x20range.\
    \n\x20If\x20neither\x20field\x20is\x20set,\x20interpreted\x20as\x20the\
    \x20empty\x20string,\x20inclusive.\n\n\r\n\x05\x04\x08\x08\0\x01\x12\x04\
    \xa2\x01\x08\x13\nH\n\x04\x04\x08\x02\0\x12\x04\xa4\x01\x04!\x1a:\x20Use\
    d\x20when\x20giving\x20an\x20inclusive\x20lower\x20bound\x20for\x20the\
    \x20range.\n\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\xa4\x01\x04\t\n\r\n\x05\
    \x04\x08\x02\0\x01\x12\x04\xa4\x01\n\x1c\n\r\n\x05\x04\x08\x02\0\x03\x12\
    \x04\xa4\x01\x1f\x20\nH\n\x04\x04\x08\x02\x01\x12\x04\xa7\x01\x04\x1f\
    \x1a:\x20Used\x20when\x20giving\x20an\x20exclusive\x20lower\x20bound\x20\
    for\x20the\x20range.\n\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\xa7\x01\x04\
    \t\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xa7\x01\n\x1a\n\r\n\x05\x04\x08\
    \x02\x01\x03\x12\x04\xa7\x01\x1d\x1e\n\x7f\n\x04\x04\x08\x08\x01\x12\x06\
    \xac\x01\x02\xb2\x01\x03\x1ao\x20The\x20value\x20at\x20which\x20to\x20en\
    d\x20the\x20range.\n\x20If\x20neither\x20field\x20is\x20set,\x20interpre\
    ted\x20as\x20the\x20infinite\x20string,\x20exclusive.\n\n\r\n\x05\x04\
    \x08\x08\x01\x01\x12\x04\xac\x01\x08\x11\nH\n\x04\x04\x08\x02\x02\x12\
    \x04\xae\x01\x04\x1f\x1a:\x20Used\x20when\x20giving\x20an\x20inclusive\
    \x20upper\x20bound\x20for\x20the\x20range.\n\n\r\n\x05\x04\x08\x02\x02\
    \x05\x12\x04\xae\x01\x04\t\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\xae\x01\
    \n\x1a\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\xae\x01\x1d\x1e\nH\n\x04\
    \x04\x08\x02\x03\x12\x04\xb1\x01\x04\x1d\x1a:\x20Used\x20when\x20giving\
    \x20an\x20exclusive\x20upper\x20bound\x20for\x20the\x20range.\n\n\r\n\
    \x05\x04\x08\x02\x03\x05\x12\x04\xb1\x01\x04\t\n\r\n\x05\x04\x08\x02\x03\
    \x01\x12\x04\xb1\x01\n\x18\n\r\n\x05\x04\x08\x02\x03\x03\x12\x04\xb1\x01\
    \x1b\x1c\n\xa9\x0f\n\x02\x04\t\x12\x06\xd6\x01\0\xb9\x03\x01\x1a\x9a\x0f\
    \x20Takes\x20a\x20row\x20as\x20input\x20and\x20produces\x20an\x20alterna\
    te\x20view\x20of\x20the\x20row\x20based\x20on\n\x20specified\x20rules.\
    \x20For\x20example,\x20a\x20RowFilter\x20might\x20trim\x20down\x20a\x20r\
    ow\x20to\x20include\n\x20just\x20the\x20cells\x20from\x20columns\x20matc\
    hing\x20a\x20given\x20regular\x20expression,\x20or\x20might\n\x20return\
    \x20all\x20the\x20cells\x20of\x20a\x20row\x20but\x20not\x20their\x20valu\
    es.\x20More\x20complicated\x20filters\n\x20can\x20be\x20composed\x20out\
    \x20of\x20these\x20components\x20to\x20express\x20requests\x20such\x20as\
    ,\x20\"within\n\x20every\x20column\x20of\x20a\x20particular\x20family,\
    \x20give\x20just\x20the\x20two\x20most\x20recent\x20cells\n\x20which\x20\
    are\x20older\x20than\x20timestamp\x20X.\"\n\n\x20There\x20are\x20two\x20\
    broad\x20categories\x20of\x20RowFilters\x20(true\x20filters\x20and\x20tr\
    ansformers),\n\x20as\x20well\x20as\x20two\x20ways\x20to\x20compose\x20si\
    mple\x20filters\x20into\x20more\x20complex\x20ones\n\x20(chains\x20and\
    \x20interleaves).\x20They\x20work\x20as\x20follows:\n\n\x20*\x20True\x20\
    filters\x20alter\x20the\x20input\x20row\x20by\x20excluding\x20some\x20of\
    \x20its\x20cells\x20wholesale\n\x20from\x20the\x20output\x20row.\x20An\
    \x20example\x20of\x20a\x20true\x20filter\x20is\x20the\x20`value_regex_fi\
    lter`,\n\x20which\x20excludes\x20cells\x20whose\x20values\x20don't\x20ma\
    tch\x20the\x20specified\x20pattern.\x20All\n\x20regex\x20true\x20filters\
    \x20use\x20RE2\x20syntax\x20(https://github.com/google/re2/wiki/Syntax)\
    \n\x20in\x20raw\x20byte\x20mode\x20(RE2::Latin1),\x20and\x20are\x20evalu\
    ated\x20as\x20full\x20matches.\x20An\n\x20important\x20point\x20to\x20ke\
    ep\x20in\x20mind\x20is\x20that\x20`RE2(.)`\x20is\x20equivalent\x20by\x20\
    default\x20to\n\x20`RE2([^\\n])`,\x20meaning\x20that\x20it\x20does\x20no\
    t\x20match\x20newlines.\x20When\x20attempting\x20to\n\x20match\x20an\x20\
    arbitrary\x20byte,\x20you\x20should\x20therefore\x20use\x20the\x20escape\
    \x20sequence\x20`\\C`,\n\x20which\x20may\x20need\x20to\x20be\x20further\
    \x20escaped\x20as\x20`\\\\C`\x20in\x20your\x20client\x20language.\n\n\
    \x20*\x20Transformers\x20alter\x20the\x20input\x20row\x20by\x20changing\
    \x20the\x20values\x20of\x20some\x20of\x20its\n\x20cells\x20in\x20the\x20\
    output,\x20without\x20excluding\x20them\x20completely.\x20Currently,\x20\
    the\x20only\n\x20supported\x20transformer\x20is\x20the\x20`strip_value_t\
    ransformer`,\x20which\x20replaces\x20every\n\x20cell's\x20value\x20with\
    \x20the\x20empty\x20string.\n\n\x20*\x20Chains\x20and\x20interleaves\x20\
    are\x20described\x20in\x20more\x20detail\x20in\x20the\n\x20RowFilter.Cha\
    in\x20and\x20RowFilter.Interleave\x20documentation.\n\n\x20The\x20total\
    \x20serialized\x20size\x20of\x20a\x20RowFilter\x20message\x20must\x20not\
    \n\x20exceed\x204096\x20bytes,\x20and\x20RowFilters\x20may\x20not\x20be\
    \x20nested\x20within\x20each\x20other\n\x20(in\x20Chains\x20or\x20Interl\
    eaves)\x20to\x20a\x20depth\x20of\x20more\x20than\x2020.\n\n\x0b\n\x03\
    \x04\t\x01\x12\x04\xd6\x01\x08\x11\nV\n\x04\x04\t\x03\0\x12\x06\xd8\x01\
    \x02\xdd\x01\x03\x1aF\x20A\x20RowFilter\x20which\x20sends\x20rows\x20thr\
    ough\x20several\x20RowFilters\x20in\x20sequence.\n\n\r\n\x05\x04\t\x03\0\
    \x01\x12\x04\xd8\x01\n\x0f\n\xc9\x01\n\x06\x04\t\x03\0\x02\0\x12\x04\xdc\
    \x01\x04#\x1a\xb8\x01\x20The\x20elements\x20of\x20\"filters\"\x20are\x20\
    chained\x20together\x20to\x20process\x20the\x20input\x20row:\n\x20in\x20\
    row\x20->\x20f(0)\x20->\x20intermediate\x20row\x20->\x20f(1)\x20->\x20..\
    .\x20->\x20f(N)\x20->\x20out\x20row\n\x20The\x20full\x20chain\x20is\x20e\
    xecuted\x20atomically.\n\n\x0f\n\x07\x04\t\x03\0\x02\0\x04\x12\x04\xdc\
    \x01\x04\x0c\n\x0f\n\x07\x04\t\x03\0\x02\0\x06\x12\x04\xdc\x01\r\x16\n\
    \x0f\n\x07\x04\t\x03\0\x02\0\x01\x12\x04\xdc\x01\x17\x1e\n\x0f\n\x07\x04\
    \t\x03\0\x02\0\x03\x12\x04\xdc\x01!\"\nx\n\x04\x04\t\x03\x01\x12\x06\xe1\
    \x01\x02\xfc\x01\x03\x1ah\x20A\x20RowFilter\x20which\x20sends\x20each\
    \x20row\x20to\x20each\x20of\x20several\x20component\n\x20RowFilters\x20a\
    nd\x20interleaves\x20the\x20results.\n\n\r\n\x05\x04\t\x03\x01\x01\x12\
    \x04\xe1\x01\n\x14\n\x93\x0b\n\x06\x04\t\x03\x01\x02\0\x12\x04\xfb\x01\
    \x04#\x1a\x82\x0b\x20The\x20elements\x20of\x20\"filters\"\x20all\x20proc\
    ess\x20a\x20copy\x20of\x20the\x20input\x20row,\x20and\x20the\n\x20result\
    s\x20are\x20pooled,\x20sorted,\x20and\x20combined\x20into\x20a\x20single\
    \x20output\x20row.\n\x20If\x20multiple\x20cells\x20are\x20produced\x20wi\
    th\x20the\x20same\x20column\x20and\x20timestamp,\n\x20they\x20will\x20al\
    l\x20appear\x20in\x20the\x20output\x20row\x20in\x20an\x20unspecified\x20\
    mutual\x20order.\n\x20Consider\x20the\x20following\x20example,\x20with\
    \x20three\x20filters:\n\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20input\x20row\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20------------------------------------------------\
    -----\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20f(0)\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20f(1)\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20f(2)\n\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x201:\x20foo,bar\
    ,10,x\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20foo,bar,10,z\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20far,bar,7,a\n\
    \x20\x20\x20\x20\x202:\x20foo,blah,11,z\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20far,blah,5,x\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20far,blah,5,x\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20------------------------\
    -----------------------------\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x201:\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20foo,bar,10,z\x20\x20\x20//\x20could\x20have\x20switched\x20w\
    ith\x20#2\n\x20\x20\x20\x20\x202:\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20foo,bar,10,x\x20\x20\
    \x20//\x20could\x20have\x20switched\x20with\x20#1\n\x20\x20\x20\x20\x203\
    :\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20foo,blah,11,z\n\x20\x20\x20\x20\x204:\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20far,bar,7,a\n\x20\x20\x20\x20\x205:\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20far,blah,5,x\x20\
    \x20\x20//\x20identical\x20to\x20#6\n\x20\x20\x20\x20\x206:\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20far,blah,5,x\x20\x20\x20//\x20identical\x20to\x20#5\n\n\x20All\x20in\
    terleaved\x20filters\x20are\x20executed\x20atomically.\n\n\x0f\n\x07\x04\
    \t\x03\x01\x02\0\x04\x12\x04\xfb\x01\x04\x0c\n\x0f\n\x07\x04\t\x03\x01\
    \x02\0\x06\x12\x04\xfb\x01\r\x16\n\x0f\n\x07\x04\t\x03\x01\x02\0\x01\x12\
    \x04\xfb\x01\x17\x1e\n\x0f\n\x07\x04\t\x03\x01\x02\0\x03\x12\x04\xfb\x01\
    !\"\n\xb4\x03\n\x04\x04\t\x03\x02\x12\x06\x85\x02\x02\x92\x02\x03\x1a\
    \xa3\x03\x20A\x20RowFilter\x20which\x20evaluates\x20one\x20of\x20two\x20\
    possible\x20RowFilters,\x20depending\x20on\n\x20whether\x20or\x20not\x20\
    a\x20predicate\x20RowFilter\x20outputs\x20any\x20cells\x20from\x20the\
    \x20input\x20row.\n\n\x20IMPORTANT\x20NOTE:\x20The\x20predicate\x20filte\
    r\x20does\x20not\x20execute\x20atomically\x20with\x20the\n\x20true\x20an\
    d\x20false\x20filters,\x20which\x20may\x20lead\x20to\x20inconsistent\x20\
    or\x20unexpected\n\x20results.\x20Additionally,\x20Condition\x20filters\
    \x20have\x20poor\x20performance,\x20especially\n\x20when\x20filters\x20a\
    re\x20set\x20for\x20the\x20false\x20condition.\n\n\r\n\x05\x04\t\x03\x02\
    \x01\x12\x04\x85\x02\n\x13\n\xa0\x01\n\x06\x04\t\x03\x02\x02\0\x12\x04\
    \x88\x02\x04#\x1a\x8f\x01\x20If\x20`predicate_filter`\x20outputs\x20any\
    \x20cells,\x20then\x20`true_filter`\x20will\x20be\n\x20evaluated\x20on\
    \x20the\x20input\x20row.\x20Otherwise,\x20`false_filter`\x20will\x20be\
    \x20evaluated.\n\n\x11\n\x07\x04\t\x03\x02\x02\0\x04\x12\x06\x88\x02\x04\
    \x85\x02\x15\n\x0f\n\x07\x04\t\x03\x02\x02\0\x06\x12\x04\x88\x02\x04\r\n\
    \x0f\n\x07\x04\t\x03\x02\x02\0\x01\x12\x04\x88\x02\x0e\x1e\n\x0f\n\x07\
    \x04\t\x03\x02\x02\0\x03\x12\x04\x88\x02!\"\n\xa2\x01\n\x06\x04\t\x03\
    \x02\x02\x01\x12\x04\x8c\x02\x04\x1e\x1a\x91\x01\x20The\x20filter\x20to\
    \x20apply\x20to\x20the\x20input\x20row\x20if\x20`predicate_filter`\x20re\
    turns\x20any\n\x20results.\x20If\x20not\x20provided,\x20no\x20results\
    \x20will\x20be\x20returned\x20in\x20the\x20true\x20case.\n\n\x11\n\x07\
    \x04\t\x03\x02\x02\x01\x04\x12\x06\x8c\x02\x04\x88\x02#\n\x0f\n\x07\x04\
    \t\x03\x02\x02\x01\x06\x12\x04\x8c\x02\x04\r\n\x0f\n\x07\x04\t\x03\x02\
    \x02\x01\x01\x12\x04\x8c\x02\x0e\x19\n\x0f\n\x07\x04\t\x03\x02\x02\x01\
    \x03\x12\x04\x8c\x02\x1c\x1d\n\xac\x01\n\x06\x04\t\x03\x02\x02\x02\x12\
    \x04\x91\x02\x04\x1f\x1a\x9b\x01\x20The\x20filter\x20to\x20apply\x20to\
    \x20the\x20input\x20row\x20if\x20`predicate_filter`\x20does\x20not\n\x20\
    return\x20any\x20results.\x20If\x20not\x20provided,\x20no\x20results\x20\
    will\x20be\x20returned\x20in\x20the\n\x20false\x20case.\n\n\x11\n\x07\
    \x04\t\x03\x02\x02\x02\x04\x12\x06\x91\x02\x04\x8c\x02\x1e\n\x0f\n\x07\
    \x04\t\x03\x02\x02\x02\x06\x12\x04\x91\x02\x04\r\n\x0f\n\x07\x04\t\x03\
    \x02\x02\x02\x01\x12\x04\x91\x02\x0e\x1a\n\x0f\n\x07\x04\t\x03\x02\x02\
    \x02\x03\x12\x04\x91\x02\x1d\x1e\n\x86\x01\n\x04\x04\t\x08\0\x12\x06\x96\
    \x02\x02\xb8\x03\x03\x1av\x20Which\x20of\x20the\x20possible\x20RowFilter\
    \x20types\x20to\x20apply.\x20If\x20none\x20are\x20set,\x20this\n\x20RowF\
    ilter\x20returns\x20all\x20cells\x20in\x20the\x20input\x20row.\n\n\r\n\
    \x05\x04\t\x08\0\x01\x12\x04\x96\x02\x08\x0e\ni\n\x04\x04\t\x02\0\x12\
    \x04\x99\x02\x04\x14\x1a[\x20Applies\x20several\x20RowFilters\x20to\x20t\
    he\x20data\x20in\x20sequence,\x20progressively\n\x20narrowing\x20the\x20\
    results.\n\n\r\n\x05\x04\t\x02\0\x06\x12\x04\x99\x02\x04\t\n\r\n\x05\x04\
    \t\x02\0\x01\x12\x04\x99\x02\n\x0f\n\r\n\x05\x04\t\x02\0\x03\x12\x04\x99\
    \x02\x12\x13\n]\n\x04\x04\t\x02\x01\x12\x04\x9d\x02\x04\x1e\x1aO\x20Appl\
    ies\x20several\x20RowFilters\x20to\x20the\x20data\x20in\x20parallel\x20a\
    nd\x20combines\x20the\n\x20results.\n\n\r\n\x05\x04\t\x02\x01\x06\x12\
    \x04\x9d\x02\x04\x0e\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\x9d\x02\x0f\x19\
    \n\r\n\x05\x04\t\x02\x01\x03\x12\x04\x9d\x02\x1c\x1d\nq\n\x04\x04\t\x02\
    \x02\x12\x04\xa1\x02\x04\x1c\x1ac\x20Applies\x20one\x20of\x20two\x20poss\
    ible\x20RowFilters\x20to\x20the\x20data\x20based\x20on\x20the\x20output\
    \x20of\n\x20a\x20predicate\x20RowFilter.\n\n\r\n\x05\x04\t\x02\x02\x06\
    \x12\x04\xa1\x02\x04\r\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\xa1\x02\x0e\
    \x17\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\xa1\x02\x1a\x1b\n\xb7\x14\n\x04\
    \x04\t\x02\x03\x12\x04\xde\x02\x04\x13\x1a\xa8\x14\x20ADVANCED\x20USE\
    \x20ONLY.\n\x20Hook\x20for\x20introspection\x20into\x20the\x20RowFilter.\
    \x20Outputs\x20all\x20cells\x20directly\x20to\n\x20the\x20output\x20of\
    \x20the\x20read\x20rather\x20than\x20to\x20any\x20parent\x20filter.\x20C\
    onsider\x20the\n\x20following\x20example:\n\n\x20\x20\x20\x20\x20Chain(\
    \n\x20\x20\x20\x20\x20\x20\x20FamilyRegex(\"A\"),\n\x20\x20\x20\x20\x20\
    \x20\x20Interleave(\n\x20\x20\x20\x20\x20\x20\x20\x20\x20All(),\n\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20Chain(Label(\"foo\"),\x20Sink())\n\x20\
    \x20\x20\x20\x20\x20\x20),\n\x20\x20\x20\x20\x20\x20\x20QualifierRegex(\
    \"B\")\n\x20\x20\x20\x20\x20)\n\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20A,A,1,w\
    \n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20A,B,2,x\n\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    B,B,4,z\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20Fami\
    lyRegex(\"A\")\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20A,A,1,w\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20A,B,2,x\n\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20+------------+-------------+\n\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20|\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20All()\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20Label(foo)\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20A,A,1,w\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20A,A,1,w,labels:[foo]\n\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20A,B,2,x\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20A,B,2,x,labels:[foo]\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20Sink()\x20--------------+\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20+------------+\x20\
    \x20\x20\x20\x20\x20x------+\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20A,A,\
    1,w,labels:[foo]\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20A,B,2,x,labels:[foo]\n\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20A,A,\
    1,w\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20A,B,2,x\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20QualifierRegex(\"B\")\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    |\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20A,B,2,x\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20|\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20+-----------------------\
    ---------+\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20A,A,1,w,labels:[foo]\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20A,B,2,x,\
    labels:[foo]\x20\x20//\x20could\x20be\x20switched\n\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20A,B,2,x\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20//\x20could\x20be\x20switched\n\n\x20Despite\x20being\x20excluded\
    \x20by\x20the\x20qualifier\x20filter,\x20a\x20copy\x20of\x20every\x20cel\
    l\n\x20that\x20reaches\x20the\x20sink\x20is\x20present\x20in\x20the\x20f\
    inal\x20result.\n\n\x20As\x20with\x20an\x20[Interleave][google.bigtable.\
    v2.RowFilter.Interleave],\n\x20duplicate\x20cells\x20are\x20possible,\
    \x20and\x20appear\x20in\x20an\x20unspecified\x20mutual\x20order.\n\x20In\
    \x20this\x20case\x20we\x20have\x20a\x20duplicate\x20with\x20column\x20\"\
    A:B\"\x20and\x20timestamp\x202,\n\x20because\x20one\x20copy\x20passed\
    \x20through\x20the\x20all\x20filter\x20while\x20the\x20other\x20was\n\
    \x20passed\x20through\x20the\x20label\x20and\x20sink.\x20Note\x20that\
    \x20one\x20copy\x20has\x20label\x20\"foo\",\n\x20while\x20the\x20other\
    \x20does\x20not.\n\n\x20Cannot\x20be\x20used\x20within\x20the\x20`predic\
    ate_filter`,\x20`true_filter`,\x20or\n\x20`false_filter`\x20of\x20a\x20[\
    Condition][google.bigtable.v2.RowFilter.Condition].\n\n\r\n\x05\x04\t\
    \x02\x03\x05\x12\x04\xde\x02\x04\x08\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\
    \xde\x02\t\r\n\r\n\x05\x04\t\x02\x03\x03\x12\x04\xde\x02\x10\x12\n\x8a\
    \x01\n\x04\x04\t\x02\x04\x12\x04\xe2\x02\x04\x1e\x1a|\x20Matches\x20all\
    \x20cells,\x20regardless\x20of\x20input.\x20Functionally\x20equivalent\
    \x20to\n\x20leaving\x20`filter`\x20unset,\x20but\x20included\x20for\x20c\
    ompleteness.\n\n\r\n\x05\x04\t\x02\x04\x05\x12\x04\xe2\x02\x04\x08\n\r\n\
    \x05\x04\t\x02\x04\x01\x12\x04\xe2\x02\t\x18\n\r\n\x05\x04\t\x02\x04\x03\
    \x12\x04\xe2\x02\x1b\x1d\nw\n\x04\x04\t\x02\x05\x12\x04\xe6\x02\x04\x1f\
    \x1ai\x20Does\x20not\x20match\x20any\x20cells,\x20regardless\x20of\x20in\
    put.\x20Useful\x20for\x20temporarily\n\x20disabling\x20just\x20part\x20o\
    f\x20a\x20filter.\n\n\r\n\x05\x04\t\x02\x05\x05\x12\x04\xe6\x02\x04\x08\
    \n\r\n\x05\x04\t\x02\x05\x01\x12\x04\xe6\x02\t\x19\n\r\n\x05\x04\t\x02\
    \x05\x03\x12\x04\xe6\x02\x1c\x1e\n\xa4\x03\n\x04\x04\t\x02\x06\x12\x04\
    \xef\x02\x04#\x1a\x95\x03\x20Matches\x20only\x20cells\x20from\x20rows\
    \x20whose\x20keys\x20satisfy\x20the\x20given\x20RE2\x20regex.\x20In\n\
    \x20other\x20words,\x20passes\x20through\x20the\x20entire\x20row\x20when\
    \x20the\x20key\x20matches,\x20and\n\x20otherwise\x20produces\x20an\x20em\
    pty\x20row.\n\x20Note\x20that,\x20since\x20row\x20keys\x20can\x20contain\
    \x20arbitrary\x20bytes,\x20the\x20`\\C`\x20escape\n\x20sequence\x20must\
    \x20be\x20used\x20if\x20a\x20true\x20wildcard\x20is\x20desired.\x20The\
    \x20`.`\x20character\n\x20will\x20not\x20match\x20the\x20new\x20line\x20\
    character\x20`\\n`,\x20which\x20may\x20be\x20present\x20in\x20a\n\x20bin\
    ary\x20key.\n\n\r\n\x05\x04\t\x02\x06\x05\x12\x04\xef\x02\x04\t\n\r\n\
    \x05\x04\t\x02\x06\x01\x12\x04\xef\x02\n\x1e\n\r\n\x05\x04\t\x02\x06\x03\
    \x12\x04\xef\x02!\"\ny\n\x04\x04\t\x02\x07\x12\x04\xf3\x02\x04\"\x1ak\
    \x20Matches\x20all\x20cells\x20from\x20a\x20row\x20with\x20probability\
    \x20p,\x20and\x20matches\x20no\x20cells\n\x20from\x20the\x20row\x20with\
    \x20probability\x201-p.\n\n\r\n\x05\x04\t\x02\x07\x05\x12\x04\xf3\x02\
    \x04\n\n\r\n\x05\x04\t\x02\x07\x01\x12\x04\xf3\x02\x0b\x1c\n\r\n\x05\x04\
    \t\x02\x07\x03\x12\x04\xf3\x02\x1f!\n\xf0\x02\n\x04\x04\t\x02\x08\x12\
    \x04\xfb\x02\x04(\x1a\xe1\x02\x20Matches\x20only\x20cells\x20from\x20col\
    umns\x20whose\x20families\x20satisfy\x20the\x20given\x20RE2\n\x20regex.\
    \x20For\x20technical\x20reasons,\x20the\x20regex\x20must\x20not\x20conta\
    in\x20the\x20`:`\n\x20character,\x20even\x20if\x20it\x20is\x20not\x20bei\
    ng\x20used\x20as\x20a\x20literal.\n\x20Note\x20that,\x20since\x20column\
    \x20families\x20cannot\x20contain\x20the\x20new\x20line\x20character\n\
    \x20`\\n`,\x20it\x20is\x20sufficient\x20to\x20use\x20`.`\x20as\x20a\x20f\
    ull\x20wildcard\x20when\x20matching\n\x20column\x20family\x20names.\n\n\
    \r\n\x05\x04\t\x02\x08\x05\x12\x04\xfb\x02\x04\n\n\r\n\x05\x04\t\x02\x08\
    \x01\x12\x04\xfb\x02\x0b#\n\r\n\x05\x04\t\x02\x08\x03\x12\x04\xfb\x02&'\
    \n\xd2\x02\n\x04\x04\t\x02\t\x12\x04\x83\x03\x04,\x1a\xc3\x02\x20Matches\
    \x20only\x20cells\x20from\x20columns\x20whose\x20qualifiers\x20satisfy\
    \x20the\x20given\x20RE2\n\x20regex.\n\x20Note\x20that,\x20since\x20colum\
    n\x20qualifiers\x20can\x20contain\x20arbitrary\x20bytes,\x20the\x20`\\C`\
    \n\x20escape\x20sequence\x20must\x20be\x20used\x20if\x20a\x20true\x20wil\
    dcard\x20is\x20desired.\x20The\x20`.`\n\x20character\x20will\x20not\x20m\
    atch\x20the\x20new\x20line\x20character\x20`\\n`,\x20which\x20may\x20be\
    \n\x20present\x20in\x20a\x20binary\x20qualifier.\n\n\r\n\x05\x04\t\x02\t\
    \x05\x12\x04\x83\x03\x04\t\n\r\n\x05\x04\t\x02\t\x01\x12\x04\x83\x03\n'\
    \n\r\n\x05\x04\t\x02\t\x03\x12\x04\x83\x03*+\nG\n\x04\x04\t\x02\n\x12\
    \x04\x86\x03\x04(\x1a9\x20Matches\x20only\x20cells\x20from\x20columns\
    \x20within\x20the\x20given\x20range.\n\n\r\n\x05\x04\t\x02\n\x06\x12\x04\
    \x86\x03\x04\x0f\n\r\n\x05\x04\t\x02\n\x01\x12\x04\x86\x03\x10#\n\r\n\
    \x05\x04\t\x02\n\x03\x12\x04\x86\x03&'\nJ\n\x04\x04\t\x02\x0b\x12\x04\
    \x89\x03\x04.\x1a<\x20Matches\x20only\x20cells\x20with\x20timestamps\x20\
    within\x20the\x20given\x20range.\n\n\r\n\x05\x04\t\x02\x0b\x06\x12\x04\
    \x89\x03\x04\x12\n\r\n\x05\x04\t\x02\x0b\x01\x12\x04\x89\x03\x13)\n\r\n\
    \x05\x04\t\x02\x0b\x03\x12\x04\x89\x03,-\n\xc3\x02\n\x04\x04\t\x02\x0c\
    \x12\x04\x90\x03\x04!\x1a\xb4\x02\x20Matches\x20only\x20cells\x20with\
    \x20values\x20that\x20satisfy\x20the\x20given\x20regular\x20expression.\
    \n\x20Note\x20that,\x20since\x20cell\x20values\x20can\x20contain\x20arbi\
    trary\x20bytes,\x20the\x20`\\C`\x20escape\n\x20sequence\x20must\x20be\
    \x20used\x20if\x20a\x20true\x20wildcard\x20is\x20desired.\x20The\x20`.`\
    \x20character\n\x20will\x20not\x20match\x20the\x20new\x20line\x20charact\
    er\x20`\\n`,\x20which\x20may\x20be\x20present\x20in\x20a\n\x20binary\x20\
    value.\n\n\r\n\x05\x04\t\x02\x0c\x05\x12\x04\x90\x03\x04\t\n\r\n\x05\x04\
    \t\x02\x0c\x01\x12\x04\x90\x03\n\x1c\n\r\n\x05\x04\t\x02\x0c\x03\x12\x04\
    \x90\x03\x1f\x20\nP\n\x04\x04\t\x02\r\x12\x04\x93\x03\x04'\x1aB\x20Match\
    es\x20only\x20cells\x20with\x20values\x20that\x20fall\x20within\x20the\
    \x20given\x20range.\n\n\r\n\x05\x04\t\x02\r\x06\x12\x04\x93\x03\x04\x0e\
    \n\r\n\x05\x04\t\x02\r\x01\x12\x04\x93\x03\x0f!\n\r\n\x05\x04\t\x02\r\
    \x03\x12\x04\x93\x03$&\n\xcc\x01\n\x04\x04\t\x02\x0e\x12\x04\x98\x03\x04\
    +\x1a\xbd\x01\x20Skips\x20the\x20first\x20N\x20cells\x20of\x20each\x20ro\
    w,\x20matching\x20all\x20subsequent\x20cells.\n\x20If\x20duplicate\x20ce\
    lls\x20are\x20present,\x20as\x20is\x20possible\x20when\x20using\x20an\
    \x20Interleave,\n\x20each\x20copy\x20of\x20the\x20cell\x20is\x20counted\
    \x20separately.\n\n\r\n\x05\x04\t\x02\x0e\x05\x12\x04\x98\x03\x04\t\n\r\
    \n\x05\x04\t\x02\x0e\x01\x12\x04\x98\x03\n%\n\r\n\x05\x04\t\x02\x0e\x03\
    \x12\x04\x98\x03(*\n\xb4\x01\n\x04\x04\t\x02\x0f\x12\x04\x9d\x03\x04*\
    \x1a\xa5\x01\x20Matches\x20only\x20the\x20first\x20N\x20cells\x20of\x20e\
    ach\x20row.\n\x20If\x20duplicate\x20cells\x20are\x20present,\x20as\x20is\
    \x20possible\x20when\x20using\x20an\x20Interleave,\n\x20each\x20copy\x20\
    of\x20the\x20cell\x20is\x20counted\x20separately.\n\n\r\n\x05\x04\t\x02\
    \x0f\x05\x12\x04\x9d\x03\x04\t\n\r\n\x05\x04\t\x02\x0f\x01\x12\x04\x9d\
    \x03\n$\n\r\n\x05\x04\t\x02\x0f\x03\x12\x04\x9d\x03')\n\xf3\x02\n\x04\
    \x04\t\x02\x10\x12\x04\xa5\x03\x04-\x1a\xe4\x02\x20Matches\x20only\x20th\
    e\x20most\x20recent\x20N\x20cells\x20within\x20each\x20column.\x20For\
    \x20example,\n\x20if\x20N=2,\x20this\x20filter\x20would\x20match\x20colu\
    mn\x20`foo:bar`\x20at\x20timestamps\x2010\x20and\x209,\n\x20skip\x20all\
    \x20earlier\x20cells\x20in\x20`foo:bar`,\x20and\x20then\x20begin\x20matc\
    hing\x20again\x20in\n\x20column\x20`foo:bar2`.\n\x20If\x20duplicate\x20c\
    ells\x20are\x20present,\x20as\x20is\x20possible\x20when\x20using\x20an\
    \x20Interleave,\n\x20each\x20copy\x20of\x20the\x20cell\x20is\x20counted\
    \x20separately.\n\n\r\n\x05\x04\t\x02\x10\x05\x12\x04\xa5\x03\x04\t\n\r\
    \n\x05\x04\t\x02\x10\x01\x12\x04\xa5\x03\n'\n\r\n\x05\x04\t\x02\x10\x03\
    \x12\x04\xa5\x03*,\nA\n\x04\x04\t\x02\x11\x12\x04\xa8\x03\x04&\x1a3\x20R\
    eplaces\x20each\x20cell's\x20value\x20with\x20the\x20empty\x20string.\n\
    \n\r\n\x05\x04\t\x02\x11\x05\x12\x04\xa8\x03\x04\x08\n\r\n\x05\x04\t\x02\
    \x11\x01\x12\x04\xa8\x03\t\x20\n\r\n\x05\x04\t\x02\x11\x03\x12\x04\xa8\
    \x03#%\n\xfb\x04\n\x04\x04\t\x02\x12\x12\x04\xb7\x03\x04(\x1a\xec\x04\
    \x20Applies\x20the\x20given\x20label\x20to\x20all\x20cells\x20in\x20the\
    \x20output\x20row.\x20This\x20allows\n\x20the\x20client\x20to\x20determi\
    ne\x20which\x20results\x20were\x20produced\x20from\x20which\x20part\x20o\
    f\n\x20the\x20filter.\n\n\x20Values\x20must\x20be\x20at\x20most\x2015\
    \x20characters\x20in\x20length,\x20and\x20match\x20the\x20RE2\n\x20patte\
    rn\x20`[a-z0-9\\\\-]+`\n\n\x20Due\x20to\x20a\x20technical\x20limitation,\
    \x20it\x20is\x20not\x20currently\x20possible\x20to\x20apply\n\x20multipl\
    e\x20labels\x20to\x20a\x20cell.\x20As\x20a\x20result,\x20a\x20Chain\x20m\
    ay\x20have\x20no\x20more\x20than\n\x20one\x20sub-filter\x20which\x20cont\
    ains\x20a\x20`apply_label_transformer`.\x20It\x20is\x20okay\x20for\n\x20\
    an\x20Interleave\x20to\x20contain\x20multiple\x20`apply_label_transforme\
    rs`,\x20as\x20they\n\x20will\x20be\x20applied\x20to\x20separate\x20copie\
    s\x20of\x20the\x20input.\x20This\x20may\x20be\x20relaxed\x20in\n\x20the\
    \x20future.\n\n\r\n\x05\x04\t\x02\x12\x05\x12\x04\xb7\x03\x04\n\n\r\n\
    \x05\x04\t\x02\x12\x01\x12\x04\xb7\x03\x0b\"\n\r\n\x05\x04\t\x02\x12\x03\
    \x12\x04\xb7\x03%'\nR\n\x02\x04\n\x12\x06\xbc\x03\0\xfb\x03\x01\x1aD\x20\
    Specifies\x20a\x20particular\x20change\x20to\x20be\x20made\x20to\x20the\
    \x20contents\x20of\x20a\x20row.\n\n\x0b\n\x03\x04\n\x01\x12\x04\xbc\x03\
    \x08\x10\nH\n\x04\x04\n\x03\0\x12\x06\xbe\x03\x02\xd0\x03\x03\x1a8\x20A\
    \x20Mutation\x20which\x20sets\x20the\x20value\x20of\x20the\x20specified\
    \x20cell.\n\n\r\n\x05\x04\n\x03\0\x01\x12\x04\xbe\x03\n\x11\nm\n\x06\x04\
    \n\x03\0\x02\0\x12\x04\xc1\x03\x04\x1b\x1a]\x20The\x20name\x20of\x20the\
    \x20family\x20into\x20which\x20new\x20data\x20should\x20be\x20written.\n\
    \x20Must\x20match\x20`[-_.a-zA-Z0-9]+`\n\n\x11\n\x07\x04\n\x03\0\x02\0\
    \x04\x12\x06\xc1\x03\x04\xbe\x03\x13\n\x0f\n\x07\x04\n\x03\0\x02\0\x05\
    \x12\x04\xc1\x03\x04\n\n\x0f\n\x07\x04\n\x03\0\x02\0\x01\x12\x04\xc1\x03\
    \x0b\x16\n\x0f\n\x07\x04\n\x03\0\x02\0\x03\x12\x04\xc1\x03\x19\x1a\n\x89\
    \x01\n\x06\x04\n\x03\0\x02\x01\x12\x04\xc5\x03\x04\x1f\x1ay\x20The\x20qu\
    alifier\x20of\x20the\x20column\x20into\x20which\x20new\x20data\x20should\
    \x20be\x20written.\n\x20Can\x20be\x20any\x20byte\x20string,\x20including\
    \x20the\x20empty\x20string.\n\n\x11\n\x07\x04\n\x03\0\x02\x01\x04\x12\
    \x06\xc5\x03\x04\xc1\x03\x1b\n\x0f\n\x07\x04\n\x03\0\x02\x01\x05\x12\x04\
    \xc5\x03\x04\t\n\x0f\n\x07\x04\n\x03\0\x02\x01\x01\x12\x04\xc5\x03\n\x1a\
    \n\x0f\n\x07\x04\n\x03\0\x02\x01\x03\x12\x04\xc5\x03\x1d\x1e\n\xd1\x02\n\
    \x06\x04\n\x03\0\x02\x02\x12\x04\xcc\x03\x04\x1f\x1a\xc0\x02\x20The\x20t\
    imestamp\x20of\x20the\x20cell\x20into\x20which\x20new\x20data\x20should\
    \x20be\x20written.\n\x20Use\x20-1\x20for\x20current\x20Bigtable\x20serve\
    r\x20time.\n\x20Otherwise,\x20the\x20client\x20should\x20set\x20this\x20\
    value\x20itself,\x20noting\x20that\x20the\n\x20default\x20value\x20is\
    \x20a\x20timestamp\x20of\x20zero\x20if\x20the\x20field\x20is\x20left\x20\
    unspecified.\n\x20Values\x20must\x20match\x20the\x20granularity\x20of\
    \x20the\x20table\x20(e.g.\x20micros,\x20millis).\n\n\x11\n\x07\x04\n\x03\
    \0\x02\x02\x04\x12\x06\xcc\x03\x04\xc5\x03\x1f\n\x0f\n\x07\x04\n\x03\0\
    \x02\x02\x05\x12\x04\xcc\x03\x04\t\n\x0f\n\x07\x04\n\x03\0\x02\x02\x01\
    \x12\x04\xcc\x03\n\x1a\n\x0f\n\x07\x04\n\x03\0\x02\x02\x03\x12\x04\xcc\
    \x03\x1d\x1e\nB\n\x06\x04\n\x03\0\x02\x03\x12\x04\xcf\x03\x04\x14\x1a2\
    \x20The\x20value\x20to\x20be\x20written\x20into\x20the\x20specified\x20c\
    ell.\n\n\x11\n\x07\x04\n\x03\0\x02\x03\x04\x12\x06\xcf\x03\x04\xcc\x03\
    \x1f\n\x0f\n\x07\x04\n\x03\0\x02\x03\x05\x12\x04\xcf\x03\x04\t\n\x0f\n\
    \x07\x04\n\x03\0\x02\x03\x01\x12\x04\xcf\x03\n\x0f\n\x0f\n\x07\x04\n\x03\
    \0\x02\x03\x03\x12\x04\xcf\x03\x12\x13\n\x8d\x01\n\x04\x04\n\x03\x01\x12\
    \x06\xd4\x03\x02\xdf\x03\x03\x1a}\x20A\x20Mutation\x20which\x20deletes\
    \x20cells\x20from\x20the\x20specified\x20column,\x20optionally\n\x20rest\
    ricting\x20the\x20deletions\x20to\x20a\x20given\x20timestamp\x20range.\n\
    \n\r\n\x05\x04\n\x03\x01\x01\x12\x04\xd4\x03\n\x1a\nj\n\x06\x04\n\x03\
    \x01\x02\0\x12\x04\xd7\x03\x04\x1b\x1aZ\x20The\x20name\x20of\x20the\x20f\
    amily\x20from\x20which\x20cells\x20should\x20be\x20deleted.\n\x20Must\
    \x20match\x20`[-_.a-zA-Z0-9]+`\n\n\x11\n\x07\x04\n\x03\x01\x02\0\x04\x12\
    \x06\xd7\x03\x04\xd4\x03\x1c\n\x0f\n\x07\x04\n\x03\x01\x02\0\x05\x12\x04\
    \xd7\x03\x04\n\n\x0f\n\x07\x04\n\x03\x01\x02\0\x01\x12\x04\xd7\x03\x0b\
    \x16\n\x0f\n\x07\x04\n\x03\x01\x02\0\x03\x12\x04\xd7\x03\x19\x1a\n\x86\
    \x01\n\x06\x04\n\x03\x01\x02\x01\x12\x04\xdb\x03\x04\x1f\x1av\x20The\x20\
    qualifier\x20of\x20the\x20column\x20from\x20which\x20cells\x20should\x20\
    be\x20deleted.\n\x20Can\x20be\x20any\x20byte\x20string,\x20including\x20\
    the\x20empty\x20string.\n\n\x11\n\x07\x04\n\x03\x01\x02\x01\x04\x12\x06\
    \xdb\x03\x04\xd7\x03\x1b\n\x0f\n\x07\x04\n\x03\x01\x02\x01\x05\x12\x04\
    \xdb\x03\x04\t\n\x0f\n\x07\x04\n\x03\x01\x02\x01\x01\x12\x04\xdb\x03\n\
    \x1a\n\x0f\n\x07\x04\n\x03\x01\x02\x01\x03\x12\x04\xdb\x03\x1d\x1e\nO\n\
    \x06\x04\n\x03\x01\x02\x02\x12\x04\xde\x03\x04\"\x1a?\x20The\x20range\
    \x20of\x20timestamps\x20within\x20which\x20cells\x20should\x20be\x20dele\
    ted.\n\n\x11\n\x07\x04\n\x03\x01\x02\x02\x04\x12\x06\xde\x03\x04\xdb\x03\
    \x1f\n\x0f\n\x07\x04\n\x03\x01\x02\x02\x06\x12\x04\xde\x03\x04\x12\n\x0f\
    \n\x07\x04\n\x03\x01\x02\x02\x01\x12\x04\xde\x03\x13\x1d\n\x0f\n\x07\x04\
    \n\x03\x01\x02\x02\x03\x12\x04\xde\x03\x20!\nV\n\x04\x04\n\x03\x02\x12\
    \x06\xe2\x03\x02\xe6\x03\x03\x1aF\x20A\x20Mutation\x20which\x20deletes\
    \x20all\x20cells\x20from\x20the\x20specified\x20column\x20family.\n\n\r\
    \n\x05\x04\n\x03\x02\x01\x12\x04\xe2\x03\n\x1a\nj\n\x06\x04\n\x03\x02\
    \x02\0\x12\x04\xe5\x03\x04\x1b\x1aZ\x20The\x20name\x20of\x20the\x20famil\
    y\x20from\x20which\x20cells\x20should\x20be\x20deleted.\n\x20Must\x20mat\
    ch\x20`[-_.a-zA-Z0-9]+`\n\n\x11\n\x07\x04\n\x03\x02\x02\0\x04\x12\x06\
    \xe5\x03\x04\xe2\x03\x1c\n\x0f\n\x07\x04\n\x03\x02\x02\0\x05\x12\x04\xe5\
    \x03\x04\n\n\x0f\n\x07\x04\n\x03\x02\x02\0\x01\x12\x04\xe5\x03\x0b\x16\n\
    \x0f\n\x07\x04\n\x03\x02\x02\0\x03\x12\x04\xe5\x03\x19\x1a\nM\n\x04\x04\
    \n\x03\x03\x12\x06\xe9\x03\x02\xeb\x03\x03\x1a=\x20A\x20Mutation\x20whic\
    h\x20deletes\x20all\x20cells\x20from\x20the\x20containing\x20row.\n\n\r\
    \n\x05\x04\n\x03\x03\x01\x12\x04\xe9\x03\n\x17\n@\n\x04\x04\n\x08\0\x12\
    \x06\xee\x03\x02\xfa\x03\x03\x1a0\x20Which\x20of\x20the\x20possible\x20M\
    utation\x20types\x20to\x20apply.\n\n\r\n\x05\x04\n\x08\0\x01\x12\x04\xee\
    \x03\x08\x10\n#\n\x04\x04\n\x02\0\x12\x04\xf0\x03\x04\x19\x1a\x15\x20Set\
    \x20a\x20cell's\x20value.\n\n\r\n\x05\x04\n\x02\0\x06\x12\x04\xf0\x03\
    \x04\x0b\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xf0\x03\x0c\x14\n\r\n\x05\x04\
    \n\x02\0\x03\x12\x04\xf0\x03\x17\x18\n,\n\x04\x04\n\x02\x01\x12\x04\xf3\
    \x03\x04,\x1a\x1e\x20Deletes\x20cells\x20from\x20a\x20column.\n\n\r\n\
    \x05\x04\n\x02\x01\x06\x12\x04\xf3\x03\x04\x14\n\r\n\x05\x04\n\x02\x01\
    \x01\x12\x04\xf3\x03\x15'\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xf3\x03*+\
    \n3\n\x04\x04\n\x02\x02\x12\x04\xf6\x03\x04,\x1a%\x20Deletes\x20cells\
    \x20from\x20a\x20column\x20family.\n\n\r\n\x05\x04\n\x02\x02\x06\x12\x04\
    \xf6\x03\x04\x14\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\xf6\x03\x15'\n\r\n\
    \x05\x04\n\x02\x02\x03\x12\x04\xf6\x03*+\n2\n\x04\x04\n\x02\x03\x12\x04\
    \xf9\x03\x04&\x1a$\x20Deletes\x20cells\x20from\x20the\x20entire\x20row.\
    \n\n\r\n\x05\x04\n\x02\x03\x06\x12\x04\xf9\x03\x04\x11\n\r\n\x05\x04\n\
    \x02\x03\x01\x12\x04\xf9\x03\x12!\n\r\n\x05\x04\n\x02\x03\x03\x12\x04\
    \xf9\x03$%\nm\n\x02\x04\x0b\x12\x06\xff\x03\0\x97\x04\x01\x1a_\x20Specif\
    ies\x20an\x20atomic\x20read/modify/write\x20operation\x20on\x20the\x20la\
    test\x20value\x20of\x20the\n\x20specified\x20column.\n\n\x0b\n\x03\x04\
    \x0b\x01\x12\x04\xff\x03\x08\x1b\nv\n\x04\x04\x0b\x02\0\x12\x04\x82\x04\
    \x02\x19\x1ah\x20The\x20name\x20of\x20the\x20family\x20to\x20which\x20th\
    e\x20read/modify/write\x20should\x20be\x20applied.\n\x20Must\x20match\
    \x20`[-_.a-zA-Z0-9]+`\n\n\x0f\n\x05\x04\x0b\x02\0\x04\x12\x06\x82\x04\
    \x02\xff\x03\x1d\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\x82\x04\x02\x08\n\r\
    \n\x05\x04\x0b\x02\0\x01\x12\x04\x82\x04\t\x14\n\r\n\x05\x04\x0b\x02\0\
    \x03\x12\x04\x82\x04\x17\x18\n\x94\x01\n\x04\x04\x0b\x02\x01\x12\x04\x87\
    \x04\x02\x1d\x1a\x85\x01\x20The\x20qualifier\x20of\x20the\x20column\x20t\
    o\x20which\x20the\x20read/modify/write\x20should\x20be\n\x20applied.\n\
    \x20Can\x20be\x20any\x20byte\x20string,\x20including\x20the\x20empty\x20\
    string.\n\n\x0f\n\x05\x04\x0b\x02\x01\x04\x12\x06\x87\x04\x02\x82\x04\
    \x19\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\x87\x04\x02\x07\n\r\n\x05\x04\
    \x0b\x02\x01\x01\x12\x04\x87\x04\x08\x18\n\r\n\x05\x04\x0b\x02\x01\x03\
    \x12\x04\x87\x04\x1b\x1c\nj\n\x04\x04\x0b\x08\0\x12\x06\x8b\x04\x02\x96\
    \x04\x03\x1aZ\x20The\x20rule\x20used\x20to\x20determine\x20the\x20column\
    's\x20new\x20latest\x20value\x20from\x20its\x20current\n\x20latest\x20va\
    lue.\n\n\r\n\x05\x04\x0b\x08\0\x01\x12\x04\x8b\x04\x08\x0c\n\xab\x01\n\
    \x04\x04\x0b\x02\x02\x12\x04\x8f\x04\x04\x1b\x1a\x9c\x01\x20Rule\x20spec\
    ifying\x20that\x20`append_value`\x20be\x20appended\x20to\x20the\x20exist\
    ing\x20value.\n\x20If\x20the\x20targeted\x20cell\x20is\x20unset,\x20it\
    \x20will\x20be\x20treated\x20as\x20containing\x20the\n\x20empty\x20strin\
    g.\n\n\r\n\x05\x04\x0b\x02\x02\x05\x12\x04\x8f\x04\x04\t\n\r\n\x05\x04\
    \x0b\x02\x02\x01\x12\x04\x8f\x04\n\x16\n\r\n\x05\x04\x0b\x02\x02\x03\x12\
    \x04\x8f\x04\x19\x1a\n\xb3\x02\n\x04\x04\x0b\x02\x03\x12\x04\x95\x04\x04\
    \x1f\x1a\xa4\x02\x20Rule\x20specifying\x20that\x20`increment_amount`\x20\
    be\x20added\x20to\x20the\x20existing\x20value.\n\x20If\x20the\x20targete\
    d\x20cell\x20is\x20unset,\x20it\x20will\x20be\x20treated\x20as\x20contai\
    ning\x20a\x20zero.\n\x20Otherwise,\x20the\x20targeted\x20cell\x20must\
    \x20contain\x20an\x208-byte\x20value\x20(interpreted\n\x20as\x20a\x2064-\
    bit\x20big-endian\x20signed\x20integer),\x20or\x20the\x20entire\x20reque\
    st\x20will\x20fail.\n\n\r\n\x05\x04\x0b\x02\x03\x05\x12\x04\x95\x04\x04\
    \t\n\r\n\x05\x04\x0b\x02\x03\x01\x12\x04\x95\x04\n\x1a\n\r\n\x05\x04\x0b\
    \x02\x03\x03\x12\x04\x95\x04\x1d\x1eb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
