// This file is generated by rust-protobuf 2.22.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/storage/v1/storage_resources.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_22_0;

#[derive(PartialEq,Clone,Default)]
pub struct Bucket {
    // message fields
    pub acl: ::protobuf::RepeatedField<BucketAccessControl>,
    pub default_object_acl: ::protobuf::RepeatedField<ObjectAccessControl>,
    pub lifecycle: ::protobuf::SingularPtrField<Bucket_Lifecycle>,
    pub time_created: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    pub project_number: i64,
    pub metageneration: i64,
    pub cors: ::protobuf::RepeatedField<Bucket_Cors>,
    pub location: ::std::string::String,
    pub storage_class: ::std::string::String,
    pub etag: ::std::string::String,
    pub updated: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub default_event_based_hold: bool,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub website: ::protobuf::SingularPtrField<Bucket_Website>,
    pub versioning: ::protobuf::SingularPtrField<Bucket_Versioning>,
    pub logging: ::protobuf::SingularPtrField<Bucket_Logging>,
    pub owner: ::protobuf::SingularPtrField<Owner>,
    pub encryption: ::protobuf::SingularPtrField<Bucket_Encryption>,
    pub billing: ::protobuf::SingularPtrField<Bucket_Billing>,
    pub retention_policy: ::protobuf::SingularPtrField<Bucket_RetentionPolicy>,
    pub location_type: ::std::string::String,
    pub iam_configuration: ::protobuf::SingularPtrField<Bucket_IamConfiguration>,
    pub zone_affinity: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Bucket {
    fn default() -> &'a Bucket {
        <Bucket as ::protobuf::Message>::default_instance()
    }
}

impl Bucket {
    pub fn new() -> Bucket {
        ::std::default::Default::default()
    }

    // repeated .google.storage.v1.BucketAccessControl acl = 1;


    pub fn get_acl(&self) -> &[BucketAccessControl] {
        &self.acl
    }
    pub fn clear_acl(&mut self) {
        self.acl.clear();
    }

    // Param is passed by value, moved
    pub fn set_acl(&mut self, v: ::protobuf::RepeatedField<BucketAccessControl>) {
        self.acl = v;
    }

    // Mutable pointer to the field.
    pub fn mut_acl(&mut self) -> &mut ::protobuf::RepeatedField<BucketAccessControl> {
        &mut self.acl
    }

    // Take field
    pub fn take_acl(&mut self) -> ::protobuf::RepeatedField<BucketAccessControl> {
        ::std::mem::replace(&mut self.acl, ::protobuf::RepeatedField::new())
    }

    // repeated .google.storage.v1.ObjectAccessControl default_object_acl = 2;


    pub fn get_default_object_acl(&self) -> &[ObjectAccessControl] {
        &self.default_object_acl
    }
    pub fn clear_default_object_acl(&mut self) {
        self.default_object_acl.clear();
    }

    // Param is passed by value, moved
    pub fn set_default_object_acl(&mut self, v: ::protobuf::RepeatedField<ObjectAccessControl>) {
        self.default_object_acl = v;
    }

    // Mutable pointer to the field.
    pub fn mut_default_object_acl(&mut self) -> &mut ::protobuf::RepeatedField<ObjectAccessControl> {
        &mut self.default_object_acl
    }

    // Take field
    pub fn take_default_object_acl(&mut self) -> ::protobuf::RepeatedField<ObjectAccessControl> {
        ::std::mem::replace(&mut self.default_object_acl, ::protobuf::RepeatedField::new())
    }

    // .google.storage.v1.Bucket.Lifecycle lifecycle = 3;


    pub fn get_lifecycle(&self) -> &Bucket_Lifecycle {
        self.lifecycle.as_ref().unwrap_or_else(|| <Bucket_Lifecycle as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lifecycle(&mut self) {
        self.lifecycle.clear();
    }

    pub fn has_lifecycle(&self) -> bool {
        self.lifecycle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lifecycle(&mut self, v: Bucket_Lifecycle) {
        self.lifecycle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lifecycle(&mut self) -> &mut Bucket_Lifecycle {
        if self.lifecycle.is_none() {
            self.lifecycle.set_default();
        }
        self.lifecycle.as_mut().unwrap()
    }

    // Take field
    pub fn take_lifecycle(&mut self) -> Bucket_Lifecycle {
        self.lifecycle.take().unwrap_or_else(|| Bucket_Lifecycle::new())
    }

    // .google.protobuf.Timestamp time_created = 4;


    pub fn get_time_created(&self) -> &::protobuf::well_known_types::Timestamp {
        self.time_created.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_time_created(&mut self) {
        self.time_created.clear();
    }

    pub fn has_time_created(&self) -> bool {
        self.time_created.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_created(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.time_created = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time_created(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.time_created.is_none() {
            self.time_created.set_default();
        }
        self.time_created.as_mut().unwrap()
    }

    // Take field
    pub fn take_time_created(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.time_created.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string id = 5;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string name = 6;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // int64 project_number = 7;


    pub fn get_project_number(&self) -> i64 {
        self.project_number
    }
    pub fn clear_project_number(&mut self) {
        self.project_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_project_number(&mut self, v: i64) {
        self.project_number = v;
    }

    // int64 metageneration = 8;


    pub fn get_metageneration(&self) -> i64 {
        self.metageneration
    }
    pub fn clear_metageneration(&mut self) {
        self.metageneration = 0;
    }

    // Param is passed by value, moved
    pub fn set_metageneration(&mut self, v: i64) {
        self.metageneration = v;
    }

    // repeated .google.storage.v1.Bucket.Cors cors = 9;


    pub fn get_cors(&self) -> &[Bucket_Cors] {
        &self.cors
    }
    pub fn clear_cors(&mut self) {
        self.cors.clear();
    }

    // Param is passed by value, moved
    pub fn set_cors(&mut self, v: ::protobuf::RepeatedField<Bucket_Cors>) {
        self.cors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cors(&mut self) -> &mut ::protobuf::RepeatedField<Bucket_Cors> {
        &mut self.cors
    }

    // Take field
    pub fn take_cors(&mut self) -> ::protobuf::RepeatedField<Bucket_Cors> {
        ::std::mem::replace(&mut self.cors, ::protobuf::RepeatedField::new())
    }

    // string location = 10;


    pub fn get_location(&self) -> &str {
        &self.location
    }
    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: ::std::string::String) {
        self.location = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut ::std::string::String {
        &mut self.location
    }

    // Take field
    pub fn take_location(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.location, ::std::string::String::new())
    }

    // string storage_class = 11;


    pub fn get_storage_class(&self) -> &str {
        &self.storage_class
    }
    pub fn clear_storage_class(&mut self) {
        self.storage_class.clear();
    }

    // Param is passed by value, moved
    pub fn set_storage_class(&mut self, v: ::std::string::String) {
        self.storage_class = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storage_class(&mut self) -> &mut ::std::string::String {
        &mut self.storage_class
    }

    // Take field
    pub fn take_storage_class(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.storage_class, ::std::string::String::new())
    }

    // string etag = 12;


    pub fn get_etag(&self) -> &str {
        &self.etag
    }
    pub fn clear_etag(&mut self) {
        self.etag.clear();
    }

    // Param is passed by value, moved
    pub fn set_etag(&mut self, v: ::std::string::String) {
        self.etag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_etag(&mut self) -> &mut ::std::string::String {
        &mut self.etag
    }

    // Take field
    pub fn take_etag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.etag, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp updated = 13;


    pub fn get_updated(&self) -> &::protobuf::well_known_types::Timestamp {
        self.updated.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_updated(&mut self) {
        self.updated.clear();
    }

    pub fn has_updated(&self) -> bool {
        self.updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.updated = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updated(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.updated.is_none() {
            self.updated.set_default();
        }
        self.updated.as_mut().unwrap()
    }

    // Take field
    pub fn take_updated(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.updated.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // bool default_event_based_hold = 14;


    pub fn get_default_event_based_hold(&self) -> bool {
        self.default_event_based_hold
    }
    pub fn clear_default_event_based_hold(&mut self) {
        self.default_event_based_hold = false;
    }

    // Param is passed by value, moved
    pub fn set_default_event_based_hold(&mut self, v: bool) {
        self.default_event_based_hold = v;
    }

    // repeated .google.storage.v1.Bucket.LabelsEntry labels = 15;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }

    // .google.storage.v1.Bucket.Website website = 16;


    pub fn get_website(&self) -> &Bucket_Website {
        self.website.as_ref().unwrap_or_else(|| <Bucket_Website as ::protobuf::Message>::default_instance())
    }
    pub fn clear_website(&mut self) {
        self.website.clear();
    }

    pub fn has_website(&self) -> bool {
        self.website.is_some()
    }

    // Param is passed by value, moved
    pub fn set_website(&mut self, v: Bucket_Website) {
        self.website = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_website(&mut self) -> &mut Bucket_Website {
        if self.website.is_none() {
            self.website.set_default();
        }
        self.website.as_mut().unwrap()
    }

    // Take field
    pub fn take_website(&mut self) -> Bucket_Website {
        self.website.take().unwrap_or_else(|| Bucket_Website::new())
    }

    // .google.storage.v1.Bucket.Versioning versioning = 17;


    pub fn get_versioning(&self) -> &Bucket_Versioning {
        self.versioning.as_ref().unwrap_or_else(|| <Bucket_Versioning as ::protobuf::Message>::default_instance())
    }
    pub fn clear_versioning(&mut self) {
        self.versioning.clear();
    }

    pub fn has_versioning(&self) -> bool {
        self.versioning.is_some()
    }

    // Param is passed by value, moved
    pub fn set_versioning(&mut self, v: Bucket_Versioning) {
        self.versioning = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_versioning(&mut self) -> &mut Bucket_Versioning {
        if self.versioning.is_none() {
            self.versioning.set_default();
        }
        self.versioning.as_mut().unwrap()
    }

    // Take field
    pub fn take_versioning(&mut self) -> Bucket_Versioning {
        self.versioning.take().unwrap_or_else(|| Bucket_Versioning::new())
    }

    // .google.storage.v1.Bucket.Logging logging = 18;


    pub fn get_logging(&self) -> &Bucket_Logging {
        self.logging.as_ref().unwrap_or_else(|| <Bucket_Logging as ::protobuf::Message>::default_instance())
    }
    pub fn clear_logging(&mut self) {
        self.logging.clear();
    }

    pub fn has_logging(&self) -> bool {
        self.logging.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logging(&mut self, v: Bucket_Logging) {
        self.logging = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logging(&mut self) -> &mut Bucket_Logging {
        if self.logging.is_none() {
            self.logging.set_default();
        }
        self.logging.as_mut().unwrap()
    }

    // Take field
    pub fn take_logging(&mut self) -> Bucket_Logging {
        self.logging.take().unwrap_or_else(|| Bucket_Logging::new())
    }

    // .google.storage.v1.Owner owner = 19;


    pub fn get_owner(&self) -> &Owner {
        self.owner.as_ref().unwrap_or_else(|| <Owner as ::protobuf::Message>::default_instance())
    }
    pub fn clear_owner(&mut self) {
        self.owner.clear();
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: Owner) {
        self.owner = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner(&mut self) -> &mut Owner {
        if self.owner.is_none() {
            self.owner.set_default();
        }
        self.owner.as_mut().unwrap()
    }

    // Take field
    pub fn take_owner(&mut self) -> Owner {
        self.owner.take().unwrap_or_else(|| Owner::new())
    }

    // .google.storage.v1.Bucket.Encryption encryption = 20;


    pub fn get_encryption(&self) -> &Bucket_Encryption {
        self.encryption.as_ref().unwrap_or_else(|| <Bucket_Encryption as ::protobuf::Message>::default_instance())
    }
    pub fn clear_encryption(&mut self) {
        self.encryption.clear();
    }

    pub fn has_encryption(&self) -> bool {
        self.encryption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption(&mut self, v: Bucket_Encryption) {
        self.encryption = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption(&mut self) -> &mut Bucket_Encryption {
        if self.encryption.is_none() {
            self.encryption.set_default();
        }
        self.encryption.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryption(&mut self) -> Bucket_Encryption {
        self.encryption.take().unwrap_or_else(|| Bucket_Encryption::new())
    }

    // .google.storage.v1.Bucket.Billing billing = 21;


    pub fn get_billing(&self) -> &Bucket_Billing {
        self.billing.as_ref().unwrap_or_else(|| <Bucket_Billing as ::protobuf::Message>::default_instance())
    }
    pub fn clear_billing(&mut self) {
        self.billing.clear();
    }

    pub fn has_billing(&self) -> bool {
        self.billing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_billing(&mut self, v: Bucket_Billing) {
        self.billing = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_billing(&mut self) -> &mut Bucket_Billing {
        if self.billing.is_none() {
            self.billing.set_default();
        }
        self.billing.as_mut().unwrap()
    }

    // Take field
    pub fn take_billing(&mut self) -> Bucket_Billing {
        self.billing.take().unwrap_or_else(|| Bucket_Billing::new())
    }

    // .google.storage.v1.Bucket.RetentionPolicy retention_policy = 22;


    pub fn get_retention_policy(&self) -> &Bucket_RetentionPolicy {
        self.retention_policy.as_ref().unwrap_or_else(|| <Bucket_RetentionPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_retention_policy(&mut self) {
        self.retention_policy.clear();
    }

    pub fn has_retention_policy(&self) -> bool {
        self.retention_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retention_policy(&mut self, v: Bucket_RetentionPolicy) {
        self.retention_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retention_policy(&mut self) -> &mut Bucket_RetentionPolicy {
        if self.retention_policy.is_none() {
            self.retention_policy.set_default();
        }
        self.retention_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_retention_policy(&mut self) -> Bucket_RetentionPolicy {
        self.retention_policy.take().unwrap_or_else(|| Bucket_RetentionPolicy::new())
    }

    // string location_type = 23;


    pub fn get_location_type(&self) -> &str {
        &self.location_type
    }
    pub fn clear_location_type(&mut self) {
        self.location_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_location_type(&mut self, v: ::std::string::String) {
        self.location_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location_type(&mut self) -> &mut ::std::string::String {
        &mut self.location_type
    }

    // Take field
    pub fn take_location_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.location_type, ::std::string::String::new())
    }

    // .google.storage.v1.Bucket.IamConfiguration iam_configuration = 24;


    pub fn get_iam_configuration(&self) -> &Bucket_IamConfiguration {
        self.iam_configuration.as_ref().unwrap_or_else(|| <Bucket_IamConfiguration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_iam_configuration(&mut self) {
        self.iam_configuration.clear();
    }

    pub fn has_iam_configuration(&self) -> bool {
        self.iam_configuration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iam_configuration(&mut self, v: Bucket_IamConfiguration) {
        self.iam_configuration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iam_configuration(&mut self) -> &mut Bucket_IamConfiguration {
        if self.iam_configuration.is_none() {
            self.iam_configuration.set_default();
        }
        self.iam_configuration.as_mut().unwrap()
    }

    // Take field
    pub fn take_iam_configuration(&mut self) -> Bucket_IamConfiguration {
        self.iam_configuration.take().unwrap_or_else(|| Bucket_IamConfiguration::new())
    }

    // repeated string zone_affinity = 25;


    pub fn get_zone_affinity(&self) -> &[::std::string::String] {
        &self.zone_affinity
    }
    pub fn clear_zone_affinity(&mut self) {
        self.zone_affinity.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone_affinity(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.zone_affinity = v;
    }

    // Mutable pointer to the field.
    pub fn mut_zone_affinity(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.zone_affinity
    }

    // Take field
    pub fn take_zone_affinity(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.zone_affinity, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Bucket {
    fn is_initialized(&self) -> bool {
        for v in &self.acl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.default_object_acl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lifecycle {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.time_created {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cors {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updated {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.website {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.versioning {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.logging {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.owner {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.encryption {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.billing {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.retention_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.iam_configuration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.acl)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.default_object_acl)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lifecycle)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time_created)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.project_number = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.metageneration = tmp;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cors)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.location)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.storage_class)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.etag)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.updated)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.default_event_based_hold = tmp;
                },
                15 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.website)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.versioning)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.logging)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.owner)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.encryption)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.billing)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.retention_policy)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.location_type)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.iam_configuration)?;
                },
                25 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.zone_affinity)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.acl {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.default_object_acl {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.lifecycle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.time_created.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.name);
        }
        if self.project_number != 0 {
            my_size += ::protobuf::rt::value_size(7, self.project_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.metageneration != 0 {
            my_size += ::protobuf::rt::value_size(8, self.metageneration, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.cors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.location.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.location);
        }
        if !self.storage_class.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.storage_class);
        }
        if !self.etag.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.etag);
        }
        if let Some(ref v) = self.updated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.default_event_based_hold != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(15, &self.labels);
        if let Some(ref v) = self.website.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.versioning.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.logging.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.owner.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.encryption.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.billing.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.retention_policy.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.location_type.is_empty() {
            my_size += ::protobuf::rt::string_size(23, &self.location_type);
        }
        if let Some(ref v) = self.iam_configuration.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.zone_affinity {
            my_size += ::protobuf::rt::string_size(25, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.acl {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.default_object_acl {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.lifecycle.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.time_created.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.id.is_empty() {
            os.write_string(5, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(6, &self.name)?;
        }
        if self.project_number != 0 {
            os.write_int64(7, self.project_number)?;
        }
        if self.metageneration != 0 {
            os.write_int64(8, self.metageneration)?;
        }
        for v in &self.cors {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.location.is_empty() {
            os.write_string(10, &self.location)?;
        }
        if !self.storage_class.is_empty() {
            os.write_string(11, &self.storage_class)?;
        }
        if !self.etag.is_empty() {
            os.write_string(12, &self.etag)?;
        }
        if let Some(ref v) = self.updated.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.default_event_based_hold != false {
            os.write_bool(14, self.default_event_based_hold)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(15, &self.labels, os)?;
        if let Some(ref v) = self.website.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.versioning.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.logging.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.owner.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.encryption.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.billing.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.retention_policy.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.location_type.is_empty() {
            os.write_string(23, &self.location_type)?;
        }
        if let Some(ref v) = self.iam_configuration.as_ref() {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.zone_affinity {
            os.write_string(25, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bucket {
        Bucket::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BucketAccessControl>>(
                "acl",
                |m: &Bucket| { &m.acl },
                |m: &mut Bucket| { &mut m.acl },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectAccessControl>>(
                "default_object_acl",
                |m: &Bucket| { &m.default_object_acl },
                |m: &mut Bucket| { &mut m.default_object_acl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bucket_Lifecycle>>(
                "lifecycle",
                |m: &Bucket| { &m.lifecycle },
                |m: &mut Bucket| { &mut m.lifecycle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "time_created",
                |m: &Bucket| { &m.time_created },
                |m: &mut Bucket| { &mut m.time_created },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Bucket| { &m.id },
                |m: &mut Bucket| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Bucket| { &m.name },
                |m: &mut Bucket| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "project_number",
                |m: &Bucket| { &m.project_number },
                |m: &mut Bucket| { &mut m.project_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "metageneration",
                |m: &Bucket| { &m.metageneration },
                |m: &mut Bucket| { &mut m.metageneration },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bucket_Cors>>(
                "cors",
                |m: &Bucket| { &m.cors },
                |m: &mut Bucket| { &mut m.cors },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "location",
                |m: &Bucket| { &m.location },
                |m: &mut Bucket| { &mut m.location },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "storage_class",
                |m: &Bucket| { &m.storage_class },
                |m: &mut Bucket| { &mut m.storage_class },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "etag",
                |m: &Bucket| { &m.etag },
                |m: &mut Bucket| { &mut m.etag },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "updated",
                |m: &Bucket| { &m.updated },
                |m: &mut Bucket| { &mut m.updated },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "default_event_based_hold",
                |m: &Bucket| { &m.default_event_based_hold },
                |m: &mut Bucket| { &mut m.default_event_based_hold },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "labels",
                |m: &Bucket| { &m.labels },
                |m: &mut Bucket| { &mut m.labels },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bucket_Website>>(
                "website",
                |m: &Bucket| { &m.website },
                |m: &mut Bucket| { &mut m.website },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bucket_Versioning>>(
                "versioning",
                |m: &Bucket| { &m.versioning },
                |m: &mut Bucket| { &mut m.versioning },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bucket_Logging>>(
                "logging",
                |m: &Bucket| { &m.logging },
                |m: &mut Bucket| { &mut m.logging },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Owner>>(
                "owner",
                |m: &Bucket| { &m.owner },
                |m: &mut Bucket| { &mut m.owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bucket_Encryption>>(
                "encryption",
                |m: &Bucket| { &m.encryption },
                |m: &mut Bucket| { &mut m.encryption },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bucket_Billing>>(
                "billing",
                |m: &Bucket| { &m.billing },
                |m: &mut Bucket| { &mut m.billing },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bucket_RetentionPolicy>>(
                "retention_policy",
                |m: &Bucket| { &m.retention_policy },
                |m: &mut Bucket| { &mut m.retention_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "location_type",
                |m: &Bucket| { &m.location_type },
                |m: &mut Bucket| { &mut m.location_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bucket_IamConfiguration>>(
                "iam_configuration",
                |m: &Bucket| { &m.iam_configuration },
                |m: &mut Bucket| { &mut m.iam_configuration },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone_affinity",
                |m: &Bucket| { &m.zone_affinity },
                |m: &mut Bucket| { &mut m.zone_affinity },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Bucket>(
                "Bucket",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bucket {
        static instance: ::protobuf::rt::LazyV2<Bucket> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Bucket::new)
    }
}

impl ::protobuf::Clear for Bucket {
    fn clear(&mut self) {
        self.acl.clear();
        self.default_object_acl.clear();
        self.lifecycle.clear();
        self.time_created.clear();
        self.id.clear();
        self.name.clear();
        self.project_number = 0;
        self.metageneration = 0;
        self.cors.clear();
        self.location.clear();
        self.storage_class.clear();
        self.etag.clear();
        self.updated.clear();
        self.default_event_based_hold = false;
        self.labels.clear();
        self.website.clear();
        self.versioning.clear();
        self.logging.clear();
        self.owner.clear();
        self.encryption.clear();
        self.billing.clear();
        self.retention_policy.clear();
        self.location_type.clear();
        self.iam_configuration.clear();
        self.zone_affinity.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bucket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bucket {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Bucket_Billing {
    // message fields
    pub requester_pays: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Bucket_Billing {
    fn default() -> &'a Bucket_Billing {
        <Bucket_Billing as ::protobuf::Message>::default_instance()
    }
}

impl Bucket_Billing {
    pub fn new() -> Bucket_Billing {
        ::std::default::Default::default()
    }

    // bool requester_pays = 1;


    pub fn get_requester_pays(&self) -> bool {
        self.requester_pays
    }
    pub fn clear_requester_pays(&mut self) {
        self.requester_pays = false;
    }

    // Param is passed by value, moved
    pub fn set_requester_pays(&mut self, v: bool) {
        self.requester_pays = v;
    }
}

impl ::protobuf::Message for Bucket_Billing {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.requester_pays = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requester_pays != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requester_pays != false {
            os.write_bool(1, self.requester_pays)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bucket_Billing {
        Bucket_Billing::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "requester_pays",
                |m: &Bucket_Billing| { &m.requester_pays },
                |m: &mut Bucket_Billing| { &mut m.requester_pays },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Bucket_Billing>(
                "Bucket.Billing",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bucket_Billing {
        static instance: ::protobuf::rt::LazyV2<Bucket_Billing> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Bucket_Billing::new)
    }
}

impl ::protobuf::Clear for Bucket_Billing {
    fn clear(&mut self) {
        self.requester_pays = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bucket_Billing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bucket_Billing {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Bucket_Cors {
    // message fields
    pub origin: ::protobuf::RepeatedField<::std::string::String>,
    pub method: ::protobuf::RepeatedField<::std::string::String>,
    pub response_header: ::protobuf::RepeatedField<::std::string::String>,
    pub max_age_seconds: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Bucket_Cors {
    fn default() -> &'a Bucket_Cors {
        <Bucket_Cors as ::protobuf::Message>::default_instance()
    }
}

impl Bucket_Cors {
    pub fn new() -> Bucket_Cors {
        ::std::default::Default::default()
    }

    // repeated string origin = 1;


    pub fn get_origin(&self) -> &[::std::string::String] {
        &self.origin
    }
    pub fn clear_origin(&mut self) {
        self.origin.clear();
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.origin = v;
    }

    // Mutable pointer to the field.
    pub fn mut_origin(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.origin
    }

    // Take field
    pub fn take_origin(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.origin, ::protobuf::RepeatedField::new())
    }

    // repeated string method = 2;


    pub fn get_method(&self) -> &[::std::string::String] {
        &self.method
    }
    pub fn clear_method(&mut self) {
        self.method.clear();
    }

    // Param is passed by value, moved
    pub fn set_method(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.method = v;
    }

    // Mutable pointer to the field.
    pub fn mut_method(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.method
    }

    // Take field
    pub fn take_method(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.method, ::protobuf::RepeatedField::new())
    }

    // repeated string response_header = 3;


    pub fn get_response_header(&self) -> &[::std::string::String] {
        &self.response_header
    }
    pub fn clear_response_header(&mut self) {
        self.response_header.clear();
    }

    // Param is passed by value, moved
    pub fn set_response_header(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.response_header = v;
    }

    // Mutable pointer to the field.
    pub fn mut_response_header(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.response_header
    }

    // Take field
    pub fn take_response_header(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.response_header, ::protobuf::RepeatedField::new())
    }

    // int32 max_age_seconds = 4;


    pub fn get_max_age_seconds(&self) -> i32 {
        self.max_age_seconds
    }
    pub fn clear_max_age_seconds(&mut self) {
        self.max_age_seconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_age_seconds(&mut self, v: i32) {
        self.max_age_seconds = v;
    }
}

impl ::protobuf::Message for Bucket_Cors {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.origin)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.method)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.response_header)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_age_seconds = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.origin {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.method {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.response_header {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.max_age_seconds != 0 {
            my_size += ::protobuf::rt::value_size(4, self.max_age_seconds, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.origin {
            os.write_string(1, &v)?;
        };
        for v in &self.method {
            os.write_string(2, &v)?;
        };
        for v in &self.response_header {
            os.write_string(3, &v)?;
        };
        if self.max_age_seconds != 0 {
            os.write_int32(4, self.max_age_seconds)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bucket_Cors {
        Bucket_Cors::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "origin",
                |m: &Bucket_Cors| { &m.origin },
                |m: &mut Bucket_Cors| { &mut m.origin },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "method",
                |m: &Bucket_Cors| { &m.method },
                |m: &mut Bucket_Cors| { &mut m.method },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "response_header",
                |m: &Bucket_Cors| { &m.response_header },
                |m: &mut Bucket_Cors| { &mut m.response_header },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_age_seconds",
                |m: &Bucket_Cors| { &m.max_age_seconds },
                |m: &mut Bucket_Cors| { &mut m.max_age_seconds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Bucket_Cors>(
                "Bucket.Cors",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bucket_Cors {
        static instance: ::protobuf::rt::LazyV2<Bucket_Cors> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Bucket_Cors::new)
    }
}

impl ::protobuf::Clear for Bucket_Cors {
    fn clear(&mut self) {
        self.origin.clear();
        self.method.clear();
        self.response_header.clear();
        self.max_age_seconds = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bucket_Cors {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bucket_Cors {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Bucket_Encryption {
    // message fields
    pub default_kms_key_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Bucket_Encryption {
    fn default() -> &'a Bucket_Encryption {
        <Bucket_Encryption as ::protobuf::Message>::default_instance()
    }
}

impl Bucket_Encryption {
    pub fn new() -> Bucket_Encryption {
        ::std::default::Default::default()
    }

    // string default_kms_key_name = 1;


    pub fn get_default_kms_key_name(&self) -> &str {
        &self.default_kms_key_name
    }
    pub fn clear_default_kms_key_name(&mut self) {
        self.default_kms_key_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_default_kms_key_name(&mut self, v: ::std::string::String) {
        self.default_kms_key_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_kms_key_name(&mut self) -> &mut ::std::string::String {
        &mut self.default_kms_key_name
    }

    // Take field
    pub fn take_default_kms_key_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.default_kms_key_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Bucket_Encryption {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.default_kms_key_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.default_kms_key_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.default_kms_key_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.default_kms_key_name.is_empty() {
            os.write_string(1, &self.default_kms_key_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bucket_Encryption {
        Bucket_Encryption::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "default_kms_key_name",
                |m: &Bucket_Encryption| { &m.default_kms_key_name },
                |m: &mut Bucket_Encryption| { &mut m.default_kms_key_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Bucket_Encryption>(
                "Bucket.Encryption",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bucket_Encryption {
        static instance: ::protobuf::rt::LazyV2<Bucket_Encryption> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Bucket_Encryption::new)
    }
}

impl ::protobuf::Clear for Bucket_Encryption {
    fn clear(&mut self) {
        self.default_kms_key_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bucket_Encryption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bucket_Encryption {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Bucket_IamConfiguration {
    // message fields
    pub uniform_bucket_level_access: ::protobuf::SingularPtrField<Bucket_IamConfiguration_UniformBucketLevelAccess>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Bucket_IamConfiguration {
    fn default() -> &'a Bucket_IamConfiguration {
        <Bucket_IamConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl Bucket_IamConfiguration {
    pub fn new() -> Bucket_IamConfiguration {
        ::std::default::Default::default()
    }

    // .google.storage.v1.Bucket.IamConfiguration.UniformBucketLevelAccess uniform_bucket_level_access = 1;


    pub fn get_uniform_bucket_level_access(&self) -> &Bucket_IamConfiguration_UniformBucketLevelAccess {
        self.uniform_bucket_level_access.as_ref().unwrap_or_else(|| <Bucket_IamConfiguration_UniformBucketLevelAccess as ::protobuf::Message>::default_instance())
    }
    pub fn clear_uniform_bucket_level_access(&mut self) {
        self.uniform_bucket_level_access.clear();
    }

    pub fn has_uniform_bucket_level_access(&self) -> bool {
        self.uniform_bucket_level_access.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uniform_bucket_level_access(&mut self, v: Bucket_IamConfiguration_UniformBucketLevelAccess) {
        self.uniform_bucket_level_access = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uniform_bucket_level_access(&mut self) -> &mut Bucket_IamConfiguration_UniformBucketLevelAccess {
        if self.uniform_bucket_level_access.is_none() {
            self.uniform_bucket_level_access.set_default();
        }
        self.uniform_bucket_level_access.as_mut().unwrap()
    }

    // Take field
    pub fn take_uniform_bucket_level_access(&mut self) -> Bucket_IamConfiguration_UniformBucketLevelAccess {
        self.uniform_bucket_level_access.take().unwrap_or_else(|| Bucket_IamConfiguration_UniformBucketLevelAccess::new())
    }
}

impl ::protobuf::Message for Bucket_IamConfiguration {
    fn is_initialized(&self) -> bool {
        for v in &self.uniform_bucket_level_access {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.uniform_bucket_level_access)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.uniform_bucket_level_access.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.uniform_bucket_level_access.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bucket_IamConfiguration {
        Bucket_IamConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bucket_IamConfiguration_UniformBucketLevelAccess>>(
                "uniform_bucket_level_access",
                |m: &Bucket_IamConfiguration| { &m.uniform_bucket_level_access },
                |m: &mut Bucket_IamConfiguration| { &mut m.uniform_bucket_level_access },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Bucket_IamConfiguration>(
                "Bucket.IamConfiguration",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bucket_IamConfiguration {
        static instance: ::protobuf::rt::LazyV2<Bucket_IamConfiguration> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Bucket_IamConfiguration::new)
    }
}

impl ::protobuf::Clear for Bucket_IamConfiguration {
    fn clear(&mut self) {
        self.uniform_bucket_level_access.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bucket_IamConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bucket_IamConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Bucket_IamConfiguration_UniformBucketLevelAccess {
    // message fields
    pub enabled: bool,
    pub locked_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Bucket_IamConfiguration_UniformBucketLevelAccess {
    fn default() -> &'a Bucket_IamConfiguration_UniformBucketLevelAccess {
        <Bucket_IamConfiguration_UniformBucketLevelAccess as ::protobuf::Message>::default_instance()
    }
}

impl Bucket_IamConfiguration_UniformBucketLevelAccess {
    pub fn new() -> Bucket_IamConfiguration_UniformBucketLevelAccess {
        ::std::default::Default::default()
    }

    // bool enabled = 1;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }

    // .google.protobuf.Timestamp locked_time = 2;


    pub fn get_locked_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.locked_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_locked_time(&mut self) {
        self.locked_time.clear();
    }

    pub fn has_locked_time(&self) -> bool {
        self.locked_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_locked_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.locked_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locked_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.locked_time.is_none() {
            self.locked_time.set_default();
        }
        self.locked_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_locked_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.locked_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for Bucket_IamConfiguration_UniformBucketLevelAccess {
    fn is_initialized(&self) -> bool {
        for v in &self.locked_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.locked_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 2;
        }
        if let Some(ref v) = self.locked_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        if let Some(ref v) = self.locked_time.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bucket_IamConfiguration_UniformBucketLevelAccess {
        Bucket_IamConfiguration_UniformBucketLevelAccess::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enabled",
                |m: &Bucket_IamConfiguration_UniformBucketLevelAccess| { &m.enabled },
                |m: &mut Bucket_IamConfiguration_UniformBucketLevelAccess| { &mut m.enabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "locked_time",
                |m: &Bucket_IamConfiguration_UniformBucketLevelAccess| { &m.locked_time },
                |m: &mut Bucket_IamConfiguration_UniformBucketLevelAccess| { &mut m.locked_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Bucket_IamConfiguration_UniformBucketLevelAccess>(
                "Bucket.IamConfiguration.UniformBucketLevelAccess",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bucket_IamConfiguration_UniformBucketLevelAccess {
        static instance: ::protobuf::rt::LazyV2<Bucket_IamConfiguration_UniformBucketLevelAccess> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Bucket_IamConfiguration_UniformBucketLevelAccess::new)
    }
}

impl ::protobuf::Clear for Bucket_IamConfiguration_UniformBucketLevelAccess {
    fn clear(&mut self) {
        self.enabled = false;
        self.locked_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bucket_IamConfiguration_UniformBucketLevelAccess {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bucket_IamConfiguration_UniformBucketLevelAccess {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Bucket_Lifecycle {
    // message fields
    pub rule: ::protobuf::RepeatedField<Bucket_Lifecycle_Rule>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Bucket_Lifecycle {
    fn default() -> &'a Bucket_Lifecycle {
        <Bucket_Lifecycle as ::protobuf::Message>::default_instance()
    }
}

impl Bucket_Lifecycle {
    pub fn new() -> Bucket_Lifecycle {
        ::std::default::Default::default()
    }

    // repeated .google.storage.v1.Bucket.Lifecycle.Rule rule = 1;


    pub fn get_rule(&self) -> &[Bucket_Lifecycle_Rule] {
        &self.rule
    }
    pub fn clear_rule(&mut self) {
        self.rule.clear();
    }

    // Param is passed by value, moved
    pub fn set_rule(&mut self, v: ::protobuf::RepeatedField<Bucket_Lifecycle_Rule>) {
        self.rule = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rule(&mut self) -> &mut ::protobuf::RepeatedField<Bucket_Lifecycle_Rule> {
        &mut self.rule
    }

    // Take field
    pub fn take_rule(&mut self) -> ::protobuf::RepeatedField<Bucket_Lifecycle_Rule> {
        ::std::mem::replace(&mut self.rule, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Bucket_Lifecycle {
    fn is_initialized(&self) -> bool {
        for v in &self.rule {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rule)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.rule {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.rule {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bucket_Lifecycle {
        Bucket_Lifecycle::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bucket_Lifecycle_Rule>>(
                "rule",
                |m: &Bucket_Lifecycle| { &m.rule },
                |m: &mut Bucket_Lifecycle| { &mut m.rule },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Bucket_Lifecycle>(
                "Bucket.Lifecycle",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bucket_Lifecycle {
        static instance: ::protobuf::rt::LazyV2<Bucket_Lifecycle> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Bucket_Lifecycle::new)
    }
}

impl ::protobuf::Clear for Bucket_Lifecycle {
    fn clear(&mut self) {
        self.rule.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bucket_Lifecycle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bucket_Lifecycle {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Bucket_Lifecycle_Rule {
    // message fields
    pub action: ::protobuf::SingularPtrField<Bucket_Lifecycle_Rule_Action>,
    pub condition: ::protobuf::SingularPtrField<Bucket_Lifecycle_Rule_Condition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Bucket_Lifecycle_Rule {
    fn default() -> &'a Bucket_Lifecycle_Rule {
        <Bucket_Lifecycle_Rule as ::protobuf::Message>::default_instance()
    }
}

impl Bucket_Lifecycle_Rule {
    pub fn new() -> Bucket_Lifecycle_Rule {
        ::std::default::Default::default()
    }

    // .google.storage.v1.Bucket.Lifecycle.Rule.Action action = 1;


    pub fn get_action(&self) -> &Bucket_Lifecycle_Rule_Action {
        self.action.as_ref().unwrap_or_else(|| <Bucket_Lifecycle_Rule_Action as ::protobuf::Message>::default_instance())
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: Bucket_Lifecycle_Rule_Action) {
        self.action = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut Bucket_Lifecycle_Rule_Action {
        if self.action.is_none() {
            self.action.set_default();
        }
        self.action.as_mut().unwrap()
    }

    // Take field
    pub fn take_action(&mut self) -> Bucket_Lifecycle_Rule_Action {
        self.action.take().unwrap_or_else(|| Bucket_Lifecycle_Rule_Action::new())
    }

    // .google.storage.v1.Bucket.Lifecycle.Rule.Condition condition = 2;


    pub fn get_condition(&self) -> &Bucket_Lifecycle_Rule_Condition {
        self.condition.as_ref().unwrap_or_else(|| <Bucket_Lifecycle_Rule_Condition as ::protobuf::Message>::default_instance())
    }
    pub fn clear_condition(&mut self) {
        self.condition.clear();
    }

    pub fn has_condition(&self) -> bool {
        self.condition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_condition(&mut self, v: Bucket_Lifecycle_Rule_Condition) {
        self.condition = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_condition(&mut self) -> &mut Bucket_Lifecycle_Rule_Condition {
        if self.condition.is_none() {
            self.condition.set_default();
        }
        self.condition.as_mut().unwrap()
    }

    // Take field
    pub fn take_condition(&mut self) -> Bucket_Lifecycle_Rule_Condition {
        self.condition.take().unwrap_or_else(|| Bucket_Lifecycle_Rule_Condition::new())
    }
}

impl ::protobuf::Message for Bucket_Lifecycle_Rule {
    fn is_initialized(&self) -> bool {
        for v in &self.action {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.condition {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.action)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.condition)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.action.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.condition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.action.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.condition.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bucket_Lifecycle_Rule {
        Bucket_Lifecycle_Rule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bucket_Lifecycle_Rule_Action>>(
                "action",
                |m: &Bucket_Lifecycle_Rule| { &m.action },
                |m: &mut Bucket_Lifecycle_Rule| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bucket_Lifecycle_Rule_Condition>>(
                "condition",
                |m: &Bucket_Lifecycle_Rule| { &m.condition },
                |m: &mut Bucket_Lifecycle_Rule| { &mut m.condition },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Bucket_Lifecycle_Rule>(
                "Bucket.Lifecycle.Rule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bucket_Lifecycle_Rule {
        static instance: ::protobuf::rt::LazyV2<Bucket_Lifecycle_Rule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Bucket_Lifecycle_Rule::new)
    }
}

impl ::protobuf::Clear for Bucket_Lifecycle_Rule {
    fn clear(&mut self) {
        self.action.clear();
        self.condition.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bucket_Lifecycle_Rule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bucket_Lifecycle_Rule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Bucket_Lifecycle_Rule_Action {
    // message fields
    pub field_type: ::std::string::String,
    pub storage_class: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Bucket_Lifecycle_Rule_Action {
    fn default() -> &'a Bucket_Lifecycle_Rule_Action {
        <Bucket_Lifecycle_Rule_Action as ::protobuf::Message>::default_instance()
    }
}

impl Bucket_Lifecycle_Rule_Action {
    pub fn new() -> Bucket_Lifecycle_Rule_Action {
        ::std::default::Default::default()
    }

    // string type = 1;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // string storage_class = 2;


    pub fn get_storage_class(&self) -> &str {
        &self.storage_class
    }
    pub fn clear_storage_class(&mut self) {
        self.storage_class.clear();
    }

    // Param is passed by value, moved
    pub fn set_storage_class(&mut self, v: ::std::string::String) {
        self.storage_class = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storage_class(&mut self) -> &mut ::std::string::String {
        &mut self.storage_class
    }

    // Take field
    pub fn take_storage_class(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.storage_class, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Bucket_Lifecycle_Rule_Action {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.storage_class)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field_type);
        }
        if !self.storage_class.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.storage_class);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.field_type.is_empty() {
            os.write_string(1, &self.field_type)?;
        }
        if !self.storage_class.is_empty() {
            os.write_string(2, &self.storage_class)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bucket_Lifecycle_Rule_Action {
        Bucket_Lifecycle_Rule_Action::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &Bucket_Lifecycle_Rule_Action| { &m.field_type },
                |m: &mut Bucket_Lifecycle_Rule_Action| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "storage_class",
                |m: &Bucket_Lifecycle_Rule_Action| { &m.storage_class },
                |m: &mut Bucket_Lifecycle_Rule_Action| { &mut m.storage_class },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Bucket_Lifecycle_Rule_Action>(
                "Bucket.Lifecycle.Rule.Action",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bucket_Lifecycle_Rule_Action {
        static instance: ::protobuf::rt::LazyV2<Bucket_Lifecycle_Rule_Action> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Bucket_Lifecycle_Rule_Action::new)
    }
}

impl ::protobuf::Clear for Bucket_Lifecycle_Rule_Action {
    fn clear(&mut self) {
        self.field_type.clear();
        self.storage_class.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bucket_Lifecycle_Rule_Action {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bucket_Lifecycle_Rule_Action {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Bucket_Lifecycle_Rule_Condition {
    // message fields
    pub age: i32,
    pub created_before: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub is_live: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub num_newer_versions: i32,
    pub matches_storage_class: ::protobuf::RepeatedField<::std::string::String>,
    pub matches_pattern: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Bucket_Lifecycle_Rule_Condition {
    fn default() -> &'a Bucket_Lifecycle_Rule_Condition {
        <Bucket_Lifecycle_Rule_Condition as ::protobuf::Message>::default_instance()
    }
}

impl Bucket_Lifecycle_Rule_Condition {
    pub fn new() -> Bucket_Lifecycle_Rule_Condition {
        ::std::default::Default::default()
    }

    // int32 age = 1;


    pub fn get_age(&self) -> i32 {
        self.age
    }
    pub fn clear_age(&mut self) {
        self.age = 0;
    }

    // Param is passed by value, moved
    pub fn set_age(&mut self, v: i32) {
        self.age = v;
    }

    // .google.protobuf.Timestamp created_before = 2;


    pub fn get_created_before(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_before.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_before(&mut self) {
        self.created_before.clear();
    }

    pub fn has_created_before(&self) -> bool {
        self.created_before.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_before(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_before = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_before(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_before.is_none() {
            self.created_before.set_default();
        }
        self.created_before.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_before(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_before.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.BoolValue is_live = 3;


    pub fn get_is_live(&self) -> &::protobuf::well_known_types::BoolValue {
        self.is_live.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_is_live(&mut self) {
        self.is_live.clear();
    }

    pub fn has_is_live(&self) -> bool {
        self.is_live.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_live(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.is_live = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_is_live(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.is_live.is_none() {
            self.is_live.set_default();
        }
        self.is_live.as_mut().unwrap()
    }

    // Take field
    pub fn take_is_live(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.is_live.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // int32 num_newer_versions = 4;


    pub fn get_num_newer_versions(&self) -> i32 {
        self.num_newer_versions
    }
    pub fn clear_num_newer_versions(&mut self) {
        self.num_newer_versions = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_newer_versions(&mut self, v: i32) {
        self.num_newer_versions = v;
    }

    // repeated string matches_storage_class = 5;


    pub fn get_matches_storage_class(&self) -> &[::std::string::String] {
        &self.matches_storage_class
    }
    pub fn clear_matches_storage_class(&mut self) {
        self.matches_storage_class.clear();
    }

    // Param is passed by value, moved
    pub fn set_matches_storage_class(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.matches_storage_class = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matches_storage_class(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.matches_storage_class
    }

    // Take field
    pub fn take_matches_storage_class(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.matches_storage_class, ::protobuf::RepeatedField::new())
    }

    // string matches_pattern = 6;


    pub fn get_matches_pattern(&self) -> &str {
        &self.matches_pattern
    }
    pub fn clear_matches_pattern(&mut self) {
        self.matches_pattern.clear();
    }

    // Param is passed by value, moved
    pub fn set_matches_pattern(&mut self, v: ::std::string::String) {
        self.matches_pattern = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_matches_pattern(&mut self) -> &mut ::std::string::String {
        &mut self.matches_pattern
    }

    // Take field
    pub fn take_matches_pattern(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.matches_pattern, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Bucket_Lifecycle_Rule_Condition {
    fn is_initialized(&self) -> bool {
        for v in &self.created_before {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.is_live {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.age = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_before)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.is_live)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_newer_versions = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.matches_storage_class)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.matches_pattern)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.age != 0 {
            my_size += ::protobuf::rt::value_size(1, self.age, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.created_before.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.is_live.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.num_newer_versions != 0 {
            my_size += ::protobuf::rt::value_size(4, self.num_newer_versions, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.matches_storage_class {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if !self.matches_pattern.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.matches_pattern);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.age != 0 {
            os.write_int32(1, self.age)?;
        }
        if let Some(ref v) = self.created_before.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.is_live.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.num_newer_versions != 0 {
            os.write_int32(4, self.num_newer_versions)?;
        }
        for v in &self.matches_storage_class {
            os.write_string(5, &v)?;
        };
        if !self.matches_pattern.is_empty() {
            os.write_string(6, &self.matches_pattern)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bucket_Lifecycle_Rule_Condition {
        Bucket_Lifecycle_Rule_Condition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "age",
                |m: &Bucket_Lifecycle_Rule_Condition| { &m.age },
                |m: &mut Bucket_Lifecycle_Rule_Condition| { &mut m.age },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_before",
                |m: &Bucket_Lifecycle_Rule_Condition| { &m.created_before },
                |m: &mut Bucket_Lifecycle_Rule_Condition| { &mut m.created_before },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "is_live",
                |m: &Bucket_Lifecycle_Rule_Condition| { &m.is_live },
                |m: &mut Bucket_Lifecycle_Rule_Condition| { &mut m.is_live },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_newer_versions",
                |m: &Bucket_Lifecycle_Rule_Condition| { &m.num_newer_versions },
                |m: &mut Bucket_Lifecycle_Rule_Condition| { &mut m.num_newer_versions },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "matches_storage_class",
                |m: &Bucket_Lifecycle_Rule_Condition| { &m.matches_storage_class },
                |m: &mut Bucket_Lifecycle_Rule_Condition| { &mut m.matches_storage_class },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "matches_pattern",
                |m: &Bucket_Lifecycle_Rule_Condition| { &m.matches_pattern },
                |m: &mut Bucket_Lifecycle_Rule_Condition| { &mut m.matches_pattern },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Bucket_Lifecycle_Rule_Condition>(
                "Bucket.Lifecycle.Rule.Condition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bucket_Lifecycle_Rule_Condition {
        static instance: ::protobuf::rt::LazyV2<Bucket_Lifecycle_Rule_Condition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Bucket_Lifecycle_Rule_Condition::new)
    }
}

impl ::protobuf::Clear for Bucket_Lifecycle_Rule_Condition {
    fn clear(&mut self) {
        self.age = 0;
        self.created_before.clear();
        self.is_live.clear();
        self.num_newer_versions = 0;
        self.matches_storage_class.clear();
        self.matches_pattern.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bucket_Lifecycle_Rule_Condition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bucket_Lifecycle_Rule_Condition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Bucket_Logging {
    // message fields
    pub log_bucket: ::std::string::String,
    pub log_object_prefix: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Bucket_Logging {
    fn default() -> &'a Bucket_Logging {
        <Bucket_Logging as ::protobuf::Message>::default_instance()
    }
}

impl Bucket_Logging {
    pub fn new() -> Bucket_Logging {
        ::std::default::Default::default()
    }

    // string log_bucket = 1;


    pub fn get_log_bucket(&self) -> &str {
        &self.log_bucket
    }
    pub fn clear_log_bucket(&mut self) {
        self.log_bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_log_bucket(&mut self, v: ::std::string::String) {
        self.log_bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_log_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.log_bucket
    }

    // Take field
    pub fn take_log_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.log_bucket, ::std::string::String::new())
    }

    // string log_object_prefix = 2;


    pub fn get_log_object_prefix(&self) -> &str {
        &self.log_object_prefix
    }
    pub fn clear_log_object_prefix(&mut self) {
        self.log_object_prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_log_object_prefix(&mut self, v: ::std::string::String) {
        self.log_object_prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_log_object_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.log_object_prefix
    }

    // Take field
    pub fn take_log_object_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.log_object_prefix, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Bucket_Logging {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.log_bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.log_object_prefix)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.log_bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.log_bucket);
        }
        if !self.log_object_prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.log_object_prefix);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.log_bucket.is_empty() {
            os.write_string(1, &self.log_bucket)?;
        }
        if !self.log_object_prefix.is_empty() {
            os.write_string(2, &self.log_object_prefix)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bucket_Logging {
        Bucket_Logging::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "log_bucket",
                |m: &Bucket_Logging| { &m.log_bucket },
                |m: &mut Bucket_Logging| { &mut m.log_bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "log_object_prefix",
                |m: &Bucket_Logging| { &m.log_object_prefix },
                |m: &mut Bucket_Logging| { &mut m.log_object_prefix },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Bucket_Logging>(
                "Bucket.Logging",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bucket_Logging {
        static instance: ::protobuf::rt::LazyV2<Bucket_Logging> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Bucket_Logging::new)
    }
}

impl ::protobuf::Clear for Bucket_Logging {
    fn clear(&mut self) {
        self.log_bucket.clear();
        self.log_object_prefix.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bucket_Logging {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bucket_Logging {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Bucket_RetentionPolicy {
    // message fields
    pub effective_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub is_locked: bool,
    pub retention_period: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Bucket_RetentionPolicy {
    fn default() -> &'a Bucket_RetentionPolicy {
        <Bucket_RetentionPolicy as ::protobuf::Message>::default_instance()
    }
}

impl Bucket_RetentionPolicy {
    pub fn new() -> Bucket_RetentionPolicy {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp effective_time = 1;


    pub fn get_effective_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.effective_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_effective_time(&mut self) {
        self.effective_time.clear();
    }

    pub fn has_effective_time(&self) -> bool {
        self.effective_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effective_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.effective_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_effective_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.effective_time.is_none() {
            self.effective_time.set_default();
        }
        self.effective_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_effective_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.effective_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // bool is_locked = 2;


    pub fn get_is_locked(&self) -> bool {
        self.is_locked
    }
    pub fn clear_is_locked(&mut self) {
        self.is_locked = false;
    }

    // Param is passed by value, moved
    pub fn set_is_locked(&mut self, v: bool) {
        self.is_locked = v;
    }

    // int64 retention_period = 3;


    pub fn get_retention_period(&self) -> i64 {
        self.retention_period
    }
    pub fn clear_retention_period(&mut self) {
        self.retention_period = 0;
    }

    // Param is passed by value, moved
    pub fn set_retention_period(&mut self, v: i64) {
        self.retention_period = v;
    }
}

impl ::protobuf::Message for Bucket_RetentionPolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.effective_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.effective_time)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_locked = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.retention_period = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.effective_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.is_locked != false {
            my_size += 2;
        }
        if self.retention_period != 0 {
            my_size += ::protobuf::rt::value_size(3, self.retention_period, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.effective_time.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.is_locked != false {
            os.write_bool(2, self.is_locked)?;
        }
        if self.retention_period != 0 {
            os.write_int64(3, self.retention_period)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bucket_RetentionPolicy {
        Bucket_RetentionPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "effective_time",
                |m: &Bucket_RetentionPolicy| { &m.effective_time },
                |m: &mut Bucket_RetentionPolicy| { &mut m.effective_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_locked",
                |m: &Bucket_RetentionPolicy| { &m.is_locked },
                |m: &mut Bucket_RetentionPolicy| { &mut m.is_locked },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "retention_period",
                |m: &Bucket_RetentionPolicy| { &m.retention_period },
                |m: &mut Bucket_RetentionPolicy| { &mut m.retention_period },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Bucket_RetentionPolicy>(
                "Bucket.RetentionPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bucket_RetentionPolicy {
        static instance: ::protobuf::rt::LazyV2<Bucket_RetentionPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Bucket_RetentionPolicy::new)
    }
}

impl ::protobuf::Clear for Bucket_RetentionPolicy {
    fn clear(&mut self) {
        self.effective_time.clear();
        self.is_locked = false;
        self.retention_period = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bucket_RetentionPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bucket_RetentionPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Bucket_Versioning {
    // message fields
    pub enabled: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Bucket_Versioning {
    fn default() -> &'a Bucket_Versioning {
        <Bucket_Versioning as ::protobuf::Message>::default_instance()
    }
}

impl Bucket_Versioning {
    pub fn new() -> Bucket_Versioning {
        ::std::default::Default::default()
    }

    // bool enabled = 1;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }
}

impl ::protobuf::Message for Bucket_Versioning {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bucket_Versioning {
        Bucket_Versioning::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enabled",
                |m: &Bucket_Versioning| { &m.enabled },
                |m: &mut Bucket_Versioning| { &mut m.enabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Bucket_Versioning>(
                "Bucket.Versioning",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bucket_Versioning {
        static instance: ::protobuf::rt::LazyV2<Bucket_Versioning> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Bucket_Versioning::new)
    }
}

impl ::protobuf::Clear for Bucket_Versioning {
    fn clear(&mut self) {
        self.enabled = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bucket_Versioning {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bucket_Versioning {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Bucket_Website {
    // message fields
    pub main_page_suffix: ::std::string::String,
    pub not_found_page: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Bucket_Website {
    fn default() -> &'a Bucket_Website {
        <Bucket_Website as ::protobuf::Message>::default_instance()
    }
}

impl Bucket_Website {
    pub fn new() -> Bucket_Website {
        ::std::default::Default::default()
    }

    // string main_page_suffix = 1;


    pub fn get_main_page_suffix(&self) -> &str {
        &self.main_page_suffix
    }
    pub fn clear_main_page_suffix(&mut self) {
        self.main_page_suffix.clear();
    }

    // Param is passed by value, moved
    pub fn set_main_page_suffix(&mut self, v: ::std::string::String) {
        self.main_page_suffix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_main_page_suffix(&mut self) -> &mut ::std::string::String {
        &mut self.main_page_suffix
    }

    // Take field
    pub fn take_main_page_suffix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.main_page_suffix, ::std::string::String::new())
    }

    // string not_found_page = 2;


    pub fn get_not_found_page(&self) -> &str {
        &self.not_found_page
    }
    pub fn clear_not_found_page(&mut self) {
        self.not_found_page.clear();
    }

    // Param is passed by value, moved
    pub fn set_not_found_page(&mut self, v: ::std::string::String) {
        self.not_found_page = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_not_found_page(&mut self) -> &mut ::std::string::String {
        &mut self.not_found_page
    }

    // Take field
    pub fn take_not_found_page(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.not_found_page, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Bucket_Website {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.main_page_suffix)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.not_found_page)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.main_page_suffix.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.main_page_suffix);
        }
        if !self.not_found_page.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.not_found_page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.main_page_suffix.is_empty() {
            os.write_string(1, &self.main_page_suffix)?;
        }
        if !self.not_found_page.is_empty() {
            os.write_string(2, &self.not_found_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bucket_Website {
        Bucket_Website::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "main_page_suffix",
                |m: &Bucket_Website| { &m.main_page_suffix },
                |m: &mut Bucket_Website| { &mut m.main_page_suffix },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "not_found_page",
                |m: &Bucket_Website| { &m.not_found_page },
                |m: &mut Bucket_Website| { &mut m.not_found_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Bucket_Website>(
                "Bucket.Website",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bucket_Website {
        static instance: ::protobuf::rt::LazyV2<Bucket_Website> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Bucket_Website::new)
    }
}

impl ::protobuf::Clear for Bucket_Website {
    fn clear(&mut self) {
        self.main_page_suffix.clear();
        self.not_found_page.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bucket_Website {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bucket_Website {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BucketAccessControl {
    // message fields
    pub role: ::std::string::String,
    pub etag: ::std::string::String,
    pub id: ::std::string::String,
    pub bucket: ::std::string::String,
    pub entity: ::std::string::String,
    pub entity_id: ::std::string::String,
    pub email: ::std::string::String,
    pub domain: ::std::string::String,
    pub project_team: ::protobuf::SingularPtrField<ProjectTeam>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BucketAccessControl {
    fn default() -> &'a BucketAccessControl {
        <BucketAccessControl as ::protobuf::Message>::default_instance()
    }
}

impl BucketAccessControl {
    pub fn new() -> BucketAccessControl {
        ::std::default::Default::default()
    }

    // string role = 1;


    pub fn get_role(&self) -> &str {
        &self.role
    }
    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: ::std::string::String) {
        self.role = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role(&mut self) -> &mut ::std::string::String {
        &mut self.role
    }

    // Take field
    pub fn take_role(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.role, ::std::string::String::new())
    }

    // string etag = 2;


    pub fn get_etag(&self) -> &str {
        &self.etag
    }
    pub fn clear_etag(&mut self) {
        self.etag.clear();
    }

    // Param is passed by value, moved
    pub fn set_etag(&mut self, v: ::std::string::String) {
        self.etag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_etag(&mut self) -> &mut ::std::string::String {
        &mut self.etag
    }

    // Take field
    pub fn take_etag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.etag, ::std::string::String::new())
    }

    // string id = 3;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string bucket = 4;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string entity = 6;


    pub fn get_entity(&self) -> &str {
        &self.entity
    }
    pub fn clear_entity(&mut self) {
        self.entity.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: ::std::string::String) {
        self.entity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity(&mut self) -> &mut ::std::string::String {
        &mut self.entity
    }

    // Take field
    pub fn take_entity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity, ::std::string::String::new())
    }

    // string entity_id = 7;


    pub fn get_entity_id(&self) -> &str {
        &self.entity_id
    }
    pub fn clear_entity_id(&mut self) {
        self.entity_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity_id(&mut self, v: ::std::string::String) {
        self.entity_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_id(&mut self) -> &mut ::std::string::String {
        &mut self.entity_id
    }

    // Take field
    pub fn take_entity_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity_id, ::std::string::String::new())
    }

    // string email = 8;


    pub fn get_email(&self) -> &str {
        &self.email
    }
    pub fn clear_email(&mut self) {
        self.email.clear();
    }

    // Param is passed by value, moved
    pub fn set_email(&mut self, v: ::std::string::String) {
        self.email = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email(&mut self) -> &mut ::std::string::String {
        &mut self.email
    }

    // Take field
    pub fn take_email(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.email, ::std::string::String::new())
    }

    // string domain = 9;


    pub fn get_domain(&self) -> &str {
        &self.domain
    }
    pub fn clear_domain(&mut self) {
        self.domain.clear();
    }

    // Param is passed by value, moved
    pub fn set_domain(&mut self, v: ::std::string::String) {
        self.domain = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain(&mut self) -> &mut ::std::string::String {
        &mut self.domain
    }

    // Take field
    pub fn take_domain(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.domain, ::std::string::String::new())
    }

    // .google.storage.v1.ProjectTeam project_team = 10;


    pub fn get_project_team(&self) -> &ProjectTeam {
        self.project_team.as_ref().unwrap_or_else(|| <ProjectTeam as ::protobuf::Message>::default_instance())
    }
    pub fn clear_project_team(&mut self) {
        self.project_team.clear();
    }

    pub fn has_project_team(&self) -> bool {
        self.project_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_project_team(&mut self, v: ProjectTeam) {
        self.project_team = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_team(&mut self) -> &mut ProjectTeam {
        if self.project_team.is_none() {
            self.project_team.set_default();
        }
        self.project_team.as_mut().unwrap()
    }

    // Take field
    pub fn take_project_team(&mut self) -> ProjectTeam {
        self.project_team.take().unwrap_or_else(|| ProjectTeam::new())
    }
}

impl ::protobuf::Message for BucketAccessControl {
    fn is_initialized(&self) -> bool {
        for v in &self.project_team {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.role)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.etag)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entity)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entity_id)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.email)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.domain)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.project_team)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.role.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.role);
        }
        if !self.etag.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.etag);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.id);
        }
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.bucket);
        }
        if !self.entity.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.entity);
        }
        if !self.entity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.entity_id);
        }
        if !self.email.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.email);
        }
        if !self.domain.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.domain);
        }
        if let Some(ref v) = self.project_team.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.role.is_empty() {
            os.write_string(1, &self.role)?;
        }
        if !self.etag.is_empty() {
            os.write_string(2, &self.etag)?;
        }
        if !self.id.is_empty() {
            os.write_string(3, &self.id)?;
        }
        if !self.bucket.is_empty() {
            os.write_string(4, &self.bucket)?;
        }
        if !self.entity.is_empty() {
            os.write_string(6, &self.entity)?;
        }
        if !self.entity_id.is_empty() {
            os.write_string(7, &self.entity_id)?;
        }
        if !self.email.is_empty() {
            os.write_string(8, &self.email)?;
        }
        if !self.domain.is_empty() {
            os.write_string(9, &self.domain)?;
        }
        if let Some(ref v) = self.project_team.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BucketAccessControl {
        BucketAccessControl::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "role",
                |m: &BucketAccessControl| { &m.role },
                |m: &mut BucketAccessControl| { &mut m.role },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "etag",
                |m: &BucketAccessControl| { &m.etag },
                |m: &mut BucketAccessControl| { &mut m.etag },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &BucketAccessControl| { &m.id },
                |m: &mut BucketAccessControl| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &BucketAccessControl| { &m.bucket },
                |m: &mut BucketAccessControl| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entity",
                |m: &BucketAccessControl| { &m.entity },
                |m: &mut BucketAccessControl| { &mut m.entity },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entity_id",
                |m: &BucketAccessControl| { &m.entity_id },
                |m: &mut BucketAccessControl| { &mut m.entity_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "email",
                |m: &BucketAccessControl| { &m.email },
                |m: &mut BucketAccessControl| { &mut m.email },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "domain",
                |m: &BucketAccessControl| { &m.domain },
                |m: &mut BucketAccessControl| { &mut m.domain },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProjectTeam>>(
                "project_team",
                |m: &BucketAccessControl| { &m.project_team },
                |m: &mut BucketAccessControl| { &mut m.project_team },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BucketAccessControl>(
                "BucketAccessControl",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BucketAccessControl {
        static instance: ::protobuf::rt::LazyV2<BucketAccessControl> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BucketAccessControl::new)
    }
}

impl ::protobuf::Clear for BucketAccessControl {
    fn clear(&mut self) {
        self.role.clear();
        self.etag.clear();
        self.id.clear();
        self.bucket.clear();
        self.entity.clear();
        self.entity_id.clear();
        self.email.clear();
        self.domain.clear();
        self.project_team.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BucketAccessControl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BucketAccessControl {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListBucketAccessControlsResponse {
    // message fields
    pub items: ::protobuf::RepeatedField<BucketAccessControl>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListBucketAccessControlsResponse {
    fn default() -> &'a ListBucketAccessControlsResponse {
        <ListBucketAccessControlsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListBucketAccessControlsResponse {
    pub fn new() -> ListBucketAccessControlsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.storage.v1.BucketAccessControl items = 1;


    pub fn get_items(&self) -> &[BucketAccessControl] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<BucketAccessControl>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<BucketAccessControl> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<BucketAccessControl> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListBucketAccessControlsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListBucketAccessControlsResponse {
        ListBucketAccessControlsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BucketAccessControl>>(
                "items",
                |m: &ListBucketAccessControlsResponse| { &m.items },
                |m: &mut ListBucketAccessControlsResponse| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListBucketAccessControlsResponse>(
                "ListBucketAccessControlsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListBucketAccessControlsResponse {
        static instance: ::protobuf::rt::LazyV2<ListBucketAccessControlsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListBucketAccessControlsResponse::new)
    }
}

impl ::protobuf::Clear for ListBucketAccessControlsResponse {
    fn clear(&mut self) {
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListBucketAccessControlsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListBucketAccessControlsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListBucketsResponse {
    // message fields
    pub items: ::protobuf::RepeatedField<Bucket>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListBucketsResponse {
    fn default() -> &'a ListBucketsResponse {
        <ListBucketsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListBucketsResponse {
    pub fn new() -> ListBucketsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.storage.v1.Bucket items = 1;


    pub fn get_items(&self) -> &[Bucket] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<Bucket>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<Bucket> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<Bucket> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListBucketsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListBucketsResponse {
        ListBucketsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bucket>>(
                "items",
                |m: &ListBucketsResponse| { &m.items },
                |m: &mut ListBucketsResponse| { &mut m.items },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListBucketsResponse| { &m.next_page_token },
                |m: &mut ListBucketsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListBucketsResponse>(
                "ListBucketsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListBucketsResponse {
        static instance: ::protobuf::rt::LazyV2<ListBucketsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListBucketsResponse::new)
    }
}

impl ::protobuf::Clear for ListBucketsResponse {
    fn clear(&mut self) {
        self.items.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListBucketsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListBucketsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Channel {
    // message fields
    pub id: ::std::string::String,
    pub resource_id: ::std::string::String,
    pub resource_uri: ::std::string::String,
    pub token: ::std::string::String,
    pub expiration: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub field_type: ::std::string::String,
    pub address: ::std::string::String,
    pub params: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub payload: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Channel {
    fn default() -> &'a Channel {
        <Channel as ::protobuf::Message>::default_instance()
    }
}

impl Channel {
    pub fn new() -> Channel {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string resource_id = 2;


    pub fn get_resource_id(&self) -> &str {
        &self.resource_id
    }
    pub fn clear_resource_id(&mut self) {
        self.resource_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_resource_id(&mut self, v: ::std::string::String) {
        self.resource_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource_id(&mut self) -> &mut ::std::string::String {
        &mut self.resource_id
    }

    // Take field
    pub fn take_resource_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.resource_id, ::std::string::String::new())
    }

    // string resource_uri = 3;


    pub fn get_resource_uri(&self) -> &str {
        &self.resource_uri
    }
    pub fn clear_resource_uri(&mut self) {
        self.resource_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_resource_uri(&mut self, v: ::std::string::String) {
        self.resource_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource_uri(&mut self) -> &mut ::std::string::String {
        &mut self.resource_uri
    }

    // Take field
    pub fn take_resource_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.resource_uri, ::std::string::String::new())
    }

    // string token = 4;


    pub fn get_token(&self) -> &str {
        &self.token
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        &mut self.token
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.token, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp expiration = 5;


    pub fn get_expiration(&self) -> &::protobuf::well_known_types::Timestamp {
        self.expiration.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_expiration(&mut self) {
        self.expiration.clear();
    }

    pub fn has_expiration(&self) -> bool {
        self.expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.expiration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expiration(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.expiration.is_none() {
            self.expiration.set_default();
        }
        self.expiration.as_mut().unwrap()
    }

    // Take field
    pub fn take_expiration(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.expiration.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string type = 6;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // string address = 7;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // repeated .google.storage.v1.Channel.ParamsEntry params = 8;


    pub fn get_params(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.params
    }
    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.params = v;
    }

    // Mutable pointer to the field.
    pub fn mut_params(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.params
    }

    // Take field
    pub fn take_params(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.params, ::std::collections::HashMap::new())
    }

    // bool payload = 9;


    pub fn get_payload(&self) -> bool {
        self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload = false;
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: bool) {
        self.payload = v;
    }
}

impl ::protobuf::Message for Channel {
    fn is_initialized(&self) -> bool {
        for v in &self.expiration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.resource_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.resource_uri)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.token)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expiration)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                8 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.params)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.payload = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.resource_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.resource_id);
        }
        if !self.resource_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.resource_uri);
        }
        if !self.token.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.token);
        }
        if let Some(ref v) = self.expiration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.field_type);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.address);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(8, &self.params);
        if self.payload != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.resource_id.is_empty() {
            os.write_string(2, &self.resource_id)?;
        }
        if !self.resource_uri.is_empty() {
            os.write_string(3, &self.resource_uri)?;
        }
        if !self.token.is_empty() {
            os.write_string(4, &self.token)?;
        }
        if let Some(ref v) = self.expiration.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(6, &self.field_type)?;
        }
        if !self.address.is_empty() {
            os.write_string(7, &self.address)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(8, &self.params, os)?;
        if self.payload != false {
            os.write_bool(9, self.payload)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Channel {
        Channel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Channel| { &m.id },
                |m: &mut Channel| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resource_id",
                |m: &Channel| { &m.resource_id },
                |m: &mut Channel| { &mut m.resource_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resource_uri",
                |m: &Channel| { &m.resource_uri },
                |m: &mut Channel| { &mut m.resource_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "token",
                |m: &Channel| { &m.token },
                |m: &mut Channel| { &mut m.token },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "expiration",
                |m: &Channel| { &m.expiration },
                |m: &mut Channel| { &mut m.expiration },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &Channel| { &m.field_type },
                |m: &mut Channel| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &Channel| { &m.address },
                |m: &mut Channel| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "params",
                |m: &Channel| { &m.params },
                |m: &mut Channel| { &mut m.params },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "payload",
                |m: &Channel| { &m.payload },
                |m: &mut Channel| { &mut m.payload },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Channel>(
                "Channel",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Channel {
        static instance: ::protobuf::rt::LazyV2<Channel> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Channel::new)
    }
}

impl ::protobuf::Clear for Channel {
    fn clear(&mut self) {
        self.id.clear();
        self.resource_id.clear();
        self.resource_uri.clear();
        self.token.clear();
        self.expiration.clear();
        self.field_type.clear();
        self.address.clear();
        self.params.clear();
        self.payload = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Channel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Channel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListChannelsResponse {
    // message fields
    pub items: ::protobuf::RepeatedField<ListChannelsResponse_Items>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListChannelsResponse {
    fn default() -> &'a ListChannelsResponse {
        <ListChannelsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListChannelsResponse {
    pub fn new() -> ListChannelsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.storage.v1.ListChannelsResponse.Items items = 1;


    pub fn get_items(&self) -> &[ListChannelsResponse_Items] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<ListChannelsResponse_Items>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<ListChannelsResponse_Items> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<ListChannelsResponse_Items> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListChannelsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListChannelsResponse {
        ListChannelsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ListChannelsResponse_Items>>(
                "items",
                |m: &ListChannelsResponse| { &m.items },
                |m: &mut ListChannelsResponse| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListChannelsResponse>(
                "ListChannelsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListChannelsResponse {
        static instance: ::protobuf::rt::LazyV2<ListChannelsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListChannelsResponse::new)
    }
}

impl ::protobuf::Clear for ListChannelsResponse {
    fn clear(&mut self) {
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListChannelsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListChannelsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListChannelsResponse_Items {
    // message fields
    pub channel_id: ::std::string::String,
    pub resource_id: ::std::string::String,
    pub push_url: ::std::string::String,
    pub subscriber_email: ::std::string::String,
    pub creation_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListChannelsResponse_Items {
    fn default() -> &'a ListChannelsResponse_Items {
        <ListChannelsResponse_Items as ::protobuf::Message>::default_instance()
    }
}

impl ListChannelsResponse_Items {
    pub fn new() -> ListChannelsResponse_Items {
        ::std::default::Default::default()
    }

    // string channel_id = 1;


    pub fn get_channel_id(&self) -> &str {
        &self.channel_id
    }
    pub fn clear_channel_id(&mut self) {
        self.channel_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: ::std::string::String) {
        self.channel_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_id(&mut self) -> &mut ::std::string::String {
        &mut self.channel_id
    }

    // Take field
    pub fn take_channel_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel_id, ::std::string::String::new())
    }

    // string resource_id = 2;


    pub fn get_resource_id(&self) -> &str {
        &self.resource_id
    }
    pub fn clear_resource_id(&mut self) {
        self.resource_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_resource_id(&mut self, v: ::std::string::String) {
        self.resource_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource_id(&mut self) -> &mut ::std::string::String {
        &mut self.resource_id
    }

    // Take field
    pub fn take_resource_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.resource_id, ::std::string::String::new())
    }

    // string push_url = 3;


    pub fn get_push_url(&self) -> &str {
        &self.push_url
    }
    pub fn clear_push_url(&mut self) {
        self.push_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_push_url(&mut self, v: ::std::string::String) {
        self.push_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_push_url(&mut self) -> &mut ::std::string::String {
        &mut self.push_url
    }

    // Take field
    pub fn take_push_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.push_url, ::std::string::String::new())
    }

    // string subscriber_email = 4;


    pub fn get_subscriber_email(&self) -> &str {
        &self.subscriber_email
    }
    pub fn clear_subscriber_email(&mut self) {
        self.subscriber_email.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscriber_email(&mut self, v: ::std::string::String) {
        self.subscriber_email = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscriber_email(&mut self) -> &mut ::std::string::String {
        &mut self.subscriber_email
    }

    // Take field
    pub fn take_subscriber_email(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subscriber_email, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp creation_time = 5;


    pub fn get_creation_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.creation_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_creation_time(&mut self) {
        self.creation_time.clear();
    }

    pub fn has_creation_time(&self) -> bool {
        self.creation_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creation_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.creation_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creation_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.creation_time.is_none() {
            self.creation_time.set_default();
        }
        self.creation_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_creation_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.creation_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for ListChannelsResponse_Items {
    fn is_initialized(&self) -> bool {
        for v in &self.creation_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.resource_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.push_url)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subscriber_email)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.creation_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel_id);
        }
        if !self.resource_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.resource_id);
        }
        if !self.push_url.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.push_url);
        }
        if !self.subscriber_email.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.subscriber_email);
        }
        if let Some(ref v) = self.creation_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.channel_id.is_empty() {
            os.write_string(1, &self.channel_id)?;
        }
        if !self.resource_id.is_empty() {
            os.write_string(2, &self.resource_id)?;
        }
        if !self.push_url.is_empty() {
            os.write_string(3, &self.push_url)?;
        }
        if !self.subscriber_email.is_empty() {
            os.write_string(4, &self.subscriber_email)?;
        }
        if let Some(ref v) = self.creation_time.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListChannelsResponse_Items {
        ListChannelsResponse_Items::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "channel_id",
                |m: &ListChannelsResponse_Items| { &m.channel_id },
                |m: &mut ListChannelsResponse_Items| { &mut m.channel_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resource_id",
                |m: &ListChannelsResponse_Items| { &m.resource_id },
                |m: &mut ListChannelsResponse_Items| { &mut m.resource_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "push_url",
                |m: &ListChannelsResponse_Items| { &m.push_url },
                |m: &mut ListChannelsResponse_Items| { &mut m.push_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subscriber_email",
                |m: &ListChannelsResponse_Items| { &m.subscriber_email },
                |m: &mut ListChannelsResponse_Items| { &mut m.subscriber_email },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "creation_time",
                |m: &ListChannelsResponse_Items| { &m.creation_time },
                |m: &mut ListChannelsResponse_Items| { &mut m.creation_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListChannelsResponse_Items>(
                "ListChannelsResponse.Items",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListChannelsResponse_Items {
        static instance: ::protobuf::rt::LazyV2<ListChannelsResponse_Items> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListChannelsResponse_Items::new)
    }
}

impl ::protobuf::Clear for ListChannelsResponse_Items {
    fn clear(&mut self) {
        self.channel_id.clear();
        self.resource_id.clear();
        self.push_url.clear();
        self.subscriber_email.clear();
        self.creation_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListChannelsResponse_Items {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListChannelsResponse_Items {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChecksummedData {
    // message fields
    pub content: ::std::vec::Vec<u8>,
    pub crc32c: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChecksummedData {
    fn default() -> &'a ChecksummedData {
        <ChecksummedData as ::protobuf::Message>::default_instance()
    }
}

impl ChecksummedData {
    pub fn new() -> ChecksummedData {
        ::std::default::Default::default()
    }

    // bytes content = 1;


    pub fn get_content(&self) -> &[u8] {
        &self.content
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::vec::Vec<u8>) {
        self.content = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.content
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.content, ::std::vec::Vec::new())
    }

    // .google.protobuf.UInt32Value crc32c = 2;


    pub fn get_crc32c(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.crc32c.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_crc32c(&mut self) {
        self.crc32c.clear();
    }

    pub fn has_crc32c(&self) -> bool {
        self.crc32c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc32c(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.crc32c = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_crc32c(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.crc32c.is_none() {
            self.crc32c.set_default();
        }
        self.crc32c.as_mut().unwrap()
    }

    // Take field
    pub fn take_crc32c(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.crc32c.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }
}

impl ::protobuf::Message for ChecksummedData {
    fn is_initialized(&self) -> bool {
        for v in &self.crc32c {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.content)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.crc32c)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.content);
        }
        if let Some(ref v) = self.crc32c.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.content.is_empty() {
            os.write_bytes(1, &self.content)?;
        }
        if let Some(ref v) = self.crc32c.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChecksummedData {
        ChecksummedData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "content",
                |m: &ChecksummedData| { &m.content },
                |m: &mut ChecksummedData| { &mut m.content },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "crc32c",
                |m: &ChecksummedData| { &m.crc32c },
                |m: &mut ChecksummedData| { &mut m.crc32c },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChecksummedData>(
                "ChecksummedData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChecksummedData {
        static instance: ::protobuf::rt::LazyV2<ChecksummedData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChecksummedData::new)
    }
}

impl ::protobuf::Clear for ChecksummedData {
    fn clear(&mut self) {
        self.content.clear();
        self.crc32c.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChecksummedData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChecksummedData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ObjectChecksums {
    // message fields
    pub crc32c: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub md5_hash: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ObjectChecksums {
    fn default() -> &'a ObjectChecksums {
        <ObjectChecksums as ::protobuf::Message>::default_instance()
    }
}

impl ObjectChecksums {
    pub fn new() -> ObjectChecksums {
        ::std::default::Default::default()
    }

    // .google.protobuf.UInt32Value crc32c = 1;


    pub fn get_crc32c(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.crc32c.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_crc32c(&mut self) {
        self.crc32c.clear();
    }

    pub fn has_crc32c(&self) -> bool {
        self.crc32c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc32c(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.crc32c = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_crc32c(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.crc32c.is_none() {
            self.crc32c.set_default();
        }
        self.crc32c.as_mut().unwrap()
    }

    // Take field
    pub fn take_crc32c(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.crc32c.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    // string md5_hash = 2;


    pub fn get_md5_hash(&self) -> &str {
        &self.md5_hash
    }
    pub fn clear_md5_hash(&mut self) {
        self.md5_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_md5_hash(&mut self, v: ::std::string::String) {
        self.md5_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_md5_hash(&mut self) -> &mut ::std::string::String {
        &mut self.md5_hash
    }

    // Take field
    pub fn take_md5_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.md5_hash, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ObjectChecksums {
    fn is_initialized(&self) -> bool {
        for v in &self.crc32c {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.crc32c)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.md5_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.crc32c.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.md5_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.md5_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.crc32c.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.md5_hash.is_empty() {
            os.write_string(2, &self.md5_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ObjectChecksums {
        ObjectChecksums::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "crc32c",
                |m: &ObjectChecksums| { &m.crc32c },
                |m: &mut ObjectChecksums| { &mut m.crc32c },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "md5_hash",
                |m: &ObjectChecksums| { &m.md5_hash },
                |m: &mut ObjectChecksums| { &mut m.md5_hash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ObjectChecksums>(
                "ObjectChecksums",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ObjectChecksums {
        static instance: ::protobuf::rt::LazyV2<ObjectChecksums> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ObjectChecksums::new)
    }
}

impl ::protobuf::Clear for ObjectChecksums {
    fn clear(&mut self) {
        self.crc32c.clear();
        self.md5_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ObjectChecksums {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObjectChecksums {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommonEnums {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommonEnums {
    fn default() -> &'a CommonEnums {
        <CommonEnums as ::protobuf::Message>::default_instance()
    }
}

impl CommonEnums {
    pub fn new() -> CommonEnums {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CommonEnums {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommonEnums {
        CommonEnums::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommonEnums>(
                "CommonEnums",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommonEnums {
        static instance: ::protobuf::rt::LazyV2<CommonEnums> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommonEnums::new)
    }
}

impl ::protobuf::Clear for CommonEnums {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommonEnums {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommonEnums {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CommonEnums_Projection {
    PROJECTION_UNSPECIFIED = 0,
    NO_ACL = 1,
    FULL = 2,
}

impl ::protobuf::ProtobufEnum for CommonEnums_Projection {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CommonEnums_Projection> {
        match value {
            0 => ::std::option::Option::Some(CommonEnums_Projection::PROJECTION_UNSPECIFIED),
            1 => ::std::option::Option::Some(CommonEnums_Projection::NO_ACL),
            2 => ::std::option::Option::Some(CommonEnums_Projection::FULL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CommonEnums_Projection] = &[
            CommonEnums_Projection::PROJECTION_UNSPECIFIED,
            CommonEnums_Projection::NO_ACL,
            CommonEnums_Projection::FULL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CommonEnums_Projection>("CommonEnums.Projection", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CommonEnums_Projection {
}

impl ::std::default::Default for CommonEnums_Projection {
    fn default() -> Self {
        CommonEnums_Projection::PROJECTION_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for CommonEnums_Projection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CommonEnums_PredefinedBucketAcl {
    PREDEFINED_BUCKET_ACL_UNSPECIFIED = 0,
    BUCKET_ACL_AUTHENTICATED_READ = 1,
    BUCKET_ACL_PRIVATE = 2,
    BUCKET_ACL_PROJECT_PRIVATE = 3,
    BUCKET_ACL_PUBLIC_READ = 4,
    BUCKET_ACL_PUBLIC_READ_WRITE = 5,
}

impl ::protobuf::ProtobufEnum for CommonEnums_PredefinedBucketAcl {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CommonEnums_PredefinedBucketAcl> {
        match value {
            0 => ::std::option::Option::Some(CommonEnums_PredefinedBucketAcl::PREDEFINED_BUCKET_ACL_UNSPECIFIED),
            1 => ::std::option::Option::Some(CommonEnums_PredefinedBucketAcl::BUCKET_ACL_AUTHENTICATED_READ),
            2 => ::std::option::Option::Some(CommonEnums_PredefinedBucketAcl::BUCKET_ACL_PRIVATE),
            3 => ::std::option::Option::Some(CommonEnums_PredefinedBucketAcl::BUCKET_ACL_PROJECT_PRIVATE),
            4 => ::std::option::Option::Some(CommonEnums_PredefinedBucketAcl::BUCKET_ACL_PUBLIC_READ),
            5 => ::std::option::Option::Some(CommonEnums_PredefinedBucketAcl::BUCKET_ACL_PUBLIC_READ_WRITE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CommonEnums_PredefinedBucketAcl] = &[
            CommonEnums_PredefinedBucketAcl::PREDEFINED_BUCKET_ACL_UNSPECIFIED,
            CommonEnums_PredefinedBucketAcl::BUCKET_ACL_AUTHENTICATED_READ,
            CommonEnums_PredefinedBucketAcl::BUCKET_ACL_PRIVATE,
            CommonEnums_PredefinedBucketAcl::BUCKET_ACL_PROJECT_PRIVATE,
            CommonEnums_PredefinedBucketAcl::BUCKET_ACL_PUBLIC_READ,
            CommonEnums_PredefinedBucketAcl::BUCKET_ACL_PUBLIC_READ_WRITE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CommonEnums_PredefinedBucketAcl>("CommonEnums.PredefinedBucketAcl", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CommonEnums_PredefinedBucketAcl {
}

impl ::std::default::Default for CommonEnums_PredefinedBucketAcl {
    fn default() -> Self {
        CommonEnums_PredefinedBucketAcl::PREDEFINED_BUCKET_ACL_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for CommonEnums_PredefinedBucketAcl {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CommonEnums_PredefinedObjectAcl {
    PREDEFINED_OBJECT_ACL_UNSPECIFIED = 0,
    OBJECT_ACL_AUTHENTICATED_READ = 1,
    OBJECT_ACL_BUCKET_OWNER_FULL_CONTROL = 2,
    OBJECT_ACL_BUCKET_OWNER_READ = 3,
    OBJECT_ACL_PRIVATE = 4,
    OBJECT_ACL_PROJECT_PRIVATE = 5,
    OBJECT_ACL_PUBLIC_READ = 6,
}

impl ::protobuf::ProtobufEnum for CommonEnums_PredefinedObjectAcl {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CommonEnums_PredefinedObjectAcl> {
        match value {
            0 => ::std::option::Option::Some(CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED),
            1 => ::std::option::Option::Some(CommonEnums_PredefinedObjectAcl::OBJECT_ACL_AUTHENTICATED_READ),
            2 => ::std::option::Option::Some(CommonEnums_PredefinedObjectAcl::OBJECT_ACL_BUCKET_OWNER_FULL_CONTROL),
            3 => ::std::option::Option::Some(CommonEnums_PredefinedObjectAcl::OBJECT_ACL_BUCKET_OWNER_READ),
            4 => ::std::option::Option::Some(CommonEnums_PredefinedObjectAcl::OBJECT_ACL_PRIVATE),
            5 => ::std::option::Option::Some(CommonEnums_PredefinedObjectAcl::OBJECT_ACL_PROJECT_PRIVATE),
            6 => ::std::option::Option::Some(CommonEnums_PredefinedObjectAcl::OBJECT_ACL_PUBLIC_READ),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CommonEnums_PredefinedObjectAcl] = &[
            CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED,
            CommonEnums_PredefinedObjectAcl::OBJECT_ACL_AUTHENTICATED_READ,
            CommonEnums_PredefinedObjectAcl::OBJECT_ACL_BUCKET_OWNER_FULL_CONTROL,
            CommonEnums_PredefinedObjectAcl::OBJECT_ACL_BUCKET_OWNER_READ,
            CommonEnums_PredefinedObjectAcl::OBJECT_ACL_PRIVATE,
            CommonEnums_PredefinedObjectAcl::OBJECT_ACL_PROJECT_PRIVATE,
            CommonEnums_PredefinedObjectAcl::OBJECT_ACL_PUBLIC_READ,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CommonEnums_PredefinedObjectAcl>("CommonEnums.PredefinedObjectAcl", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CommonEnums_PredefinedObjectAcl {
}

impl ::std::default::Default for CommonEnums_PredefinedObjectAcl {
    fn default() -> Self {
        CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for CommonEnums_PredefinedObjectAcl {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContentRange {
    // message fields
    pub start: i64,
    pub end: i64,
    pub complete_length: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContentRange {
    fn default() -> &'a ContentRange {
        <ContentRange as ::protobuf::Message>::default_instance()
    }
}

impl ContentRange {
    pub fn new() -> ContentRange {
        ::std::default::Default::default()
    }

    // int64 start = 1;


    pub fn get_start(&self) -> i64 {
        self.start
    }
    pub fn clear_start(&mut self) {
        self.start = 0;
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: i64) {
        self.start = v;
    }

    // int64 end = 2;


    pub fn get_end(&self) -> i64 {
        self.end
    }
    pub fn clear_end(&mut self) {
        self.end = 0;
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: i64) {
        self.end = v;
    }

    // int64 complete_length = 3;


    pub fn get_complete_length(&self) -> i64 {
        self.complete_length
    }
    pub fn clear_complete_length(&mut self) {
        self.complete_length = 0;
    }

    // Param is passed by value, moved
    pub fn set_complete_length(&mut self, v: i64) {
        self.complete_length = v;
    }
}

impl ::protobuf::Message for ContentRange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.start = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.end = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.complete_length = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.end != 0 {
            my_size += ::protobuf::rt::value_size(2, self.end, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.complete_length != 0 {
            my_size += ::protobuf::rt::value_size(3, self.complete_length, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.start != 0 {
            os.write_int64(1, self.start)?;
        }
        if self.end != 0 {
            os.write_int64(2, self.end)?;
        }
        if self.complete_length != 0 {
            os.write_int64(3, self.complete_length)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContentRange {
        ContentRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "start",
                |m: &ContentRange| { &m.start },
                |m: &mut ContentRange| { &mut m.start },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "end",
                |m: &ContentRange| { &m.end },
                |m: &mut ContentRange| { &mut m.end },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "complete_length",
                |m: &ContentRange| { &m.complete_length },
                |m: &mut ContentRange| { &mut m.complete_length },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContentRange>(
                "ContentRange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContentRange {
        static instance: ::protobuf::rt::LazyV2<ContentRange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContentRange::new)
    }
}

impl ::protobuf::Clear for ContentRange {
    fn clear(&mut self) {
        self.start = 0;
        self.end = 0;
        self.complete_length = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContentRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentRange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HmacKeyMetadata {
    // message fields
    pub id: ::std::string::String,
    pub access_id: ::std::string::String,
    pub project_id: ::std::string::String,
    pub service_account_email: ::std::string::String,
    pub state: ::std::string::String,
    pub time_created: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub updated: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub etag: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HmacKeyMetadata {
    fn default() -> &'a HmacKeyMetadata {
        <HmacKeyMetadata as ::protobuf::Message>::default_instance()
    }
}

impl HmacKeyMetadata {
    pub fn new() -> HmacKeyMetadata {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string access_id = 2;


    pub fn get_access_id(&self) -> &str {
        &self.access_id
    }
    pub fn clear_access_id(&mut self) {
        self.access_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_access_id(&mut self, v: ::std::string::String) {
        self.access_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_access_id(&mut self) -> &mut ::std::string::String {
        &mut self.access_id
    }

    // Take field
    pub fn take_access_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.access_id, ::std::string::String::new())
    }

    // string project_id = 3;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string service_account_email = 4;


    pub fn get_service_account_email(&self) -> &str {
        &self.service_account_email
    }
    pub fn clear_service_account_email(&mut self) {
        self.service_account_email.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_account_email(&mut self, v: ::std::string::String) {
        self.service_account_email = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_account_email(&mut self) -> &mut ::std::string::String {
        &mut self.service_account_email
    }

    // Take field
    pub fn take_service_account_email(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_account_email, ::std::string::String::new())
    }

    // string state = 5;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp time_created = 6;


    pub fn get_time_created(&self) -> &::protobuf::well_known_types::Timestamp {
        self.time_created.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_time_created(&mut self) {
        self.time_created.clear();
    }

    pub fn has_time_created(&self) -> bool {
        self.time_created.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_created(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.time_created = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time_created(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.time_created.is_none() {
            self.time_created.set_default();
        }
        self.time_created.as_mut().unwrap()
    }

    // Take field
    pub fn take_time_created(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.time_created.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp updated = 7;


    pub fn get_updated(&self) -> &::protobuf::well_known_types::Timestamp {
        self.updated.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_updated(&mut self) {
        self.updated.clear();
    }

    pub fn has_updated(&self) -> bool {
        self.updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.updated = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updated(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.updated.is_none() {
            self.updated.set_default();
        }
        self.updated.as_mut().unwrap()
    }

    // Take field
    pub fn take_updated(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.updated.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string etag = 8;


    pub fn get_etag(&self) -> &str {
        &self.etag
    }
    pub fn clear_etag(&mut self) {
        self.etag.clear();
    }

    // Param is passed by value, moved
    pub fn set_etag(&mut self, v: ::std::string::String) {
        self.etag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_etag(&mut self) -> &mut ::std::string::String {
        &mut self.etag
    }

    // Take field
    pub fn take_etag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.etag, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HmacKeyMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.time_created {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updated {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.access_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_account_email)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time_created)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.updated)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.etag)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.access_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.access_id);
        }
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.project_id);
        }
        if !self.service_account_email.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.service_account_email);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.state);
        }
        if let Some(ref v) = self.time_created.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.updated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.etag.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.etag);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.access_id.is_empty() {
            os.write_string(2, &self.access_id)?;
        }
        if !self.project_id.is_empty() {
            os.write_string(3, &self.project_id)?;
        }
        if !self.service_account_email.is_empty() {
            os.write_string(4, &self.service_account_email)?;
        }
        if !self.state.is_empty() {
            os.write_string(5, &self.state)?;
        }
        if let Some(ref v) = self.time_created.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.updated.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.etag.is_empty() {
            os.write_string(8, &self.etag)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HmacKeyMetadata {
        HmacKeyMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &HmacKeyMetadata| { &m.id },
                |m: &mut HmacKeyMetadata| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "access_id",
                |m: &HmacKeyMetadata| { &m.access_id },
                |m: &mut HmacKeyMetadata| { &mut m.access_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &HmacKeyMetadata| { &m.project_id },
                |m: &mut HmacKeyMetadata| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_account_email",
                |m: &HmacKeyMetadata| { &m.service_account_email },
                |m: &mut HmacKeyMetadata| { &mut m.service_account_email },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "state",
                |m: &HmacKeyMetadata| { &m.state },
                |m: &mut HmacKeyMetadata| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "time_created",
                |m: &HmacKeyMetadata| { &m.time_created },
                |m: &mut HmacKeyMetadata| { &mut m.time_created },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "updated",
                |m: &HmacKeyMetadata| { &m.updated },
                |m: &mut HmacKeyMetadata| { &mut m.updated },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "etag",
                |m: &HmacKeyMetadata| { &m.etag },
                |m: &mut HmacKeyMetadata| { &mut m.etag },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HmacKeyMetadata>(
                "HmacKeyMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HmacKeyMetadata {
        static instance: ::protobuf::rt::LazyV2<HmacKeyMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HmacKeyMetadata::new)
    }
}

impl ::protobuf::Clear for HmacKeyMetadata {
    fn clear(&mut self) {
        self.id.clear();
        self.access_id.clear();
        self.project_id.clear();
        self.service_account_email.clear();
        self.state.clear();
        self.time_created.clear();
        self.updated.clear();
        self.etag.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HmacKeyMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HmacKeyMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Notification {
    // message fields
    pub topic: ::std::string::String,
    pub event_types: ::protobuf::RepeatedField<::std::string::String>,
    pub custom_attributes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub etag: ::std::string::String,
    pub object_name_prefix: ::std::string::String,
    pub payload_format: ::std::string::String,
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Notification {
    fn default() -> &'a Notification {
        <Notification as ::protobuf::Message>::default_instance()
    }
}

impl Notification {
    pub fn new() -> Notification {
        ::std::default::Default::default()
    }

    // string topic = 1;


    pub fn get_topic(&self) -> &str {
        &self.topic
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        &mut self.topic
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.topic, ::std::string::String::new())
    }

    // repeated string event_types = 2;


    pub fn get_event_types(&self) -> &[::std::string::String] {
        &self.event_types
    }
    pub fn clear_event_types(&mut self) {
        self.event_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_event_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.event_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_event_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.event_types
    }

    // Take field
    pub fn take_event_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.event_types, ::protobuf::RepeatedField::new())
    }

    // repeated .google.storage.v1.Notification.CustomAttributesEntry custom_attributes = 3;


    pub fn get_custom_attributes(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.custom_attributes
    }
    pub fn clear_custom_attributes(&mut self) {
        self.custom_attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_custom_attributes(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.custom_attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_custom_attributes(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.custom_attributes
    }

    // Take field
    pub fn take_custom_attributes(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.custom_attributes, ::std::collections::HashMap::new())
    }

    // string etag = 4;


    pub fn get_etag(&self) -> &str {
        &self.etag
    }
    pub fn clear_etag(&mut self) {
        self.etag.clear();
    }

    // Param is passed by value, moved
    pub fn set_etag(&mut self, v: ::std::string::String) {
        self.etag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_etag(&mut self) -> &mut ::std::string::String {
        &mut self.etag
    }

    // Take field
    pub fn take_etag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.etag, ::std::string::String::new())
    }

    // string object_name_prefix = 5;


    pub fn get_object_name_prefix(&self) -> &str {
        &self.object_name_prefix
    }
    pub fn clear_object_name_prefix(&mut self) {
        self.object_name_prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_name_prefix(&mut self, v: ::std::string::String) {
        self.object_name_prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_name_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.object_name_prefix
    }

    // Take field
    pub fn take_object_name_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_name_prefix, ::std::string::String::new())
    }

    // string payload_format = 6;


    pub fn get_payload_format(&self) -> &str {
        &self.payload_format
    }
    pub fn clear_payload_format(&mut self) {
        self.payload_format.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload_format(&mut self, v: ::std::string::String) {
        self.payload_format = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload_format(&mut self) -> &mut ::std::string::String {
        &mut self.payload_format
    }

    // Take field
    pub fn take_payload_format(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payload_format, ::std::string::String::new())
    }

    // string id = 7;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.topic)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.event_types)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.custom_attributes)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.etag)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_name_prefix)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payload_format)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.topic);
        }
        for value in &self.event_types {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.custom_attributes);
        if !self.etag.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.etag);
        }
        if !self.object_name_prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.object_name_prefix);
        }
        if !self.payload_format.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.payload_format);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.topic.is_empty() {
            os.write_string(1, &self.topic)?;
        }
        for v in &self.event_types {
            os.write_string(2, &v)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.custom_attributes, os)?;
        if !self.etag.is_empty() {
            os.write_string(4, &self.etag)?;
        }
        if !self.object_name_prefix.is_empty() {
            os.write_string(5, &self.object_name_prefix)?;
        }
        if !self.payload_format.is_empty() {
            os.write_string(6, &self.payload_format)?;
        }
        if !self.id.is_empty() {
            os.write_string(7, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Notification {
        Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "topic",
                |m: &Notification| { &m.topic },
                |m: &mut Notification| { &mut m.topic },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "event_types",
                |m: &Notification| { &m.event_types },
                |m: &mut Notification| { &mut m.event_types },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "custom_attributes",
                |m: &Notification| { &m.custom_attributes },
                |m: &mut Notification| { &mut m.custom_attributes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "etag",
                |m: &Notification| { &m.etag },
                |m: &mut Notification| { &mut m.etag },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object_name_prefix",
                |m: &Notification| { &m.object_name_prefix },
                |m: &mut Notification| { &mut m.object_name_prefix },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "payload_format",
                |m: &Notification| { &m.payload_format },
                |m: &mut Notification| { &mut m.payload_format },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Notification| { &m.id },
                |m: &mut Notification| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Notification>(
                "Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Notification {
        static instance: ::protobuf::rt::LazyV2<Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Notification::new)
    }
}

impl ::protobuf::Clear for Notification {
    fn clear(&mut self) {
        self.topic.clear();
        self.event_types.clear();
        self.custom_attributes.clear();
        self.etag.clear();
        self.object_name_prefix.clear();
        self.payload_format.clear();
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListNotificationsResponse {
    // message fields
    pub items: ::protobuf::RepeatedField<Notification>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListNotificationsResponse {
    fn default() -> &'a ListNotificationsResponse {
        <ListNotificationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListNotificationsResponse {
    pub fn new() -> ListNotificationsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.storage.v1.Notification items = 1;


    pub fn get_items(&self) -> &[Notification] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<Notification>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<Notification> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<Notification> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListNotificationsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListNotificationsResponse {
        ListNotificationsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Notification>>(
                "items",
                |m: &ListNotificationsResponse| { &m.items },
                |m: &mut ListNotificationsResponse| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListNotificationsResponse>(
                "ListNotificationsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListNotificationsResponse {
        static instance: ::protobuf::rt::LazyV2<ListNotificationsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListNotificationsResponse::new)
    }
}

impl ::protobuf::Clear for ListNotificationsResponse {
    fn clear(&mut self) {
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListNotificationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListNotificationsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Object {
    // message fields
    pub content_encoding: ::std::string::String,
    pub content_disposition: ::std::string::String,
    pub cache_control: ::std::string::String,
    pub acl: ::protobuf::RepeatedField<ObjectAccessControl>,
    pub content_language: ::std::string::String,
    pub metageneration: i64,
    pub time_deleted: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub content_type: ::std::string::String,
    pub size: i64,
    pub time_created: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub crc32c: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub component_count: i32,
    pub md5_hash: ::std::string::String,
    pub etag: ::std::string::String,
    pub updated: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub storage_class: ::std::string::String,
    pub kms_key_name: ::std::string::String,
    pub time_storage_class_updated: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub temporary_hold: bool,
    pub retention_expiration_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub event_based_hold: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub name: ::std::string::String,
    pub id: ::std::string::String,
    pub bucket: ::std::string::String,
    pub generation: i64,
    pub owner: ::protobuf::SingularPtrField<Owner>,
    pub customer_encryption: ::protobuf::SingularPtrField<Object_CustomerEncryption>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Object {
    fn default() -> &'a Object {
        <Object as ::protobuf::Message>::default_instance()
    }
}

impl Object {
    pub fn new() -> Object {
        ::std::default::Default::default()
    }

    // string content_encoding = 1;


    pub fn get_content_encoding(&self) -> &str {
        &self.content_encoding
    }
    pub fn clear_content_encoding(&mut self) {
        self.content_encoding.clear();
    }

    // Param is passed by value, moved
    pub fn set_content_encoding(&mut self, v: ::std::string::String) {
        self.content_encoding = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content_encoding(&mut self) -> &mut ::std::string::String {
        &mut self.content_encoding
    }

    // Take field
    pub fn take_content_encoding(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.content_encoding, ::std::string::String::new())
    }

    // string content_disposition = 2;


    pub fn get_content_disposition(&self) -> &str {
        &self.content_disposition
    }
    pub fn clear_content_disposition(&mut self) {
        self.content_disposition.clear();
    }

    // Param is passed by value, moved
    pub fn set_content_disposition(&mut self, v: ::std::string::String) {
        self.content_disposition = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content_disposition(&mut self) -> &mut ::std::string::String {
        &mut self.content_disposition
    }

    // Take field
    pub fn take_content_disposition(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.content_disposition, ::std::string::String::new())
    }

    // string cache_control = 3;


    pub fn get_cache_control(&self) -> &str {
        &self.cache_control
    }
    pub fn clear_cache_control(&mut self) {
        self.cache_control.clear();
    }

    // Param is passed by value, moved
    pub fn set_cache_control(&mut self, v: ::std::string::String) {
        self.cache_control = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cache_control(&mut self) -> &mut ::std::string::String {
        &mut self.cache_control
    }

    // Take field
    pub fn take_cache_control(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cache_control, ::std::string::String::new())
    }

    // repeated .google.storage.v1.ObjectAccessControl acl = 4;


    pub fn get_acl(&self) -> &[ObjectAccessControl] {
        &self.acl
    }
    pub fn clear_acl(&mut self) {
        self.acl.clear();
    }

    // Param is passed by value, moved
    pub fn set_acl(&mut self, v: ::protobuf::RepeatedField<ObjectAccessControl>) {
        self.acl = v;
    }

    // Mutable pointer to the field.
    pub fn mut_acl(&mut self) -> &mut ::protobuf::RepeatedField<ObjectAccessControl> {
        &mut self.acl
    }

    // Take field
    pub fn take_acl(&mut self) -> ::protobuf::RepeatedField<ObjectAccessControl> {
        ::std::mem::replace(&mut self.acl, ::protobuf::RepeatedField::new())
    }

    // string content_language = 5;


    pub fn get_content_language(&self) -> &str {
        &self.content_language
    }
    pub fn clear_content_language(&mut self) {
        self.content_language.clear();
    }

    // Param is passed by value, moved
    pub fn set_content_language(&mut self, v: ::std::string::String) {
        self.content_language = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content_language(&mut self) -> &mut ::std::string::String {
        &mut self.content_language
    }

    // Take field
    pub fn take_content_language(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.content_language, ::std::string::String::new())
    }

    // int64 metageneration = 6;


    pub fn get_metageneration(&self) -> i64 {
        self.metageneration
    }
    pub fn clear_metageneration(&mut self) {
        self.metageneration = 0;
    }

    // Param is passed by value, moved
    pub fn set_metageneration(&mut self, v: i64) {
        self.metageneration = v;
    }

    // .google.protobuf.Timestamp time_deleted = 7;


    pub fn get_time_deleted(&self) -> &::protobuf::well_known_types::Timestamp {
        self.time_deleted.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_time_deleted(&mut self) {
        self.time_deleted.clear();
    }

    pub fn has_time_deleted(&self) -> bool {
        self.time_deleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_deleted(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.time_deleted = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time_deleted(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.time_deleted.is_none() {
            self.time_deleted.set_default();
        }
        self.time_deleted.as_mut().unwrap()
    }

    // Take field
    pub fn take_time_deleted(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.time_deleted.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string content_type = 8;


    pub fn get_content_type(&self) -> &str {
        &self.content_type
    }
    pub fn clear_content_type(&mut self) {
        self.content_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_content_type(&mut self, v: ::std::string::String) {
        self.content_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content_type(&mut self) -> &mut ::std::string::String {
        &mut self.content_type
    }

    // Take field
    pub fn take_content_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.content_type, ::std::string::String::new())
    }

    // int64 size = 9;


    pub fn get_size(&self) -> i64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i64) {
        self.size = v;
    }

    // .google.protobuf.Timestamp time_created = 10;


    pub fn get_time_created(&self) -> &::protobuf::well_known_types::Timestamp {
        self.time_created.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_time_created(&mut self) {
        self.time_created.clear();
    }

    pub fn has_time_created(&self) -> bool {
        self.time_created.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_created(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.time_created = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time_created(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.time_created.is_none() {
            self.time_created.set_default();
        }
        self.time_created.as_mut().unwrap()
    }

    // Take field
    pub fn take_time_created(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.time_created.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.UInt32Value crc32c = 11;


    pub fn get_crc32c(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.crc32c.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_crc32c(&mut self) {
        self.crc32c.clear();
    }

    pub fn has_crc32c(&self) -> bool {
        self.crc32c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc32c(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.crc32c = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_crc32c(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.crc32c.is_none() {
            self.crc32c.set_default();
        }
        self.crc32c.as_mut().unwrap()
    }

    // Take field
    pub fn take_crc32c(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.crc32c.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    // int32 component_count = 12;


    pub fn get_component_count(&self) -> i32 {
        self.component_count
    }
    pub fn clear_component_count(&mut self) {
        self.component_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_component_count(&mut self, v: i32) {
        self.component_count = v;
    }

    // string md5_hash = 13;


    pub fn get_md5_hash(&self) -> &str {
        &self.md5_hash
    }
    pub fn clear_md5_hash(&mut self) {
        self.md5_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_md5_hash(&mut self, v: ::std::string::String) {
        self.md5_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_md5_hash(&mut self) -> &mut ::std::string::String {
        &mut self.md5_hash
    }

    // Take field
    pub fn take_md5_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.md5_hash, ::std::string::String::new())
    }

    // string etag = 14;


    pub fn get_etag(&self) -> &str {
        &self.etag
    }
    pub fn clear_etag(&mut self) {
        self.etag.clear();
    }

    // Param is passed by value, moved
    pub fn set_etag(&mut self, v: ::std::string::String) {
        self.etag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_etag(&mut self) -> &mut ::std::string::String {
        &mut self.etag
    }

    // Take field
    pub fn take_etag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.etag, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp updated = 15;


    pub fn get_updated(&self) -> &::protobuf::well_known_types::Timestamp {
        self.updated.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_updated(&mut self) {
        self.updated.clear();
    }

    pub fn has_updated(&self) -> bool {
        self.updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.updated = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updated(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.updated.is_none() {
            self.updated.set_default();
        }
        self.updated.as_mut().unwrap()
    }

    // Take field
    pub fn take_updated(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.updated.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string storage_class = 16;


    pub fn get_storage_class(&self) -> &str {
        &self.storage_class
    }
    pub fn clear_storage_class(&mut self) {
        self.storage_class.clear();
    }

    // Param is passed by value, moved
    pub fn set_storage_class(&mut self, v: ::std::string::String) {
        self.storage_class = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storage_class(&mut self) -> &mut ::std::string::String {
        &mut self.storage_class
    }

    // Take field
    pub fn take_storage_class(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.storage_class, ::std::string::String::new())
    }

    // string kms_key_name = 17;


    pub fn get_kms_key_name(&self) -> &str {
        &self.kms_key_name
    }
    pub fn clear_kms_key_name(&mut self) {
        self.kms_key_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_kms_key_name(&mut self, v: ::std::string::String) {
        self.kms_key_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kms_key_name(&mut self) -> &mut ::std::string::String {
        &mut self.kms_key_name
    }

    // Take field
    pub fn take_kms_key_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kms_key_name, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp time_storage_class_updated = 18;


    pub fn get_time_storage_class_updated(&self) -> &::protobuf::well_known_types::Timestamp {
        self.time_storage_class_updated.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_time_storage_class_updated(&mut self) {
        self.time_storage_class_updated.clear();
    }

    pub fn has_time_storage_class_updated(&self) -> bool {
        self.time_storage_class_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_storage_class_updated(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.time_storage_class_updated = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time_storage_class_updated(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.time_storage_class_updated.is_none() {
            self.time_storage_class_updated.set_default();
        }
        self.time_storage_class_updated.as_mut().unwrap()
    }

    // Take field
    pub fn take_time_storage_class_updated(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.time_storage_class_updated.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // bool temporary_hold = 19;


    pub fn get_temporary_hold(&self) -> bool {
        self.temporary_hold
    }
    pub fn clear_temporary_hold(&mut self) {
        self.temporary_hold = false;
    }

    // Param is passed by value, moved
    pub fn set_temporary_hold(&mut self, v: bool) {
        self.temporary_hold = v;
    }

    // .google.protobuf.Timestamp retention_expiration_time = 20;


    pub fn get_retention_expiration_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.retention_expiration_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_retention_expiration_time(&mut self) {
        self.retention_expiration_time.clear();
    }

    pub fn has_retention_expiration_time(&self) -> bool {
        self.retention_expiration_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retention_expiration_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.retention_expiration_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retention_expiration_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.retention_expiration_time.is_none() {
            self.retention_expiration_time.set_default();
        }
        self.retention_expiration_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_retention_expiration_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.retention_expiration_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // repeated .google.storage.v1.Object.MetadataEntry metadata = 21;


    pub fn get_metadata(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.metadata, ::std::collections::HashMap::new())
    }

    // .google.protobuf.BoolValue event_based_hold = 29;


    pub fn get_event_based_hold(&self) -> &::protobuf::well_known_types::BoolValue {
        self.event_based_hold.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_event_based_hold(&mut self) {
        self.event_based_hold.clear();
    }

    pub fn has_event_based_hold(&self) -> bool {
        self.event_based_hold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_based_hold(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.event_based_hold = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_based_hold(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.event_based_hold.is_none() {
            self.event_based_hold.set_default();
        }
        self.event_based_hold.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_based_hold(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.event_based_hold.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // string name = 23;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string id = 24;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string bucket = 25;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // int64 generation = 26;


    pub fn get_generation(&self) -> i64 {
        self.generation
    }
    pub fn clear_generation(&mut self) {
        self.generation = 0;
    }

    // Param is passed by value, moved
    pub fn set_generation(&mut self, v: i64) {
        self.generation = v;
    }

    // .google.storage.v1.Owner owner = 27;


    pub fn get_owner(&self) -> &Owner {
        self.owner.as_ref().unwrap_or_else(|| <Owner as ::protobuf::Message>::default_instance())
    }
    pub fn clear_owner(&mut self) {
        self.owner.clear();
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: Owner) {
        self.owner = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner(&mut self) -> &mut Owner {
        if self.owner.is_none() {
            self.owner.set_default();
        }
        self.owner.as_mut().unwrap()
    }

    // Take field
    pub fn take_owner(&mut self) -> Owner {
        self.owner.take().unwrap_or_else(|| Owner::new())
    }

    // .google.storage.v1.Object.CustomerEncryption customer_encryption = 28;


    pub fn get_customer_encryption(&self) -> &Object_CustomerEncryption {
        self.customer_encryption.as_ref().unwrap_or_else(|| <Object_CustomerEncryption as ::protobuf::Message>::default_instance())
    }
    pub fn clear_customer_encryption(&mut self) {
        self.customer_encryption.clear();
    }

    pub fn has_customer_encryption(&self) -> bool {
        self.customer_encryption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_customer_encryption(&mut self, v: Object_CustomerEncryption) {
        self.customer_encryption = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_customer_encryption(&mut self) -> &mut Object_CustomerEncryption {
        if self.customer_encryption.is_none() {
            self.customer_encryption.set_default();
        }
        self.customer_encryption.as_mut().unwrap()
    }

    // Take field
    pub fn take_customer_encryption(&mut self) -> Object_CustomerEncryption {
        self.customer_encryption.take().unwrap_or_else(|| Object_CustomerEncryption::new())
    }
}

impl ::protobuf::Message for Object {
    fn is_initialized(&self) -> bool {
        for v in &self.acl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.time_deleted {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.time_created {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.crc32c {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updated {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.time_storage_class_updated {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.retention_expiration_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.event_based_hold {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.owner {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.customer_encryption {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.content_encoding)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.content_disposition)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cache_control)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.acl)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.content_language)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.metageneration = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time_deleted)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.content_type)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time_created)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.crc32c)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.component_count = tmp;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.md5_hash)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.etag)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.updated)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.storage_class)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kms_key_name)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time_storage_class_updated)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.temporary_hold = tmp;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.retention_expiration_time)?;
                },
                21 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.metadata)?;
                },
                29 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.event_based_hold)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.generation = tmp;
                },
                27 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.owner)?;
                },
                28 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.customer_encryption)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.content_encoding.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.content_encoding);
        }
        if !self.content_disposition.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.content_disposition);
        }
        if !self.cache_control.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cache_control);
        }
        for value in &self.acl {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.content_language.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.content_language);
        }
        if self.metageneration != 0 {
            my_size += ::protobuf::rt::value_size(6, self.metageneration, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.time_deleted.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.content_type.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.content_type);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(9, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.time_created.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.crc32c.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.component_count != 0 {
            my_size += ::protobuf::rt::value_size(12, self.component_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.md5_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.md5_hash);
        }
        if !self.etag.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.etag);
        }
        if let Some(ref v) = self.updated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.storage_class.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.storage_class);
        }
        if !self.kms_key_name.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.kms_key_name);
        }
        if let Some(ref v) = self.time_storage_class_updated.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.temporary_hold != false {
            my_size += 3;
        }
        if let Some(ref v) = self.retention_expiration_time.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(21, &self.metadata);
        if let Some(ref v) = self.event_based_hold.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(23, &self.name);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(24, &self.id);
        }
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(25, &self.bucket);
        }
        if self.generation != 0 {
            my_size += ::protobuf::rt::value_size(26, self.generation, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.owner.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.customer_encryption.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.content_encoding.is_empty() {
            os.write_string(1, &self.content_encoding)?;
        }
        if !self.content_disposition.is_empty() {
            os.write_string(2, &self.content_disposition)?;
        }
        if !self.cache_control.is_empty() {
            os.write_string(3, &self.cache_control)?;
        }
        for v in &self.acl {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.content_language.is_empty() {
            os.write_string(5, &self.content_language)?;
        }
        if self.metageneration != 0 {
            os.write_int64(6, self.metageneration)?;
        }
        if let Some(ref v) = self.time_deleted.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.content_type.is_empty() {
            os.write_string(8, &self.content_type)?;
        }
        if self.size != 0 {
            os.write_int64(9, self.size)?;
        }
        if let Some(ref v) = self.time_created.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.crc32c.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.component_count != 0 {
            os.write_int32(12, self.component_count)?;
        }
        if !self.md5_hash.is_empty() {
            os.write_string(13, &self.md5_hash)?;
        }
        if !self.etag.is_empty() {
            os.write_string(14, &self.etag)?;
        }
        if let Some(ref v) = self.updated.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.storage_class.is_empty() {
            os.write_string(16, &self.storage_class)?;
        }
        if !self.kms_key_name.is_empty() {
            os.write_string(17, &self.kms_key_name)?;
        }
        if let Some(ref v) = self.time_storage_class_updated.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.temporary_hold != false {
            os.write_bool(19, self.temporary_hold)?;
        }
        if let Some(ref v) = self.retention_expiration_time.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(21, &self.metadata, os)?;
        if let Some(ref v) = self.event_based_hold.as_ref() {
            os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(23, &self.name)?;
        }
        if !self.id.is_empty() {
            os.write_string(24, &self.id)?;
        }
        if !self.bucket.is_empty() {
            os.write_string(25, &self.bucket)?;
        }
        if self.generation != 0 {
            os.write_int64(26, self.generation)?;
        }
        if let Some(ref v) = self.owner.as_ref() {
            os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.customer_encryption.as_ref() {
            os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Object {
        Object::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "content_encoding",
                |m: &Object| { &m.content_encoding },
                |m: &mut Object| { &mut m.content_encoding },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "content_disposition",
                |m: &Object| { &m.content_disposition },
                |m: &mut Object| { &mut m.content_disposition },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cache_control",
                |m: &Object| { &m.cache_control },
                |m: &mut Object| { &mut m.cache_control },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectAccessControl>>(
                "acl",
                |m: &Object| { &m.acl },
                |m: &mut Object| { &mut m.acl },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "content_language",
                |m: &Object| { &m.content_language },
                |m: &mut Object| { &mut m.content_language },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "metageneration",
                |m: &Object| { &m.metageneration },
                |m: &mut Object| { &mut m.metageneration },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "time_deleted",
                |m: &Object| { &m.time_deleted },
                |m: &mut Object| { &mut m.time_deleted },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "content_type",
                |m: &Object| { &m.content_type },
                |m: &mut Object| { &mut m.content_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "size",
                |m: &Object| { &m.size },
                |m: &mut Object| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "time_created",
                |m: &Object| { &m.time_created },
                |m: &mut Object| { &mut m.time_created },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "crc32c",
                |m: &Object| { &m.crc32c },
                |m: &mut Object| { &mut m.crc32c },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "component_count",
                |m: &Object| { &m.component_count },
                |m: &mut Object| { &mut m.component_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "md5_hash",
                |m: &Object| { &m.md5_hash },
                |m: &mut Object| { &mut m.md5_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "etag",
                |m: &Object| { &m.etag },
                |m: &mut Object| { &mut m.etag },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "updated",
                |m: &Object| { &m.updated },
                |m: &mut Object| { &mut m.updated },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "storage_class",
                |m: &Object| { &m.storage_class },
                |m: &mut Object| { &mut m.storage_class },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kms_key_name",
                |m: &Object| { &m.kms_key_name },
                |m: &mut Object| { &mut m.kms_key_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "time_storage_class_updated",
                |m: &Object| { &m.time_storage_class_updated },
                |m: &mut Object| { &mut m.time_storage_class_updated },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "temporary_hold",
                |m: &Object| { &m.temporary_hold },
                |m: &mut Object| { &mut m.temporary_hold },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "retention_expiration_time",
                |m: &Object| { &m.retention_expiration_time },
                |m: &mut Object| { &mut m.retention_expiration_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "metadata",
                |m: &Object| { &m.metadata },
                |m: &mut Object| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "event_based_hold",
                |m: &Object| { &m.event_based_hold },
                |m: &mut Object| { &mut m.event_based_hold },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Object| { &m.name },
                |m: &mut Object| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Object| { &m.id },
                |m: &mut Object| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &Object| { &m.bucket },
                |m: &mut Object| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "generation",
                |m: &Object| { &m.generation },
                |m: &mut Object| { &mut m.generation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Owner>>(
                "owner",
                |m: &Object| { &m.owner },
                |m: &mut Object| { &mut m.owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Object_CustomerEncryption>>(
                "customer_encryption",
                |m: &Object| { &m.customer_encryption },
                |m: &mut Object| { &mut m.customer_encryption },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Object>(
                "Object",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Object {
        static instance: ::protobuf::rt::LazyV2<Object> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Object::new)
    }
}

impl ::protobuf::Clear for Object {
    fn clear(&mut self) {
        self.content_encoding.clear();
        self.content_disposition.clear();
        self.cache_control.clear();
        self.acl.clear();
        self.content_language.clear();
        self.metageneration = 0;
        self.time_deleted.clear();
        self.content_type.clear();
        self.size = 0;
        self.time_created.clear();
        self.crc32c.clear();
        self.component_count = 0;
        self.md5_hash.clear();
        self.etag.clear();
        self.updated.clear();
        self.storage_class.clear();
        self.kms_key_name.clear();
        self.time_storage_class_updated.clear();
        self.temporary_hold = false;
        self.retention_expiration_time.clear();
        self.metadata.clear();
        self.event_based_hold.clear();
        self.name.clear();
        self.id.clear();
        self.bucket.clear();
        self.generation = 0;
        self.owner.clear();
        self.customer_encryption.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Object {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Object {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Object_CustomerEncryption {
    // message fields
    pub encryption_algorithm: ::std::string::String,
    pub key_sha256: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Object_CustomerEncryption {
    fn default() -> &'a Object_CustomerEncryption {
        <Object_CustomerEncryption as ::protobuf::Message>::default_instance()
    }
}

impl Object_CustomerEncryption {
    pub fn new() -> Object_CustomerEncryption {
        ::std::default::Default::default()
    }

    // string encryption_algorithm = 1;


    pub fn get_encryption_algorithm(&self) -> &str {
        &self.encryption_algorithm
    }
    pub fn clear_encryption_algorithm(&mut self) {
        self.encryption_algorithm.clear();
    }

    // Param is passed by value, moved
    pub fn set_encryption_algorithm(&mut self, v: ::std::string::String) {
        self.encryption_algorithm = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_algorithm(&mut self) -> &mut ::std::string::String {
        &mut self.encryption_algorithm
    }

    // Take field
    pub fn take_encryption_algorithm(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.encryption_algorithm, ::std::string::String::new())
    }

    // string key_sha256 = 2;


    pub fn get_key_sha256(&self) -> &str {
        &self.key_sha256
    }
    pub fn clear_key_sha256(&mut self) {
        self.key_sha256.clear();
    }

    // Param is passed by value, moved
    pub fn set_key_sha256(&mut self, v: ::std::string::String) {
        self.key_sha256 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_sha256(&mut self) -> &mut ::std::string::String {
        &mut self.key_sha256
    }

    // Take field
    pub fn take_key_sha256(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key_sha256, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Object_CustomerEncryption {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.encryption_algorithm)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key_sha256)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.encryption_algorithm.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.encryption_algorithm);
        }
        if !self.key_sha256.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key_sha256);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.encryption_algorithm.is_empty() {
            os.write_string(1, &self.encryption_algorithm)?;
        }
        if !self.key_sha256.is_empty() {
            os.write_string(2, &self.key_sha256)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Object_CustomerEncryption {
        Object_CustomerEncryption::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "encryption_algorithm",
                |m: &Object_CustomerEncryption| { &m.encryption_algorithm },
                |m: &mut Object_CustomerEncryption| { &mut m.encryption_algorithm },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key_sha256",
                |m: &Object_CustomerEncryption| { &m.key_sha256 },
                |m: &mut Object_CustomerEncryption| { &mut m.key_sha256 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Object_CustomerEncryption>(
                "Object.CustomerEncryption",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Object_CustomerEncryption {
        static instance: ::protobuf::rt::LazyV2<Object_CustomerEncryption> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Object_CustomerEncryption::new)
    }
}

impl ::protobuf::Clear for Object_CustomerEncryption {
    fn clear(&mut self) {
        self.encryption_algorithm.clear();
        self.key_sha256.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Object_CustomerEncryption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Object_CustomerEncryption {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ObjectAccessControl {
    // message fields
    pub role: ::std::string::String,
    pub etag: ::std::string::String,
    pub id: ::std::string::String,
    pub bucket: ::std::string::String,
    pub object: ::std::string::String,
    pub generation: i64,
    pub entity: ::std::string::String,
    pub entity_id: ::std::string::String,
    pub email: ::std::string::String,
    pub domain: ::std::string::String,
    pub project_team: ::protobuf::SingularPtrField<ProjectTeam>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ObjectAccessControl {
    fn default() -> &'a ObjectAccessControl {
        <ObjectAccessControl as ::protobuf::Message>::default_instance()
    }
}

impl ObjectAccessControl {
    pub fn new() -> ObjectAccessControl {
        ::std::default::Default::default()
    }

    // string role = 1;


    pub fn get_role(&self) -> &str {
        &self.role
    }
    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: ::std::string::String) {
        self.role = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role(&mut self) -> &mut ::std::string::String {
        &mut self.role
    }

    // Take field
    pub fn take_role(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.role, ::std::string::String::new())
    }

    // string etag = 2;


    pub fn get_etag(&self) -> &str {
        &self.etag
    }
    pub fn clear_etag(&mut self) {
        self.etag.clear();
    }

    // Param is passed by value, moved
    pub fn set_etag(&mut self, v: ::std::string::String) {
        self.etag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_etag(&mut self) -> &mut ::std::string::String {
        &mut self.etag
    }

    // Take field
    pub fn take_etag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.etag, ::std::string::String::new())
    }

    // string id = 3;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string bucket = 4;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string object = 5;


    pub fn get_object(&self) -> &str {
        &self.object
    }
    pub fn clear_object(&mut self) {
        self.object.clear();
    }

    // Param is passed by value, moved
    pub fn set_object(&mut self, v: ::std::string::String) {
        self.object = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object(&mut self) -> &mut ::std::string::String {
        &mut self.object
    }

    // Take field
    pub fn take_object(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object, ::std::string::String::new())
    }

    // int64 generation = 6;


    pub fn get_generation(&self) -> i64 {
        self.generation
    }
    pub fn clear_generation(&mut self) {
        self.generation = 0;
    }

    // Param is passed by value, moved
    pub fn set_generation(&mut self, v: i64) {
        self.generation = v;
    }

    // string entity = 7;


    pub fn get_entity(&self) -> &str {
        &self.entity
    }
    pub fn clear_entity(&mut self) {
        self.entity.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: ::std::string::String) {
        self.entity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity(&mut self) -> &mut ::std::string::String {
        &mut self.entity
    }

    // Take field
    pub fn take_entity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity, ::std::string::String::new())
    }

    // string entity_id = 8;


    pub fn get_entity_id(&self) -> &str {
        &self.entity_id
    }
    pub fn clear_entity_id(&mut self) {
        self.entity_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity_id(&mut self, v: ::std::string::String) {
        self.entity_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_id(&mut self) -> &mut ::std::string::String {
        &mut self.entity_id
    }

    // Take field
    pub fn take_entity_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity_id, ::std::string::String::new())
    }

    // string email = 9;


    pub fn get_email(&self) -> &str {
        &self.email
    }
    pub fn clear_email(&mut self) {
        self.email.clear();
    }

    // Param is passed by value, moved
    pub fn set_email(&mut self, v: ::std::string::String) {
        self.email = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email(&mut self) -> &mut ::std::string::String {
        &mut self.email
    }

    // Take field
    pub fn take_email(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.email, ::std::string::String::new())
    }

    // string domain = 10;


    pub fn get_domain(&self) -> &str {
        &self.domain
    }
    pub fn clear_domain(&mut self) {
        self.domain.clear();
    }

    // Param is passed by value, moved
    pub fn set_domain(&mut self, v: ::std::string::String) {
        self.domain = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain(&mut self) -> &mut ::std::string::String {
        &mut self.domain
    }

    // Take field
    pub fn take_domain(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.domain, ::std::string::String::new())
    }

    // .google.storage.v1.ProjectTeam project_team = 11;


    pub fn get_project_team(&self) -> &ProjectTeam {
        self.project_team.as_ref().unwrap_or_else(|| <ProjectTeam as ::protobuf::Message>::default_instance())
    }
    pub fn clear_project_team(&mut self) {
        self.project_team.clear();
    }

    pub fn has_project_team(&self) -> bool {
        self.project_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_project_team(&mut self, v: ProjectTeam) {
        self.project_team = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_team(&mut self) -> &mut ProjectTeam {
        if self.project_team.is_none() {
            self.project_team.set_default();
        }
        self.project_team.as_mut().unwrap()
    }

    // Take field
    pub fn take_project_team(&mut self) -> ProjectTeam {
        self.project_team.take().unwrap_or_else(|| ProjectTeam::new())
    }
}

impl ::protobuf::Message for ObjectAccessControl {
    fn is_initialized(&self) -> bool {
        for v in &self.project_team {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.role)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.etag)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.generation = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entity)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entity_id)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.email)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.domain)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.project_team)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.role.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.role);
        }
        if !self.etag.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.etag);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.id);
        }
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.bucket);
        }
        if !self.object.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.object);
        }
        if self.generation != 0 {
            my_size += ::protobuf::rt::value_size(6, self.generation, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.entity.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.entity);
        }
        if !self.entity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.entity_id);
        }
        if !self.email.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.email);
        }
        if !self.domain.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.domain);
        }
        if let Some(ref v) = self.project_team.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.role.is_empty() {
            os.write_string(1, &self.role)?;
        }
        if !self.etag.is_empty() {
            os.write_string(2, &self.etag)?;
        }
        if !self.id.is_empty() {
            os.write_string(3, &self.id)?;
        }
        if !self.bucket.is_empty() {
            os.write_string(4, &self.bucket)?;
        }
        if !self.object.is_empty() {
            os.write_string(5, &self.object)?;
        }
        if self.generation != 0 {
            os.write_int64(6, self.generation)?;
        }
        if !self.entity.is_empty() {
            os.write_string(7, &self.entity)?;
        }
        if !self.entity_id.is_empty() {
            os.write_string(8, &self.entity_id)?;
        }
        if !self.email.is_empty() {
            os.write_string(9, &self.email)?;
        }
        if !self.domain.is_empty() {
            os.write_string(10, &self.domain)?;
        }
        if let Some(ref v) = self.project_team.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ObjectAccessControl {
        ObjectAccessControl::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "role",
                |m: &ObjectAccessControl| { &m.role },
                |m: &mut ObjectAccessControl| { &mut m.role },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "etag",
                |m: &ObjectAccessControl| { &m.etag },
                |m: &mut ObjectAccessControl| { &mut m.etag },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &ObjectAccessControl| { &m.id },
                |m: &mut ObjectAccessControl| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &ObjectAccessControl| { &m.bucket },
                |m: &mut ObjectAccessControl| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object",
                |m: &ObjectAccessControl| { &m.object },
                |m: &mut ObjectAccessControl| { &mut m.object },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "generation",
                |m: &ObjectAccessControl| { &m.generation },
                |m: &mut ObjectAccessControl| { &mut m.generation },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entity",
                |m: &ObjectAccessControl| { &m.entity },
                |m: &mut ObjectAccessControl| { &mut m.entity },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entity_id",
                |m: &ObjectAccessControl| { &m.entity_id },
                |m: &mut ObjectAccessControl| { &mut m.entity_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "email",
                |m: &ObjectAccessControl| { &m.email },
                |m: &mut ObjectAccessControl| { &mut m.email },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "domain",
                |m: &ObjectAccessControl| { &m.domain },
                |m: &mut ObjectAccessControl| { &mut m.domain },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProjectTeam>>(
                "project_team",
                |m: &ObjectAccessControl| { &m.project_team },
                |m: &mut ObjectAccessControl| { &mut m.project_team },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ObjectAccessControl>(
                "ObjectAccessControl",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ObjectAccessControl {
        static instance: ::protobuf::rt::LazyV2<ObjectAccessControl> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ObjectAccessControl::new)
    }
}

impl ::protobuf::Clear for ObjectAccessControl {
    fn clear(&mut self) {
        self.role.clear();
        self.etag.clear();
        self.id.clear();
        self.bucket.clear();
        self.object.clear();
        self.generation = 0;
        self.entity.clear();
        self.entity_id.clear();
        self.email.clear();
        self.domain.clear();
        self.project_team.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ObjectAccessControl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObjectAccessControl {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListObjectAccessControlsResponse {
    // message fields
    pub items: ::protobuf::RepeatedField<ObjectAccessControl>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListObjectAccessControlsResponse {
    fn default() -> &'a ListObjectAccessControlsResponse {
        <ListObjectAccessControlsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListObjectAccessControlsResponse {
    pub fn new() -> ListObjectAccessControlsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.storage.v1.ObjectAccessControl items = 1;


    pub fn get_items(&self) -> &[ObjectAccessControl] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<ObjectAccessControl>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<ObjectAccessControl> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<ObjectAccessControl> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListObjectAccessControlsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListObjectAccessControlsResponse {
        ListObjectAccessControlsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectAccessControl>>(
                "items",
                |m: &ListObjectAccessControlsResponse| { &m.items },
                |m: &mut ListObjectAccessControlsResponse| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListObjectAccessControlsResponse>(
                "ListObjectAccessControlsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListObjectAccessControlsResponse {
        static instance: ::protobuf::rt::LazyV2<ListObjectAccessControlsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListObjectAccessControlsResponse::new)
    }
}

impl ::protobuf::Clear for ListObjectAccessControlsResponse {
    fn clear(&mut self) {
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListObjectAccessControlsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListObjectAccessControlsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListObjectsResponse {
    // message fields
    pub prefixes: ::protobuf::RepeatedField<::std::string::String>,
    pub items: ::protobuf::RepeatedField<Object>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListObjectsResponse {
    fn default() -> &'a ListObjectsResponse {
        <ListObjectsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListObjectsResponse {
    pub fn new() -> ListObjectsResponse {
        ::std::default::Default::default()
    }

    // repeated string prefixes = 1;


    pub fn get_prefixes(&self) -> &[::std::string::String] {
        &self.prefixes
    }
    pub fn clear_prefixes(&mut self) {
        self.prefixes.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefixes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.prefixes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_prefixes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.prefixes
    }

    // Take field
    pub fn take_prefixes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.prefixes, ::protobuf::RepeatedField::new())
    }

    // repeated .google.storage.v1.Object items = 2;


    pub fn get_items(&self) -> &[Object] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<Object>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<Object> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<Object> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 3;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListObjectsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.prefixes)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.prefixes {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.prefixes {
            os.write_string(1, &v)?;
        };
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(3, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListObjectsResponse {
        ListObjectsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "prefixes",
                |m: &ListObjectsResponse| { &m.prefixes },
                |m: &mut ListObjectsResponse| { &mut m.prefixes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Object>>(
                "items",
                |m: &ListObjectsResponse| { &m.items },
                |m: &mut ListObjectsResponse| { &mut m.items },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListObjectsResponse| { &m.next_page_token },
                |m: &mut ListObjectsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListObjectsResponse>(
                "ListObjectsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListObjectsResponse {
        static instance: ::protobuf::rt::LazyV2<ListObjectsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListObjectsResponse::new)
    }
}

impl ::protobuf::Clear for ListObjectsResponse {
    fn clear(&mut self) {
        self.prefixes.clear();
        self.items.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListObjectsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListObjectsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProjectTeam {
    // message fields
    pub project_number: ::std::string::String,
    pub team: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProjectTeam {
    fn default() -> &'a ProjectTeam {
        <ProjectTeam as ::protobuf::Message>::default_instance()
    }
}

impl ProjectTeam {
    pub fn new() -> ProjectTeam {
        ::std::default::Default::default()
    }

    // string project_number = 1;


    pub fn get_project_number(&self) -> &str {
        &self.project_number
    }
    pub fn clear_project_number(&mut self) {
        self.project_number.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_number(&mut self, v: ::std::string::String) {
        self.project_number = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_number(&mut self) -> &mut ::std::string::String {
        &mut self.project_number
    }

    // Take field
    pub fn take_project_number(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_number, ::std::string::String::new())
    }

    // string team = 2;


    pub fn get_team(&self) -> &str {
        &self.team
    }
    pub fn clear_team(&mut self) {
        self.team.clear();
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: ::std::string::String) {
        self.team = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team(&mut self) -> &mut ::std::string::String {
        &mut self.team
    }

    // Take field
    pub fn take_team(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.team, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ProjectTeam {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_number)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.team)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_number.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_number);
        }
        if !self.team.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.team);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_number.is_empty() {
            os.write_string(1, &self.project_number)?;
        }
        if !self.team.is_empty() {
            os.write_string(2, &self.team)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProjectTeam {
        ProjectTeam::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_number",
                |m: &ProjectTeam| { &m.project_number },
                |m: &mut ProjectTeam| { &mut m.project_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "team",
                |m: &ProjectTeam| { &m.team },
                |m: &mut ProjectTeam| { &mut m.team },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProjectTeam>(
                "ProjectTeam",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProjectTeam {
        static instance: ::protobuf::rt::LazyV2<ProjectTeam> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProjectTeam::new)
    }
}

impl ::protobuf::Clear for ProjectTeam {
    fn clear(&mut self) {
        self.project_number.clear();
        self.team.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProjectTeam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProjectTeam {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServiceAccount {
    // message fields
    pub email_address: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServiceAccount {
    fn default() -> &'a ServiceAccount {
        <ServiceAccount as ::protobuf::Message>::default_instance()
    }
}

impl ServiceAccount {
    pub fn new() -> ServiceAccount {
        ::std::default::Default::default()
    }

    // string email_address = 1;


    pub fn get_email_address(&self) -> &str {
        &self.email_address
    }
    pub fn clear_email_address(&mut self) {
        self.email_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_email_address(&mut self, v: ::std::string::String) {
        self.email_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email_address(&mut self) -> &mut ::std::string::String {
        &mut self.email_address
    }

    // Take field
    pub fn take_email_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.email_address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ServiceAccount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.email_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.email_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.email_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.email_address.is_empty() {
            os.write_string(1, &self.email_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServiceAccount {
        ServiceAccount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "email_address",
                |m: &ServiceAccount| { &m.email_address },
                |m: &mut ServiceAccount| { &mut m.email_address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServiceAccount>(
                "ServiceAccount",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServiceAccount {
        static instance: ::protobuf::rt::LazyV2<ServiceAccount> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServiceAccount::new)
    }
}

impl ::protobuf::Clear for ServiceAccount {
    fn clear(&mut self) {
        self.email_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServiceAccount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceAccount {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Owner {
    // message fields
    pub entity: ::std::string::String,
    pub entity_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Owner {
    fn default() -> &'a Owner {
        <Owner as ::protobuf::Message>::default_instance()
    }
}

impl Owner {
    pub fn new() -> Owner {
        ::std::default::Default::default()
    }

    // string entity = 1;


    pub fn get_entity(&self) -> &str {
        &self.entity
    }
    pub fn clear_entity(&mut self) {
        self.entity.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: ::std::string::String) {
        self.entity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity(&mut self) -> &mut ::std::string::String {
        &mut self.entity
    }

    // Take field
    pub fn take_entity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity, ::std::string::String::new())
    }

    // string entity_id = 2;


    pub fn get_entity_id(&self) -> &str {
        &self.entity_id
    }
    pub fn clear_entity_id(&mut self) {
        self.entity_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity_id(&mut self, v: ::std::string::String) {
        self.entity_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_id(&mut self) -> &mut ::std::string::String {
        &mut self.entity_id
    }

    // Take field
    pub fn take_entity_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Owner {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entity)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entity_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.entity.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.entity);
        }
        if !self.entity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.entity_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.entity.is_empty() {
            os.write_string(1, &self.entity)?;
        }
        if !self.entity_id.is_empty() {
            os.write_string(2, &self.entity_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Owner {
        Owner::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entity",
                |m: &Owner| { &m.entity },
                |m: &mut Owner| { &mut m.entity },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entity_id",
                |m: &Owner| { &m.entity_id },
                |m: &mut Owner| { &mut m.entity_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Owner>(
                "Owner",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Owner {
        static instance: ::protobuf::rt::LazyV2<Owner> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Owner::new)
    }
}

impl ::protobuf::Clear for Owner {
    fn clear(&mut self) {
        self.entity.clear();
        self.entity_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Owner {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Owner {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n)google/storage/v1/storage_resources.proto\x12\x11google.storage.v1\
    \x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1egoogle/protobuf/wrappers.\
    proto\"\xc1\x16\n\x06Bucket\x128\n\x03acl\x18\x01\x20\x03(\x0b2&.google.\
    storage.v1.BucketAccessControlR\x03acl\x12T\n\x12default_object_acl\x18\
    \x02\x20\x03(\x0b2&.google.storage.v1.ObjectAccessControlR\x10defaultObj\
    ectAcl\x12A\n\tlifecycle\x18\x03\x20\x01(\x0b2#.google.storage.v1.Bucket\
    .LifecycleR\tlifecycle\x12=\n\x0ctime_created\x18\x04\x20\x01(\x0b2\x1a.\
    google.protobuf.TimestampR\x0btimeCreated\x12\x0e\n\x02id\x18\x05\x20\
    \x01(\tR\x02id\x12\x12\n\x04name\x18\x06\x20\x01(\tR\x04name\x12%\n\x0ep\
    roject_number\x18\x07\x20\x01(\x03R\rprojectNumber\x12&\n\x0emetagenerat\
    ion\x18\x08\x20\x01(\x03R\x0emetageneration\x122\n\x04cors\x18\t\x20\x03\
    (\x0b2\x1e.google.storage.v1.Bucket.CorsR\x04cors\x12\x1a\n\x08location\
    \x18\n\x20\x01(\tR\x08location\x12#\n\rstorage_class\x18\x0b\x20\x01(\tR\
    \x0cstorageClass\x12\x12\n\x04etag\x18\x0c\x20\x01(\tR\x04etag\x124\n\
    \x07updated\x18\r\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x07update\
    d\x127\n\x18default_event_based_hold\x18\x0e\x20\x01(\x08R\x15defaultEve\
    ntBasedHold\x12=\n\x06labels\x18\x0f\x20\x03(\x0b2%.google.storage.v1.Bu\
    cket.LabelsEntryR\x06labels\x12;\n\x07website\x18\x10\x20\x01(\x0b2!.goo\
    gle.storage.v1.Bucket.WebsiteR\x07website\x12D\n\nversioning\x18\x11\x20\
    \x01(\x0b2$.google.storage.v1.Bucket.VersioningR\nversioning\x12;\n\x07l\
    ogging\x18\x12\x20\x01(\x0b2!.google.storage.v1.Bucket.LoggingR\x07loggi\
    ng\x12.\n\x05owner\x18\x13\x20\x01(\x0b2\x18.google.storage.v1.OwnerR\
    \x05owner\x12D\n\nencryption\x18\x14\x20\x01(\x0b2$.google.storage.v1.Bu\
    cket.EncryptionR\nencryption\x12;\n\x07billing\x18\x15\x20\x01(\x0b2!.go\
    ogle.storage.v1.Bucket.BillingR\x07billing\x12T\n\x10retention_policy\
    \x18\x16\x20\x01(\x0b2).google.storage.v1.Bucket.RetentionPolicyR\x0fret\
    entionPolicy\x12#\n\rlocation_type\x18\x17\x20\x01(\tR\x0clocationType\
    \x12W\n\x11iam_configuration\x18\x18\x20\x01(\x0b2*.google.storage.v1.Bu\
    cket.IamConfigurationR\x10iamConfiguration\x12#\n\rzone_affinity\x18\x19\
    \x20\x03(\tR\x0czoneAffinity\x1a0\n\x07Billing\x12%\n\x0erequester_pays\
    \x18\x01\x20\x01(\x08R\rrequesterPays\x1a\x87\x01\n\x04Cors\x12\x16\n\
    \x06origin\x18\x01\x20\x03(\tR\x06origin\x12\x16\n\x06method\x18\x02\x20\
    \x03(\tR\x06method\x12'\n\x0fresponse_header\x18\x03\x20\x03(\tR\x0eresp\
    onseHeader\x12&\n\x0fmax_age_seconds\x18\x04\x20\x01(\x05R\rmaxAgeSecond\
    s\x1a=\n\nEncryption\x12/\n\x14default_kms_key_name\x18\x01\x20\x01(\tR\
    \x11defaultKmsKeyName\x1a\x8a\x02\n\x10IamConfiguration\x12\x82\x01\n\
    \x1buniform_bucket_level_access\x18\x01\x20\x01(\x0b2C.google.storage.v1\
    .Bucket.IamConfiguration.UniformBucketLevelAccessR\x18uniformBucketLevel\
    Access\x1aq\n\x18UniformBucketLevelAccess\x12\x18\n\x07enabled\x18\x01\
    \x20\x01(\x08R\x07enabled\x12;\n\x0blocked_time\x18\x02\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\nlockedTime\x1a\xd3\x04\n\tLifecycle\x12\
    <\n\x04rule\x18\x01\x20\x03(\x0b2(.google.storage.v1.Bucket.Lifecycle.Ru\
    leR\x04rule\x1a\x87\x04\n\x04Rule\x12G\n\x06action\x18\x01\x20\x01(\x0b2\
    /.google.storage.v1.Bucket.Lifecycle.Rule.ActionR\x06action\x12P\n\tcond\
    ition\x18\x02\x20\x01(\x0b22.google.storage.v1.Bucket.Lifecycle.Rule.Con\
    ditionR\tcondition\x1aA\n\x06Action\x12\x12\n\x04type\x18\x01\x20\x01(\t\
    R\x04type\x12#\n\rstorage_class\x18\x02\x20\x01(\tR\x0cstorageClass\x1a\
    \xa0\x02\n\tCondition\x12\x10\n\x03age\x18\x01\x20\x01(\x05R\x03age\x12A\
    \n\x0ecreated_before\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.Timestamp\
    R\rcreatedBefore\x123\n\x07is_live\x18\x03\x20\x01(\x0b2\x1a.google.prot\
    obuf.BoolValueR\x06isLive\x12,\n\x12num_newer_versions\x18\x04\x20\x01(\
    \x05R\x10numNewerVersions\x122\n\x15matches_storage_class\x18\x05\x20\
    \x03(\tR\x13matchesStorageClass\x12'\n\x0fmatches_pattern\x18\x06\x20\
    \x01(\tR\x0ematchesPattern\x1aT\n\x07Logging\x12\x1d\n\nlog_bucket\x18\
    \x01\x20\x01(\tR\tlogBucket\x12*\n\x11log_object_prefix\x18\x02\x20\x01(\
    \tR\x0flogObjectPrefix\x1a\x9c\x01\n\x0fRetentionPolicy\x12A\n\x0eeffect\
    ive_time\x18\x01\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\reffective\
    Time\x12\x1b\n\tis_locked\x18\x02\x20\x01(\x08R\x08isLocked\x12)\n\x10re\
    tention_period\x18\x03\x20\x01(\x03R\x0fretentionPeriod\x1a&\n\nVersioni\
    ng\x12\x18\n\x07enabled\x18\x01\x20\x01(\x08R\x07enabled\x1aY\n\x07Websi\
    te\x12(\n\x10main_page_suffix\x18\x01\x20\x01(\tR\x0emainPageSuffix\x12$\
    \n\x0enot_found_page\x18\x02\x20\x01(\tR\x0cnotFoundPage\x1a9\n\x0bLabel\
    sEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\tR\x05value:\x028\x01\"\x8b\x02\n\x13BucketAccessContr\
    ol\x12\x12\n\x04role\x18\x01\x20\x01(\tR\x04role\x12\x12\n\x04etag\x18\
    \x02\x20\x01(\tR\x04etag\x12\x0e\n\x02id\x18\x03\x20\x01(\tR\x02id\x12\
    \x16\n\x06bucket\x18\x04\x20\x01(\tR\x06bucket\x12\x16\n\x06entity\x18\
    \x06\x20\x01(\tR\x06entity\x12\x1b\n\tentity_id\x18\x07\x20\x01(\tR\x08e\
    ntityId\x12\x14\n\x05email\x18\x08\x20\x01(\tR\x05email\x12\x16\n\x06dom\
    ain\x18\t\x20\x01(\tR\x06domain\x12A\n\x0cproject_team\x18\n\x20\x01(\
    \x0b2\x1e.google.storage.v1.ProjectTeamR\x0bprojectTeam\"`\n\x20ListBuck\
    etAccessControlsResponse\x12<\n\x05items\x18\x01\x20\x03(\x0b2&.google.s\
    torage.v1.BucketAccessControlR\x05items\"n\n\x13ListBucketsResponse\x12/\
    \n\x05items\x18\x01\x20\x03(\x0b2\x19.google.storage.v1.BucketR\x05items\
    \x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageToken\"\xf2\x02\
    \n\x07Channel\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x1f\n\x0bres\
    ource_id\x18\x02\x20\x01(\tR\nresourceId\x12!\n\x0cresource_uri\x18\x03\
    \x20\x01(\tR\x0bresourceUri\x12\x14\n\x05token\x18\x04\x20\x01(\tR\x05to\
    ken\x12:\n\nexpiration\x18\x05\x20\x01(\x0b2\x1a.google.protobuf.Timesta\
    mpR\nexpiration\x12\x12\n\x04type\x18\x06\x20\x01(\tR\x04type\x12\x18\n\
    \x07address\x18\x07\x20\x01(\tR\x07address\x12>\n\x06params\x18\x08\x20\
    \x03(\x0b2&.google.storage.v1.Channel.ParamsEntryR\x06params\x12\x18\n\
    \x07payload\x18\t\x20\x01(\x08R\x07payload\x1a9\n\x0bParamsEntry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \tR\x05value:\x028\x01\"\xac\x02\n\x14ListChannelsResponse\x12C\n\x05ite\
    ms\x18\x01\x20\x03(\x0b2-.google.storage.v1.ListChannelsResponse.ItemsR\
    \x05items\x1a\xce\x01\n\x05Items\x12\x1d\n\nchannel_id\x18\x01\x20\x01(\
    \tR\tchannelId\x12\x1f\n\x0bresource_id\x18\x02\x20\x01(\tR\nresourceId\
    \x12\x19\n\x08push_url\x18\x03\x20\x01(\tR\x07pushUrl\x12)\n\x10subscrib\
    er_email\x18\x04\x20\x01(\tR\x0fsubscriberEmail\x12?\n\rcreation_time\
    \x18\x05\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x0ccreationTime\"a\
    \n\x0fChecksummedData\x12\x18\n\x07content\x18\x01\x20\x01(\x0cR\x07cont\
    ent\x124\n\x06crc32c\x18\x02\x20\x01(\x0b2\x1c.google.protobuf.UInt32Val\
    ueR\x06crc32c\"b\n\x0fObjectChecksums\x124\n\x06crc32c\x18\x01\x20\x01(\
    \x0b2\x1c.google.protobuf.UInt32ValueR\x06crc32c\x12\x19\n\x08md5_hash\
    \x18\x02\x20\x01(\tR\x07md5Hash\"\xa7\x04\n\x0bCommonEnums\">\n\nProject\
    ion\x12\x1a\n\x16PROJECTION_UNSPECIFIED\x10\0\x12\n\n\x06NO_ACL\x10\x01\
    \x12\x08\n\x04FULL\x10\x02\"\xd5\x01\n\x13PredefinedBucketAcl\x12%\n!PRE\
    DEFINED_BUCKET_ACL_UNSPECIFIED\x10\0\x12!\n\x1dBUCKET_ACL_AUTHENTICATED_\
    READ\x10\x01\x12\x16\n\x12BUCKET_ACL_PRIVATE\x10\x02\x12\x1e\n\x1aBUCKET\
    _ACL_PROJECT_PRIVATE\x10\x03\x12\x1a\n\x16BUCKET_ACL_PUBLIC_READ\x10\x04\
    \x12\x20\n\x1cBUCKET_ACL_PUBLIC_READ_WRITE\x10\x05\"\xff\x01\n\x13Predef\
    inedObjectAcl\x12%\n!PREDEFINED_OBJECT_ACL_UNSPECIFIED\x10\0\x12!\n\x1dO\
    BJECT_ACL_AUTHENTICATED_READ\x10\x01\x12(\n$OBJECT_ACL_BUCKET_OWNER_FULL\
    _CONTROL\x10\x02\x12\x20\n\x1cOBJECT_ACL_BUCKET_OWNER_READ\x10\x03\x12\
    \x16\n\x12OBJECT_ACL_PRIVATE\x10\x04\x12\x1e\n\x1aOBJECT_ACL_PROJECT_PRI\
    VATE\x10\x05\x12\x1a\n\x16OBJECT_ACL_PUBLIC_READ\x10\x06\"_\n\x0cContent\
    Range\x12\x14\n\x05start\x18\x01\x20\x01(\x03R\x05start\x12\x10\n\x03end\
    \x18\x02\x20\x01(\x03R\x03end\x12'\n\x0fcomplete_length\x18\x03\x20\x01(\
    \x03R\x0ecompleteLength\"\xb0\x02\n\x0fHmacKeyMetadata\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\tR\x02id\x12\x1b\n\taccess_id\x18\x02\x20\x01(\tR\x08a\
    ccessId\x12\x1d\n\nproject_id\x18\x03\x20\x01(\tR\tprojectId\x122\n\x15s\
    ervice_account_email\x18\x04\x20\x01(\tR\x13serviceAccountEmail\x12\x14\
    \n\x05state\x18\x05\x20\x01(\tR\x05state\x12=\n\x0ctime_created\x18\x06\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x0btimeCreated\x124\n\x07u\
    pdated\x18\x07\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x07updated\
    \x12\x12\n\x04etag\x18\x08\x20\x01(\tR\x04etag\"\xe7\x02\n\x0cNotificati\
    on\x12\x14\n\x05topic\x18\x01\x20\x01(\tR\x05topic\x12\x1f\n\x0bevent_ty\
    pes\x18\x02\x20\x03(\tR\neventTypes\x12b\n\x11custom_attributes\x18\x03\
    \x20\x03(\x0b25.google.storage.v1.Notification.CustomAttributesEntryR\
    \x10customAttributes\x12\x12\n\x04etag\x18\x04\x20\x01(\tR\x04etag\x12,\
    \n\x12object_name_prefix\x18\x05\x20\x01(\tR\x10objectNamePrefix\x12%\n\
    \x0epayload_format\x18\x06\x20\x01(\tR\rpayloadFormat\x12\x0e\n\x02id\
    \x18\x07\x20\x01(\tR\x02id\x1aC\n\x15CustomAttributesEntry\x12\x10\n\x03\
    key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\
    \x05value:\x028\x01\"R\n\x19ListNotificationsResponse\x125\n\x05items\
    \x18\x01\x20\x03(\x0b2\x1f.google.storage.v1.NotificationR\x05items\"\
    \xc9\x0b\n\x06Object\x12)\n\x10content_encoding\x18\x01\x20\x01(\tR\x0fc\
    ontentEncoding\x12/\n\x13content_disposition\x18\x02\x20\x01(\tR\x12cont\
    entDisposition\x12#\n\rcache_control\x18\x03\x20\x01(\tR\x0ccacheControl\
    \x128\n\x03acl\x18\x04\x20\x03(\x0b2&.google.storage.v1.ObjectAccessCont\
    rolR\x03acl\x12)\n\x10content_language\x18\x05\x20\x01(\tR\x0fcontentLan\
    guage\x12&\n\x0emetageneration\x18\x06\x20\x01(\x03R\x0emetageneration\
    \x12=\n\x0ctime_deleted\x18\x07\x20\x01(\x0b2\x1a.google.protobuf.Timest\
    ampR\x0btimeDeleted\x12!\n\x0ccontent_type\x18\x08\x20\x01(\tR\x0bconten\
    tType\x12\x12\n\x04size\x18\t\x20\x01(\x03R\x04size\x12=\n\x0ctime_creat\
    ed\x18\n\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x0btimeCreated\x12\
    4\n\x06crc32c\x18\x0b\x20\x01(\x0b2\x1c.google.protobuf.UInt32ValueR\x06\
    crc32c\x12'\n\x0fcomponent_count\x18\x0c\x20\x01(\x05R\x0ecomponentCount\
    \x12\x19\n\x08md5_hash\x18\r\x20\x01(\tR\x07md5Hash\x12\x12\n\x04etag\
    \x18\x0e\x20\x01(\tR\x04etag\x124\n\x07updated\x18\x0f\x20\x01(\x0b2\x1a\
    .google.protobuf.TimestampR\x07updated\x12#\n\rstorage_class\x18\x10\x20\
    \x01(\tR\x0cstorageClass\x12\x20\n\x0ckms_key_name\x18\x11\x20\x01(\tR\n\
    kmsKeyName\x12W\n\x1atime_storage_class_updated\x18\x12\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\x17timeStorageClassUpdated\x12%\n\x0etem\
    porary_hold\x18\x13\x20\x01(\x08R\rtemporaryHold\x12V\n\x19retention_exp\
    iration_time\x18\x14\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x17ret\
    entionExpirationTime\x12C\n\x08metadata\x18\x15\x20\x03(\x0b2'.google.st\
    orage.v1.Object.MetadataEntryR\x08metadata\x12D\n\x10event_based_hold\
    \x18\x1d\x20\x01(\x0b2\x1a.google.protobuf.BoolValueR\x0eeventBasedHold\
    \x12\x12\n\x04name\x18\x17\x20\x01(\tR\x04name\x12\x0e\n\x02id\x18\x18\
    \x20\x01(\tR\x02id\x12\x16\n\x06bucket\x18\x19\x20\x01(\tR\x06bucket\x12\
    \x1e\n\ngeneration\x18\x1a\x20\x01(\x03R\ngeneration\x12.\n\x05owner\x18\
    \x1b\x20\x01(\x0b2\x18.google.storage.v1.OwnerR\x05owner\x12]\n\x13custo\
    mer_encryption\x18\x1c\x20\x01(\x0b2,.google.storage.v1.Object.CustomerE\
    ncryptionR\x12customerEncryption\x1af\n\x12CustomerEncryption\x121\n\x14\
    encryption_algorithm\x18\x01\x20\x01(\tR\x13encryptionAlgorithm\x12\x1d\
    \n\nkey_sha256\x18\x02\x20\x01(\tR\tkeySha256\x1a;\n\rMetadataEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\"\xc3\x02\n\x13ObjectAccessControl\x12\x12\n\
    \x04role\x18\x01\x20\x01(\tR\x04role\x12\x12\n\x04etag\x18\x02\x20\x01(\
    \tR\x04etag\x12\x0e\n\x02id\x18\x03\x20\x01(\tR\x02id\x12\x16\n\x06bucke\
    t\x18\x04\x20\x01(\tR\x06bucket\x12\x16\n\x06object\x18\x05\x20\x01(\tR\
    \x06object\x12\x1e\n\ngeneration\x18\x06\x20\x01(\x03R\ngeneration\x12\
    \x16\n\x06entity\x18\x07\x20\x01(\tR\x06entity\x12\x1b\n\tentity_id\x18\
    \x08\x20\x01(\tR\x08entityId\x12\x14\n\x05email\x18\t\x20\x01(\tR\x05ema\
    il\x12\x16\n\x06domain\x18\n\x20\x01(\tR\x06domain\x12A\n\x0cproject_tea\
    m\x18\x0b\x20\x01(\x0b2\x1e.google.storage.v1.ProjectTeamR\x0bprojectTea\
    m\"`\n\x20ListObjectAccessControlsResponse\x12<\n\x05items\x18\x01\x20\
    \x03(\x0b2&.google.storage.v1.ObjectAccessControlR\x05items\"\x8a\x01\n\
    \x13ListObjectsResponse\x12\x1a\n\x08prefixes\x18\x01\x20\x03(\tR\x08pre\
    fixes\x12/\n\x05items\x18\x02\x20\x03(\x0b2\x19.google.storage.v1.Object\
    R\x05items\x12&\n\x0fnext_page_token\x18\x03\x20\x01(\tR\rnextPageToken\
    \"H\n\x0bProjectTeam\x12%\n\x0eproject_number\x18\x01\x20\x01(\tR\rproje\
    ctNumber\x12\x12\n\x04team\x18\x02\x20\x01(\tR\x04team\"5\n\x0eServiceAc\
    count\x12#\n\remail_address\x18\x01\x20\x01(\tR\x0cemailAddress\"<\n\x05\
    Owner\x12\x16\n\x06entity\x18\x01\x20\x01(\tR\x06entity\x12\x1b\n\tentit\
    y_id\x18\x02\x20\x01(\tR\x08entityIdBo\n\x15com.google.storage.v1B\x1aCl\
    oudStorageResourcesProtoP\x01Z8google.golang.org/genproto/googleapis/sto\
    rage/v1;storageJ\xcb\xa7\x02\n\x07\x12\x05\x0e\0\xe7\x06\x01\n\xbc\x04\n\
    \x01\x0c\x12\x03\x0e\0\x122\xb1\x04\x20Copyright\x202020\x20Google\x20LL\
    C\n\n\x20Licensed\x20under\x20the\x20Apache\x20License,\x20Version\x202.\
    0\x20(the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\x20file\
    \x20except\x20in\x20compliance\x20with\x20the\x20License.\n\x20You\x20ma\
    y\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\
    \x20\x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\x20requ\
    ired\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\
    \x20software\n\x20distributed\x20under\x20the\x20License\x20is\x20distri\
    buted\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\
    \x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\
    \x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20specific\x20lan\
    guage\x20governing\x20permissions\x20and\n\x20limitations\x20under\x20th\
    e\x20License.\n\n\x08\n\x01\x02\x12\x03\x10\0\x1a\n\t\n\x02\x03\0\x12\
    \x03\x12\0)\n\t\n\x02\x03\x01\x12\x03\x13\0(\n\x08\n\x01\x08\x12\x03\x15\
    \0O\n\t\n\x02\x08\x0b\x12\x03\x15\0O\n\x08\n\x01\x08\x12\x03\x16\0\"\n\t\
    \n\x02\x08\n\x12\x03\x16\0\"\n\x08\n\x01\x08\x12\x03\x17\0;\n\t\n\x02\
    \x08\x08\x12\x03\x17\0;\n\x08\n\x01\x08\x12\x03\x18\0.\n\t\n\x02\x08\x01\
    \x12\x03\x18\0.\n\x18\n\x02\x04\0\x12\x05\x1b\0\xc7\x02\x01\x1a\x0b\x20A\
    \x20bucket.\n\n\n\n\x03\x04\0\x01\x12\x03\x1b\x08\x0e\n/\n\x04\x04\0\x03\
    \0\x12\x04\x1d\x02\x20\x03\x1a!\x20Billing\x20properties\x20of\x20a\x20b\
    ucket.\n\n\x0c\n\x05\x04\0\x03\0\x01\x12\x03\x1d\n\x11\nM\n\x06\x04\0\
    \x03\0\x02\0\x12\x03\x1f\x04\x1c\x1a>\x20When\x20set\x20to\x20true,\x20R\
    equester\x20Pays\x20is\x20enabled\x20for\x20this\x20bucket.\n\n\x0f\n\
    \x07\x04\0\x03\0\x02\0\x04\x12\x04\x1f\x04\x1d\x13\n\x0e\n\x07\x04\0\x03\
    \0\x02\0\x05\x12\x03\x1f\x04\x08\n\x0e\n\x07\x04\0\x03\0\x02\0\x01\x12\
    \x03\x1f\t\x17\n\x0e\n\x07\x04\0\x03\0\x02\0\x03\x12\x03\x1f\x1a\x1b\n\
    \xe9\x01\n\x04\x04\0\x03\x01\x12\x04&\x02:\x03\x1a\xda\x01\x20Cross-Orig\
    in\x20Response\x20sharing\x20(CORS)\x20properties\x20for\x20a\x20bucket.\
    \n\x20For\x20more\x20on\x20GCS\x20and\x20CORS,\x20see\n\x20https://cloud\
    .google.com/storage/docs/cross-origin.\n\x20For\x20more\x20on\x20CORS\
    \x20in\x20general,\x20see\x20https://tools.ietf.org/html/rfc6454.\n\n\
    \x0c\n\x05\x04\0\x03\x01\x01\x12\x03&\n\x0e\n\xe2\x01\n\x06\x04\0\x03\
    \x01\x02\0\x12\x03*\x04\x1f\x1a\xd2\x01\x20The\x20list\x20of\x20Origins\
    \x20eligible\x20to\x20receive\x20CORS\x20response\x20headers.\x20See\n\
    \x20[https://tools.ietf.org/html/rfc6454][RFC\x206454]\x20for\x20more\
    \x20on\x20origins.\n\x20Note:\x20\"*\"\x20is\x20permitted\x20in\x20the\
    \x20list\x20of\x20origins,\x20and\x20means\x20\"any\x20Origin\".\n\n\x0e\
    \n\x07\x04\0\x03\x01\x02\0\x04\x12\x03*\x04\x0c\n\x0e\n\x07\x04\0\x03\
    \x01\x02\0\x05\x12\x03*\r\x13\n\x0e\n\x07\x04\0\x03\x01\x02\0\x01\x12\
    \x03*\x14\x1a\n\x0e\n\x07\x04\0\x03\x01\x02\0\x03\x12\x03*\x1d\x1e\n\xbe\
    \x01\n\x06\x04\0\x03\x01\x02\x01\x12\x03/\x04\x1f\x1a\xae\x01\x20The\x20\
    list\x20of\x20HTTP\x20methods\x20on\x20which\x20to\x20include\x20CORS\
    \x20response\x20headers,\n\x20(`GET`,\x20`OPTIONS`,\x20`POST`,\x20etc)\
    \x20Note:\x20\"*\"\x20is\x20permitted\x20in\x20the\x20list\x20of\n\x20me\
    thods,\x20and\x20means\x20\"any\x20method\".\n\n\x0e\n\x07\x04\0\x03\x01\
    \x02\x01\x04\x12\x03/\x04\x0c\n\x0e\n\x07\x04\0\x03\x01\x02\x01\x05\x12\
    \x03/\r\x13\n\x0e\n\x07\x04\0\x03\x01\x02\x01\x01\x12\x03/\x14\x1a\n\x0e\
    \n\x07\x04\0\x03\x01\x02\x01\x03\x12\x03/\x1d\x1e\n\xc8\x01\n\x06\x04\0\
    \x03\x01\x02\x02\x12\x034\x04(\x1a\xb8\x01\x20The\x20list\x20of\x20HTTP\
    \x20headers\x20other\x20than\x20the\n\x20[https://www.w3.org/TR/cors/#si\
    mple-response-header][simple\x20response\n\x20headers]\x20to\x20give\x20\
    permission\x20for\x20the\x20user-agent\x20to\x20share\x20across\x20domai\
    ns.\n\n\x0e\n\x07\x04\0\x03\x01\x02\x02\x04\x12\x034\x04\x0c\n\x0e\n\x07\
    \x04\0\x03\x01\x02\x02\x05\x12\x034\r\x13\n\x0e\n\x07\x04\0\x03\x01\x02\
    \x02\x01\x12\x034\x14#\n\x0e\n\x07\x04\0\x03\x01\x02\x02\x03\x12\x034&'\
    \n\xbc\x01\n\x06\x04\0\x03\x01\x02\x03\x12\x039\x04\x1e\x1a\xac\x01\x20T\
    he\x20value,\x20in\x20seconds,\x20to\x20return\x20in\x20the\n\x20[https:\
    //www.w3.org/TR/cors/#access-control-max-age-response-header][Access-Con\
    trol-Max-Age\n\x20header]\x20used\x20in\x20preflight\x20responses.\n\n\
    \x0f\n\x07\x04\0\x03\x01\x02\x03\x04\x12\x049\x044(\n\x0e\n\x07\x04\0\
    \x03\x01\x02\x03\x05\x12\x039\x04\t\n\x0e\n\x07\x04\0\x03\x01\x02\x03\
    \x01\x12\x039\n\x19\n\x0e\n\x07\x04\0\x03\x01\x02\x03\x03\x12\x039\x1c\
    \x1d\n2\n\x04\x04\0\x03\x02\x12\x04=\x02A\x03\x1a$\x20Encryption\x20prop\
    erties\x20of\x20a\x20bucket.\n\n\x0c\n\x05\x04\0\x03\x02\x01\x12\x03=\n\
    \x14\n\x87\x01\n\x06\x04\0\x03\x02\x02\0\x12\x03@\x04$\x1ax\x20A\x20Clou\
    d\x20KMS\x20key\x20that\x20will\x20be\x20used\x20to\x20encrypt\x20object\
    s\x20inserted\x20into\x20this\n\x20bucket,\x20if\x20no\x20encryption\x20\
    method\x20is\x20specified.\n\n\x0f\n\x07\x04\0\x03\x02\x02\0\x04\x12\x04\
    @\x04=\x16\n\x0e\n\x07\x04\0\x03\x02\x02\0\x05\x12\x03@\x04\n\n\x0e\n\
    \x07\x04\0\x03\x02\x02\0\x01\x12\x03@\x0b\x1f\n\x0e\n\x07\x04\0\x03\x02\
    \x02\0\x03\x12\x03@\"#\nL\n\x04\x04\0\x03\x03\x12\x04D\x02Q\x03\x1a>\x20\
    Bucket\x20restriction\x20options\x20currently\x20enforced\x20on\x20the\
    \x20bucket.\n\n\x0c\n\x05\x04\0\x03\x03\x01\x12\x03D\n\x1a\n\x0e\n\x06\
    \x04\0\x03\x03\x03\0\x12\x04E\x04N\x05\n\x0e\n\x07\x04\0\x03\x03\x03\0\
    \x01\x12\x03E\x0c$\nU\n\x08\x04\0\x03\x03\x03\0\x02\0\x12\x03G\x06\x17\
    \x1aD\x20If\x20set,\x20access\x20checks\x20only\x20use\x20bucket-level\
    \x20IAM\x20policies\x20or\x20above.\n\n\x11\n\t\x04\0\x03\x03\x03\0\x02\
    \0\x04\x12\x04G\x06E&\n\x10\n\t\x04\0\x03\x03\x03\0\x02\0\x05\x12\x03G\
    \x06\n\n\x10\n\t\x04\0\x03\x03\x03\0\x02\0\x01\x12\x03G\x0b\x12\n\x10\n\
    \t\x04\0\x03\x03\x03\0\x02\0\x03\x12\x03G\x15\x16\n\xf0\x01\n\x08\x04\0\
    \x03\x03\x03\0\x02\x01\x12\x03M\x060\x1a\xde\x01\x20The\x20deadline\x20t\
    ime\x20for\x20changing\n\x20<code>iamConfiguration.uniformBucketLevelAcc\
    ess.enabled</code>\x20from\n\x20true\x20to\x20false\x20in\x20[https://to\
    ols.ietf.org/html/rfc3339][RFC\x203339].\x20After\n\x20the\x20deadline\
    \x20is\x20passed\x20the\x20field\x20is\x20immutable.\n\n\x11\n\t\x04\0\
    \x03\x03\x03\0\x02\x01\x04\x12\x04M\x06G\x17\n\x10\n\t\x04\0\x03\x03\x03\
    \0\x02\x01\x06\x12\x03M\x06\x1f\n\x10\n\t\x04\0\x03\x03\x03\0\x02\x01\
    \x01\x12\x03M\x20+\n\x10\n\t\x04\0\x03\x03\x03\0\x02\x01\x03\x12\x03M./\
    \n\r\n\x06\x04\0\x03\x03\x02\0\x12\x03P\x04=\n\x0f\n\x07\x04\0\x03\x03\
    \x02\0\x04\x12\x04P\x04N\x05\n\x0e\n\x07\x04\0\x03\x03\x02\0\x06\x12\x03\
    P\x04\x1c\n\x0e\n\x07\x04\0\x03\x03\x02\0\x01\x12\x03P\x1d8\n\x0e\n\x07\
    \x04\0\x03\x03\x02\0\x03\x12\x03P;<\n~\n\x04\x04\0\x03\x04\x12\x05U\x02\
    \x93\x01\x03\x1ao\x20Lifecycle\x20properties\x20of\x20a\x20bucket.\n\x20\
    For\x20more\x20information,\x20see\x20https://cloud.google.com/storage/d\
    ocs/lifecycle.\n\n\x0c\n\x05\x04\0\x03\x04\x01\x12\x03U\n\x13\n~\n\x06\
    \x04\0\x03\x04\x03\0\x12\x05X\x04\x8e\x01\x05\x1am\x20A\x20lifecycle\x20\
    Rule,\x20combining\x20an\x20action\x20to\x20take\x20on\x20an\x20object\
    \x20and\x20a\n\x20condition\x20which\x20will\x20trigger\x20that\x20actio\
    n.\n\n\x0e\n\x07\x04\0\x03\x04\x03\0\x01\x12\x03X\x0c\x10\n3\n\x08\x04\0\
    \x03\x04\x03\0\x03\0\x12\x04Z\x06b\x07\x1a!\x20An\x20action\x20to\x20tak\
    e\x20on\x20an\x20object.\n\n\x10\n\t\x04\0\x03\x04\x03\0\x03\0\x01\x12\
    \x03Z\x0e\x14\ng\n\n\x04\0\x03\x04\x03\0\x03\0\x02\0\x12\x03]\x08\x18\
    \x1aT\x20Type\x20of\x20the\x20action.\x20Currently,\x20only\x20`Delete`\
    \x20and\n\x20`SetStorageClass`\x20are\x20supported.\n\n\x13\n\x0b\x04\0\
    \x03\x04\x03\0\x03\0\x02\0\x04\x12\x04]\x08Z\x16\n\x12\n\x0b\x04\0\x03\
    \x04\x03\0\x03\0\x02\0\x05\x12\x03]\x08\x0e\n\x12\n\x0b\x04\0\x03\x04\
    \x03\0\x03\0\x02\0\x01\x12\x03]\x0f\x13\n\x12\n\x0b\x04\0\x03\x04\x03\0\
    \x03\0\x02\0\x03\x12\x03]\x16\x17\nc\n\n\x04\0\x03\x04\x03\0\x03\0\x02\
    \x01\x12\x03a\x08!\x1aP\x20Target\x20storage\x20class.\x20Required\x20if\
    f\x20the\x20type\x20of\x20the\x20action\x20is\n\x20SetStorageClass.\n\n\
    \x13\n\x0b\x04\0\x03\x04\x03\0\x03\0\x02\x01\x04\x12\x04a\x08]\x18\n\x12\
    \n\x0b\x04\0\x03\x04\x03\0\x03\0\x02\x01\x05\x12\x03a\x08\x0e\n\x12\n\
    \x0b\x04\0\x03\x04\x03\0\x03\0\x02\x01\x01\x12\x03a\x0f\x1c\n\x12\n\x0b\
    \x04\0\x03\x04\x03\0\x03\0\x02\x01\x03\x12\x03a\x1f\x20\nI\n\x08\x04\0\
    \x03\x04\x03\0\x03\x01\x12\x05e\x06\x87\x01\x07\x1a6\x20A\x20condition\
    \x20of\x20an\x20object\x20which\x20triggers\x20some\x20action.\n\n\x10\n\
    \t\x04\0\x03\x04\x03\0\x03\x01\x01\x12\x03e\x0e\x17\nw\n\n\x04\0\x03\x04\
    \x03\0\x03\x01\x02\0\x12\x03h\x08\x16\x1ad\x20Age\x20of\x20an\x20object\
    \x20(in\x20days).\x20This\x20condition\x20is\x20satisfied\x20when\x20an\
    \n\x20object\x20reaches\x20the\x20specified\x20age.\n\n\x13\n\x0b\x04\0\
    \x03\x04\x03\0\x03\x01\x02\0\x04\x12\x04h\x08e\x19\n\x12\n\x0b\x04\0\x03\
    \x04\x03\0\x03\x01\x02\0\x05\x12\x03h\x08\r\n\x12\n\x0b\x04\0\x03\x04\
    \x03\0\x03\x01\x02\0\x01\x12\x03h\x0e\x11\n\x12\n\x0b\x04\0\x03\x04\x03\
    \0\x03\x01\x02\0\x03\x12\x03h\x14\x15\n\xfa\x01\n\n\x04\0\x03\x04\x03\0\
    \x03\x01\x02\x01\x12\x03n\x085\x1a\xe6\x01\x20A\x20date\x20in\x20[RFC\
    \x203339][1]\x20format\x20with\x20only\x20the\x20date\x20part\x20(for\n\
    \x20instance,\x20\"2013-01-15\").\x20This\x20condition\x20is\x20satisfie\
    d\x20when\x20an\n\x20object\x20is\x20created\x20before\x20midnight\x20of\
    \x20the\x20specified\x20date\x20in\x20UTC.\n\x20[1]:\x20https://tools.ie\
    tf.org/html/rfc3339\n\n\x13\n\x0b\x04\0\x03\x04\x03\0\x03\x01\x02\x01\
    \x04\x12\x04n\x08h\x16\n\x12\n\x0b\x04\0\x03\x04\x03\0\x03\x01\x02\x01\
    \x06\x12\x03n\x08!\n\x12\n\x0b\x04\0\x03\x04\x03\0\x03\x01\x02\x01\x01\
    \x12\x03n\"0\n\x12\n\x0b\x04\0\x03\x04\x03\0\x03\x01\x02\x01\x03\x12\x03\
    n34\n\xaf\x01\n\n\x04\0\x03\x04\x03\0\x03\x01\x02\x02\x12\x03s\x08.\x1a\
    \x9b\x01\x20Relevant\x20only\x20for\x20versioned\x20objects.\x20If\x20th\
    e\x20value\x20is\n\x20`true`,\x20this\x20condition\x20matches\x20live\
    \x20objects;\x20if\x20the\x20value\n\x20is\x20`false`,\x20it\x20matches\
    \x20archived\x20objects.\n\n\x13\n\x0b\x04\0\x03\x04\x03\0\x03\x01\x02\
    \x02\x04\x12\x04s\x08n5\n\x12\n\x0b\x04\0\x03\x04\x03\0\x03\x01\x02\x02\
    \x06\x12\x03s\x08!\n\x12\n\x0b\x04\0\x03\x04\x03\0\x03\x01\x02\x02\x01\
    \x12\x03s\")\n\x12\n\x0b\x04\0\x03\x04\x03\0\x03\x01\x02\x02\x03\x12\x03\
    s,-\n\xd2\x01\n\n\x04\0\x03\x04\x03\0\x03\x01\x02\x03\x12\x03x\x08%\x1a\
    \xbe\x01\x20Relevant\x20only\x20for\x20versioned\x20objects.\x20If\x20th\
    e\x20value\x20is\x20N,\x20this\n\x20condition\x20is\x20satisfied\x20when\
    \x20there\x20are\x20at\x20least\x20N\x20versions\x20(including\n\x20the\
    \x20live\x20version)\x20newer\x20than\x20this\x20version\x20of\x20the\
    \x20object.\n\n\x13\n\x0b\x04\0\x03\x04\x03\0\x03\x01\x02\x03\x04\x12\
    \x04x\x08s.\n\x12\n\x0b\x04\0\x03\x04\x03\0\x03\x01\x02\x03\x05\x12\x03x\
    \x08\r\n\x12\n\x0b\x04\0\x03\x04\x03\0\x03\x01\x02\x03\x01\x12\x03x\x0e\
    \x20\n\x12\n\x0b\x04\0\x03\x04\x03\0\x03\x01\x02\x03\x03\x12\x03x#$\n\
    \xe4\x01\n\n\x04\0\x03\x04\x03\0\x03\x01\x02\x04\x12\x03~\x082\x1a\xd0\
    \x01\x20Objects\x20having\x20any\x20of\x20the\x20storage\x20classes\x20s\
    pecified\x20by\x20this\x20condition\n\x20will\x20be\x20matched.\x20Value\
    s\x20include\x20`MULTI_REGIONAL`,\x20`REGIONAL`,\n\x20`NEARLINE`,\x20`CO\
    LDLINE`,\x20`STANDARD`,\x20and\n\x20`DURABLE_REDUCED_AVAILABILITY`.\n\n\
    \x12\n\x0b\x04\0\x03\x04\x03\0\x03\x01\x02\x04\x04\x12\x03~\x08\x10\n\
    \x12\n\x0b\x04\0\x03\x04\x03\0\x03\x01\x02\x04\x05\x12\x03~\x11\x17\n\
    \x12\n\x0b\x04\0\x03\x04\x03\0\x03\x01\x02\x04\x01\x12\x03~\x18-\n\x12\n\
    \x0b\x04\0\x03\x04\x03\0\x03\x01\x02\x04\x03\x12\x03~01\n\x91\x03\n\n\
    \x04\0\x03\x04\x03\0\x03\x01\x02\x05\x12\x04\x86\x01\x08#\x1a\xfc\x02\
    \x20A\x20regular\x20expression\x20that\x20satisfies\x20the\x20RE2\x20syn\
    tax.\x20This\x20condition\x20is\n\x20satisfied\x20when\x20the\x20name\
    \x20of\x20the\x20object\x20matches\x20the\x20RE2\x20pattern.\x20\x20Note\
    :\n\x20This\x20feature\x20is\x20currently\x20in\x20the\x20\"Early\x20Acc\
    ess\"\x20launch\x20stage\x20and\x20is\n\x20only\x20available\x20to\x20a\
    \x20whitelisted\x20set\x20of\x20users;\x20that\x20means\x20that\x20this\
    \n\x20feature\x20may\x20be\x20changed\x20in\x20backward-incompatible\x20\
    ways\x20and\x20that\x20it\x20is\n\x20not\x20guaranteed\x20to\x20be\x20re\
    leased.\n\n\x14\n\x0b\x04\0\x03\x04\x03\0\x03\x01\x02\x05\x04\x12\x05\
    \x86\x01\x08~2\n\x13\n\x0b\x04\0\x03\x04\x03\0\x03\x01\x02\x05\x05\x12\
    \x04\x86\x01\x08\x0e\n\x13\n\x0b\x04\0\x03\x04\x03\0\x03\x01\x02\x05\x01\
    \x12\x04\x86\x01\x0f\x1e\n\x13\n\x0b\x04\0\x03\x04\x03\0\x03\x01\x02\x05\
    \x03\x12\x04\x86\x01!\"\n'\n\x08\x04\0\x03\x04\x03\0\x02\0\x12\x04\x8a\
    \x01\x06\x18\x1a\x15\x20The\x20action\x20to\x20take.\n\n\x13\n\t\x04\0\
    \x03\x04\x03\0\x02\0\x04\x12\x06\x8a\x01\x06\x87\x01\x07\n\x11\n\t\x04\0\
    \x03\x04\x03\0\x02\0\x06\x12\x04\x8a\x01\x06\x0c\n\x11\n\t\x04\0\x03\x04\
    \x03\0\x02\0\x01\x12\x04\x8a\x01\r\x13\n\x11\n\t\x04\0\x03\x04\x03\0\x02\
    \0\x03\x12\x04\x8a\x01\x16\x17\nJ\n\x08\x04\0\x03\x04\x03\0\x02\x01\x12\
    \x04\x8d\x01\x06\x1e\x1a8\x20The\x20condition(s)\x20under\x20which\x20th\
    e\x20action\x20will\x20be\x20taken.\n\n\x13\n\t\x04\0\x03\x04\x03\0\x02\
    \x01\x04\x12\x06\x8d\x01\x06\x8a\x01\x18\n\x11\n\t\x04\0\x03\x04\x03\0\
    \x02\x01\x06\x12\x04\x8d\x01\x06\x0f\n\x11\n\t\x04\0\x03\x04\x03\0\x02\
    \x01\x01\x12\x04\x8d\x01\x10\x19\n\x11\n\t\x04\0\x03\x04\x03\0\x02\x01\
    \x03\x12\x04\x8d\x01\x1c\x1d\n\x8d\x01\n\x06\x04\0\x03\x04\x02\0\x12\x04\
    \x92\x01\x04\x1b\x1a}\x20A\x20lifecycle\x20management\x20rule,\x20which\
    \x20is\x20made\x20of\x20an\x20action\x20to\x20take\x20and\x20the\n\x20co\
    ndition(s)\x20under\x20which\x20the\x20action\x20will\x20be\x20taken.\n\
    \n\x0f\n\x07\x04\0\x03\x04\x02\0\x04\x12\x04\x92\x01\x04\x0c\n\x0f\n\x07\
    \x04\0\x03\x04\x02\0\x06\x12\x04\x92\x01\r\x11\n\x0f\n\x07\x04\0\x03\x04\
    \x02\0\x01\x12\x04\x92\x01\x12\x16\n\x0f\n\x07\x04\0\x03\x04\x02\0\x03\
    \x12\x04\x92\x01\x19\x1a\n9\n\x04\x04\0\x03\x05\x12\x06\x96\x01\x02\x9c\
    \x01\x03\x1a)\x20Logging-related\x20properties\x20of\x20a\x20bucket.\n\n\
    \r\n\x05\x04\0\x03\x05\x01\x12\x04\x96\x01\n\x11\nZ\n\x06\x04\0\x03\x05\
    \x02\0\x12\x04\x98\x01\x04\x1a\x1aJ\x20The\x20destination\x20bucket\x20w\
    here\x20the\x20current\x20bucket's\x20logs\x20should\x20be\x20placed.\n\
    \n\x11\n\x07\x04\0\x03\x05\x02\0\x04\x12\x06\x98\x01\x04\x96\x01\x13\n\
    \x0f\n\x07\x04\0\x03\x05\x02\0\x05\x12\x04\x98\x01\x04\n\n\x0f\n\x07\x04\
    \0\x03\x05\x02\0\x01\x12\x04\x98\x01\x0b\x15\n\x0f\n\x07\x04\0\x03\x05\
    \x02\0\x03\x12\x04\x98\x01\x18\x19\n0\n\x06\x04\0\x03\x05\x02\x01\x12\
    \x04\x9b\x01\x04!\x1a\x20\x20A\x20prefix\x20for\x20log\x20object\x20name\
    s.\n\n\x11\n\x07\x04\0\x03\x05\x02\x01\x04\x12\x06\x9b\x01\x04\x98\x01\
    \x1a\n\x0f\n\x07\x04\0\x03\x05\x02\x01\x05\x12\x04\x9b\x01\x04\n\n\x0f\n\
    \x07\x04\0\x03\x05\x02\x01\x01\x12\x04\x9b\x01\x0b\x1c\n\x0f\n\x07\x04\0\
    \x03\x05\x02\x01\x03\x12\x04\x9b\x01\x1f\x20\n:\n\x04\x04\0\x03\x06\x12\
    \x06\x9f\x01\x02\xad\x01\x03\x1a*\x20Retention\x20policy\x20properties\
    \x20of\x20a\x20bucket.\n\n\r\n\x05\x04\0\x03\x06\x01\x12\x04\x9f\x01\n\
    \x19\n\xbb\x01\n\x06\x04\0\x03\x06\x02\0\x12\x04\xa3\x01\x041\x1a\xaa\
    \x01\x20Server-determined\x20value\x20that\x20indicates\x20the\x20time\
    \x20from\x20which\x20policy\x20was\n\x20enforced\x20and\x20effective.\
    \x20This\x20value\x20is\x20in\n\x20[https://tools.ietf.org/html/rfc3339]\
    [RFC\x203339]\x20format.\n\n\x11\n\x07\x04\0\x03\x06\x02\0\x04\x12\x06\
    \xa3\x01\x04\x9f\x01\x1b\n\x0f\n\x07\x04\0\x03\x06\x02\0\x06\x12\x04\xa3\
    \x01\x04\x1d\n\x0f\n\x07\x04\0\x03\x06\x02\0\x01\x12\x04\xa3\x01\x1e,\n\
    \x0f\n\x07\x04\0\x03\x06\x02\0\x03\x12\x04\xa3\x01/0\nM\n\x06\x04\0\x03\
    \x06\x02\x01\x12\x04\xa6\x01\x04\x17\x1a=\x20Once\x20locked,\x20an\x20ob\
    ject\x20retention\x20policy\x20cannot\x20be\x20modified.\n\n\x11\n\x07\
    \x04\0\x03\x06\x02\x01\x04\x12\x06\xa6\x01\x04\xa3\x011\n\x0f\n\x07\x04\
    \0\x03\x06\x02\x01\x05\x12\x04\xa6\x01\x04\x08\n\x0f\n\x07\x04\0\x03\x06\
    \x02\x01\x01\x12\x04\xa6\x01\t\x12\n\x0f\n\x07\x04\0\x03\x06\x02\x01\x03\
    \x12\x04\xa6\x01\x15\x16\n\x9a\x02\n\x06\x04\0\x03\x06\x02\x02\x12\x04\
    \xac\x01\x04\x1f\x1a\x89\x02\x20The\x20duration\x20in\x20seconds\x20that\
    \x20objects\x20need\x20to\x20be\x20retained.\x20Retention\n\x20duration\
    \x20must\x20be\x20greater\x20than\x20zero\x20and\x20less\x20than\x20100\
    \x20years.\x20Note\x20that\n\x20enforcement\x20of\x20retention\x20period\
    s\x20less\x20than\x20a\x20day\x20is\x20not\x20guaranteed.\x20Such\n\x20p\
    eriods\x20should\x20only\x20be\x20used\x20for\x20testing\x20purposes.\n\
    \n\x11\n\x07\x04\0\x03\x06\x02\x02\x04\x12\x06\xac\x01\x04\xa6\x01\x17\n\
    \x0f\n\x07\x04\0\x03\x06\x02\x02\x05\x12\x04\xac\x01\x04\t\n\x0f\n\x07\
    \x04\0\x03\x06\x02\x02\x01\x12\x04\xac\x01\n\x1a\n\x0f\n\x07\x04\0\x03\
    \x06\x02\x02\x03\x12\x04\xac\x01\x1d\x1e\n\x9b\x01\n\x04\x04\0\x03\x07\
    \x12\x06\xb2\x01\x02\xb5\x01\x03\x1a\x8a\x01\x20Properties\x20of\x20a\
    \x20bucket\x20related\x20to\x20versioning.\n\x20For\x20more\x20on\x20GCS\
    \x20versioning,\x20see\n\x20https://cloud.google.com/storage/docs/object\
    -versioning.\n\n\r\n\x05\x04\0\x03\x07\x01\x12\x04\xb2\x01\n\x14\nQ\n\
    \x06\x04\0\x03\x07\x02\0\x12\x04\xb4\x01\x04\x15\x1aA\x20While\x20set\
    \x20to\x20true,\x20versioning\x20is\x20fully\x20enabled\x20for\x20this\
    \x20bucket.\n\n\x11\n\x07\x04\0\x03\x07\x02\0\x04\x12\x06\xb4\x01\x04\
    \xb2\x01\x16\n\x0f\n\x07\x04\0\x03\x07\x02\0\x05\x12\x04\xb4\x01\x04\x08\
    \n\x0f\n\x07\x04\0\x03\x07\x02\0\x01\x12\x04\xb4\x01\t\x10\n\x0f\n\x07\
    \x04\0\x03\x07\x02\0\x03\x12\x04\xb4\x01\x13\x14\n\xd2\x01\n\x04\x04\0\
    \x03\x08\x12\x06\xba\x01\x02\xc7\x01\x03\x1a\xc1\x01\x20Properties\x20of\
    \x20a\x20bucket\x20related\x20to\x20accessing\x20the\x20contents\x20as\
    \x20a\x20static\n\x20website.\x20For\x20more\x20on\x20hosting\x20a\x20st\
    atic\x20website\x20via\x20GCS,\x20see\n\x20https://cloud.google.com/stor\
    age/docs/hosting-static-website.\n\n\r\n\x05\x04\0\x03\x08\x01\x12\x04\
    \xba\x01\n\x11\n\x84\x02\n\x06\x04\0\x03\x08\x02\0\x12\x04\xbf\x01\x04\
    \x20\x1a\xf3\x01\x20If\x20the\x20requested\x20object\x20path\x20is\x20mi\
    ssing,\x20the\x20service\x20will\x20ensure\x20the\x20path\n\x20has\x20a\
    \x20trailing\x20'/',\x20append\x20this\x20suffix,\x20and\x20attempt\x20t\
    o\x20retrieve\x20the\n\x20resulting\x20object.\x20This\x20allows\x20the\
    \x20creation\x20of\x20`index.html`\n\x20objects\x20to\x20represent\x20di\
    rectory\x20pages.\n\n\x11\n\x07\x04\0\x03\x08\x02\0\x04\x12\x06\xbf\x01\
    \x04\xba\x01\x13\n\x0f\n\x07\x04\0\x03\x08\x02\0\x05\x12\x04\xbf\x01\x04\
    \n\n\x0f\n\x07\x04\0\x03\x08\x02\0\x01\x12\x04\xbf\x01\x0b\x1b\n\x0f\n\
    \x07\x04\0\x03\x08\x02\0\x03\x12\x04\xbf\x01\x1e\x1f\n\x94\x02\n\x06\x04\
    \0\x03\x08\x02\x01\x12\x04\xc6\x01\x04\x1e\x1a\x83\x02\x20If\x20the\x20r\
    equested\x20object\x20path\x20is\x20missing,\x20and\x20any\n\x20`mainPag\
    eSuffix`\x20object\x20is\x20missing,\x20if\x20applicable,\x20the\x20serv\
    ice\n\x20will\x20return\x20the\x20named\x20object\x20from\x20this\x20buc\
    ket\x20as\x20the\x20content\x20for\x20a\n\x20[https://tools.ietf.org/htm\
    l/rfc7231#section-6.5.4][404\x20Not\x20Found]\n\x20result.\n\n\x11\n\x07\
    \x04\0\x03\x08\x02\x01\x04\x12\x06\xc6\x01\x04\xbf\x01\x20\n\x0f\n\x07\
    \x04\0\x03\x08\x02\x01\x05\x12\x04\xc6\x01\x04\n\n\x0f\n\x07\x04\0\x03\
    \x08\x02\x01\x01\x12\x04\xc6\x01\x0b\x19\n\x0f\n\x07\x04\0\x03\x08\x02\
    \x01\x03\x12\x04\xc6\x01\x1c\x1d\n.\n\x04\x04\0\x02\0\x12\x04\xca\x01\
    \x02'\x1a\x20\x20Access\x20controls\x20on\x20the\x20bucket.\n\n\r\n\x05\
    \x04\0\x02\0\x04\x12\x04\xca\x01\x02\n\n\r\n\x05\x04\0\x02\0\x06\x12\x04\
    \xca\x01\x0b\x1e\n\r\n\x05\x04\0\x02\0\x01\x12\x04\xca\x01\x1f\"\n\r\n\
    \x05\x04\0\x02\0\x03\x12\x04\xca\x01%&\nX\n\x04\x04\0\x02\x01\x12\x04\
    \xcd\x01\x026\x1aJ\x20Default\x20access\x20controls\x20to\x20apply\x20to\
    \x20new\x20objects\x20when\x20no\x20ACL\x20is\x20provided.\n\n\r\n\x05\
    \x04\0\x02\x01\x04\x12\x04\xcd\x01\x02\n\n\r\n\x05\x04\0\x02\x01\x06\x12\
    \x04\xcd\x01\x0b\x1e\n\r\n\x05\x04\0\x02\x01\x01\x12\x04\xcd\x01\x1f1\n\
    \r\n\x05\x04\0\x02\x01\x03\x12\x04\xcd\x0145\n\x9e\x01\n\x04\x04\0\x02\
    \x02\x12\x04\xd2\x01\x02\x1a\x1a\x8f\x01\x20The\x20bucket's\x20lifecycle\
    \x20configuration.\x20See\n\x20[https://developers.google.com/storage/do\
    cs/lifecycle]Lifecycle\x20Management]\n\x20for\x20more\x20information.\n\
    \n\x0f\n\x05\x04\0\x02\x02\x04\x12\x06\xd2\x01\x02\xcd\x016\n\r\n\x05\
    \x04\0\x02\x02\x06\x12\x04\xd2\x01\x02\x0b\n\r\n\x05\x04\0\x02\x02\x01\
    \x12\x04\xd2\x01\x0c\x15\n\r\n\x05\x04\0\x02\x02\x03\x12\x04\xd2\x01\x18\
    \x19\n\xa3\x01\n\x04\x04\0\x02\x03\x12\x04\xd7\x01\x02-\x1a\x94\x01\x20T\
    he\x20creation\x20time\x20of\x20the\x20bucket\x20in\n\x20[https://tools.\
    ietf.org/html/rfc3339][RFC\x203339]\x20format.\n\x20Attempting\x20to\x20\
    set\x20this\x20field\x20will\x20result\x20in\x20an\x20error.\n\n\x0f\n\
    \x05\x04\0\x02\x03\x04\x12\x06\xd7\x01\x02\xd2\x01\x1a\n\r\n\x05\x04\0\
    \x02\x03\x06\x12\x04\xd7\x01\x02\x1b\n\r\n\x05\x04\0\x02\x03\x01\x12\x04\
    \xd7\x01\x1c(\n\r\n\x05\x04\0\x02\x03\x03\x12\x04\xd7\x01+,\n\xb8\x01\n\
    \x04\x04\0\x02\x04\x12\x04\xdd\x01\x02\x10\x1a\xa9\x01\x20The\x20ID\x20o\
    f\x20the\x20bucket.\x20For\x20buckets,\x20the\x20`id`\x20and\x20`name`\
    \x20properties\x20are\x20the\n\x20same.\n\x20Attempting\x20to\x20update\
    \x20this\x20field\x20after\x20the\x20bucket\x20is\x20created\x20will\x20\
    result\x20in\n\x20an\x20error.\n\n\x0f\n\x05\x04\0\x02\x04\x04\x12\x06\
    \xdd\x01\x02\xd7\x01-\n\r\n\x05\x04\0\x02\x04\x05\x12\x04\xdd\x01\x02\
    \x08\n\r\n\x05\x04\0\x02\x04\x01\x12\x04\xdd\x01\t\x0b\n\r\n\x05\x04\0\
    \x02\x04\x03\x12\x04\xdd\x01\x0e\x0f\n~\n\x04\x04\0\x02\x05\x12\x04\xe2\
    \x01\x02\x12\x1ap\x20The\x20name\x20of\x20the\x20bucket.\n\x20Attempting\
    \x20to\x20update\x20this\x20field\x20after\x20the\x20bucket\x20is\x20cre\
    ated\x20will\x20result\x20in\n\x20an\x20error.\n\n\x0f\n\x05\x04\0\x02\
    \x05\x04\x12\x06\xe2\x01\x02\xdd\x01\x10\n\r\n\x05\x04\0\x02\x05\x05\x12\
    \x04\xe2\x01\x02\x08\n\r\n\x05\x04\0\x02\x05\x01\x12\x04\xe2\x01\t\r\n\r\
    \n\x05\x04\0\x02\x05\x03\x12\x04\xe2\x01\x10\x11\n\x7f\n\x04\x04\0\x02\
    \x06\x12\x04\xe6\x01\x02\x1b\x1aq\x20The\x20project\x20number\x20of\x20t\
    he\x20project\x20the\x20bucket\x20belongs\x20to.\n\x20Attempting\x20to\
    \x20set\x20this\x20field\x20will\x20result\x20in\x20an\x20error.\n\n\x0f\
    \n\x05\x04\0\x02\x06\x04\x12\x06\xe6\x01\x02\xe2\x01\x12\n\r\n\x05\x04\0\
    \x02\x06\x05\x12\x04\xe6\x01\x02\x07\n\r\n\x05\x04\0\x02\x06\x01\x12\x04\
    \xe6\x01\x08\x16\n\r\n\x05\x04\0\x02\x06\x03\x12\x04\xe6\x01\x19\x1a\nn\
    \n\x04\x04\0\x02\x07\x12\x04\xea\x01\x02\x1b\x1a`\x20The\x20metadata\x20\
    generation\x20of\x20this\x20bucket.\n\x20Attempting\x20to\x20set\x20this\
    \x20field\x20will\x20result\x20in\x20an\x20error.\n\n\x0f\n\x05\x04\0\
    \x02\x07\x04\x12\x06\xea\x01\x02\xe6\x01\x1b\n\r\n\x05\x04\0\x02\x07\x05\
    \x12\x04\xea\x01\x02\x07\n\r\n\x05\x04\0\x02\x07\x01\x12\x04\xea\x01\x08\
    \x16\n\r\n\x05\x04\0\x02\x07\x03\x12\x04\xea\x01\x19\x1a\np\n\x04\x04\0\
    \x02\x08\x12\x04\xee\x01\x02\x19\x1ab\x20The\x20bucket's\x20[https://www\
    .w3.org/TR/cors/][Cross-Origin\x20Resource\x20Sharing]\n\x20(CORS)\x20co\
    nfiguration.\n\n\r\n\x05\x04\0\x02\x08\x04\x12\x04\xee\x01\x02\n\n\r\n\
    \x05\x04\0\x02\x08\x06\x12\x04\xee\x01\x0b\x0f\n\r\n\x05\x04\0\x02\x08\
    \x01\x12\x04\xee\x01\x10\x14\n\r\n\x05\x04\0\x02\x08\x03\x12\x04\xee\x01\
    \x17\x18\n\xfb\x02\n\x04\x04\0\x02\t\x12\x04\xf5\x01\x02\x17\x1a\xec\x02\
    \x20The\x20location\x20of\x20the\x20bucket.\x20Object\x20data\x20for\x20\
    objects\x20in\x20the\x20bucket\x20resides\n\x20in\x20physical\x20storage\
    \x20within\x20this\x20region.\x20\x20Defaults\x20to\x20`US`.\x20See\x20t\
    he\n\x20[https://developers.google.com/storage/docs/concepts-techniques#\
    specifyinglocations\"][developer's\n\x20guide]\x20for\x20the\x20authorit\
    ative\x20list.\x20Attempting\x20to\x20update\x20this\x20field\x20after\n\
    \x20the\x20bucket\x20is\x20created\x20will\x20result\x20in\x20an\x20erro\
    r.\n\n\x0f\n\x05\x04\0\x02\t\x04\x12\x06\xf5\x01\x02\xee\x01\x19\n\r\n\
    \x05\x04\0\x02\t\x05\x12\x04\xf5\x01\x02\x08\n\r\n\x05\x04\0\x02\t\x01\
    \x12\x04\xf5\x01\t\x11\n\r\n\x05\x04\0\x02\t\x03\x12\x04\xf5\x01\x14\x16\
    \n\x92\x03\n\x04\x04\0\x02\n\x12\x04\xfd\x01\x02\x1c\x1a\x83\x03\x20The\
    \x20bucket's\x20default\x20storage\x20class,\x20used\x20whenever\x20no\
    \x20storageClass\x20is\n\x20specified\x20for\x20a\x20newly-created\x20ob\
    ject.\x20This\x20defines\x20how\x20objects\x20in\x20the\n\x20bucket\x20a\
    re\x20stored\x20and\x20determines\x20the\x20SLA\x20and\x20the\x20cost\
    \x20of\x20storage.\n\x20If\x20this\x20value\x20is\x20not\x20specified\
    \x20when\x20the\x20bucket\x20is\x20created,\x20it\x20will\x20default\n\
    \x20to\x20`STANDARD`.\x20For\x20more\x20information,\x20see\n\x20https:/\
    /developers.google.com/storage/docs/storage-classes.\n\n\x0f\n\x05\x04\0\
    \x02\n\x04\x12\x06\xfd\x01\x02\xf5\x01\x17\n\r\n\x05\x04\0\x02\n\x05\x12\
    \x04\xfd\x01\x02\x08\n\r\n\x05\x04\0\x02\n\x01\x12\x04\xfd\x01\t\x16\n\r\
    \n\x05\x04\0\x02\n\x03\x12\x04\xfd\x01\x19\x1b\n\x9f\x01\n\x04\x04\0\x02\
    \x0b\x12\x04\x82\x02\x02\x13\x1a\x90\x01\x20HTTP\x201.1\x20[https://tool\
    s.ietf.org/html/rfc7232#section-2.3\"]Entity\x20tag]\n\x20for\x20the\x20\
    bucket.\n\x20Attempting\x20to\x20set\x20this\x20field\x20will\x20result\
    \x20in\x20an\x20error.\n\n\x0f\n\x05\x04\0\x02\x0b\x04\x12\x06\x82\x02\
    \x02\xfd\x01\x1c\n\r\n\x05\x04\0\x02\x0b\x05\x12\x04\x82\x02\x02\x08\n\r\
    \n\x05\x04\0\x02\x0b\x01\x12\x04\x82\x02\t\r\n\r\n\x05\x04\0\x02\x0b\x03\
    \x12\x04\x82\x02\x10\x12\nk\n\x04\x04\0\x02\x0c\x12\x04\x86\x02\x02)\x1a\
    ]\x20The\x20modification\x20time\x20of\x20the\x20bucket.\n\x20Attempting\
    \x20to\x20set\x20this\x20field\x20will\x20result\x20in\x20an\x20error.\n\
    \n\x0f\n\x05\x04\0\x02\x0c\x04\x12\x06\x86\x02\x02\x82\x02\x13\n\r\n\x05\
    \x04\0\x02\x0c\x06\x12\x04\x86\x02\x02\x1b\n\r\n\x05\x04\0\x02\x0c\x01\
    \x12\x04\x86\x02\x1c#\n\r\n\x05\x04\0\x02\x0c\x03\x12\x04\x86\x02&(\n\
    \x91\x07\n\x04\x04\0\x02\r\x12\x04\x95\x02\x02%\x1a\x82\x07\x20The\x20de\
    fault\x20value\x20for\x20event-based\x20hold\x20on\x20newly\x20created\
    \x20objects\x20in\x20this\n\x20bucket.\x20\x20Event-based\x20hold\x20is\
    \x20a\x20way\x20to\x20retain\x20objects\x20indefinitely\x20until\x20an\n\
    \x20event\x20occurs,\x20signified\x20by\x20the\n\x20hold's\x20release.\
    \x20After\x20being\x20released,\x20such\x20objects\x20will\x20be\x20subj\
    ect\x20to\n\x20bucket-level\x20retention\x20(if\x20any).\x20\x20One\x20s\
    ample\x20use\x20case\x20of\x20this\x20flag\x20is\x20for\n\x20banks\x20to\
    \x20hold\x20loan\x20documents\x20for\x20at\x20least\x203\x20years\x20aft\
    er\x20loan\x20is\x20paid\x20in\n\x20full.\x20Here,\x20bucket-level\x20re\
    tention\x20is\x203\x20years\x20and\x20the\x20event\x20is\x20loan\x20bein\
    g\n\x20paid\x20in\x20full.\x20In\x20this\x20example,\x20these\x20objects\
    \x20will\x20be\x20held\x20intact\x20for\x20any\n\x20number\x20of\x20year\
    s\x20until\x20the\x20event\x20has\x20occurred\x20(event-based\x20hold\
    \x20on\x20the\n\x20object\x20is\x20released)\x20and\x20then\x203\x20more\
    \x20years\x20after\x20that.\x20That\x20means\x20retention\n\x20duration\
    \x20of\x20the\x20objects\x20begins\x20from\x20the\x20moment\x20event-bas\
    ed\x20hold\n\x20transitioned\x20from\x20true\x20to\x20false.\x20\x20Obje\
    cts\x20under\x20event-based\x20hold\x20cannot\x20be\n\x20deleted,\x20ove\
    rwritten\x20or\x20archived\x20until\x20the\x20hold\x20is\x20removed.\n\n\
    \x0f\n\x05\x04\0\x02\r\x04\x12\x06\x95\x02\x02\x86\x02)\n\r\n\x05\x04\0\
    \x02\r\x05\x12\x04\x95\x02\x02\x06\n\r\n\x05\x04\0\x02\r\x01\x12\x04\x95\
    \x02\x07\x1f\n\r\n\x05\x04\0\x02\r\x03\x12\x04\x95\x02\"$\n9\n\x04\x04\0\
    \x02\x0e\x12\x04\x98\x02\x02\"\x1a+\x20User-provided\x20labels,\x20in\
    \x20key/value\x20pairs.\n\n\x0f\n\x05\x04\0\x02\x0e\x04\x12\x06\x98\x02\
    \x02\x95\x02%\n\r\n\x05\x04\0\x02\x0e\x06\x12\x04\x98\x02\x02\x15\n\r\n\
    \x05\x04\0\x02\x0e\x01\x12\x04\x98\x02\x16\x1c\n\r\n\x05\x04\0\x02\x0e\
    \x03\x12\x04\x98\x02\x1f!\n\xf7\x01\n\x04\x04\0\x02\x0f\x12\x04\x9e\x02\
    \x02\x17\x1a\xe8\x01\x20The\x20bucket's\x20website\x20configuration,\x20\
    controlling\x20how\x20the\x20service\x20behaves\n\x20when\x20accessing\
    \x20bucket\x20contents\x20as\x20a\x20web\x20site.\x20See\x20the\n\x20[ht\
    tps://cloud.google.com/storage/docs/static-website][Static\x20Website\n\
    \x20Examples]\x20for\x20more\x20information.\n\n\x0f\n\x05\x04\0\x02\x0f\
    \x04\x12\x06\x9e\x02\x02\x98\x02\"\n\r\n\x05\x04\0\x02\x0f\x06\x12\x04\
    \x9e\x02\x02\t\n\r\n\x05\x04\0\x02\x0f\x01\x12\x04\x9e\x02\n\x11\n\r\n\
    \x05\x04\0\x02\x0f\x03\x12\x04\x9e\x02\x14\x16\n6\n\x04\x04\0\x02\x10\
    \x12\x04\xa1\x02\x02\x1d\x1a(\x20The\x20bucket's\x20versioning\x20config\
    uration.\n\n\x0f\n\x05\x04\0\x02\x10\x04\x12\x06\xa1\x02\x02\x9e\x02\x17\
    \n\r\n\x05\x04\0\x02\x10\x06\x12\x04\xa1\x02\x02\x0c\n\r\n\x05\x04\0\x02\
    \x10\x01\x12\x04\xa1\x02\r\x17\n\r\n\x05\x04\0\x02\x10\x03\x12\x04\xa1\
    \x02\x1a\x1c\n\x92\x01\n\x04\x04\0\x02\x11\x12\x04\xa5\x02\x02\x17\x1a\
    \x83\x01\x20The\x20bucket's\x20logging\x20configuration,\x20which\x20def\
    ines\x20the\x20destination\x20bucket\n\x20and\x20optional\x20name\x20pre\
    fix\x20for\x20the\x20current\x20bucket's\x20logs.\n\n\x0f\n\x05\x04\0\
    \x02\x11\x04\x12\x06\xa5\x02\x02\xa1\x02\x1d\n\r\n\x05\x04\0\x02\x11\x06\
    \x12\x04\xa5\x02\x02\t\n\r\n\x05\x04\0\x02\x11\x01\x12\x04\xa5\x02\n\x11\
    \n\r\n\x05\x04\0\x02\x11\x03\x12\x04\xa5\x02\x14\x16\nW\n\x04\x04\0\x02\
    \x12\x12\x04\xa8\x02\x02\x13\x1aI\x20The\x20owner\x20of\x20the\x20bucket\
    .\x20This\x20is\x20always\x20the\x20project\x20team's\x20owner\x20group.\
    \n\n\x0f\n\x05\x04\0\x02\x12\x04\x12\x06\xa8\x02\x02\xa5\x02\x17\n\r\n\
    \x05\x04\0\x02\x12\x06\x12\x04\xa8\x02\x02\x07\n\r\n\x05\x04\0\x02\x12\
    \x01\x12\x04\xa8\x02\x08\r\n\r\n\x05\x04\0\x02\x12\x03\x12\x04\xa8\x02\
    \x10\x12\n6\n\x04\x04\0\x02\x13\x12\x04\xab\x02\x02\x1d\x1a(\x20Encrypti\
    on\x20configuration\x20for\x20a\x20bucket.\n\n\x0f\n\x05\x04\0\x02\x13\
    \x04\x12\x06\xab\x02\x02\xa8\x02\x13\n\r\n\x05\x04\0\x02\x13\x06\x12\x04\
    \xab\x02\x02\x0c\n\r\n\x05\x04\0\x02\x13\x01\x12\x04\xab\x02\r\x17\n\r\n\
    \x05\x04\0\x02\x13\x03\x12\x04\xab\x02\x1a\x1c\n3\n\x04\x04\0\x02\x14\
    \x12\x04\xae\x02\x02\x17\x1a%\x20The\x20bucket's\x20billing\x20configura\
    tion.\n\n\x0f\n\x05\x04\0\x02\x14\x04\x12\x06\xae\x02\x02\xab\x02\x1d\n\
    \r\n\x05\x04\0\x02\x14\x06\x12\x04\xae\x02\x02\t\n\r\n\x05\x04\0\x02\x14\
    \x01\x12\x04\xae\x02\n\x11\n\r\n\x05\x04\0\x02\x14\x03\x12\x04\xae\x02\
    \x14\x16\n\xf1\x04\n\x04\x04\0\x02\x15\x12\x04\xb9\x02\x02(\x1a\xe2\x04\
    \x20The\x20bucket's\x20retention\x20policy.\x20The\x20retention\x20polic\
    y\x20enforces\x20a\x20minimum\n\x20retention\x20time\x20for\x20all\x20ob\
    jects\x20contained\x20in\x20the\x20bucket,\x20based\x20on\x20their\n\x20\
    creation\x20time.\x20Any\x20attempt\x20to\x20overwrite\x20or\x20delete\
    \x20objects\x20younger\x20than\x20the\n\x20retention\x20period\x20will\
    \x20result\x20in\x20a\x20PERMISSION_DENIED\x20error.\x20\x20An\x20unlock\
    ed\n\x20retention\x20policy\x20can\x20be\x20modified\x20or\x20removed\
    \x20from\x20the\x20bucket\x20via\x20a\n\x20storage.buckets.update\x20ope\
    ration.\x20A\x20locked\x20retention\x20policy\x20cannot\x20be\n\x20remov\
    ed\x20or\x20shortened\x20in\x20duration\x20for\x20the\x20lifetime\x20of\
    \x20the\x20bucket.\n\x20Attempting\x20to\x20remove\x20or\x20decrease\x20\
    period\x20of\x20a\x20locked\x20retention\x20policy\x20will\n\x20result\
    \x20in\x20a\x20PERMISSION_DENIED\x20error.\n\n\x0f\n\x05\x04\0\x02\x15\
    \x04\x12\x06\xb9\x02\x02\xae\x02\x17\n\r\n\x05\x04\0\x02\x15\x06\x12\x04\
    \xb9\x02\x02\x11\n\r\n\x05\x04\0\x02\x15\x01\x12\x04\xb9\x02\x12\"\n\r\n\
    \x05\x04\0\x02\x15\x03\x12\x04\xb9\x02%'\nY\n\x04\x04\0\x02\x16\x12\x04\
    \xbc\x02\x02\x1c\x1aK\x20The\x20location\x20type\x20of\x20the\x20bucket\
    \x20(region,\x20dual-region,\x20multi-region,\x20etc).\n\n\x0f\n\x05\x04\
    \0\x02\x16\x04\x12\x06\xbc\x02\x02\xb9\x02(\n\r\n\x05\x04\0\x02\x16\x05\
    \x12\x04\xbc\x02\x02\x08\n\r\n\x05\x04\0\x02\x16\x01\x12\x04\xbc\x02\t\
    \x16\n\r\n\x05\x04\0\x02\x16\x03\x12\x04\xbc\x02\x19\x1b\n/\n\x04\x04\0\
    \x02\x17\x12\x04\xbf\x02\x02*\x1a!\x20The\x20bucket's\x20IAM\x20configur\
    ation.\n\n\x0f\n\x05\x04\0\x02\x17\x04\x12\x06\xbf\x02\x02\xbc\x02\x1c\n\
    \r\n\x05\x04\0\x02\x17\x06\x12\x04\xbf\x02\x02\x12\n\r\n\x05\x04\0\x02\
    \x17\x01\x12\x04\xbf\x02\x13$\n\r\n\x05\x04\0\x02\x17\x03\x12\x04\xbf\
    \x02')\n\xc0\x02\n\x04\x04\0\x02\x18\x12\x04\xc6\x02\x02%\x1a\xb1\x02\
    \x20The\x20zone\x20or\x20zones\x20from\x20which\x20the\x20bucket\x20is\
    \x20intended\x20to\x20use\x20zonal\x20quota.\n\x20Requests\x20for\x20dat\
    a\x20from\x20outside\x20the\x20specified\x20affinities\x20are\x20still\
    \x20allowed\n\x20but\x20won\xe2\x80\x99t\x20be\x20able\x20to\x20use\x20z\
    onal\x20quota.\x20The\x20values\x20are\x20case-insensitive.\n\x20Attempt\
    ing\x20to\x20update\x20this\x20field\x20after\x20bucket\x20is\x20created\
    \x20will\x20result\x20in\x20an\n\x20error.\n\n\r\n\x05\x04\0\x02\x18\x04\
    \x12\x04\xc6\x02\x02\n\n\r\n\x05\x04\0\x02\x18\x05\x12\x04\xc6\x02\x0b\
    \x11\n\r\n\x05\x04\0\x02\x18\x01\x12\x04\xc6\x02\x12\x1f\n\r\n\x05\x04\0\
    \x02\x18\x03\x12\x04\xc6\x02\"$\n(\n\x02\x04\x01\x12\x06\xca\x02\0\xf4\
    \x02\x01\x1a\x1a\x20An\x20access-control\x20entry.\n\n\x0b\n\x03\x04\x01\
    \x01\x12\x04\xca\x02\x08\x1b\n5\n\x04\x04\x01\x02\0\x12\x04\xcc\x02\x02\
    \x12\x1a'\x20The\x20access\x20permission\x20for\x20the\x20entity.\n\n\
    \x0f\n\x05\x04\x01\x02\0\x04\x12\x06\xcc\x02\x02\xca\x02\x1d\n\r\n\x05\
    \x04\x01\x02\0\x05\x12\x04\xcc\x02\x02\x08\n\r\n\x05\x04\x01\x02\0\x01\
    \x12\x04\xcc\x02\t\r\n\r\n\x05\x04\x01\x02\0\x03\x12\x04\xcc\x02\x10\x11\
    \nv\n\x04\x04\x01\x02\x01\x12\x04\xd0\x02\x02\x12\x1ah\x20HTTP\x201.1\
    \x20[\"https://tools.ietf.org/html/rfc7232#section-2.3][Entity\x20tag]\n\
    \x20for\x20the\x20access-control\x20entry.\n\n\x0f\n\x05\x04\x01\x02\x01\
    \x04\x12\x06\xd0\x02\x02\xcc\x02\x12\n\r\n\x05\x04\x01\x02\x01\x05\x12\
    \x04\xd0\x02\x02\x08\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\xd0\x02\t\r\n\
    \r\n\x05\x04\x01\x02\x01\x03\x12\x04\xd0\x02\x10\x11\n3\n\x04\x04\x01\
    \x02\x02\x12\x04\xd3\x02\x02\x10\x1a%\x20The\x20ID\x20of\x20the\x20acces\
    s-control\x20entry.\n\n\x0f\n\x05\x04\x01\x02\x02\x04\x12\x06\xd3\x02\
    \x02\xd0\x02\x12\n\r\n\x05\x04\x01\x02\x02\x05\x12\x04\xd3\x02\x02\x08\n\
    \r\n\x05\x04\x01\x02\x02\x01\x12\x04\xd3\x02\t\x0b\n\r\n\x05\x04\x01\x02\
    \x02\x03\x12\x04\xd3\x02\x0e\x0f\n'\n\x04\x04\x01\x02\x03\x12\x04\xd6\
    \x02\x02\x14\x1a\x19\x20The\x20name\x20of\x20the\x20bucket.\n\n\x0f\n\
    \x05\x04\x01\x02\x03\x04\x12\x06\xd6\x02\x02\xd3\x02\x10\n\r\n\x05\x04\
    \x01\x02\x03\x05\x12\x04\xd6\x02\x02\x08\n\r\n\x05\x04\x01\x02\x03\x01\
    \x12\x04\xd6\x02\t\x0f\n\r\n\x05\x04\x01\x02\x03\x03\x12\x04\xd6\x02\x12\
    \x13\n\xfb\x03\n\x04\x04\x01\x02\x04\x12\x04\xe7\x02\x02\x14\x1a\xec\x03\
    \x20The\x20entity\x20holding\x20the\x20permission,\x20in\x20one\x20of\
    \x20the\x20following\x20forms:\n\x20*\x20`user-{userid}`\n\x20*\x20`user\
    -{email}`\n\x20*\x20`group-{groupid}`\n\x20*\x20`group-{email}`\n\x20*\
    \x20`domain-{domain}`\n\x20*\x20`project-{team-projectid}`\n\x20*\x20`al\
    lUsers`\n\x20*\x20`allAuthenticatedUsers`\n\x20Examples:\n\x20*\x20The\
    \x20user\x20`liz@example.com`\x20would\x20be\x20`user-liz@example.com`.\
    \n\x20*\x20The\x20group\x20`example@googlegroups.com`\x20would\x20be\n\
    \x20`group-example@googlegroups.com`\n\x20*\x20All\x20members\x20of\x20t\
    he\x20Google\x20Apps\x20for\x20Business\x20domain\x20`example.com`\x20wo\
    uld\x20be\n\x20`domain-example.com`\n\n\x0f\n\x05\x04\x01\x02\x04\x04\
    \x12\x06\xe7\x02\x02\xd6\x02\x14\n\r\n\x05\x04\x01\x02\x04\x05\x12\x04\
    \xe7\x02\x02\x08\n\r\n\x05\x04\x01\x02\x04\x01\x12\x04\xe7\x02\t\x0f\n\r\
    \n\x05\x04\x01\x02\x04\x03\x12\x04\xe7\x02\x12\x13\n.\n\x04\x04\x01\x02\
    \x05\x12\x04\xea\x02\x02\x17\x1a\x20\x20The\x20ID\x20for\x20the\x20entit\
    y,\x20if\x20any.\n\n\x0f\n\x05\x04\x01\x02\x05\x04\x12\x06\xea\x02\x02\
    \xe7\x02\x14\n\r\n\x05\x04\x01\x02\x05\x05\x12\x04\xea\x02\x02\x08\n\r\n\
    \x05\x04\x01\x02\x05\x01\x12\x04\xea\x02\t\x12\n\r\n\x05\x04\x01\x02\x05\
    \x03\x12\x04\xea\x02\x15\x16\nE\n\x04\x04\x01\x02\x06\x12\x04\xed\x02\
    \x02\x13\x1a7\x20The\x20email\x20address\x20associated\x20with\x20the\
    \x20entity,\x20if\x20any.\n\n\x0f\n\x05\x04\x01\x02\x06\x04\x12\x06\xed\
    \x02\x02\xea\x02\x17\n\r\n\x05\x04\x01\x02\x06\x05\x12\x04\xed\x02\x02\
    \x08\n\r\n\x05\x04\x01\x02\x06\x01\x12\x04\xed\x02\t\x0e\n\r\n\x05\x04\
    \x01\x02\x06\x03\x12\x04\xed\x02\x11\x12\n>\n\x04\x04\x01\x02\x07\x12\
    \x04\xf0\x02\x02\x14\x1a0\x20The\x20domain\x20associated\x20with\x20the\
    \x20entity,\x20if\x20any.\n\n\x0f\n\x05\x04\x01\x02\x07\x04\x12\x06\xf0\
    \x02\x02\xed\x02\x13\n\r\n\x05\x04\x01\x02\x07\x05\x12\x04\xf0\x02\x02\
    \x08\n\r\n\x05\x04\x01\x02\x07\x01\x12\x04\xf0\x02\t\x0f\n\r\n\x05\x04\
    \x01\x02\x07\x03\x12\x04\xf0\x02\x12\x13\nD\n\x04\x04\x01\x02\x08\x12\
    \x04\xf3\x02\x02\x20\x1a6\x20The\x20project\x20team\x20associated\x20wit\
    h\x20the\x20entity,\x20if\x20any.\n\n\x0f\n\x05\x04\x01\x02\x08\x04\x12\
    \x06\xf3\x02\x02\xf0\x02\x14\n\r\n\x05\x04\x01\x02\x08\x06\x12\x04\xf3\
    \x02\x02\r\n\r\n\x05\x04\x01\x02\x08\x01\x12\x04\xf3\x02\x0e\x1a\n\r\n\
    \x05\x04\x01\x02\x08\x03\x12\x04\xf3\x02\x1d\x1f\nX\n\x02\x04\x02\x12\
    \x06\xf7\x02\0\xfa\x02\x01\x1aJ\x20The\x20response\x20to\x20a\x20call\
    \x20to\x20BucketAccessControls.ListBucketAccessControls.\n\n\x0b\n\x03\
    \x04\x02\x01\x12\x04\xf7\x02\x08(\n\"\n\x04\x04\x02\x02\0\x12\x04\xf9\
    \x02\x02)\x1a\x14\x20The\x20list\x20of\x20items.\n\n\r\n\x05\x04\x02\x02\
    \0\x04\x12\x04\xf9\x02\x02\n\n\r\n\x05\x04\x02\x02\0\x06\x12\x04\xf9\x02\
    \x0b\x1e\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\xf9\x02\x1f$\n\r\n\x05\x04\
    \x02\x02\0\x03\x12\x04\xf9\x02'(\n;\n\x02\x04\x03\x12\x06\xfd\x02\0\x84\
    \x03\x01\x1a-\x20The\x20result\x20of\x20a\x20call\x20to\x20Buckets.ListB\
    uckets\n\n\x0b\n\x03\x04\x03\x01\x12\x04\xfd\x02\x08\x1b\n\"\n\x04\x04\
    \x03\x02\0\x12\x04\xff\x02\x02\x1c\x1a\x14\x20The\x20list\x20of\x20items\
    .\n\n\r\n\x05\x04\x03\x02\0\x04\x12\x04\xff\x02\x02\n\n\r\n\x05\x04\x03\
    \x02\0\x06\x12\x04\xff\x02\x0b\x11\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\
    \xff\x02\x12\x17\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\xff\x02\x1a\x1b\n\
    \xa0\x01\n\x04\x04\x03\x02\x01\x12\x04\x83\x03\x02\x1d\x1a\x91\x01\x20Th\
    e\x20continuation\x20token,\x20used\x20to\x20page\x20through\x20large\
    \x20result\x20sets.\x20Provide\n\x20this\x20value\x20in\x20a\x20subseque\
    nt\x20request\x20to\x20return\x20the\x20next\x20page\x20of\x20results.\n\
    \n\x0f\n\x05\x04\x03\x02\x01\x04\x12\x06\x83\x03\x02\xff\x02\x1c\n\r\n\
    \x05\x04\x03\x02\x01\x05\x12\x04\x83\x03\x02\x08\n\r\n\x05\x04\x03\x02\
    \x01\x01\x12\x04\x83\x03\t\x18\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\x83\
    \x03\x1b\x1c\nK\n\x02\x04\x04\x12\x06\x87\x03\0\xa4\x03\x01\x1a=\x20An\
    \x20notification\x20channel\x20used\x20to\x20watch\x20for\x20resource\
    \x20changes.\n\n\x0b\n\x03\x04\x04\x01\x12\x04\x87\x03\x08\x0f\nM\n\x04\
    \x04\x04\x02\0\x12\x04\x89\x03\x02\x10\x1a?\x20A\x20UUID\x20or\x20simila\
    r\x20unique\x20string\x20that\x20identifies\x20this\x20channel.\n\n\x0f\
    \n\x05\x04\x04\x02\0\x04\x12\x06\x89\x03\x02\x87\x03\x11\n\r\n\x05\x04\
    \x04\x02\0\x05\x12\x04\x89\x03\x02\x08\n\r\n\x05\x04\x04\x02\0\x01\x12\
    \x04\x89\x03\t\x0b\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\x89\x03\x0e\x0f\n\
    \x7f\n\x04\x04\x04\x02\x01\x12\x04\x8d\x03\x02\x19\x1aq\x20An\x20opaque\
    \x20ID\x20that\x20identifies\x20the\x20resource\x20being\x20watched\x20o\
    n\x20this\x20channel.\n\x20Stable\x20across\x20different\x20API\x20versi\
    ons.\n\n\x0f\n\x05\x04\x04\x02\x01\x04\x12\x06\x8d\x03\x02\x89\x03\x10\n\
    \r\n\x05\x04\x04\x02\x01\x05\x12\x04\x8d\x03\x02\x08\n\r\n\x05\x04\x04\
    \x02\x01\x01\x12\x04\x8d\x03\t\x14\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\
    \x8d\x03\x17\x18\nG\n\x04\x04\x04\x02\x02\x12\x04\x90\x03\x02\x1a\x1a9\
    \x20A\x20version-specific\x20identifier\x20for\x20the\x20watched\x20reso\
    urce.\n\n\x0f\n\x05\x04\x04\x02\x02\x04\x12\x06\x90\x03\x02\x8d\x03\x19\
    \n\r\n\x05\x04\x04\x02\x02\x05\x12\x04\x90\x03\x02\x08\n\r\n\x05\x04\x04\
    \x02\x02\x01\x12\x04\x90\x03\t\x15\n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\
    \x90\x03\x18\x19\n\x82\x01\n\x04\x04\x04\x02\x03\x12\x04\x94\x03\x02\x13\
    \x1at\x20An\x20arbitrary\x20string\x20delivered\x20to\x20the\x20target\
    \x20address\x20with\x20each\x20notification\n\x20delivered\x20over\x20th\
    is\x20channel.\x20Optional.\n\n\x0f\n\x05\x04\x04\x02\x03\x04\x12\x06\
    \x94\x03\x02\x90\x03\x1a\n\r\n\x05\x04\x04\x02\x03\x05\x12\x04\x94\x03\
    \x02\x08\n\r\n\x05\x04\x04\x02\x03\x01\x12\x04\x94\x03\t\x0e\n\r\n\x05\
    \x04\x04\x02\x03\x03\x12\x04\x94\x03\x11\x12\nK\n\x04\x04\x04\x02\x04\
    \x12\x04\x97\x03\x02+\x1a=\x20Date\x20and\x20time\x20of\x20notification\
    \x20channel\x20expiration.\x20Optional.\n\n\x0f\n\x05\x04\x04\x02\x04\
    \x04\x12\x06\x97\x03\x02\x94\x03\x13\n\r\n\x05\x04\x04\x02\x04\x06\x12\
    \x04\x97\x03\x02\x1b\n\r\n\x05\x04\x04\x02\x04\x01\x12\x04\x97\x03\x1c&\
    \n\r\n\x05\x04\x04\x02\x04\x03\x12\x04\x97\x03)*\nE\n\x04\x04\x04\x02\
    \x05\x12\x04\x9a\x03\x02\x12\x1a7\x20The\x20type\x20of\x20delivery\x20me\
    chanism\x20used\x20for\x20this\x20channel.\n\n\x0f\n\x05\x04\x04\x02\x05\
    \x04\x12\x06\x9a\x03\x02\x97\x03+\n\r\n\x05\x04\x04\x02\x05\x05\x12\x04\
    \x9a\x03\x02\x08\n\r\n\x05\x04\x04\x02\x05\x01\x12\x04\x9a\x03\t\r\n\r\n\
    \x05\x04\x04\x02\x05\x03\x12\x04\x9a\x03\x10\x11\nO\n\x04\x04\x04\x02\
    \x06\x12\x04\x9d\x03\x02\x15\x1aA\x20The\x20address\x20where\x20notifica\
    tions\x20are\x20delivered\x20for\x20this\x20channel.\n\n\x0f\n\x05\x04\
    \x04\x02\x06\x04\x12\x06\x9d\x03\x02\x9a\x03\x12\n\r\n\x05\x04\x04\x02\
    \x06\x05\x12\x04\x9d\x03\x02\x08\n\r\n\x05\x04\x04\x02\x06\x01\x12\x04\
    \x9d\x03\t\x10\n\r\n\x05\x04\x04\x02\x06\x03\x12\x04\x9d\x03\x13\x14\nV\
    \n\x04\x04\x04\x02\x07\x12\x04\xa0\x03\x02!\x1aH\x20Additional\x20parame\
    ters\x20controlling\x20delivery\x20channel\x20behavior.\x20Optional.\n\n\
    \x0f\n\x05\x04\x04\x02\x07\x04\x12\x06\xa0\x03\x02\x9d\x03\x15\n\r\n\x05\
    \x04\x04\x02\x07\x06\x12\x04\xa0\x03\x02\x15\n\r\n\x05\x04\x04\x02\x07\
    \x01\x12\x04\xa0\x03\x16\x1c\n\r\n\x05\x04\x04\x02\x07\x03\x12\x04\xa0\
    \x03\x1f\x20\nP\n\x04\x04\x04\x02\x08\x12\x04\xa3\x03\x02\x13\x1aB\x20A\
    \x20Boolean\x20value\x20to\x20indicate\x20whether\x20payload\x20is\x20wa\
    nted.\x20Optional.\n\n\x0f\n\x05\x04\x04\x02\x08\x04\x12\x06\xa3\x03\x02\
    \xa0\x03!\n\r\n\x05\x04\x04\x02\x08\x05\x12\x04\xa3\x03\x02\x06\n\r\n\
    \x05\x04\x04\x02\x08\x01\x12\x04\xa3\x03\x07\x0e\n\r\n\x05\x04\x04\x02\
    \x08\x03\x12\x04\xa3\x03\x11\x12\n=\n\x02\x04\x05\x12\x06\xa7\x03\0\xbc\
    \x03\x01\x1a/\x20The\x20result\x20of\x20a\x20call\x20to\x20Channels.List\
    Channels\n\n\x0b\n\x03\x04\x05\x01\x12\x04\xa7\x03\x08\x1c\n\x0e\n\x04\
    \x04\x05\x03\0\x12\x06\xa8\x03\x02\xb8\x03\x03\n\r\n\x05\x04\x05\x03\0\
    \x01\x12\x04\xa8\x03\n\x0f\nK\n\x06\x04\x05\x03\0\x02\0\x12\x04\xaa\x03\
    \x04\x1a\x1a;\x20User-specified\x20name\x20for\x20a\x20channel.\x20Neede\
    d\x20to\x20unsubscribe.\n\n\x11\n\x07\x04\x05\x03\0\x02\0\x04\x12\x06\
    \xaa\x03\x04\xa8\x03\x11\n\x0f\n\x07\x04\x05\x03\0\x02\0\x05\x12\x04\xaa\
    \x03\x04\n\n\x0f\n\x07\x04\x05\x03\0\x02\0\x01\x12\x04\xaa\x03\x0b\x15\n\
    \x0f\n\x07\x04\x05\x03\0\x02\0\x03\x12\x04\xaa\x03\x18\x19\n^\n\x06\x04\
    \x05\x03\0\x02\x01\x12\x04\xae\x03\x04\x1b\x1aN\x20Opaque\x20value\x20ge\
    nerated\x20by\x20GCS\x20representing\x20a\x20bucket.\x20Needed\x20to\n\
    \x20unsubscribe.\n\n\x11\n\x07\x04\x05\x03\0\x02\x01\x04\x12\x06\xae\x03\
    \x04\xaa\x03\x1a\n\x0f\n\x07\x04\x05\x03\0\x02\x01\x05\x12\x04\xae\x03\
    \x04\n\n\x0f\n\x07\x04\x05\x03\0\x02\x01\x01\x12\x04\xae\x03\x0b\x16\n\
    \x0f\n\x07\x04\x05\x03\0\x02\x01\x03\x12\x04\xae\x03\x19\x1a\nG\n\x06\
    \x04\x05\x03\0\x02\x02\x12\x04\xb1\x03\x04\x18\x1a7\x20Url\x20used\x20to\
    \x20identify\x20where\x20notifications\x20are\x20sent\x20to.\n\n\x11\n\
    \x07\x04\x05\x03\0\x02\x02\x04\x12\x06\xb1\x03\x04\xae\x03\x1b\n\x0f\n\
    \x07\x04\x05\x03\0\x02\x02\x05\x12\x04\xb1\x03\x04\n\n\x0f\n\x07\x04\x05\
    \x03\0\x02\x02\x01\x12\x04\xb1\x03\x0b\x13\n\x0f\n\x07\x04\x05\x03\0\x02\
    \x02\x03\x12\x04\xb1\x03\x16\x17\n2\n\x06\x04\x05\x03\0\x02\x03\x12\x04\
    \xb4\x03\x04\x20\x1a\"\x20Email\x20address\x20of\x20the\x20subscriber.\n\
    \n\x11\n\x07\x04\x05\x03\0\x02\x03\x04\x12\x06\xb4\x03\x04\xb1\x03\x18\n\
    \x0f\n\x07\x04\x05\x03\0\x02\x03\x05\x12\x04\xb4\x03\x04\n\n\x0f\n\x07\
    \x04\x05\x03\0\x02\x03\x01\x12\x04\xb4\x03\x0b\x1b\n\x0f\n\x07\x04\x05\
    \x03\0\x02\x03\x03\x12\x04\xb4\x03\x1e\x1f\n4\n\x06\x04\x05\x03\0\x02\
    \x04\x12\x04\xb7\x03\x040\x1a$\x20Time\x20when\x20the\x20channel\x20was\
    \x20created.\n\n\x11\n\x07\x04\x05\x03\0\x02\x04\x04\x12\x06\xb7\x03\x04\
    \xb4\x03\x20\n\x0f\n\x07\x04\x05\x03\0\x02\x04\x06\x12\x04\xb7\x03\x04\
    \x1d\n\x0f\n\x07\x04\x05\x03\0\x02\x04\x01\x12\x04\xb7\x03\x1e+\n\x0f\n\
    \x07\x04\x05\x03\0\x02\x04\x03\x12\x04\xb7\x03./\n?\n\x04\x04\x05\x02\0\
    \x12\x04\xbb\x03\x02\x1b\x1a1\x20The\x20list\x20of\x20notification\x20ch\
    annels\x20for\x20a\x20bucket.\n\n\r\n\x05\x04\x05\x02\0\x04\x12\x04\xbb\
    \x03\x02\n\n\r\n\x05\x04\x05\x02\0\x06\x12\x04\xbb\x03\x0b\x10\n\r\n\x05\
    \x04\x05\x02\0\x01\x12\x04\xbb\x03\x11\x16\n\r\n\x05\x04\x05\x02\0\x03\
    \x12\x04\xbb\x03\x19\x1a\n_\n\x02\x04\x06\x12\x06\xc0\x03\0\xc6\x03\x01\
    \x1aQ\x20Message\x20used\x20to\x20convey\x20content\x20being\x20read\x20\
    or\x20written,\x20along\x20with\x20its\n\x20checksum.\n\n\x0b\n\x03\x04\
    \x06\x01\x12\x04\xc0\x03\x08\x17\n\x19\n\x04\x04\x06\x02\0\x12\x04\xc2\
    \x03\x02\x14\x1a\x0b\x20The\x20data.\n\n\x0f\n\x05\x04\x06\x02\0\x04\x12\
    \x06\xc2\x03\x02\xc0\x03\x19\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\xc2\x03\
    \x02\x07\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xc2\x03\x08\x0f\n\r\n\x05\
    \x04\x06\x02\0\x03\x12\x04\xc2\x03\x12\x13\n.\n\x04\x04\x06\x02\x01\x12\
    \x04\xc5\x03\x02)\x1a\x20\x20CRC32C\x20digest\x20of\x20the\x20contents.\
    \n\n\x0f\n\x05\x04\x06\x02\x01\x04\x12\x06\xc5\x03\x02\xc2\x03\x14\n\r\n\
    \x05\x04\x06\x02\x01\x06\x12\x04\xc5\x03\x02\x1d\n\r\n\x05\x04\x06\x02\
    \x01\x01\x12\x04\xc5\x03\x1e$\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xc5\
    \x03'(\nN\n\x02\x04\x07\x12\x06\xc9\x03\0\xd2\x03\x01\x1a@\x20Message\
    \x20used\x20for\x20storing\x20full\x20(not\x20subrange)\x20object\x20che\
    cksums.\n\n\x0b\n\x03\x04\x07\x01\x12\x04\xc9\x03\x08\x17\n\xcf\x01\n\
    \x04\x04\x07\x02\0\x12\x04\xcd\x03\x02)\x1a\xc0\x01\x20CRC32C\x20digest\
    \x20of\x20the\x20object\x20data.\x20Computed\x20by\x20the\x20GCS\x20serv\
    ice\x20for\n\x20all\x20written\x20objects,\x20and\x20validated\x20by\x20\
    the\x20GCS\x20service\x20against\n\x20client-supplied\x20values\x20if\
    \x20present\x20in\x20an\x20InsertObjectRequest.\n\n\x0f\n\x05\x04\x07\
    \x02\0\x04\x12\x06\xcd\x03\x02\xc9\x03\x19\n\r\n\x05\x04\x07\x02\0\x06\
    \x12\x04\xcd\x03\x02\x1d\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xcd\x03\x1e\
    $\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xcd\x03'(\n\x90\x01\n\x04\x04\x07\
    \x02\x01\x12\x04\xd1\x03\x02\x16\x1a\x81\x01\x20Hex-encoded\x20MD5\x20ha\
    sh\x20of\x20the\x20object\x20data\x20(hexdigest).\x20Whether/how\x20this\
    \n\x20checksum\x20is\x20provided\x20and\x20validated\x20is\x20service-de\
    pendent.\n\n\x0f\n\x05\x04\x07\x02\x01\x04\x12\x06\xd1\x03\x02\xcd\x03)\
    \n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\xd1\x03\x02\x08\n\r\n\x05\x04\x07\
    \x02\x01\x01\x12\x04\xd1\x03\t\x11\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\
    \xd1\x03\x14\x15\nQ\n\x02\x04\x08\x12\x06\xd5\x03\0\x98\x04\x01\x1aC\x20\
    A\x20collection\x20of\x20enums\x20used\x20in\x20multiple\x20places\x20th\
    roughout\x20the\x20API.\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xd5\x03\x08\
    \x13\n>\n\x04\x04\x08\x04\0\x12\x06\xd7\x03\x02\xe0\x03\x03\x1a.\x20A\
    \x20set\x20of\x20properties\x20to\x20return\x20in\x20a\x20response.\n\n\
    \r\n\x05\x04\x08\x04\0\x01\x12\x04\xd7\x03\x07\x11\n*\n\x06\x04\x08\x04\
    \0\x02\0\x12\x04\xd9\x03\x04\x1f\x1a\x1a\x20No\x20specified\x20projectio\
    n.\n\n\x0f\n\x07\x04\x08\x04\0\x02\0\x01\x12\x04\xd9\x03\x04\x1a\n\x0f\n\
    \x07\x04\x08\x04\0\x02\0\x02\x12\x04\xd9\x03\x1d\x1e\nI\n\x06\x04\x08\
    \x04\0\x02\x01\x12\x04\xdc\x03\x04\x0f\x1a9\x20Omit\x20`owner`,\x20`acl`\
    ,\x20and\x20`defaultObjectAcl`\x20properties.\n\n\x0f\n\x07\x04\x08\x04\
    \0\x02\x01\x01\x12\x04\xdc\x03\x04\n\n\x0f\n\x07\x04\x08\x04\0\x02\x01\
    \x02\x12\x04\xdc\x03\r\x0e\n)\n\x06\x04\x08\x04\0\x02\x02\x12\x04\xdf\
    \x03\x04\r\x1a\x19\x20Include\x20all\x20properties.\n\n\x0f\n\x07\x04\
    \x08\x04\0\x02\x02\x01\x12\x04\xdf\x03\x04\x08\n\x0f\n\x07\x04\x08\x04\0\
    \x02\x02\x02\x12\x04\xdf\x03\x0b\x0c\nY\n\x04\x04\x08\x04\x01\x12\x06\
    \xe3\x03\x02\xf8\x03\x03\x1aI\x20Predefined\x20or\x20\"canned\"\x20alias\
    es\x20for\x20sets\x20of\x20specific\x20bucket\x20ACL\x20entries.\n\n\r\n\
    \x05\x04\x08\x04\x01\x01\x12\x04\xe3\x03\x07\x1a\n$\n\x06\x04\x08\x04\
    \x01\x02\0\x12\x04\xe5\x03\x04*\x1a\x14\x20No\x20predefined\x20ACL.\n\n\
    \x0f\n\x07\x04\x08\x04\x01\x02\0\x01\x12\x04\xe5\x03\x04%\n\x0f\n\x07\
    \x04\x08\x04\x01\x02\0\x02\x12\x04\xe5\x03()\nk\n\x06\x04\x08\x04\x01\
    \x02\x01\x12\x04\xe9\x03\x04&\x1a[\x20Project\x20team\x20owners\x20get\
    \x20`OWNER`\x20access,\x20and\n\x20`allAuthenticatedUsers`\x20get\x20`RE\
    ADER`\x20access.\n\n\x0f\n\x07\x04\x08\x04\x01\x02\x01\x01\x12\x04\xe9\
    \x03\x04!\n\x0f\n\x07\x04\x08\x04\x01\x02\x01\x02\x12\x04\xe9\x03$%\n9\n\
    \x06\x04\x08\x04\x01\x02\x02\x12\x04\xec\x03\x04\x1b\x1a)\x20Project\x20\
    team\x20owners\x20get\x20`OWNER`\x20access.\n\n\x0f\n\x07\x04\x08\x04\
    \x01\x02\x02\x01\x12\x04\xec\x03\x04\x16\n\x0f\n\x07\x04\x08\x04\x01\x02\
    \x02\x02\x12\x04\xec\x03\x19\x1a\nK\n\x06\x04\x08\x04\x01\x02\x03\x12\
    \x04\xef\x03\x04#\x1a;\x20Project\x20team\x20members\x20get\x20access\
    \x20according\x20to\x20their\x20roles.\n\n\x0f\n\x07\x04\x08\x04\x01\x02\
    \x03\x01\x12\x04\xef\x03\x04\x1e\n\x0f\n\x07\x04\x08\x04\x01\x02\x03\x02\
    \x12\x04\xef\x03!\"\n^\n\x06\x04\x08\x04\x01\x02\x04\x12\x04\xf3\x03\x04\
    \x1f\x1aN\x20Project\x20team\x20owners\x20get\x20`OWNER`\x20access,\x20a\
    nd\n\x20`allUsers`\x20get\x20`READER`\x20access.\n\n\x0f\n\x07\x04\x08\
    \x04\x01\x02\x04\x01\x12\x04\xf3\x03\x04\x1a\n\x0f\n\x07\x04\x08\x04\x01\
    \x02\x04\x02\x12\x04\xf3\x03\x1d\x1e\n^\n\x06\x04\x08\x04\x01\x02\x05\
    \x12\x04\xf7\x03\x04%\x1aN\x20Project\x20team\x20owners\x20get\x20`OWNER\
    `\x20access,\x20and\n\x20`allUsers`\x20get\x20`WRITER`\x20access.\n\n\
    \x0f\n\x07\x04\x08\x04\x01\x02\x05\x01\x12\x04\xf7\x03\x04\x20\n\x0f\n\
    \x07\x04\x08\x04\x01\x02\x05\x02\x12\x04\xf7\x03#$\nY\n\x04\x04\x08\x04\
    \x02\x12\x06\xfb\x03\x02\x95\x04\x03\x1aI\x20Predefined\x20or\x20\"canne\
    d\"\x20aliases\x20for\x20sets\x20of\x20specific\x20object\x20ACL\x20entr\
    ies.\n\n\r\n\x05\x04\x08\x04\x02\x01\x12\x04\xfb\x03\x07\x1a\n$\n\x06\
    \x04\x08\x04\x02\x02\0\x12\x04\xfd\x03\x04*\x1a\x14\x20No\x20predefined\
    \x20ACL.\n\n\x0f\n\x07\x04\x08\x04\x02\x02\0\x01\x12\x04\xfd\x03\x04%\n\
    \x0f\n\x07\x04\x08\x04\x02\x02\0\x02\x12\x04\xfd\x03()\ne\n\x06\x04\x08\
    \x04\x02\x02\x01\x12\x04\x81\x04\x04&\x1aU\x20Object\x20owner\x20gets\
    \x20`OWNER`\x20access,\x20and\n\x20`allAuthenticatedUsers`\x20get\x20`RE\
    ADER`\x20access.\n\n\x0f\n\x07\x04\x08\x04\x02\x02\x01\x01\x12\x04\x81\
    \x04\x04!\n\x0f\n\x07\x04\x08\x04\x02\x02\x01\x02\x12\x04\x81\x04$%\n`\n\
    \x06\x04\x08\x04\x02\x02\x02\x12\x04\x85\x04\x04-\x1aP\x20Object\x20owne\
    r\x20gets\x20`OWNER`\x20access,\x20and\x20project\x20team\x20owners\x20g\
    et\n\x20`OWNER`\x20access.\n\n\x0f\n\x07\x04\x08\x04\x02\x02\x02\x01\x12\
    \x04\x85\x04\x04(\n\x0f\n\x07\x04\x08\x04\x02\x02\x02\x02\x12\x04\x85\
    \x04+,\na\n\x06\x04\x08\x04\x02\x02\x03\x12\x04\x89\x04\x04%\x1aQ\x20Obj\
    ect\x20owner\x20gets\x20`OWNER`\x20access,\x20and\x20project\x20team\x20\
    owners\x20get\n\x20`READER`\x20access.\n\n\x0f\n\x07\x04\x08\x04\x02\x02\
    \x03\x01\x12\x04\x89\x04\x04\x20\n\x0f\n\x07\x04\x08\x04\x02\x02\x03\x02\
    \x12\x04\x89\x04#$\n3\n\x06\x04\x08\x04\x02\x02\x04\x12\x04\x8c\x04\x04\
    \x1b\x1a#\x20Object\x20owner\x20gets\x20`OWNER`\x20access.\n\n\x0f\n\x07\
    \x04\x08\x04\x02\x02\x04\x01\x12\x04\x8c\x04\x04\x16\n\x0f\n\x07\x04\x08\
    \x04\x02\x02\x04\x02\x12\x04\x8c\x04\x19\x1a\nr\n\x06\x04\x08\x04\x02\
    \x02\x05\x12\x04\x90\x04\x04#\x1ab\x20Object\x20owner\x20gets\x20`OWNER`\
    \x20access,\x20and\x20project\x20team\x20members\x20get\n\x20access\x20a\
    ccording\x20to\x20their\x20roles.\n\n\x0f\n\x07\x04\x08\x04\x02\x02\x05\
    \x01\x12\x04\x90\x04\x04\x1e\n\x0f\n\x07\x04\x08\x04\x02\x02\x05\x02\x12\
    \x04\x90\x04!\"\nX\n\x06\x04\x08\x04\x02\x02\x06\x12\x04\x94\x04\x04\x1f\
    \x1aH\x20Object\x20owner\x20gets\x20`OWNER`\x20access,\x20and\x20`allUse\
    rs`\n\x20get\x20`READER`\x20access.\n\n\x0f\n\x07\x04\x08\x04\x02\x02\
    \x06\x01\x12\x04\x94\x04\x04\x1a\n\x0f\n\x07\x04\x08\x04\x02\x02\x06\x02\
    \x12\x04\x94\x04\x1d\x1e\nA\n\x02\x04\t\x12\x06\x9b\x04\0\xa4\x04\x01\
    \x1a3\x20Specifies\x20a\x20requested\x20range\x20of\x20bytes\x20to\x20do\
    wnload.\n\n\x0b\n\x03\x04\t\x01\x12\x04\x9b\x04\x08\x14\n7\n\x04\x04\t\
    \x02\0\x12\x04\x9d\x04\x02\x12\x1a)\x20The\x20starting\x20offset\x20of\
    \x20the\x20object\x20data.\n\n\x0f\n\x05\x04\t\x02\0\x04\x12\x06\x9d\x04\
    \x02\x9b\x04\x16\n\r\n\x05\x04\t\x02\0\x05\x12\x04\x9d\x04\x02\x07\n\r\n\
    \x05\x04\t\x02\0\x01\x12\x04\x9d\x04\x08\r\n\r\n\x05\x04\t\x02\0\x03\x12\
    \x04\x9d\x04\x10\x11\n5\n\x04\x04\t\x02\x01\x12\x04\xa0\x04\x02\x10\x1a'\
    \x20The\x20ending\x20offset\x20of\x20the\x20object\x20data.\n\n\x0f\n\
    \x05\x04\t\x02\x01\x04\x12\x06\xa0\x04\x02\x9d\x04\x12\n\r\n\x05\x04\t\
    \x02\x01\x05\x12\x04\xa0\x04\x02\x07\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\
    \xa0\x04\x08\x0b\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xa0\x04\x0e\x0f\n7\
    \n\x04\x04\t\x02\x02\x12\x04\xa3\x04\x02\x1c\x1a)\x20The\x20complete\x20\
    length\x20of\x20the\x20object\x20data.\n\n\x0f\n\x05\x04\t\x02\x02\x04\
    \x12\x06\xa3\x04\x02\xa0\x04\x10\n\r\n\x05\x04\t\x02\x02\x05\x12\x04\xa3\
    \x04\x02\x07\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\xa3\x04\x08\x17\n\r\n\
    \x05\x04\t\x02\x02\x03\x12\x04\xa3\x04\x1a\x1b\nX\n\x02\x04\n\x12\x06\
    \xa7\x04\0\xbf\x04\x01\x1aJ\x20Hmac\x20Key\x20Metadata,\x20which\x20incl\
    udes\x20all\x20information\x20other\x20than\x20the\x20secret.\n\n\x0b\n\
    \x03\x04\n\x01\x12\x04\xa7\x04\x08\x17\nQ\n\x04\x04\n\x02\0\x12\x04\xa9\
    \x04\x02\x10\x1aC\x20Resource\x20name\x20ID\x20of\x20the\x20key\x20in\
    \x20the\x20format\x20<projectId>/<accessId>.\n\n\x0f\n\x05\x04\n\x02\0\
    \x04\x12\x06\xa9\x04\x02\xa7\x04\x19\n\r\n\x05\x04\n\x02\0\x05\x12\x04\
    \xa9\x04\x02\x08\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xa9\x04\t\x0b\n\r\n\
    \x05\x04\n\x02\0\x03\x12\x04\xa9\x04\x0e\x0f\n,\n\x04\x04\n\x02\x01\x12\
    \x04\xac\x04\x02\x17\x1a\x1e\x20Globally\x20unique\x20id\x20for\x20keys.\
    \n\n\x0f\n\x05\x04\n\x02\x01\x04\x12\x06\xac\x04\x02\xa9\x04\x10\n\r\n\
    \x05\x04\n\x02\x01\x05\x12\x04\xac\x04\x02\x08\n\r\n\x05\x04\n\x02\x01\
    \x01\x12\x04\xac\x04\t\x12\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xac\x04\
    \x15\x16\nA\n\x04\x04\n\x02\x02\x12\x04\xaf\x04\x02\x18\x1a3\x20The\x20p\
    roject\x20ID\x20that\x20the\x20hmac\x20key\x20is\x20contained\x20in.\n\n\
    \x0f\n\x05\x04\n\x02\x02\x04\x12\x06\xaf\x04\x02\xac\x04\x17\n\r\n\x05\
    \x04\n\x02\x02\x05\x12\x04\xaf\x04\x02\x08\n\r\n\x05\x04\n\x02\x02\x01\
    \x12\x04\xaf\x04\t\x13\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\xaf\x04\x16\
    \x17\nF\n\x04\x04\n\x02\x03\x12\x04\xb2\x04\x02#\x1a8\x20Email\x20of\x20\
    the\x20service\x20account\x20the\x20key\x20authenticates\x20as.\n\n\x0f\
    \n\x05\x04\n\x02\x03\x04\x12\x06\xb2\x04\x02\xaf\x04\x18\n\r\n\x05\x04\n\
    \x02\x03\x05\x12\x04\xb2\x04\x02\x08\n\r\n\x05\x04\n\x02\x03\x01\x12\x04\
    \xb2\x04\t\x1e\n\r\n\x05\x04\n\x02\x03\x03\x12\x04\xb2\x04!\"\nF\n\x04\
    \x04\n\x02\x04\x12\x04\xb5\x04\x02\x13\x1a8\x20State\x20of\x20the\x20key\
    .\x20One\x20of\x20ACTIVE,\x20INACTIVE,\x20or\x20DELETED.\n\n\x0f\n\x05\
    \x04\n\x02\x04\x04\x12\x06\xb5\x04\x02\xb2\x04#\n\r\n\x05\x04\n\x02\x04\
    \x05\x12\x04\xb5\x04\x02\x08\n\r\n\x05\x04\n\x02\x04\x01\x12\x04\xb5\x04\
    \t\x0e\n\r\n\x05\x04\n\x02\x04\x03\x12\x04\xb5\x04\x11\x12\nE\n\x04\x04\
    \n\x02\x05\x12\x04\xb8\x04\x02-\x1a7\x20The\x20creation\x20time\x20of\
    \x20the\x20HMAC\x20key\x20in\x20RFC\x203339\x20format.\n\n\x0f\n\x05\x04\
    \n\x02\x05\x04\x12\x06\xb8\x04\x02\xb5\x04\x13\n\r\n\x05\x04\n\x02\x05\
    \x06\x12\x04\xb8\x04\x02\x1b\n\r\n\x05\x04\n\x02\x05\x01\x12\x04\xb8\x04\
    \x1c(\n\r\n\x05\x04\n\x02\x05\x03\x12\x04\xb8\x04+,\nW\n\x04\x04\n\x02\
    \x06\x12\x04\xbb\x04\x02(\x1aI\x20The\x20last\x20modification\x20time\
    \x20of\x20the\x20HMAC\x20key\x20metadata\x20in\x20RFC\x203339\x20format.\
    \n\n\x0f\n\x05\x04\n\x02\x06\x04\x12\x06\xbb\x04\x02\xb8\x04-\n\r\n\x05\
    \x04\n\x02\x06\x06\x12\x04\xbb\x04\x02\x1b\n\r\n\x05\x04\n\x02\x06\x01\
    \x12\x04\xbb\x04\x1c#\n\r\n\x05\x04\n\x02\x06\x03\x12\x04\xbb\x04&'\n1\n\
    \x04\x04\n\x02\x07\x12\x04\xbe\x04\x02\x12\x1a#\x20Tag\x20updated\x20wit\
    h\x20each\x20key\x20update.\n\n\x0f\n\x05\x04\n\x02\x07\x04\x12\x06\xbe\
    \x04\x02\xbb\x04(\n\r\n\x05\x04\n\x02\x07\x05\x12\x04\xbe\x04\x02\x08\n\
    \r\n\x05\x04\n\x02\x07\x01\x12\x04\xbe\x04\t\r\n\r\n\x05\x04\n\x02\x07\
    \x03\x12\x04\xbe\x04\x10\x11\nF\n\x02\x04\x0b\x12\x06\xc2\x04\0\xdc\x04\
    \x01\x1a8\x20A\x20subscription\x20to\x20receive\x20Google\x20PubSub\x20n\
    otifications.\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\xc2\x04\x08\x14\n\xa6\
    \x01\n\x04\x04\x0b\x02\0\x12\x04\xc5\x04\x02\x13\x1a\x97\x01\x20The\x20C\
    loud\x20PubSub\x20topic\x20to\x20which\x20this\x20subscription\x20publis\
    hes.\x20Formatted\x20as:\n\x20'//pubsub.googleapis.com/projects/{project\
    -identifier}/topics/{my-topic}'\n\n\x0f\n\x05\x04\x0b\x02\0\x04\x12\x06\
    \xc5\x04\x02\xc2\x04\x16\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\xc5\x04\x02\
    \x08\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xc5\x04\t\x0e\n\r\n\x05\x04\x0b\
    \x02\0\x03\x12\x04\xc5\x04\x11\x12\n\x80\x01\n\x04\x04\x0b\x02\x01\x12\
    \x04\xc9\x04\x02\"\x1ar\x20If\x20present,\x20only\x20send\x20notificatio\
    ns\x20about\x20listed\x20event\x20types.\x20If\x20empty,\n\x20sent\x20no\
    tifications\x20for\x20all\x20event\x20types.\n\n\r\n\x05\x04\x0b\x02\x01\
    \x04\x12\x04\xc9\x04\x02\n\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\xc9\x04\
    \x0b\x11\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xc9\x04\x12\x1d\n\r\n\x05\
    \x04\x0b\x02\x01\x03\x12\x04\xc9\x04\x20!\n\x90\x01\n\x04\x04\x0b\x02\
    \x02\x12\x04\xcd\x04\x02,\x1a\x81\x01\x20An\x20optional\x20list\x20of\
    \x20additional\x20attributes\x20to\x20attach\x20to\x20each\x20Cloud\x20P\
    ubSub\n\x20message\x20published\x20for\x20this\x20notification\x20subscr\
    iption.\n\n\x0f\n\x05\x04\x0b\x02\x02\x04\x12\x06\xcd\x04\x02\xc9\x04\"\
    \n\r\n\x05\x04\x0b\x02\x02\x06\x12\x04\xcd\x04\x02\x15\n\r\n\x05\x04\x0b\
    \x02\x02\x01\x12\x04\xcd\x04\x16'\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\
    \xcd\x04*+\n{\n\x04\x04\x0b\x02\x03\x12\x04\xd1\x04\x02\x12\x1am\x20HTTP\
    \x201.1\x20[https://tools.ietf.org/html/rfc7232#section-2.3][Entity\x20t\
    ag]\n\x20for\x20this\x20subscription\x20notification.\n\n\x0f\n\x05\x04\
    \x0b\x02\x03\x04\x12\x06\xd1\x04\x02\xcd\x04,\n\r\n\x05\x04\x0b\x02\x03\
    \x05\x12\x04\xd1\x04\x02\x08\n\r\n\x05\x04\x0b\x02\x03\x01\x12\x04\xd1\
    \x04\t\r\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\xd1\x04\x10\x11\nt\n\x04\
    \x04\x0b\x02\x04\x12\x04\xd5\x04\x02\x20\x1af\x20If\x20present,\x20only\
    \x20apply\x20this\x20notification\x20configuration\x20to\x20object\x20na\
    mes\x20that\n\x20begin\x20with\x20this\x20prefix.\n\n\x0f\n\x05\x04\x0b\
    \x02\x04\x04\x12\x06\xd5\x04\x02\xd1\x04\x12\n\r\n\x05\x04\x0b\x02\x04\
    \x05\x12\x04\xd5\x04\x02\x08\n\r\n\x05\x04\x0b\x02\x04\x01\x12\x04\xd5\
    \x04\t\x1b\n\r\n\x05\x04\x0b\x02\x04\x03\x12\x04\xd5\x04\x1e\x1f\n3\n\
    \x04\x04\x0b\x02\x05\x12\x04\xd8\x04\x02\x1c\x1a%\x20The\x20desired\x20c\
    ontent\x20of\x20the\x20Payload.\n\n\x0f\n\x05\x04\x0b\x02\x05\x04\x12\
    \x06\xd8\x04\x02\xd5\x04\x20\n\r\n\x05\x04\x0b\x02\x05\x05\x12\x04\xd8\
    \x04\x02\x08\n\r\n\x05\x04\x0b\x02\x05\x01\x12\x04\xd8\x04\t\x17\n\r\n\
    \x05\x04\x0b\x02\x05\x03\x12\x04\xd8\x04\x1a\x1b\n+\n\x04\x04\x0b\x02\
    \x06\x12\x04\xdb\x04\x02\x10\x1a\x1d\x20The\x20ID\x20of\x20the\x20notifi\
    cation.\n\n\x0f\n\x05\x04\x0b\x02\x06\x04\x12\x06\xdb\x04\x02\xd8\x04\
    \x1c\n\r\n\x05\x04\x0b\x02\x06\x05\x12\x04\xdb\x04\x02\x08\n\r\n\x05\x04\
    \x0b\x02\x06\x01\x12\x04\xdb\x04\t\x0b\n\r\n\x05\x04\x0b\x02\x06\x03\x12\
    \x04\xdb\x04\x0e\x0f\nG\n\x02\x04\x0c\x12\x06\xdf\x04\0\xe2\x04\x01\x1a9\
    \x20The\x20result\x20of\x20a\x20call\x20to\x20Notifications.ListNotifica\
    tions\n\n\x0b\n\x03\x04\x0c\x01\x12\x04\xdf\x04\x08!\n\"\n\x04\x04\x0c\
    \x02\0\x12\x04\xe1\x04\x02\"\x1a\x14\x20The\x20list\x20of\x20items.\n\n\
    \r\n\x05\x04\x0c\x02\0\x04\x12\x04\xe1\x04\x02\n\n\r\n\x05\x04\x0c\x02\0\
    \x06\x12\x04\xe1\x04\x0b\x17\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xe1\x04\
    \x18\x1d\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xe1\x04\x20!\n\x1a\n\x02\
    \x04\r\x12\x06\xe5\x04\0\x88\x06\x01\x1a\x0c\x20An\x20object.\n\n\x0b\n\
    \x03\x04\r\x01\x12\x04\xe5\x04\x08\x0e\n\\\n\x04\x04\r\x03\0\x12\x06\xe7\
    \x04\x02\xed\x04\x03\x1aL\x20Describes\x20the\x20customer-specified\x20m\
    echanism\x20used\x20to\x20store\x20the\x20data\x20at\x20rest.\n\n\r\n\
    \x05\x04\r\x03\0\x01\x12\x04\xe7\x04\n\x1c\n+\n\x06\x04\r\x03\0\x02\0\
    \x12\x04\xe9\x04\x04$\x1a\x1b\x20The\x20encryption\x20algorithm.\n\n\x11\
    \n\x07\x04\r\x03\0\x02\0\x04\x12\x06\xe9\x04\x04\xe7\x04\x1e\n\x0f\n\x07\
    \x04\r\x03\0\x02\0\x05\x12\x04\xe9\x04\x04\n\n\x0f\n\x07\x04\r\x03\0\x02\
    \0\x01\x12\x04\xe9\x04\x0b\x1f\n\x0f\n\x07\x04\r\x03\0\x02\0\x03\x12\x04\
    \xe9\x04\"#\n:\n\x06\x04\r\x03\0\x02\x01\x12\x04\xec\x04\x04\x1a\x1a*\
    \x20SHA256\x20hash\x20value\x20of\x20the\x20encryption\x20key.\n\n\x11\n\
    \x07\x04\r\x03\0\x02\x01\x04\x12\x06\xec\x04\x04\xe9\x04$\n\x0f\n\x07\
    \x04\r\x03\0\x02\x01\x05\x12\x04\xec\x04\x04\n\n\x0f\n\x07\x04\r\x03\0\
    \x02\x01\x01\x12\x04\xec\x04\x0b\x15\n\x0f\n\x07\x04\r\x03\0\x02\x01\x03\
    \x12\x04\xec\x04\x18\x19\n\x88\x01\n\x04\x04\r\x02\0\x12\x04\xf1\x04\x02\
    \x1e\x1az\x20Content-Encoding\x20of\x20the\x20object\x20data,\x20matchin\
    g\n\x20[https://tools.ietf.org/html/rfc7231#section-3.1.2.2][RFC\x207231\
    \x20\xc2\xa73.1.2.2]\n\n\x0f\n\x05\x04\r\x02\0\x04\x12\x06\xf1\x04\x02\
    \xed\x04\x03\n\r\n\x05\x04\r\x02\0\x05\x12\x04\xf1\x04\x02\x08\n\r\n\x05\
    \x04\r\x02\0\x01\x12\x04\xf1\x04\t\x19\n\r\n\x05\x04\r\x02\0\x03\x12\x04\
    \xf1\x04\x1c\x1d\nr\n\x04\x04\r\x02\x01\x12\x04\xf5\x04\x02!\x1ad\x20Con\
    tent-Disposition\x20of\x20the\x20object\x20data,\x20matching\n\x20[https\
    ://tools.ietf.org/html/rfc6266][RFC\x206266].\n\n\x0f\n\x05\x04\r\x02\
    \x01\x04\x12\x06\xf5\x04\x02\xf1\x04\x1e\n\r\n\x05\x04\r\x02\x01\x05\x12\
    \x04\xf5\x04\x02\x08\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xf5\x04\t\x1c\n\
    \r\n\x05\x04\r\x02\x01\x03\x12\x04\xf5\x04\x1f\x20\n\xfa\x01\n\x04\x04\r\
    \x02\x02\x12\x04\xfb\x04\x02\x1b\x1a\xeb\x01\x20Cache-Control\x20directi\
    ve\x20for\x20the\x20object\x20data,\x20matching\n\x20[https://tools.ietf\
    .org/html/rfc7234#section-5.2\"][RFC\x207234\x20\xc2\xa75.2].\n\x20If\
    \x20omitted,\x20and\x20the\x20object\x20is\x20accessible\x20to\x20all\
    \x20anonymous\x20users,\x20the\n\x20default\x20will\x20be\x20`public,\
    \x20max-age=3600`.\n\n\x0f\n\x05\x04\r\x02\x02\x04\x12\x06\xfb\x04\x02\
    \xf5\x04!\n\r\n\x05\x04\r\x02\x02\x05\x12\x04\xfb\x04\x02\x08\n\r\n\x05\
    \x04\r\x02\x02\x01\x12\x04\xfb\x04\t\x16\n\r\n\x05\x04\r\x02\x02\x03\x12\
    \x04\xfb\x04\x19\x1a\n.\n\x04\x04\r\x02\x03\x12\x04\xfe\x04\x02'\x1a\x20\
    \x20Access\x20controls\x20on\x20the\x20object.\n\n\r\n\x05\x04\r\x02\x03\
    \x04\x12\x04\xfe\x04\x02\n\n\r\n\x05\x04\r\x02\x03\x06\x12\x04\xfe\x04\
    \x0b\x1e\n\r\n\x05\x04\r\x02\x03\x01\x12\x04\xfe\x04\x1f\"\n\r\n\x05\x04\
    \r\x02\x03\x03\x12\x04\xfe\x04%&\n\x89\x01\n\x04\x04\r\x02\x04\x12\x04\
    \x82\x05\x02\x1e\x1a{\x20Content-Language\x20of\x20the\x20object\x20data\
    ,\x20matching\n\x20[https://tools.ietf.org/html/rfc7231#section-3.1.3.2]\
    [RFC\x207231\x20\xc2\xa73.1.3.2].\n\n\x0f\n\x05\x04\r\x02\x04\x04\x12\
    \x06\x82\x05\x02\xfe\x04'\n\r\n\x05\x04\r\x02\x04\x05\x12\x04\x82\x05\
    \x02\x08\n\r\n\x05\x04\r\x02\x04\x01\x12\x04\x82\x05\t\x19\n\r\n\x05\x04\
    \r\x02\x04\x03\x12\x04\x82\x05\x1c\x1d\n\xb5\x02\n\x04\x04\r\x02\x05\x12\
    \x04\x89\x05\x02\x1b\x1a\xa6\x02\x20The\x20version\x20of\x20the\x20metad\
    ata\x20for\x20this\x20object\x20at\x20this\x20generation.\x20Used\x20for\
    \n\x20preconditions\x20and\x20for\x20detecting\x20changes\x20in\x20metad\
    ata.\x20A\x20metageneration\n\x20number\x20is\x20only\x20meaningful\x20i\
    n\x20the\x20context\x20of\x20a\x20particular\x20generation\x20of\x20a\n\
    \x20particular\x20object.\n\x20Attempting\x20to\x20set\x20this\x20field\
    \x20will\x20result\x20in\x20an\x20error.\n\n\x0f\n\x05\x04\r\x02\x05\x04\
    \x12\x06\x89\x05\x02\x82\x05\x1e\n\r\n\x05\x04\r\x02\x05\x05\x12\x04\x89\
    \x05\x02\x07\n\r\n\x05\x04\r\x02\x05\x01\x12\x04\x89\x05\x08\x16\n\r\n\
    \x05\x04\r\x02\x05\x03\x12\x04\x89\x05\x19\x1a\n\xb6\x01\n\x04\x04\r\x02\
    \x06\x12\x04\x8e\x05\x02-\x1a\xa7\x01\x20The\x20deletion\x20time\x20of\
    \x20the\x20object.\x20Will\x20be\x20returned\x20if\x20and\x20only\x20if\
    \x20this\n\x20version\x20of\x20the\x20object\x20has\x20been\x20deleted.\
    \n\x20Attempting\x20to\x20set\x20this\x20field\x20will\x20result\x20in\
    \x20an\x20error.\n\n\x0f\n\x05\x04\r\x02\x06\x04\x12\x06\x8e\x05\x02\x89\
    \x05\x1b\n\r\n\x05\x04\r\x02\x06\x06\x12\x04\x8e\x05\x02\x1b\n\r\n\x05\
    \x04\r\x02\x06\x01\x12\x04\x8e\x05\x1c(\n\r\n\x05\x04\r\x02\x06\x03\x12\
    \x04\x8e\x05+,\n\xe3\x01\n\x04\x04\r\x02\x07\x12\x04\x94\x05\x02\x1a\x1a\
    \xd4\x01\x20Content-Type\x20of\x20the\x20object\x20data,\x20matching\n\
    \x20[https://tools.ietf.org/html/rfc7231#section-3.1.1.5][RFC\x207231\
    \x20\xc2\xa73.1.1.5].\n\x20If\x20an\x20object\x20is\x20stored\x20without\
    \x20a\x20Content-Type,\x20it\x20is\x20served\x20as\n\x20`application/oct\
    et-stream`.\n\n\x0f\n\x05\x04\r\x02\x07\x04\x12\x06\x94\x05\x02\x8e\x05-\
    \n\r\n\x05\x04\r\x02\x07\x05\x12\x04\x94\x05\x02\x08\n\r\n\x05\x04\r\x02\
    \x07\x01\x12\x04\x94\x05\t\x15\n\r\n\x05\x04\r\x02\x07\x03\x12\x04\x94\
    \x05\x18\x19\n\xc4\x01\n\x04\x04\r\x02\x08\x12\x04\x99\x05\x02\x11\x1a\
    \xb5\x01\x20Content-Length\x20of\x20the\x20object\x20data\x20in\x20bytes\
    ,\x20matching\n\x20[https://tools.ietf.org/html/rfc7230#section-3.3.2][R\
    FC\x207230\x20\xc2\xa73.3.2].\n\x20Attempting\x20to\x20set\x20this\x20fi\
    eld\x20will\x20result\x20in\x20an\x20error.\n\n\x0f\n\x05\x04\r\x02\x08\
    \x04\x12\x06\x99\x05\x02\x94\x05\x1a\n\r\n\x05\x04\r\x02\x08\x05\x12\x04\
    \x99\x05\x02\x07\n\r\n\x05\x04\r\x02\x08\x01\x12\x04\x99\x05\x08\x0c\n\r\
    \n\x05\x04\r\x02\x08\x03\x12\x04\x99\x05\x0f\x10\ng\n\x04\x04\r\x02\t\
    \x12\x04\x9d\x05\x02.\x1aY\x20The\x20creation\x20time\x20of\x20the\x20ob\
    ject.\n\x20Attempting\x20to\x20set\x20this\x20field\x20will\x20result\
    \x20in\x20an\x20error.\n\n\x0f\n\x05\x04\r\x02\t\x04\x12\x06\x9d\x05\x02\
    \x99\x05\x11\n\r\n\x05\x04\r\x02\t\x06\x12\x04\x9d\x05\x02\x1b\n\r\n\x05\
    \x04\r\x02\t\x01\x12\x04\x9d\x05\x1c(\n\r\n\x05\x04\r\x02\t\x03\x12\x04\
    \x9d\x05+-\n\xb7\x03\n\x04\x04\r\x02\n\x12\x04\xa6\x05\x02*\x1a\xa8\x03\
    \x20CRC32c\x20checksum.\x20For\x20more\x20information\x20about\x20using\
    \x20the\x20CRC32c\n\x20checksum,\x20see\n\x20[https://cloud.google.com/s\
    torage/docs/hashes-etags#_JSONAPI][Hashes\x20and\n\x20ETags:\x20Best\x20\
    Practices].\x20This\x20is\x20a\x20server\x20determined\x20value\x20and\
    \x20should\x20not\x20be\n\x20supplied\x20by\x20the\x20user\x20when\x20se\
    nding\x20an\x20Object.\x20The\x20server\x20will\x20ignore\x20any\n\x20va\
    lue\x20provided.\x20Users\x20should\x20instead\x20use\x20the\x20object_c\
    hecksums\x20field\x20on\x20the\n\x20InsertObjectRequest\x20when\x20uploa\
    ding\x20an\x20object.\n\n\x0f\n\x05\x04\r\x02\n\x04\x12\x06\xa6\x05\x02\
    \x9d\x05.\n\r\n\x05\x04\r\x02\n\x06\x12\x04\xa6\x05\x02\x1d\n\r\n\x05\
    \x04\r\x02\n\x01\x12\x04\xa6\x05\x1e$\n\r\n\x05\x04\r\x02\n\x03\x12\x04\
    \xa6\x05')\n\xb4\x01\n\x04\x04\r\x02\x0b\x12\x04\xab\x05\x02\x1d\x1a\xa5\
    \x01\x20Number\x20of\x20underlying\x20components\x20that\x20make\x20up\
    \x20this\x20object.\x20Components\x20are\n\x20accumulated\x20by\x20compo\
    se\x20operations.\n\x20Attempting\x20to\x20set\x20this\x20field\x20will\
    \x20result\x20in\x20an\x20error.\n\n\x0f\n\x05\x04\r\x02\x0b\x04\x12\x06\
    \xab\x05\x02\xa6\x05*\n\r\n\x05\x04\r\x02\x0b\x05\x12\x04\xab\x05\x02\
    \x07\n\r\n\x05\x04\r\x02\x0b\x01\x12\x04\xab\x05\x08\x17\n\r\n\x05\x04\r\
    \x02\x0b\x03\x12\x04\xab\x05\x1a\x1c\n\x91\x04\n\x04\x04\r\x02\x0c\x12\
    \x04\xb5\x05\x02\x17\x1a\x82\x04\x20MD5\x20hash\x20of\x20the\x20data;\
    \x20encoded\x20using\x20base64\x20as\x20per\n\x20[https://tools.ietf.org\
    /html/rfc4648#section-4][RFC\x204648\x20\xc2\xa74].\x20For\x20more\n\x20\
    information\x20about\x20using\x20the\x20MD5\x20hash,\x20see\n\x20[https:\
    //cloud.google.com/storage/docs/hashes-etags#_JSONAPI][Hashes\x20and\n\
    \x20ETags:\x20Best\x20Practices].\x20This\x20is\x20a\x20server\x20determ\
    ined\x20value\x20and\x20should\x20not\x20be\n\x20supplied\x20by\x20the\
    \x20user\x20when\x20sending\x20an\x20Object.\x20The\x20server\x20will\
    \x20ignore\x20any\n\x20value\x20provided.\x20Users\x20should\x20instead\
    \x20use\x20the\x20object_checksums\x20field\x20on\x20the\n\x20InsertObje\
    ctRequest\x20when\x20uploading\x20an\x20object.\n\n\x0f\n\x05\x04\r\x02\
    \x0c\x04\x12\x06\xb5\x05\x02\xab\x05\x1d\n\r\n\x05\x04\r\x02\x0c\x05\x12\
    \x04\xb5\x05\x02\x08\n\r\n\x05\x04\r\x02\x0c\x01\x12\x04\xb5\x05\t\x11\n\
    \r\n\x05\x04\r\x02\x0c\x03\x12\x04\xb5\x05\x14\x16\n\xb3\x01\n\x04\x04\r\
    \x02\r\x12\x04\xba\x05\x02\x13\x1a\xa4\x01\x20HTTP\x201.1\x20Entity\x20t\
    ag\x20for\x20the\x20object.\x20See\n\x20[https://tools.ietf.org/html/rfc\
    7232#section-2.3][RFC\x207232\x20\xc2\xa72.3].\n\x20Attempting\x20to\x20\
    set\x20this\x20field\x20will\x20result\x20in\x20an\x20error.\n\n\x0f\n\
    \x05\x04\r\x02\r\x04\x12\x06\xba\x05\x02\xb5\x05\x17\n\r\n\x05\x04\r\x02\
    \r\x05\x12\x04\xba\x05\x02\x08\n\r\n\x05\x04\r\x02\r\x01\x12\x04\xba\x05\
    \t\r\n\r\n\x05\x04\r\x02\r\x03\x12\x04\xba\x05\x10\x12\nt\n\x04\x04\r\
    \x02\x0e\x12\x04\xbe\x05\x02)\x1af\x20The\x20modification\x20time\x20of\
    \x20the\x20object\x20metadata.\n\x20Attempting\x20to\x20set\x20this\x20f\
    ield\x20will\x20result\x20in\x20an\x20error.\n\n\x0f\n\x05\x04\r\x02\x0e\
    \x04\x12\x06\xbe\x05\x02\xba\x05\x13\n\r\n\x05\x04\r\x02\x0e\x06\x12\x04\
    \xbe\x05\x02\x1b\n\r\n\x05\x04\r\x02\x0e\x01\x12\x04\xbe\x05\x1c#\n\r\n\
    \x05\x04\r\x02\x0e\x03\x12\x04\xbe\x05&(\n,\n\x04\x04\r\x02\x0f\x12\x04\
    \xc1\x05\x02\x1c\x1a\x1e\x20Storage\x20class\x20of\x20the\x20object.\n\n\
    \x0f\n\x05\x04\r\x02\x0f\x04\x12\x06\xc1\x05\x02\xbe\x05)\n\r\n\x05\x04\
    \r\x02\x0f\x05\x12\x04\xc1\x05\x02\x08\n\r\n\x05\x04\r\x02\x0f\x01\x12\
    \x04\xc1\x05\t\x16\n\r\n\x05\x04\r\x02\x0f\x03\x12\x04\xc1\x05\x19\x1b\n\
    e\n\x04\x04\r\x02\x10\x12\x04\xc5\x05\x02\x1b\x1aW\x20Cloud\x20KMS\x20Ke\
    y\x20used\x20to\x20encrypt\x20this\x20object,\x20if\x20the\x20object\x20\
    is\x20encrypted\x20by\n\x20such\x20a\x20key.\n\n\x0f\n\x05\x04\r\x02\x10\
    \x04\x12\x06\xc5\x05\x02\xc1\x05\x1c\n\r\n\x05\x04\r\x02\x10\x05\x12\x04\
    \xc5\x05\x02\x08\n\r\n\x05\x04\r\x02\x10\x01\x12\x04\xc5\x05\t\x15\n\r\n\
    \x05\x04\r\x02\x10\x03\x12\x04\xc5\x05\x18\x1a\n\xcd\x01\n\x04\x04\r\x02\
    \x11\x12\x04\xca\x05\x02<\x1a\xbe\x01\x20The\x20time\x20at\x20which\x20t\
    he\x20object's\x20storage\x20class\x20was\x20last\x20changed.\x20When\
    \x20the\n\x20object\x20is\x20initially\x20created,\x20it\x20will\x20be\
    \x20set\x20to\x20time_created.\n\x20Attempting\x20to\x20set\x20this\x20f\
    ield\x20will\x20result\x20in\x20an\x20error.\n\n\x0f\n\x05\x04\r\x02\x11\
    \x04\x12\x06\xca\x05\x02\xc5\x05\x1b\n\r\n\x05\x04\r\x02\x11\x06\x12\x04\
    \xca\x05\x02\x1b\n\r\n\x05\x04\r\x02\x11\x01\x12\x04\xca\x05\x1c6\n\r\n\
    \x05\x04\r\x02\x11\x03\x12\x04\xca\x059;\n\x85\x03\n\x04\x04\r\x02\x12\
    \x12\x04\xd1\x05\x02\x1b\x1a\xf6\x02\x20Whether\x20an\x20object\x20is\
    \x20under\x20temporary\x20hold.\x20While\x20this\x20flag\x20is\x20set\
    \x20to\x20true,\n\x20the\x20object\x20is\x20protected\x20against\x20dele\
    tion\x20and\x20overwrites.\x20\x20A\x20common\x20use\x20case\n\x20of\x20\
    this\x20flag\x20is\x20regulatory\x20investigations\x20where\x20objects\
    \x20need\x20to\x20be\x20retained\n\x20while\x20the\x20investigation\x20i\
    s\x20ongoing.\x20Note\x20that\x20unlike\x20event-based\x20hold,\n\x20tem\
    porary\x20hold\x20does\x20not\x20impact\x20retention\x20expiration\x20ti\
    me\x20of\x20an\x20object.\n\n\x0f\n\x05\x04\r\x02\x12\x04\x12\x06\xd1\
    \x05\x02\xca\x05<\n\r\n\x05\x04\r\x02\x12\x05\x12\x04\xd1\x05\x02\x06\n\
    \r\n\x05\x04\r\x02\x12\x01\x12\x04\xd1\x05\x07\x15\n\r\n\x05\x04\r\x02\
    \x12\x03\x12\x04\xd1\x05\x18\x1a\n\xf8\x03\n\x04\x04\r\x02\x13\x12\x04\
    \xdb\x05\x02;\x1a\xe9\x03\x20A\x20server-determined\x20value\x20that\x20\
    specifies\x20the\x20earliest\x20time\x20that\x20the\n\x20object's\x20ret\
    ention\x20period\x20expires.\x20This\x20value\x20is\x20in\n\x20[https://\
    tools.ietf.org/html/rfc3339][RFC\x203339]\x20format.\n\x20Note\x201:\x20\
    This\x20field\x20is\x20not\x20provided\x20for\x20objects\x20with\x20an\
    \x20active\x20event-based\n\x20hold,\x20since\x20retention\x20expiration\
    \x20is\x20unknown\x20until\x20the\x20hold\x20is\x20removed.\n\x20Note\
    \x202:\x20This\x20value\x20can\x20be\x20provided\x20even\x20when\x20temp\
    orary\x20hold\x20is\x20set\x20(so\x20that\n\x20the\x20user\x20can\x20rea\
    son\x20about\x20policy\x20without\x20having\x20to\x20first\x20unset\x20t\
    he\n\x20temporary\x20hold).\n\n\x0f\n\x05\x04\r\x02\x13\x04\x12\x06\xdb\
    \x05\x02\xd1\x05\x1b\n\r\n\x05\x04\r\x02\x13\x06\x12\x04\xdb\x05\x02\x1b\
    \n\r\n\x05\x04\r\x02\x13\x01\x12\x04\xdb\x05\x1c5\n\r\n\x05\x04\r\x02\
    \x13\x03\x12\x04\xdb\x058:\n;\n\x04\x04\r\x02\x14\x12\x04\xde\x05\x02$\
    \x1a-\x20User-provided\x20metadata,\x20in\x20key/value\x20pairs.\n\n\x0f\
    \n\x05\x04\r\x02\x14\x04\x12\x06\xde\x05\x02\xdb\x05;\n\r\n\x05\x04\r\
    \x02\x14\x06\x12\x04\xde\x05\x02\x15\n\r\n\x05\x04\r\x02\x14\x01\x12\x04\
    \xde\x05\x16\x1e\n\r\n\x05\x04\r\x02\x14\x03\x12\x04\xde\x05!#\n\xb5\x06\
    \n\x04\x04\r\x02\x15\x12\x04\xeb\x05\x022\x1a\xa6\x06\x20Whether\x20an\
    \x20object\x20is\x20under\x20event-based\x20hold.\x20Event-based\x20hold\
    \x20is\x20a\x20way\x20to\n\x20retain\x20objects\x20until\x20an\x20event\
    \x20occurs,\x20which\x20is\x20signified\x20by\x20the\n\x20hold's\x20rele\
    ase\x20(i.e.\x20this\x20value\x20is\x20set\x20to\x20false).\x20After\x20\
    being\x20released\x20(set\n\x20to\x20false),\x20such\x20objects\x20will\
    \x20be\x20subject\x20to\x20bucket-level\x20retention\x20(if\x20any).\n\
    \x20One\x20sample\x20use\x20case\x20of\x20this\x20flag\x20is\x20for\x20b\
    anks\x20to\x20hold\x20loan\x20documents\x20for\x20at\n\x20least\x203\x20\
    years\x20after\x20loan\x20is\x20paid\x20in\x20full.\x20Here,\x20bucket-l\
    evel\x20retention\x20is\x203\n\x20years\x20and\x20the\x20event\x20is\x20\
    the\x20loan\x20being\x20paid\x20in\x20full.\x20In\x20this\x20example,\
    \x20these\n\x20objects\x20will\x20be\x20held\x20intact\x20for\x20any\x20\
    number\x20of\x20years\x20until\x20the\x20event\x20has\n\x20occurred\x20(\
    event-based\x20hold\x20on\x20the\x20object\x20is\x20released)\x20and\x20\
    then\x203\x20more\x20years\n\x20after\x20that.\x20That\x20means\x20reten\
    tion\x20duration\x20of\x20the\x20objects\x20begins\x20from\x20the\n\x20m\
    oment\x20event-based\x20hold\x20transitioned\x20from\x20true\x20to\x20fa\
    lse.\n\n\x0f\n\x05\x04\r\x02\x15\x04\x12\x06\xeb\x05\x02\xde\x05$\n\r\n\
    \x05\x04\r\x02\x15\x06\x12\x04\xeb\x05\x02\x1b\n\r\n\x05\x04\r\x02\x15\
    \x01\x12\x04\xeb\x05\x1c,\n\r\n\x05\x04\r\x02\x15\x03\x12\x04\xeb\x05/1\
    \n~\n\x04\x04\r\x02\x16\x12\x04\xf0\x05\x02\x13\x1ap\x20The\x20name\x20o\
    f\x20the\x20object.\n\x20Attempting\x20to\x20update\x20this\x20field\x20\
    after\x20the\x20object\x20is\x20created\x20will\x20result\x20in\n\x20an\
    \x20error.\n\n\x0f\n\x05\x04\r\x02\x16\x04\x12\x06\xf0\x05\x02\xeb\x052\
    \n\r\n\x05\x04\r\x02\x16\x05\x12\x04\xf0\x05\x02\x08\n\r\n\x05\x04\r\x02\
    \x16\x01\x12\x04\xf0\x05\t\r\n\r\n\x05\x04\r\x02\x16\x03\x12\x04\xf0\x05\
    \x10\x12\n\xbd\x01\n\x04\x04\r\x02\x17\x12\x04\xf6\x05\x02\x11\x1a\xae\
    \x01\x20The\x20ID\x20of\x20the\x20object,\x20including\x20the\x20bucket\
    \x20name,\x20object\x20name,\x20and\n\x20generation\x20number.\n\x20Atte\
    mpting\x20to\x20update\x20this\x20field\x20after\x20the\x20object\x20is\
    \x20created\x20will\x20result\x20in\n\x20an\x20error.\n\n\x0f\n\x05\x04\
    \r\x02\x17\x04\x12\x06\xf6\x05\x02\xf0\x05\x13\n\r\n\x05\x04\r\x02\x17\
    \x05\x12\x04\xf6\x05\x02\x08\n\r\n\x05\x04\r\x02\x17\x01\x12\x04\xf6\x05\
    \t\x0b\n\r\n\x05\x04\r\x02\x17\x03\x12\x04\xf6\x05\x0e\x10\n\x96\x01\n\
    \x04\x04\r\x02\x18\x12\x04\xfb\x05\x02\x15\x1a\x87\x01\x20The\x20name\
    \x20of\x20the\x20bucket\x20containing\x20this\x20object.\n\x20Attempting\
    \x20to\x20update\x20this\x20field\x20after\x20the\x20object\x20is\x20cre\
    ated\x20will\x20result\x20in\n\x20an\x20error.\n\n\x0f\n\x05\x04\r\x02\
    \x18\x04\x12\x06\xfb\x05\x02\xf6\x05\x11\n\r\n\x05\x04\r\x02\x18\x05\x12\
    \x04\xfb\x05\x02\x08\n\r\n\x05\x04\r\x02\x18\x01\x12\x04\xfb\x05\t\x0f\n\
    \r\n\x05\x04\r\x02\x18\x03\x12\x04\xfb\x05\x12\x14\n\x89\x01\n\x04\x04\r\
    \x02\x19\x12\x04\xff\x05\x02\x18\x1a{\x20The\x20content\x20generation\
    \x20of\x20this\x20object.\x20Used\x20for\x20object\x20versioning.\n\x20A\
    ttempting\x20to\x20set\x20this\x20field\x20will\x20result\x20in\x20an\
    \x20error.\n\n\x0f\n\x05\x04\r\x02\x19\x04\x12\x06\xff\x05\x02\xfb\x05\
    \x15\n\r\n\x05\x04\r\x02\x19\x05\x12\x04\xff\x05\x02\x07\n\r\n\x05\x04\r\
    \x02\x19\x01\x12\x04\xff\x05\x08\x12\n\r\n\x05\x04\r\x02\x19\x03\x12\x04\
    \xff\x05\x15\x17\n\x90\x01\n\x04\x04\r\x02\x1a\x12\x04\x83\x06\x02\x13\
    \x1a\x81\x01\x20The\x20owner\x20of\x20the\x20object.\x20This\x20will\x20\
    always\x20be\x20the\x20uploader\x20of\x20the\x20object.\n\x20Attempting\
    \x20to\x20set\x20this\x20field\x20will\x20result\x20in\x20an\x20error.\n\
    \n\x0f\n\x05\x04\r\x02\x1a\x04\x12\x06\x83\x06\x02\xff\x05\x18\n\r\n\x05\
    \x04\r\x02\x1a\x06\x12\x04\x83\x06\x02\x07\n\r\n\x05\x04\r\x02\x1a\x01\
    \x12\x04\x83\x06\x08\r\n\r\n\x05\x04\r\x02\x1a\x03\x12\x04\x83\x06\x10\
    \x12\nh\n\x04\x04\r\x02\x1b\x12\x04\x87\x06\x02.\x1aZ\x20Metadata\x20of\
    \x20customer-supplied\x20encryption\x20key,\x20if\x20the\x20object\x20is\
    \x20encrypted\x20by\n\x20such\x20a\x20key.\n\n\x0f\n\x05\x04\r\x02\x1b\
    \x04\x12\x06\x87\x06\x02\x83\x06\x13\n\r\n\x05\x04\r\x02\x1b\x06\x12\x04\
    \x87\x06\x02\x14\n\r\n\x05\x04\r\x02\x1b\x01\x12\x04\x87\x06\x15(\n\r\n\
    \x05\x04\r\x02\x1b\x03\x12\x04\x87\x06+-\n(\n\x02\x04\x0e\x12\x06\x8b\
    \x06\0\xbb\x06\x01\x1a\x1a\x20An\x20access-control\x20entry.\n\n\x0b\n\
    \x03\x04\x0e\x01\x12\x04\x8b\x06\x08\x1b\n5\n\x04\x04\x0e\x02\0\x12\x04\
    \x8d\x06\x02\x12\x1a'\x20The\x20access\x20permission\x20for\x20the\x20en\
    tity.\n\n\x0f\n\x05\x04\x0e\x02\0\x04\x12\x06\x8d\x06\x02\x8b\x06\x1d\n\
    \r\n\x05\x04\x0e\x02\0\x05\x12\x04\x8d\x06\x02\x08\n\r\n\x05\x04\x0e\x02\
    \0\x01\x12\x04\x8d\x06\t\r\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\x8d\x06\
    \x10\x11\n\x89\x01\n\x04\x04\x0e\x02\x01\x12\x04\x91\x06\x02\x12\x1a{\
    \x20HTTP\x201.1\x20Entity\x20tag\x20for\x20the\x20access-control\x20entr\
    y.\n\x20See\x20[https://tools.ietf.org/html/rfc7232#section-2.3][RFC\x20\
    7232\x20\xc2\xa72.3].\n\n\x0f\n\x05\x04\x0e\x02\x01\x04\x12\x06\x91\x06\
    \x02\x8d\x06\x12\n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\x91\x06\x02\x08\n\
    \r\n\x05\x04\x0e\x02\x01\x01\x12\x04\x91\x06\t\r\n\r\n\x05\x04\x0e\x02\
    \x01\x03\x12\x04\x91\x06\x10\x11\n3\n\x04\x04\x0e\x02\x02\x12\x04\x94\
    \x06\x02\x10\x1a%\x20The\x20ID\x20of\x20the\x20access-control\x20entry.\
    \n\n\x0f\n\x05\x04\x0e\x02\x02\x04\x12\x06\x94\x06\x02\x91\x06\x12\n\r\n\
    \x05\x04\x0e\x02\x02\x05\x12\x04\x94\x06\x02\x08\n\r\n\x05\x04\x0e\x02\
    \x02\x01\x12\x04\x94\x06\t\x0b\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\x94\
    \x06\x0e\x0f\n'\n\x04\x04\x0e\x02\x03\x12\x04\x97\x06\x02\x14\x1a\x19\
    \x20The\x20name\x20of\x20the\x20bucket.\n\n\x0f\n\x05\x04\x0e\x02\x03\
    \x04\x12\x06\x97\x06\x02\x94\x06\x10\n\r\n\x05\x04\x0e\x02\x03\x05\x12\
    \x04\x97\x06\x02\x08\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\x97\x06\t\x0f\
    \n\r\n\x05\x04\x0e\x02\x03\x03\x12\x04\x97\x06\x12\x13\n@\n\x04\x04\x0e\
    \x02\x04\x12\x04\x9a\x06\x02\x14\x1a2\x20The\x20name\x20of\x20the\x20obj\
    ect,\x20if\x20applied\x20to\x20an\x20object.\n\n\x0f\n\x05\x04\x0e\x02\
    \x04\x04\x12\x06\x9a\x06\x02\x97\x06\x14\n\r\n\x05\x04\x0e\x02\x04\x05\
    \x12\x04\x9a\x06\x02\x08\n\r\n\x05\x04\x0e\x02\x04\x01\x12\x04\x9a\x06\t\
    \x0f\n\r\n\x05\x04\x0e\x02\x04\x03\x12\x04\x9a\x06\x12\x13\nN\n\x04\x04\
    \x0e\x02\x05\x12\x04\x9d\x06\x02\x17\x1a@\x20The\x20content\x20generatio\
    n\x20of\x20the\x20object,\x20if\x20applied\x20to\x20an\x20object.\n\n\
    \x0f\n\x05\x04\x0e\x02\x05\x04\x12\x06\x9d\x06\x02\x9a\x06\x14\n\r\n\x05\
    \x04\x0e\x02\x05\x05\x12\x04\x9d\x06\x02\x07\n\r\n\x05\x04\x0e\x02\x05\
    \x01\x12\x04\x9d\x06\x08\x12\n\r\n\x05\x04\x0e\x02\x05\x03\x12\x04\x9d\
    \x06\x15\x16\n\xfd\x03\n\x04\x04\x0e\x02\x06\x12\x04\xae\x06\x02\x14\x1a\
    \xee\x03\x20The\x20entity\x20holding\x20the\x20permission,\x20in\x20one\
    \x20of\x20the\x20following\x20forms:\n\x20*\x20`user-{userid}`\n\x20*\
    \x20`user-{email}`\n\x20*\x20`group-{groupid}`\n\x20*\x20`group-{email}`\
    \n\x20*\x20`domain-{domain}`\n\x20*\x20`project-{team-projectid}`\n\x20*\
    \x20`allUsers`\n\x20*\x20`allAuthenticatedUsers`\n\x20Examples:\n\x20*\
    \x20The\x20user\x20`liz@example.com`\x20would\x20be\x20`user-liz@example\
    .com`.\n\x20*\x20The\x20group\x20`example@googlegroups.com`\x20would\x20\
    be\n\x20`group-example@googlegroups.com`.\n\x20*\x20All\x20members\x20of\
    \x20the\x20Google\x20Apps\x20for\x20Business\x20domain\x20`example.com`\
    \x20would\x20be\n\x20`domain-example.com`.\n\n\x0f\n\x05\x04\x0e\x02\x06\
    \x04\x12\x06\xae\x06\x02\x9d\x06\x17\n\r\n\x05\x04\x0e\x02\x06\x05\x12\
    \x04\xae\x06\x02\x08\n\r\n\x05\x04\x0e\x02\x06\x01\x12\x04\xae\x06\t\x0f\
    \n\r\n\x05\x04\x0e\x02\x06\x03\x12\x04\xae\x06\x12\x13\n.\n\x04\x04\x0e\
    \x02\x07\x12\x04\xb1\x06\x02\x17\x1a\x20\x20The\x20ID\x20for\x20the\x20e\
    ntity,\x20if\x20any.\n\n\x0f\n\x05\x04\x0e\x02\x07\x04\x12\x06\xb1\x06\
    \x02\xae\x06\x14\n\r\n\x05\x04\x0e\x02\x07\x05\x12\x04\xb1\x06\x02\x08\n\
    \r\n\x05\x04\x0e\x02\x07\x01\x12\x04\xb1\x06\t\x12\n\r\n\x05\x04\x0e\x02\
    \x07\x03\x12\x04\xb1\x06\x15\x16\nE\n\x04\x04\x0e\x02\x08\x12\x04\xb4\
    \x06\x02\x13\x1a7\x20The\x20email\x20address\x20associated\x20with\x20th\
    e\x20entity,\x20if\x20any.\n\n\x0f\n\x05\x04\x0e\x02\x08\x04\x12\x06\xb4\
    \x06\x02\xb1\x06\x17\n\r\n\x05\x04\x0e\x02\x08\x05\x12\x04\xb4\x06\x02\
    \x08\n\r\n\x05\x04\x0e\x02\x08\x01\x12\x04\xb4\x06\t\x0e\n\r\n\x05\x04\
    \x0e\x02\x08\x03\x12\x04\xb4\x06\x11\x12\n>\n\x04\x04\x0e\x02\t\x12\x04\
    \xb7\x06\x02\x15\x1a0\x20The\x20domain\x20associated\x20with\x20the\x20e\
    ntity,\x20if\x20any.\n\n\x0f\n\x05\x04\x0e\x02\t\x04\x12\x06\xb7\x06\x02\
    \xb4\x06\x13\n\r\n\x05\x04\x0e\x02\t\x05\x12\x04\xb7\x06\x02\x08\n\r\n\
    \x05\x04\x0e\x02\t\x01\x12\x04\xb7\x06\t\x0f\n\r\n\x05\x04\x0e\x02\t\x03\
    \x12\x04\xb7\x06\x12\x14\nD\n\x04\x04\x0e\x02\n\x12\x04\xba\x06\x02\x20\
    \x1a6\x20The\x20project\x20team\x20associated\x20with\x20the\x20entity,\
    \x20if\x20any.\n\n\x0f\n\x05\x04\x0e\x02\n\x04\x12\x06\xba\x06\x02\xb7\
    \x06\x15\n\r\n\x05\x04\x0e\x02\n\x06\x12\x04\xba\x06\x02\r\n\r\n\x05\x04\
    \x0e\x02\n\x01\x12\x04\xba\x06\x0e\x1a\n\r\n\x05\x04\x0e\x02\n\x03\x12\
    \x04\xba\x06\x1d\x1f\nV\n\x02\x04\x0f\x12\x06\xbe\x06\0\xc1\x06\x01\x1aH\
    \x20The\x20result\x20of\x20a\x20call\x20to\x20ObjectAccessControls.ListO\
    bjectAccessControls.\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\xbe\x06\x08(\n\"\
    \n\x04\x04\x0f\x02\0\x12\x04\xc0\x06\x02)\x1a\x14\x20The\x20list\x20of\
    \x20items.\n\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\xc0\x06\x02\n\n\r\n\x05\
    \x04\x0f\x02\0\x06\x12\x04\xc0\x06\x0b\x1e\n\r\n\x05\x04\x0f\x02\0\x01\
    \x12\x04\xc0\x06\x1f$\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xc0\x06'(\n;\n\
    \x02\x04\x10\x12\x06\xc4\x06\0\xcf\x06\x01\x1a-\x20The\x20result\x20of\
    \x20a\x20call\x20to\x20Objects.ListObjects\n\n\x0b\n\x03\x04\x10\x01\x12\
    \x04\xc4\x06\x08\x1b\nu\n\x04\x04\x10\x02\0\x12\x04\xc7\x06\x02\x1f\x1ag\
    \x20The\x20list\x20of\x20prefixes\x20of\x20objects\x20matching-but-not-l\
    isted\x20up\x20to\x20and\x20including\n\x20the\x20requested\x20delimiter\
    .\n\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xc7\x06\x02\n\n\r\n\x05\x04\x10\
    \x02\0\x05\x12\x04\xc7\x06\x0b\x11\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\
    \xc7\x06\x12\x1a\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xc7\x06\x1d\x1e\n\"\
    \n\x04\x04\x10\x02\x01\x12\x04\xca\x06\x02\x1c\x1a\x14\x20The\x20list\
    \x20of\x20items.\n\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\xca\x06\x02\n\n\
    \r\n\x05\x04\x10\x02\x01\x06\x12\x04\xca\x06\x0b\x11\n\r\n\x05\x04\x10\
    \x02\x01\x01\x12\x04\xca\x06\x12\x17\n\r\n\x05\x04\x10\x02\x01\x03\x12\
    \x04\xca\x06\x1a\x1b\n\xa0\x01\n\x04\x04\x10\x02\x02\x12\x04\xce\x06\x02\
    \x1d\x1a\x91\x01\x20The\x20continuation\x20token,\x20used\x20to\x20page\
    \x20through\x20large\x20result\x20sets.\x20Provide\n\x20this\x20value\
    \x20in\x20a\x20subsequent\x20request\x20to\x20return\x20the\x20next\x20p\
    age\x20of\x20results.\n\n\x0f\n\x05\x04\x10\x02\x02\x04\x12\x06\xce\x06\
    \x02\xca\x06\x1c\n\r\n\x05\x04\x10\x02\x02\x05\x12\x04\xce\x06\x02\x08\n\
    \r\n\x05\x04\x10\x02\x02\x01\x12\x04\xce\x06\t\x18\n\r\n\x05\x04\x10\x02\
    \x02\x03\x12\x04\xce\x06\x1b\x1c\nN\n\x02\x04\x11\x12\x06\xd2\x06\0\xd8\
    \x06\x01\x1a@\x20Represents\x20the\x20Viewers,\x20Editors,\x20or\x20Owne\
    rs\x20of\x20a\x20given\x20project.\n\n\x0b\n\x03\x04\x11\x01\x12\x04\xd2\
    \x06\x08\x13\n#\n\x04\x04\x11\x02\0\x12\x04\xd4\x06\x02\x1c\x1a\x15\x20T\
    he\x20project\x20number.\n\n\x0f\n\x05\x04\x11\x02\0\x04\x12\x06\xd4\x06\
    \x02\xd2\x06\x15\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xd4\x06\x02\x08\n\r\
    \n\x05\x04\x11\x02\0\x01\x12\x04\xd4\x06\t\x17\n\r\n\x05\x04\x11\x02\0\
    \x03\x12\x04\xd4\x06\x1a\x1b\n\x19\n\x04\x04\x11\x02\x01\x12\x04\xd7\x06\
    \x02\x12\x1a\x0b\x20The\x20team.\n\n\x0f\n\x05\x04\x11\x02\x01\x04\x12\
    \x06\xd7\x06\x02\xd4\x06\x1c\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\xd7\
    \x06\x02\x08\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xd7\x06\t\r\n\r\n\x05\
    \x04\x11\x02\x01\x03\x12\x04\xd7\x06\x10\x11\nF\n\x02\x04\x12\x12\x06\
    \xdb\x06\0\xde\x06\x01\x1a8\x20A\x20subscription\x20to\x20receive\x20Goo\
    gle\x20PubSub\x20notifications.\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xdb\
    \x06\x08\x16\n+\n\x04\x04\x12\x02\0\x12\x04\xdd\x06\x02\x1b\x1a\x1d\x20T\
    he\x20ID\x20of\x20the\x20notification.\n\n\x0f\n\x05\x04\x12\x02\0\x04\
    \x12\x06\xdd\x06\x02\xdb\x06\x18\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\xdd\
    \x06\x02\x08\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xdd\x06\t\x16\n\r\n\x05\
    \x04\x12\x02\0\x03\x12\x04\xdd\x06\x19\x1a\n1\n\x02\x04\x13\x12\x06\xe1\
    \x06\0\xe7\x06\x01\x1a#\x20The\x20owner\x20of\x20a\x20specific\x20resour\
    ce.\n\n\x0b\n\x03\x04\x13\x01\x12\x04\xe1\x06\x08\r\n8\n\x04\x04\x13\x02\
    \0\x12\x04\xe3\x06\x02\x14\x1a*\x20The\x20entity,\x20in\x20the\x20form\
    \x20`user-`*userId*.\n\n\x0f\n\x05\x04\x13\x02\0\x04\x12\x06\xe3\x06\x02\
    \xe1\x06\x0f\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xe3\x06\x02\x08\n\r\n\
    \x05\x04\x13\x02\0\x01\x12\x04\xe3\x06\t\x0f\n\r\n\x05\x04\x13\x02\0\x03\
    \x12\x04\xe3\x06\x12\x13\n&\n\x04\x04\x13\x02\x01\x12\x04\xe6\x06\x02\
    \x17\x1a\x18\x20The\x20ID\x20for\x20the\x20entity.\n\n\x0f\n\x05\x04\x13\
    \x02\x01\x04\x12\x06\xe6\x06\x02\xe3\x06\x14\n\r\n\x05\x04\x13\x02\x01\
    \x05\x12\x04\xe6\x06\x02\x08\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xe6\
    \x06\t\x12\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\xe6\x06\x15\x16b\x06pro\
    to3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
