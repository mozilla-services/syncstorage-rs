// This file is generated by rust-protobuf 2.22.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/storage/v1/storage.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_22_0;

#[derive(PartialEq,Clone,Default)]
pub struct DeleteBucketAccessControlRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub entity: ::std::string::String,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteBucketAccessControlRequest {
    fn default() -> &'a DeleteBucketAccessControlRequest {
        <DeleteBucketAccessControlRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteBucketAccessControlRequest {
    pub fn new() -> DeleteBucketAccessControlRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string entity = 2;


    pub fn get_entity(&self) -> &str {
        &self.entity
    }
    pub fn clear_entity(&mut self) {
        self.entity.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: ::std::string::String) {
        self.entity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity(&mut self) -> &mut ::std::string::String {
        &mut self.entity
    }

    // Take field
    pub fn take_entity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity, ::std::string::String::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 4;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for DeleteBucketAccessControlRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entity)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.entity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.entity);
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.entity.is_empty() {
            os.write_string(2, &self.entity)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteBucketAccessControlRequest {
        DeleteBucketAccessControlRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &DeleteBucketAccessControlRequest| { &m.bucket },
                |m: &mut DeleteBucketAccessControlRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entity",
                |m: &DeleteBucketAccessControlRequest| { &m.entity },
                |m: &mut DeleteBucketAccessControlRequest| { &mut m.entity },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &DeleteBucketAccessControlRequest| { &m.common_request_params },
                |m: &mut DeleteBucketAccessControlRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteBucketAccessControlRequest>(
                "DeleteBucketAccessControlRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteBucketAccessControlRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteBucketAccessControlRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteBucketAccessControlRequest::new)
    }
}

impl ::protobuf::Clear for DeleteBucketAccessControlRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.entity.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteBucketAccessControlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteBucketAccessControlRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBucketAccessControlRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub entity: ::std::string::String,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBucketAccessControlRequest {
    fn default() -> &'a GetBucketAccessControlRequest {
        <GetBucketAccessControlRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetBucketAccessControlRequest {
    pub fn new() -> GetBucketAccessControlRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string entity = 2;


    pub fn get_entity(&self) -> &str {
        &self.entity
    }
    pub fn clear_entity(&mut self) {
        self.entity.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: ::std::string::String) {
        self.entity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity(&mut self) -> &mut ::std::string::String {
        &mut self.entity
    }

    // Take field
    pub fn take_entity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity, ::std::string::String::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 4;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for GetBucketAccessControlRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entity)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.entity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.entity);
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.entity.is_empty() {
            os.write_string(2, &self.entity)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBucketAccessControlRequest {
        GetBucketAccessControlRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &GetBucketAccessControlRequest| { &m.bucket },
                |m: &mut GetBucketAccessControlRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entity",
                |m: &GetBucketAccessControlRequest| { &m.entity },
                |m: &mut GetBucketAccessControlRequest| { &mut m.entity },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &GetBucketAccessControlRequest| { &m.common_request_params },
                |m: &mut GetBucketAccessControlRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetBucketAccessControlRequest>(
                "GetBucketAccessControlRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetBucketAccessControlRequest {
        static instance: ::protobuf::rt::LazyV2<GetBucketAccessControlRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetBucketAccessControlRequest::new)
    }
}

impl ::protobuf::Clear for GetBucketAccessControlRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.entity.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBucketAccessControlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBucketAccessControlRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InsertBucketAccessControlRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub bucket_access_control: ::protobuf::SingularPtrField<super::storage_resources::BucketAccessControl>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InsertBucketAccessControlRequest {
    fn default() -> &'a InsertBucketAccessControlRequest {
        <InsertBucketAccessControlRequest as ::protobuf::Message>::default_instance()
    }
}

impl InsertBucketAccessControlRequest {
    pub fn new() -> InsertBucketAccessControlRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // .google.storage.v1.BucketAccessControl bucket_access_control = 3;


    pub fn get_bucket_access_control(&self) -> &super::storage_resources::BucketAccessControl {
        self.bucket_access_control.as_ref().unwrap_or_else(|| <super::storage_resources::BucketAccessControl as ::protobuf::Message>::default_instance())
    }
    pub fn clear_bucket_access_control(&mut self) {
        self.bucket_access_control.clear();
    }

    pub fn has_bucket_access_control(&self) -> bool {
        self.bucket_access_control.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bucket_access_control(&mut self, v: super::storage_resources::BucketAccessControl) {
        self.bucket_access_control = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket_access_control(&mut self) -> &mut super::storage_resources::BucketAccessControl {
        if self.bucket_access_control.is_none() {
            self.bucket_access_control.set_default();
        }
        self.bucket_access_control.as_mut().unwrap()
    }

    // Take field
    pub fn take_bucket_access_control(&mut self) -> super::storage_resources::BucketAccessControl {
        self.bucket_access_control.take().unwrap_or_else(|| super::storage_resources::BucketAccessControl::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 4;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for InsertBucketAccessControlRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.bucket_access_control {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bucket_access_control)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if let Some(ref v) = self.bucket_access_control.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if let Some(ref v) = self.bucket_access_control.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InsertBucketAccessControlRequest {
        InsertBucketAccessControlRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &InsertBucketAccessControlRequest| { &m.bucket },
                |m: &mut InsertBucketAccessControlRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::BucketAccessControl>>(
                "bucket_access_control",
                |m: &InsertBucketAccessControlRequest| { &m.bucket_access_control },
                |m: &mut InsertBucketAccessControlRequest| { &mut m.bucket_access_control },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &InsertBucketAccessControlRequest| { &m.common_request_params },
                |m: &mut InsertBucketAccessControlRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InsertBucketAccessControlRequest>(
                "InsertBucketAccessControlRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InsertBucketAccessControlRequest {
        static instance: ::protobuf::rt::LazyV2<InsertBucketAccessControlRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InsertBucketAccessControlRequest::new)
    }
}

impl ::protobuf::Clear for InsertBucketAccessControlRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.bucket_access_control.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InsertBucketAccessControlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InsertBucketAccessControlRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListBucketAccessControlsRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListBucketAccessControlsRequest {
    fn default() -> &'a ListBucketAccessControlsRequest {
        <ListBucketAccessControlsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListBucketAccessControlsRequest {
    pub fn new() -> ListBucketAccessControlsRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 3;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for ListBucketAccessControlsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListBucketAccessControlsRequest {
        ListBucketAccessControlsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &ListBucketAccessControlsRequest| { &m.bucket },
                |m: &mut ListBucketAccessControlsRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &ListBucketAccessControlsRequest| { &m.common_request_params },
                |m: &mut ListBucketAccessControlsRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListBucketAccessControlsRequest>(
                "ListBucketAccessControlsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListBucketAccessControlsRequest {
        static instance: ::protobuf::rt::LazyV2<ListBucketAccessControlsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListBucketAccessControlsRequest::new)
    }
}

impl ::protobuf::Clear for ListBucketAccessControlsRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListBucketAccessControlsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListBucketAccessControlsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchBucketAccessControlRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub entity: ::std::string::String,
    pub bucket_access_control: ::protobuf::SingularPtrField<super::storage_resources::BucketAccessControl>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchBucketAccessControlRequest {
    fn default() -> &'a PatchBucketAccessControlRequest {
        <PatchBucketAccessControlRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchBucketAccessControlRequest {
    pub fn new() -> PatchBucketAccessControlRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string entity = 2;


    pub fn get_entity(&self) -> &str {
        &self.entity
    }
    pub fn clear_entity(&mut self) {
        self.entity.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: ::std::string::String) {
        self.entity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity(&mut self) -> &mut ::std::string::String {
        &mut self.entity
    }

    // Take field
    pub fn take_entity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity, ::std::string::String::new())
    }

    // .google.storage.v1.BucketAccessControl bucket_access_control = 4;


    pub fn get_bucket_access_control(&self) -> &super::storage_resources::BucketAccessControl {
        self.bucket_access_control.as_ref().unwrap_or_else(|| <super::storage_resources::BucketAccessControl as ::protobuf::Message>::default_instance())
    }
    pub fn clear_bucket_access_control(&mut self) {
        self.bucket_access_control.clear();
    }

    pub fn has_bucket_access_control(&self) -> bool {
        self.bucket_access_control.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bucket_access_control(&mut self, v: super::storage_resources::BucketAccessControl) {
        self.bucket_access_control = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket_access_control(&mut self) -> &mut super::storage_resources::BucketAccessControl {
        if self.bucket_access_control.is_none() {
            self.bucket_access_control.set_default();
        }
        self.bucket_access_control.as_mut().unwrap()
    }

    // Take field
    pub fn take_bucket_access_control(&mut self) -> super::storage_resources::BucketAccessControl {
        self.bucket_access_control.take().unwrap_or_else(|| super::storage_resources::BucketAccessControl::new())
    }

    // .google.protobuf.FieldMask update_mask = 5;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 6;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for PatchBucketAccessControlRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.bucket_access_control {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entity)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bucket_access_control)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.entity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.entity);
        }
        if let Some(ref v) = self.bucket_access_control.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.entity.is_empty() {
            os.write_string(2, &self.entity)?;
        }
        if let Some(ref v) = self.bucket_access_control.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchBucketAccessControlRequest {
        PatchBucketAccessControlRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &PatchBucketAccessControlRequest| { &m.bucket },
                |m: &mut PatchBucketAccessControlRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entity",
                |m: &PatchBucketAccessControlRequest| { &m.entity },
                |m: &mut PatchBucketAccessControlRequest| { &mut m.entity },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::BucketAccessControl>>(
                "bucket_access_control",
                |m: &PatchBucketAccessControlRequest| { &m.bucket_access_control },
                |m: &mut PatchBucketAccessControlRequest| { &mut m.bucket_access_control },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "update_mask",
                |m: &PatchBucketAccessControlRequest| { &m.update_mask },
                |m: &mut PatchBucketAccessControlRequest| { &mut m.update_mask },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &PatchBucketAccessControlRequest| { &m.common_request_params },
                |m: &mut PatchBucketAccessControlRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchBucketAccessControlRequest>(
                "PatchBucketAccessControlRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchBucketAccessControlRequest {
        static instance: ::protobuf::rt::LazyV2<PatchBucketAccessControlRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchBucketAccessControlRequest::new)
    }
}

impl ::protobuf::Clear for PatchBucketAccessControlRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.entity.clear();
        self.bucket_access_control.clear();
        self.update_mask.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchBucketAccessControlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchBucketAccessControlRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateBucketAccessControlRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub entity: ::std::string::String,
    pub bucket_access_control: ::protobuf::SingularPtrField<super::storage_resources::BucketAccessControl>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateBucketAccessControlRequest {
    fn default() -> &'a UpdateBucketAccessControlRequest {
        <UpdateBucketAccessControlRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateBucketAccessControlRequest {
    pub fn new() -> UpdateBucketAccessControlRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string entity = 2;


    pub fn get_entity(&self) -> &str {
        &self.entity
    }
    pub fn clear_entity(&mut self) {
        self.entity.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: ::std::string::String) {
        self.entity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity(&mut self) -> &mut ::std::string::String {
        &mut self.entity
    }

    // Take field
    pub fn take_entity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity, ::std::string::String::new())
    }

    // .google.storage.v1.BucketAccessControl bucket_access_control = 4;


    pub fn get_bucket_access_control(&self) -> &super::storage_resources::BucketAccessControl {
        self.bucket_access_control.as_ref().unwrap_or_else(|| <super::storage_resources::BucketAccessControl as ::protobuf::Message>::default_instance())
    }
    pub fn clear_bucket_access_control(&mut self) {
        self.bucket_access_control.clear();
    }

    pub fn has_bucket_access_control(&self) -> bool {
        self.bucket_access_control.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bucket_access_control(&mut self, v: super::storage_resources::BucketAccessControl) {
        self.bucket_access_control = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket_access_control(&mut self) -> &mut super::storage_resources::BucketAccessControl {
        if self.bucket_access_control.is_none() {
            self.bucket_access_control.set_default();
        }
        self.bucket_access_control.as_mut().unwrap()
    }

    // Take field
    pub fn take_bucket_access_control(&mut self) -> super::storage_resources::BucketAccessControl {
        self.bucket_access_control.take().unwrap_or_else(|| super::storage_resources::BucketAccessControl::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 5;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for UpdateBucketAccessControlRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.bucket_access_control {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entity)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bucket_access_control)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.entity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.entity);
        }
        if let Some(ref v) = self.bucket_access_control.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.entity.is_empty() {
            os.write_string(2, &self.entity)?;
        }
        if let Some(ref v) = self.bucket_access_control.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateBucketAccessControlRequest {
        UpdateBucketAccessControlRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &UpdateBucketAccessControlRequest| { &m.bucket },
                |m: &mut UpdateBucketAccessControlRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entity",
                |m: &UpdateBucketAccessControlRequest| { &m.entity },
                |m: &mut UpdateBucketAccessControlRequest| { &mut m.entity },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::BucketAccessControl>>(
                "bucket_access_control",
                |m: &UpdateBucketAccessControlRequest| { &m.bucket_access_control },
                |m: &mut UpdateBucketAccessControlRequest| { &mut m.bucket_access_control },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &UpdateBucketAccessControlRequest| { &m.common_request_params },
                |m: &mut UpdateBucketAccessControlRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateBucketAccessControlRequest>(
                "UpdateBucketAccessControlRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateBucketAccessControlRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateBucketAccessControlRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateBucketAccessControlRequest::new)
    }
}

impl ::protobuf::Clear for UpdateBucketAccessControlRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.entity.clear();
        self.bucket_access_control.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateBucketAccessControlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateBucketAccessControlRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteBucketRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub if_metageneration_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_metageneration_not_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteBucketRequest {
    fn default() -> &'a DeleteBucketRequest {
        <DeleteBucketRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteBucketRequest {
    pub fn new() -> DeleteBucketRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // .google.protobuf.Int64Value if_metageneration_match = 2;


    pub fn get_if_metageneration_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_metageneration_match(&mut self) {
        self.if_metageneration_match.clear();
    }

    pub fn has_if_metageneration_match(&self) -> bool {
        self.if_metageneration_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_metageneration_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_metageneration_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_metageneration_match.is_none() {
            self.if_metageneration_match.set_default();
        }
        self.if_metageneration_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_metageneration_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_metageneration_not_match = 3;


    pub fn get_if_metageneration_not_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_metageneration_not_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_metageneration_not_match(&mut self) {
        self.if_metageneration_not_match.clear();
    }

    pub fn has_if_metageneration_not_match(&self) -> bool {
        self.if_metageneration_not_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_not_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_metageneration_not_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_metageneration_not_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_metageneration_not_match.is_none() {
            self.if_metageneration_not_match.set_default();
        }
        self.if_metageneration_not_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_metageneration_not_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_metageneration_not_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 5;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for DeleteBucketRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.if_metageneration_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_metageneration_not_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_metageneration_match)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_metageneration_not_match)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_metageneration_not_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_metageneration_not_match.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteBucketRequest {
        DeleteBucketRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &DeleteBucketRequest| { &m.bucket },
                |m: &mut DeleteBucketRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_metageneration_match",
                |m: &DeleteBucketRequest| { &m.if_metageneration_match },
                |m: &mut DeleteBucketRequest| { &mut m.if_metageneration_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_metageneration_not_match",
                |m: &DeleteBucketRequest| { &m.if_metageneration_not_match },
                |m: &mut DeleteBucketRequest| { &mut m.if_metageneration_not_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &DeleteBucketRequest| { &m.common_request_params },
                |m: &mut DeleteBucketRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteBucketRequest>(
                "DeleteBucketRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteBucketRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteBucketRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteBucketRequest::new)
    }
}

impl ::protobuf::Clear for DeleteBucketRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.if_metageneration_match.clear();
        self.if_metageneration_not_match.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteBucketRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteBucketRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBucketRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub if_metageneration_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_metageneration_not_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub projection: super::storage_resources::CommonEnums_Projection,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBucketRequest {
    fn default() -> &'a GetBucketRequest {
        <GetBucketRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetBucketRequest {
    pub fn new() -> GetBucketRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // .google.protobuf.Int64Value if_metageneration_match = 2;


    pub fn get_if_metageneration_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_metageneration_match(&mut self) {
        self.if_metageneration_match.clear();
    }

    pub fn has_if_metageneration_match(&self) -> bool {
        self.if_metageneration_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_metageneration_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_metageneration_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_metageneration_match.is_none() {
            self.if_metageneration_match.set_default();
        }
        self.if_metageneration_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_metageneration_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_metageneration_not_match = 3;


    pub fn get_if_metageneration_not_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_metageneration_not_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_metageneration_not_match(&mut self) {
        self.if_metageneration_not_match.clear();
    }

    pub fn has_if_metageneration_not_match(&self) -> bool {
        self.if_metageneration_not_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_not_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_metageneration_not_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_metageneration_not_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_metageneration_not_match.is_none() {
            self.if_metageneration_not_match.set_default();
        }
        self.if_metageneration_not_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_metageneration_not_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_metageneration_not_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.storage.v1.CommonEnums.Projection projection = 4;


    pub fn get_projection(&self) -> super::storage_resources::CommonEnums_Projection {
        self.projection
    }
    pub fn clear_projection(&mut self) {
        self.projection = super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_projection(&mut self, v: super::storage_resources::CommonEnums_Projection) {
        self.projection = v;
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 6;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for GetBucketRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.if_metageneration_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_metageneration_not_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_metageneration_match)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_metageneration_not_match)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.projection, 4, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_metageneration_not_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.projection != super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.projection);
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_metageneration_not_match.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.projection != super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.projection))?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBucketRequest {
        GetBucketRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &GetBucketRequest| { &m.bucket },
                |m: &mut GetBucketRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_metageneration_match",
                |m: &GetBucketRequest| { &m.if_metageneration_match },
                |m: &mut GetBucketRequest| { &mut m.if_metageneration_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_metageneration_not_match",
                |m: &GetBucketRequest| { &m.if_metageneration_not_match },
                |m: &mut GetBucketRequest| { &mut m.if_metageneration_not_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::storage_resources::CommonEnums_Projection>>(
                "projection",
                |m: &GetBucketRequest| { &m.projection },
                |m: &mut GetBucketRequest| { &mut m.projection },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &GetBucketRequest| { &m.common_request_params },
                |m: &mut GetBucketRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetBucketRequest>(
                "GetBucketRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetBucketRequest {
        static instance: ::protobuf::rt::LazyV2<GetBucketRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetBucketRequest::new)
    }
}

impl ::protobuf::Clear for GetBucketRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.if_metageneration_match.clear();
        self.if_metageneration_not_match.clear();
        self.projection = super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED;
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBucketRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBucketRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InsertBucketRequest {
    // message fields
    pub predefined_acl: super::storage_resources::CommonEnums_PredefinedBucketAcl,
    pub predefined_default_object_acl: super::storage_resources::CommonEnums_PredefinedObjectAcl,
    pub project: ::std::string::String,
    pub projection: super::storage_resources::CommonEnums_Projection,
    pub bucket: ::protobuf::SingularPtrField<super::storage_resources::Bucket>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InsertBucketRequest {
    fn default() -> &'a InsertBucketRequest {
        <InsertBucketRequest as ::protobuf::Message>::default_instance()
    }
}

impl InsertBucketRequest {
    pub fn new() -> InsertBucketRequest {
        ::std::default::Default::default()
    }

    // .google.storage.v1.CommonEnums.PredefinedBucketAcl predefined_acl = 1;


    pub fn get_predefined_acl(&self) -> super::storage_resources::CommonEnums_PredefinedBucketAcl {
        self.predefined_acl
    }
    pub fn clear_predefined_acl(&mut self) {
        self.predefined_acl = super::storage_resources::CommonEnums_PredefinedBucketAcl::PREDEFINED_BUCKET_ACL_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_predefined_acl(&mut self, v: super::storage_resources::CommonEnums_PredefinedBucketAcl) {
        self.predefined_acl = v;
    }

    // .google.storage.v1.CommonEnums.PredefinedObjectAcl predefined_default_object_acl = 2;


    pub fn get_predefined_default_object_acl(&self) -> super::storage_resources::CommonEnums_PredefinedObjectAcl {
        self.predefined_default_object_acl
    }
    pub fn clear_predefined_default_object_acl(&mut self) {
        self.predefined_default_object_acl = super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_predefined_default_object_acl(&mut self, v: super::storage_resources::CommonEnums_PredefinedObjectAcl) {
        self.predefined_default_object_acl = v;
    }

    // string project = 3;


    pub fn get_project(&self) -> &str {
        &self.project
    }
    pub fn clear_project(&mut self) {
        self.project.clear();
    }

    // Param is passed by value, moved
    pub fn set_project(&mut self, v: ::std::string::String) {
        self.project = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project(&mut self) -> &mut ::std::string::String {
        &mut self.project
    }

    // Take field
    pub fn take_project(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project, ::std::string::String::new())
    }

    // .google.storage.v1.CommonEnums.Projection projection = 4;


    pub fn get_projection(&self) -> super::storage_resources::CommonEnums_Projection {
        self.projection
    }
    pub fn clear_projection(&mut self) {
        self.projection = super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_projection(&mut self, v: super::storage_resources::CommonEnums_Projection) {
        self.projection = v;
    }

    // .google.storage.v1.Bucket bucket = 6;


    pub fn get_bucket(&self) -> &super::storage_resources::Bucket {
        self.bucket.as_ref().unwrap_or_else(|| <super::storage_resources::Bucket as ::protobuf::Message>::default_instance())
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    pub fn has_bucket(&self) -> bool {
        self.bucket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: super::storage_resources::Bucket) {
        self.bucket = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut super::storage_resources::Bucket {
        if self.bucket.is_none() {
            self.bucket.set_default();
        }
        self.bucket.as_mut().unwrap()
    }

    // Take field
    pub fn take_bucket(&mut self) -> super::storage_resources::Bucket {
        self.bucket.take().unwrap_or_else(|| super::storage_resources::Bucket::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 7;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for InsertBucketRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.bucket {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.predefined_acl, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.predefined_default_object_acl, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.projection, 4, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bucket)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.predefined_acl != super::storage_resources::CommonEnums_PredefinedBucketAcl::PREDEFINED_BUCKET_ACL_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.predefined_acl);
        }
        if self.predefined_default_object_acl != super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(2, self.predefined_default_object_acl);
        }
        if !self.project.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.project);
        }
        if self.projection != super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.projection);
        }
        if let Some(ref v) = self.bucket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.predefined_acl != super::storage_resources::CommonEnums_PredefinedBucketAcl::PREDEFINED_BUCKET_ACL_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.predefined_acl))?;
        }
        if self.predefined_default_object_acl != super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.predefined_default_object_acl))?;
        }
        if !self.project.is_empty() {
            os.write_string(3, &self.project)?;
        }
        if self.projection != super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.projection))?;
        }
        if let Some(ref v) = self.bucket.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InsertBucketRequest {
        InsertBucketRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::storage_resources::CommonEnums_PredefinedBucketAcl>>(
                "predefined_acl",
                |m: &InsertBucketRequest| { &m.predefined_acl },
                |m: &mut InsertBucketRequest| { &mut m.predefined_acl },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::storage_resources::CommonEnums_PredefinedObjectAcl>>(
                "predefined_default_object_acl",
                |m: &InsertBucketRequest| { &m.predefined_default_object_acl },
                |m: &mut InsertBucketRequest| { &mut m.predefined_default_object_acl },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project",
                |m: &InsertBucketRequest| { &m.project },
                |m: &mut InsertBucketRequest| { &mut m.project },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::storage_resources::CommonEnums_Projection>>(
                "projection",
                |m: &InsertBucketRequest| { &m.projection },
                |m: &mut InsertBucketRequest| { &mut m.projection },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::Bucket>>(
                "bucket",
                |m: &InsertBucketRequest| { &m.bucket },
                |m: &mut InsertBucketRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &InsertBucketRequest| { &m.common_request_params },
                |m: &mut InsertBucketRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InsertBucketRequest>(
                "InsertBucketRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InsertBucketRequest {
        static instance: ::protobuf::rt::LazyV2<InsertBucketRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InsertBucketRequest::new)
    }
}

impl ::protobuf::Clear for InsertBucketRequest {
    fn clear(&mut self) {
        self.predefined_acl = super::storage_resources::CommonEnums_PredefinedBucketAcl::PREDEFINED_BUCKET_ACL_UNSPECIFIED;
        self.predefined_default_object_acl = super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED;
        self.project.clear();
        self.projection = super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED;
        self.bucket.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InsertBucketRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InsertBucketRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListChannelsRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListChannelsRequest {
    fn default() -> &'a ListChannelsRequest {
        <ListChannelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListChannelsRequest {
    pub fn new() -> ListChannelsRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 3;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for ListChannelsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListChannelsRequest {
        ListChannelsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &ListChannelsRequest| { &m.bucket },
                |m: &mut ListChannelsRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &ListChannelsRequest| { &m.common_request_params },
                |m: &mut ListChannelsRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListChannelsRequest>(
                "ListChannelsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListChannelsRequest {
        static instance: ::protobuf::rt::LazyV2<ListChannelsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListChannelsRequest::new)
    }
}

impl ::protobuf::Clear for ListChannelsRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListChannelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListChannelsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListBucketsRequest {
    // message fields
    pub max_results: i32,
    pub page_token: ::std::string::String,
    pub prefix: ::std::string::String,
    pub project: ::std::string::String,
    pub projection: super::storage_resources::CommonEnums_Projection,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListBucketsRequest {
    fn default() -> &'a ListBucketsRequest {
        <ListBucketsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListBucketsRequest {
    pub fn new() -> ListBucketsRequest {
        ::std::default::Default::default()
    }

    // int32 max_results = 1;


    pub fn get_max_results(&self) -> i32 {
        self.max_results
    }
    pub fn clear_max_results(&mut self) {
        self.max_results = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_results(&mut self, v: i32) {
        self.max_results = v;
    }

    // string page_token = 2;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    // string prefix = 3;


    pub fn get_prefix(&self) -> &str {
        &self.prefix
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::string::String) {
        self.prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.prefix
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prefix, ::std::string::String::new())
    }

    // string project = 4;


    pub fn get_project(&self) -> &str {
        &self.project
    }
    pub fn clear_project(&mut self) {
        self.project.clear();
    }

    // Param is passed by value, moved
    pub fn set_project(&mut self, v: ::std::string::String) {
        self.project = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project(&mut self) -> &mut ::std::string::String {
        &mut self.project
    }

    // Take field
    pub fn take_project(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project, ::std::string::String::new())
    }

    // .google.storage.v1.CommonEnums.Projection projection = 5;


    pub fn get_projection(&self) -> super::storage_resources::CommonEnums_Projection {
        self.projection
    }
    pub fn clear_projection(&mut self) {
        self.projection = super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_projection(&mut self, v: super::storage_resources::CommonEnums_Projection) {
        self.projection = v;
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 7;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for ListBucketsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_results = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.prefix)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.projection, 5, &mut self.unknown_fields)?
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.max_results != 0 {
            my_size += ::protobuf::rt::value_size(1, self.max_results, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.page_token);
        }
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.prefix);
        }
        if !self.project.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.project);
        }
        if self.projection != super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(5, self.projection);
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.max_results != 0 {
            os.write_int32(1, self.max_results)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(2, &self.page_token)?;
        }
        if !self.prefix.is_empty() {
            os.write_string(3, &self.prefix)?;
        }
        if !self.project.is_empty() {
            os.write_string(4, &self.project)?;
        }
        if self.projection != super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.projection))?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListBucketsRequest {
        ListBucketsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_results",
                |m: &ListBucketsRequest| { &m.max_results },
                |m: &mut ListBucketsRequest| { &mut m.max_results },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListBucketsRequest| { &m.page_token },
                |m: &mut ListBucketsRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "prefix",
                |m: &ListBucketsRequest| { &m.prefix },
                |m: &mut ListBucketsRequest| { &mut m.prefix },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project",
                |m: &ListBucketsRequest| { &m.project },
                |m: &mut ListBucketsRequest| { &mut m.project },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::storage_resources::CommonEnums_Projection>>(
                "projection",
                |m: &ListBucketsRequest| { &m.projection },
                |m: &mut ListBucketsRequest| { &mut m.projection },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &ListBucketsRequest| { &m.common_request_params },
                |m: &mut ListBucketsRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListBucketsRequest>(
                "ListBucketsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListBucketsRequest {
        static instance: ::protobuf::rt::LazyV2<ListBucketsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListBucketsRequest::new)
    }
}

impl ::protobuf::Clear for ListBucketsRequest {
    fn clear(&mut self) {
        self.max_results = 0;
        self.page_token.clear();
        self.prefix.clear();
        self.project.clear();
        self.projection = super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED;
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListBucketsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListBucketsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LockRetentionPolicyRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub if_metageneration_match: i64,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LockRetentionPolicyRequest {
    fn default() -> &'a LockRetentionPolicyRequest {
        <LockRetentionPolicyRequest as ::protobuf::Message>::default_instance()
    }
}

impl LockRetentionPolicyRequest {
    pub fn new() -> LockRetentionPolicyRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // int64 if_metageneration_match = 2;


    pub fn get_if_metageneration_match(&self) -> i64 {
        self.if_metageneration_match
    }
    pub fn clear_if_metageneration_match(&mut self) {
        self.if_metageneration_match = 0;
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_match(&mut self, v: i64) {
        self.if_metageneration_match = v;
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 4;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for LockRetentionPolicyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.if_metageneration_match = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if self.if_metageneration_match != 0 {
            my_size += ::protobuf::rt::value_size(2, self.if_metageneration_match, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if self.if_metageneration_match != 0 {
            os.write_int64(2, self.if_metageneration_match)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LockRetentionPolicyRequest {
        LockRetentionPolicyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &LockRetentionPolicyRequest| { &m.bucket },
                |m: &mut LockRetentionPolicyRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "if_metageneration_match",
                |m: &LockRetentionPolicyRequest| { &m.if_metageneration_match },
                |m: &mut LockRetentionPolicyRequest| { &mut m.if_metageneration_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &LockRetentionPolicyRequest| { &m.common_request_params },
                |m: &mut LockRetentionPolicyRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LockRetentionPolicyRequest>(
                "LockRetentionPolicyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LockRetentionPolicyRequest {
        static instance: ::protobuf::rt::LazyV2<LockRetentionPolicyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LockRetentionPolicyRequest::new)
    }
}

impl ::protobuf::Clear for LockRetentionPolicyRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.if_metageneration_match = 0;
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LockRetentionPolicyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LockRetentionPolicyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchBucketRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub if_metageneration_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_metageneration_not_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub predefined_acl: super::storage_resources::CommonEnums_PredefinedBucketAcl,
    pub predefined_default_object_acl: super::storage_resources::CommonEnums_PredefinedObjectAcl,
    pub projection: super::storage_resources::CommonEnums_Projection,
    pub metadata: ::protobuf::SingularPtrField<super::storage_resources::Bucket>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchBucketRequest {
    fn default() -> &'a PatchBucketRequest {
        <PatchBucketRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchBucketRequest {
    pub fn new() -> PatchBucketRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // .google.protobuf.Int64Value if_metageneration_match = 2;


    pub fn get_if_metageneration_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_metageneration_match(&mut self) {
        self.if_metageneration_match.clear();
    }

    pub fn has_if_metageneration_match(&self) -> bool {
        self.if_metageneration_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_metageneration_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_metageneration_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_metageneration_match.is_none() {
            self.if_metageneration_match.set_default();
        }
        self.if_metageneration_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_metageneration_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_metageneration_not_match = 3;


    pub fn get_if_metageneration_not_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_metageneration_not_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_metageneration_not_match(&mut self) {
        self.if_metageneration_not_match.clear();
    }

    pub fn has_if_metageneration_not_match(&self) -> bool {
        self.if_metageneration_not_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_not_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_metageneration_not_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_metageneration_not_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_metageneration_not_match.is_none() {
            self.if_metageneration_not_match.set_default();
        }
        self.if_metageneration_not_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_metageneration_not_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_metageneration_not_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.storage.v1.CommonEnums.PredefinedBucketAcl predefined_acl = 4;


    pub fn get_predefined_acl(&self) -> super::storage_resources::CommonEnums_PredefinedBucketAcl {
        self.predefined_acl
    }
    pub fn clear_predefined_acl(&mut self) {
        self.predefined_acl = super::storage_resources::CommonEnums_PredefinedBucketAcl::PREDEFINED_BUCKET_ACL_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_predefined_acl(&mut self, v: super::storage_resources::CommonEnums_PredefinedBucketAcl) {
        self.predefined_acl = v;
    }

    // .google.storage.v1.CommonEnums.PredefinedObjectAcl predefined_default_object_acl = 5;


    pub fn get_predefined_default_object_acl(&self) -> super::storage_resources::CommonEnums_PredefinedObjectAcl {
        self.predefined_default_object_acl
    }
    pub fn clear_predefined_default_object_acl(&mut self) {
        self.predefined_default_object_acl = super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_predefined_default_object_acl(&mut self, v: super::storage_resources::CommonEnums_PredefinedObjectAcl) {
        self.predefined_default_object_acl = v;
    }

    // .google.storage.v1.CommonEnums.Projection projection = 6;


    pub fn get_projection(&self) -> super::storage_resources::CommonEnums_Projection {
        self.projection
    }
    pub fn clear_projection(&mut self) {
        self.projection = super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_projection(&mut self, v: super::storage_resources::CommonEnums_Projection) {
        self.projection = v;
    }

    // .google.storage.v1.Bucket metadata = 8;


    pub fn get_metadata(&self) -> &super::storage_resources::Bucket {
        self.metadata.as_ref().unwrap_or_else(|| <super::storage_resources::Bucket as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::storage_resources::Bucket) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::storage_resources::Bucket {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::storage_resources::Bucket {
        self.metadata.take().unwrap_or_else(|| super::storage_resources::Bucket::new())
    }

    // .google.protobuf.FieldMask update_mask = 9;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 10;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for PatchBucketRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.if_metageneration_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_metageneration_not_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_metageneration_match)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_metageneration_not_match)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.predefined_acl, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.predefined_default_object_acl, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.projection, 6, &mut self.unknown_fields)?
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_metageneration_not_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.predefined_acl != super::storage_resources::CommonEnums_PredefinedBucketAcl::PREDEFINED_BUCKET_ACL_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.predefined_acl);
        }
        if self.predefined_default_object_acl != super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(5, self.predefined_default_object_acl);
        }
        if self.projection != super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(6, self.projection);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_metageneration_not_match.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.predefined_acl != super::storage_resources::CommonEnums_PredefinedBucketAcl::PREDEFINED_BUCKET_ACL_UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.predefined_acl))?;
        }
        if self.predefined_default_object_acl != super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.predefined_default_object_acl))?;
        }
        if self.projection != super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.projection))?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchBucketRequest {
        PatchBucketRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &PatchBucketRequest| { &m.bucket },
                |m: &mut PatchBucketRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_metageneration_match",
                |m: &PatchBucketRequest| { &m.if_metageneration_match },
                |m: &mut PatchBucketRequest| { &mut m.if_metageneration_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_metageneration_not_match",
                |m: &PatchBucketRequest| { &m.if_metageneration_not_match },
                |m: &mut PatchBucketRequest| { &mut m.if_metageneration_not_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::storage_resources::CommonEnums_PredefinedBucketAcl>>(
                "predefined_acl",
                |m: &PatchBucketRequest| { &m.predefined_acl },
                |m: &mut PatchBucketRequest| { &mut m.predefined_acl },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::storage_resources::CommonEnums_PredefinedObjectAcl>>(
                "predefined_default_object_acl",
                |m: &PatchBucketRequest| { &m.predefined_default_object_acl },
                |m: &mut PatchBucketRequest| { &mut m.predefined_default_object_acl },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::storage_resources::CommonEnums_Projection>>(
                "projection",
                |m: &PatchBucketRequest| { &m.projection },
                |m: &mut PatchBucketRequest| { &mut m.projection },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::Bucket>>(
                "metadata",
                |m: &PatchBucketRequest| { &m.metadata },
                |m: &mut PatchBucketRequest| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "update_mask",
                |m: &PatchBucketRequest| { &m.update_mask },
                |m: &mut PatchBucketRequest| { &mut m.update_mask },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &PatchBucketRequest| { &m.common_request_params },
                |m: &mut PatchBucketRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchBucketRequest>(
                "PatchBucketRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchBucketRequest {
        static instance: ::protobuf::rt::LazyV2<PatchBucketRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchBucketRequest::new)
    }
}

impl ::protobuf::Clear for PatchBucketRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.if_metageneration_match.clear();
        self.if_metageneration_not_match.clear();
        self.predefined_acl = super::storage_resources::CommonEnums_PredefinedBucketAcl::PREDEFINED_BUCKET_ACL_UNSPECIFIED;
        self.predefined_default_object_acl = super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED;
        self.projection = super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED;
        self.metadata.clear();
        self.update_mask.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchBucketRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchBucketRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateBucketRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub if_metageneration_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_metageneration_not_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub predefined_acl: super::storage_resources::CommonEnums_PredefinedBucketAcl,
    pub predefined_default_object_acl: super::storage_resources::CommonEnums_PredefinedObjectAcl,
    pub projection: super::storage_resources::CommonEnums_Projection,
    pub metadata: ::protobuf::SingularPtrField<super::storage_resources::Bucket>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateBucketRequest {
    fn default() -> &'a UpdateBucketRequest {
        <UpdateBucketRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateBucketRequest {
    pub fn new() -> UpdateBucketRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // .google.protobuf.Int64Value if_metageneration_match = 2;


    pub fn get_if_metageneration_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_metageneration_match(&mut self) {
        self.if_metageneration_match.clear();
    }

    pub fn has_if_metageneration_match(&self) -> bool {
        self.if_metageneration_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_metageneration_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_metageneration_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_metageneration_match.is_none() {
            self.if_metageneration_match.set_default();
        }
        self.if_metageneration_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_metageneration_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_metageneration_not_match = 3;


    pub fn get_if_metageneration_not_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_metageneration_not_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_metageneration_not_match(&mut self) {
        self.if_metageneration_not_match.clear();
    }

    pub fn has_if_metageneration_not_match(&self) -> bool {
        self.if_metageneration_not_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_not_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_metageneration_not_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_metageneration_not_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_metageneration_not_match.is_none() {
            self.if_metageneration_not_match.set_default();
        }
        self.if_metageneration_not_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_metageneration_not_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_metageneration_not_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.storage.v1.CommonEnums.PredefinedBucketAcl predefined_acl = 4;


    pub fn get_predefined_acl(&self) -> super::storage_resources::CommonEnums_PredefinedBucketAcl {
        self.predefined_acl
    }
    pub fn clear_predefined_acl(&mut self) {
        self.predefined_acl = super::storage_resources::CommonEnums_PredefinedBucketAcl::PREDEFINED_BUCKET_ACL_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_predefined_acl(&mut self, v: super::storage_resources::CommonEnums_PredefinedBucketAcl) {
        self.predefined_acl = v;
    }

    // .google.storage.v1.CommonEnums.PredefinedObjectAcl predefined_default_object_acl = 5;


    pub fn get_predefined_default_object_acl(&self) -> super::storage_resources::CommonEnums_PredefinedObjectAcl {
        self.predefined_default_object_acl
    }
    pub fn clear_predefined_default_object_acl(&mut self) {
        self.predefined_default_object_acl = super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_predefined_default_object_acl(&mut self, v: super::storage_resources::CommonEnums_PredefinedObjectAcl) {
        self.predefined_default_object_acl = v;
    }

    // .google.storage.v1.CommonEnums.Projection projection = 6;


    pub fn get_projection(&self) -> super::storage_resources::CommonEnums_Projection {
        self.projection
    }
    pub fn clear_projection(&mut self) {
        self.projection = super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_projection(&mut self, v: super::storage_resources::CommonEnums_Projection) {
        self.projection = v;
    }

    // .google.storage.v1.Bucket metadata = 8;


    pub fn get_metadata(&self) -> &super::storage_resources::Bucket {
        self.metadata.as_ref().unwrap_or_else(|| <super::storage_resources::Bucket as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::storage_resources::Bucket) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::storage_resources::Bucket {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::storage_resources::Bucket {
        self.metadata.take().unwrap_or_else(|| super::storage_resources::Bucket::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 9;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for UpdateBucketRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.if_metageneration_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_metageneration_not_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_metageneration_match)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_metageneration_not_match)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.predefined_acl, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.predefined_default_object_acl, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.projection, 6, &mut self.unknown_fields)?
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_metageneration_not_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.predefined_acl != super::storage_resources::CommonEnums_PredefinedBucketAcl::PREDEFINED_BUCKET_ACL_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.predefined_acl);
        }
        if self.predefined_default_object_acl != super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(5, self.predefined_default_object_acl);
        }
        if self.projection != super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(6, self.projection);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_metageneration_not_match.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.predefined_acl != super::storage_resources::CommonEnums_PredefinedBucketAcl::PREDEFINED_BUCKET_ACL_UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.predefined_acl))?;
        }
        if self.predefined_default_object_acl != super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.predefined_default_object_acl))?;
        }
        if self.projection != super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.projection))?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateBucketRequest {
        UpdateBucketRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &UpdateBucketRequest| { &m.bucket },
                |m: &mut UpdateBucketRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_metageneration_match",
                |m: &UpdateBucketRequest| { &m.if_metageneration_match },
                |m: &mut UpdateBucketRequest| { &mut m.if_metageneration_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_metageneration_not_match",
                |m: &UpdateBucketRequest| { &m.if_metageneration_not_match },
                |m: &mut UpdateBucketRequest| { &mut m.if_metageneration_not_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::storage_resources::CommonEnums_PredefinedBucketAcl>>(
                "predefined_acl",
                |m: &UpdateBucketRequest| { &m.predefined_acl },
                |m: &mut UpdateBucketRequest| { &mut m.predefined_acl },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::storage_resources::CommonEnums_PredefinedObjectAcl>>(
                "predefined_default_object_acl",
                |m: &UpdateBucketRequest| { &m.predefined_default_object_acl },
                |m: &mut UpdateBucketRequest| { &mut m.predefined_default_object_acl },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::storage_resources::CommonEnums_Projection>>(
                "projection",
                |m: &UpdateBucketRequest| { &m.projection },
                |m: &mut UpdateBucketRequest| { &mut m.projection },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::Bucket>>(
                "metadata",
                |m: &UpdateBucketRequest| { &m.metadata },
                |m: &mut UpdateBucketRequest| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &UpdateBucketRequest| { &m.common_request_params },
                |m: &mut UpdateBucketRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateBucketRequest>(
                "UpdateBucketRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateBucketRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateBucketRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateBucketRequest::new)
    }
}

impl ::protobuf::Clear for UpdateBucketRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.if_metageneration_match.clear();
        self.if_metageneration_not_match.clear();
        self.predefined_acl = super::storage_resources::CommonEnums_PredefinedBucketAcl::PREDEFINED_BUCKET_ACL_UNSPECIFIED;
        self.predefined_default_object_acl = super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED;
        self.projection = super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED;
        self.metadata.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateBucketRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateBucketRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StopChannelRequest {
    // message fields
    pub channel: ::protobuf::SingularPtrField<super::storage_resources::Channel>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StopChannelRequest {
    fn default() -> &'a StopChannelRequest {
        <StopChannelRequest as ::protobuf::Message>::default_instance()
    }
}

impl StopChannelRequest {
    pub fn new() -> StopChannelRequest {
        ::std::default::Default::default()
    }

    // .google.storage.v1.Channel channel = 1;


    pub fn get_channel(&self) -> &super::storage_resources::Channel {
        self.channel.as_ref().unwrap_or_else(|| <super::storage_resources::Channel as ::protobuf::Message>::default_instance())
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: super::storage_resources::Channel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut super::storage_resources::Channel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> super::storage_resources::Channel {
        self.channel.take().unwrap_or_else(|| super::storage_resources::Channel::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 2;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for StopChannelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopChannelRequest {
        StopChannelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::Channel>>(
                "channel",
                |m: &StopChannelRequest| { &m.channel },
                |m: &mut StopChannelRequest| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &StopChannelRequest| { &m.common_request_params },
                |m: &mut StopChannelRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StopChannelRequest>(
                "StopChannelRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StopChannelRequest {
        static instance: ::protobuf::rt::LazyV2<StopChannelRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StopChannelRequest::new)
    }
}

impl ::protobuf::Clear for StopChannelRequest {
    fn clear(&mut self) {
        self.channel.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopChannelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopChannelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteDefaultObjectAccessControlRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub entity: ::std::string::String,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteDefaultObjectAccessControlRequest {
    fn default() -> &'a DeleteDefaultObjectAccessControlRequest {
        <DeleteDefaultObjectAccessControlRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteDefaultObjectAccessControlRequest {
    pub fn new() -> DeleteDefaultObjectAccessControlRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string entity = 2;


    pub fn get_entity(&self) -> &str {
        &self.entity
    }
    pub fn clear_entity(&mut self) {
        self.entity.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: ::std::string::String) {
        self.entity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity(&mut self) -> &mut ::std::string::String {
        &mut self.entity
    }

    // Take field
    pub fn take_entity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity, ::std::string::String::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 4;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for DeleteDefaultObjectAccessControlRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entity)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.entity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.entity);
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.entity.is_empty() {
            os.write_string(2, &self.entity)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteDefaultObjectAccessControlRequest {
        DeleteDefaultObjectAccessControlRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &DeleteDefaultObjectAccessControlRequest| { &m.bucket },
                |m: &mut DeleteDefaultObjectAccessControlRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entity",
                |m: &DeleteDefaultObjectAccessControlRequest| { &m.entity },
                |m: &mut DeleteDefaultObjectAccessControlRequest| { &mut m.entity },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &DeleteDefaultObjectAccessControlRequest| { &m.common_request_params },
                |m: &mut DeleteDefaultObjectAccessControlRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteDefaultObjectAccessControlRequest>(
                "DeleteDefaultObjectAccessControlRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteDefaultObjectAccessControlRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteDefaultObjectAccessControlRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteDefaultObjectAccessControlRequest::new)
    }
}

impl ::protobuf::Clear for DeleteDefaultObjectAccessControlRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.entity.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteDefaultObjectAccessControlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteDefaultObjectAccessControlRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDefaultObjectAccessControlRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub entity: ::std::string::String,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDefaultObjectAccessControlRequest {
    fn default() -> &'a GetDefaultObjectAccessControlRequest {
        <GetDefaultObjectAccessControlRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDefaultObjectAccessControlRequest {
    pub fn new() -> GetDefaultObjectAccessControlRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string entity = 2;


    pub fn get_entity(&self) -> &str {
        &self.entity
    }
    pub fn clear_entity(&mut self) {
        self.entity.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: ::std::string::String) {
        self.entity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity(&mut self) -> &mut ::std::string::String {
        &mut self.entity
    }

    // Take field
    pub fn take_entity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity, ::std::string::String::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 4;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for GetDefaultObjectAccessControlRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entity)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.entity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.entity);
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.entity.is_empty() {
            os.write_string(2, &self.entity)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDefaultObjectAccessControlRequest {
        GetDefaultObjectAccessControlRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &GetDefaultObjectAccessControlRequest| { &m.bucket },
                |m: &mut GetDefaultObjectAccessControlRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entity",
                |m: &GetDefaultObjectAccessControlRequest| { &m.entity },
                |m: &mut GetDefaultObjectAccessControlRequest| { &mut m.entity },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &GetDefaultObjectAccessControlRequest| { &m.common_request_params },
                |m: &mut GetDefaultObjectAccessControlRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDefaultObjectAccessControlRequest>(
                "GetDefaultObjectAccessControlRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetDefaultObjectAccessControlRequest {
        static instance: ::protobuf::rt::LazyV2<GetDefaultObjectAccessControlRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetDefaultObjectAccessControlRequest::new)
    }
}

impl ::protobuf::Clear for GetDefaultObjectAccessControlRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.entity.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDefaultObjectAccessControlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDefaultObjectAccessControlRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InsertDefaultObjectAccessControlRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub object_access_control: ::protobuf::SingularPtrField<super::storage_resources::ObjectAccessControl>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InsertDefaultObjectAccessControlRequest {
    fn default() -> &'a InsertDefaultObjectAccessControlRequest {
        <InsertDefaultObjectAccessControlRequest as ::protobuf::Message>::default_instance()
    }
}

impl InsertDefaultObjectAccessControlRequest {
    pub fn new() -> InsertDefaultObjectAccessControlRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // .google.storage.v1.ObjectAccessControl object_access_control = 3;


    pub fn get_object_access_control(&self) -> &super::storage_resources::ObjectAccessControl {
        self.object_access_control.as_ref().unwrap_or_else(|| <super::storage_resources::ObjectAccessControl as ::protobuf::Message>::default_instance())
    }
    pub fn clear_object_access_control(&mut self) {
        self.object_access_control.clear();
    }

    pub fn has_object_access_control(&self) -> bool {
        self.object_access_control.is_some()
    }

    // Param is passed by value, moved
    pub fn set_object_access_control(&mut self, v: super::storage_resources::ObjectAccessControl) {
        self.object_access_control = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_access_control(&mut self) -> &mut super::storage_resources::ObjectAccessControl {
        if self.object_access_control.is_none() {
            self.object_access_control.set_default();
        }
        self.object_access_control.as_mut().unwrap()
    }

    // Take field
    pub fn take_object_access_control(&mut self) -> super::storage_resources::ObjectAccessControl {
        self.object_access_control.take().unwrap_or_else(|| super::storage_resources::ObjectAccessControl::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 4;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for InsertDefaultObjectAccessControlRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.object_access_control {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.object_access_control)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if let Some(ref v) = self.object_access_control.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if let Some(ref v) = self.object_access_control.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InsertDefaultObjectAccessControlRequest {
        InsertDefaultObjectAccessControlRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &InsertDefaultObjectAccessControlRequest| { &m.bucket },
                |m: &mut InsertDefaultObjectAccessControlRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::ObjectAccessControl>>(
                "object_access_control",
                |m: &InsertDefaultObjectAccessControlRequest| { &m.object_access_control },
                |m: &mut InsertDefaultObjectAccessControlRequest| { &mut m.object_access_control },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &InsertDefaultObjectAccessControlRequest| { &m.common_request_params },
                |m: &mut InsertDefaultObjectAccessControlRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InsertDefaultObjectAccessControlRequest>(
                "InsertDefaultObjectAccessControlRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InsertDefaultObjectAccessControlRequest {
        static instance: ::protobuf::rt::LazyV2<InsertDefaultObjectAccessControlRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InsertDefaultObjectAccessControlRequest::new)
    }
}

impl ::protobuf::Clear for InsertDefaultObjectAccessControlRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.object_access_control.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InsertDefaultObjectAccessControlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InsertDefaultObjectAccessControlRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListDefaultObjectAccessControlsRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub if_metageneration_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_metageneration_not_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListDefaultObjectAccessControlsRequest {
    fn default() -> &'a ListDefaultObjectAccessControlsRequest {
        <ListDefaultObjectAccessControlsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListDefaultObjectAccessControlsRequest {
    pub fn new() -> ListDefaultObjectAccessControlsRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // .google.protobuf.Int64Value if_metageneration_match = 2;


    pub fn get_if_metageneration_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_metageneration_match(&mut self) {
        self.if_metageneration_match.clear();
    }

    pub fn has_if_metageneration_match(&self) -> bool {
        self.if_metageneration_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_metageneration_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_metageneration_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_metageneration_match.is_none() {
            self.if_metageneration_match.set_default();
        }
        self.if_metageneration_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_metageneration_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_metageneration_not_match = 3;


    pub fn get_if_metageneration_not_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_metageneration_not_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_metageneration_not_match(&mut self) {
        self.if_metageneration_not_match.clear();
    }

    pub fn has_if_metageneration_not_match(&self) -> bool {
        self.if_metageneration_not_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_not_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_metageneration_not_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_metageneration_not_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_metageneration_not_match.is_none() {
            self.if_metageneration_not_match.set_default();
        }
        self.if_metageneration_not_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_metageneration_not_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_metageneration_not_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 5;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for ListDefaultObjectAccessControlsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.if_metageneration_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_metageneration_not_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_metageneration_match)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_metageneration_not_match)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_metageneration_not_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_metageneration_not_match.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListDefaultObjectAccessControlsRequest {
        ListDefaultObjectAccessControlsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &ListDefaultObjectAccessControlsRequest| { &m.bucket },
                |m: &mut ListDefaultObjectAccessControlsRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_metageneration_match",
                |m: &ListDefaultObjectAccessControlsRequest| { &m.if_metageneration_match },
                |m: &mut ListDefaultObjectAccessControlsRequest| { &mut m.if_metageneration_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_metageneration_not_match",
                |m: &ListDefaultObjectAccessControlsRequest| { &m.if_metageneration_not_match },
                |m: &mut ListDefaultObjectAccessControlsRequest| { &mut m.if_metageneration_not_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &ListDefaultObjectAccessControlsRequest| { &m.common_request_params },
                |m: &mut ListDefaultObjectAccessControlsRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListDefaultObjectAccessControlsRequest>(
                "ListDefaultObjectAccessControlsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListDefaultObjectAccessControlsRequest {
        static instance: ::protobuf::rt::LazyV2<ListDefaultObjectAccessControlsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListDefaultObjectAccessControlsRequest::new)
    }
}

impl ::protobuf::Clear for ListDefaultObjectAccessControlsRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.if_metageneration_match.clear();
        self.if_metageneration_not_match.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListDefaultObjectAccessControlsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDefaultObjectAccessControlsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchDefaultObjectAccessControlRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub entity: ::std::string::String,
    pub object_access_control: ::protobuf::SingularPtrField<super::storage_resources::ObjectAccessControl>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchDefaultObjectAccessControlRequest {
    fn default() -> &'a PatchDefaultObjectAccessControlRequest {
        <PatchDefaultObjectAccessControlRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchDefaultObjectAccessControlRequest {
    pub fn new() -> PatchDefaultObjectAccessControlRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string entity = 2;


    pub fn get_entity(&self) -> &str {
        &self.entity
    }
    pub fn clear_entity(&mut self) {
        self.entity.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: ::std::string::String) {
        self.entity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity(&mut self) -> &mut ::std::string::String {
        &mut self.entity
    }

    // Take field
    pub fn take_entity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity, ::std::string::String::new())
    }

    // .google.storage.v1.ObjectAccessControl object_access_control = 4;


    pub fn get_object_access_control(&self) -> &super::storage_resources::ObjectAccessControl {
        self.object_access_control.as_ref().unwrap_or_else(|| <super::storage_resources::ObjectAccessControl as ::protobuf::Message>::default_instance())
    }
    pub fn clear_object_access_control(&mut self) {
        self.object_access_control.clear();
    }

    pub fn has_object_access_control(&self) -> bool {
        self.object_access_control.is_some()
    }

    // Param is passed by value, moved
    pub fn set_object_access_control(&mut self, v: super::storage_resources::ObjectAccessControl) {
        self.object_access_control = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_access_control(&mut self) -> &mut super::storage_resources::ObjectAccessControl {
        if self.object_access_control.is_none() {
            self.object_access_control.set_default();
        }
        self.object_access_control.as_mut().unwrap()
    }

    // Take field
    pub fn take_object_access_control(&mut self) -> super::storage_resources::ObjectAccessControl {
        self.object_access_control.take().unwrap_or_else(|| super::storage_resources::ObjectAccessControl::new())
    }

    // .google.protobuf.FieldMask update_mask = 5;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 6;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for PatchDefaultObjectAccessControlRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.object_access_control {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entity)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.object_access_control)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.entity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.entity);
        }
        if let Some(ref v) = self.object_access_control.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.entity.is_empty() {
            os.write_string(2, &self.entity)?;
        }
        if let Some(ref v) = self.object_access_control.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchDefaultObjectAccessControlRequest {
        PatchDefaultObjectAccessControlRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &PatchDefaultObjectAccessControlRequest| { &m.bucket },
                |m: &mut PatchDefaultObjectAccessControlRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entity",
                |m: &PatchDefaultObjectAccessControlRequest| { &m.entity },
                |m: &mut PatchDefaultObjectAccessControlRequest| { &mut m.entity },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::ObjectAccessControl>>(
                "object_access_control",
                |m: &PatchDefaultObjectAccessControlRequest| { &m.object_access_control },
                |m: &mut PatchDefaultObjectAccessControlRequest| { &mut m.object_access_control },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "update_mask",
                |m: &PatchDefaultObjectAccessControlRequest| { &m.update_mask },
                |m: &mut PatchDefaultObjectAccessControlRequest| { &mut m.update_mask },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &PatchDefaultObjectAccessControlRequest| { &m.common_request_params },
                |m: &mut PatchDefaultObjectAccessControlRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchDefaultObjectAccessControlRequest>(
                "PatchDefaultObjectAccessControlRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchDefaultObjectAccessControlRequest {
        static instance: ::protobuf::rt::LazyV2<PatchDefaultObjectAccessControlRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchDefaultObjectAccessControlRequest::new)
    }
}

impl ::protobuf::Clear for PatchDefaultObjectAccessControlRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.entity.clear();
        self.object_access_control.clear();
        self.update_mask.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchDefaultObjectAccessControlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchDefaultObjectAccessControlRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateDefaultObjectAccessControlRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub entity: ::std::string::String,
    pub object_access_control: ::protobuf::SingularPtrField<super::storage_resources::ObjectAccessControl>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateDefaultObjectAccessControlRequest {
    fn default() -> &'a UpdateDefaultObjectAccessControlRequest {
        <UpdateDefaultObjectAccessControlRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateDefaultObjectAccessControlRequest {
    pub fn new() -> UpdateDefaultObjectAccessControlRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string entity = 2;


    pub fn get_entity(&self) -> &str {
        &self.entity
    }
    pub fn clear_entity(&mut self) {
        self.entity.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: ::std::string::String) {
        self.entity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity(&mut self) -> &mut ::std::string::String {
        &mut self.entity
    }

    // Take field
    pub fn take_entity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity, ::std::string::String::new())
    }

    // .google.storage.v1.ObjectAccessControl object_access_control = 4;


    pub fn get_object_access_control(&self) -> &super::storage_resources::ObjectAccessControl {
        self.object_access_control.as_ref().unwrap_or_else(|| <super::storage_resources::ObjectAccessControl as ::protobuf::Message>::default_instance())
    }
    pub fn clear_object_access_control(&mut self) {
        self.object_access_control.clear();
    }

    pub fn has_object_access_control(&self) -> bool {
        self.object_access_control.is_some()
    }

    // Param is passed by value, moved
    pub fn set_object_access_control(&mut self, v: super::storage_resources::ObjectAccessControl) {
        self.object_access_control = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_access_control(&mut self) -> &mut super::storage_resources::ObjectAccessControl {
        if self.object_access_control.is_none() {
            self.object_access_control.set_default();
        }
        self.object_access_control.as_mut().unwrap()
    }

    // Take field
    pub fn take_object_access_control(&mut self) -> super::storage_resources::ObjectAccessControl {
        self.object_access_control.take().unwrap_or_else(|| super::storage_resources::ObjectAccessControl::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 5;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for UpdateDefaultObjectAccessControlRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.object_access_control {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entity)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.object_access_control)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.entity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.entity);
        }
        if let Some(ref v) = self.object_access_control.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.entity.is_empty() {
            os.write_string(2, &self.entity)?;
        }
        if let Some(ref v) = self.object_access_control.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateDefaultObjectAccessControlRequest {
        UpdateDefaultObjectAccessControlRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &UpdateDefaultObjectAccessControlRequest| { &m.bucket },
                |m: &mut UpdateDefaultObjectAccessControlRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entity",
                |m: &UpdateDefaultObjectAccessControlRequest| { &m.entity },
                |m: &mut UpdateDefaultObjectAccessControlRequest| { &mut m.entity },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::ObjectAccessControl>>(
                "object_access_control",
                |m: &UpdateDefaultObjectAccessControlRequest| { &m.object_access_control },
                |m: &mut UpdateDefaultObjectAccessControlRequest| { &mut m.object_access_control },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &UpdateDefaultObjectAccessControlRequest| { &m.common_request_params },
                |m: &mut UpdateDefaultObjectAccessControlRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateDefaultObjectAccessControlRequest>(
                "UpdateDefaultObjectAccessControlRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateDefaultObjectAccessControlRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateDefaultObjectAccessControlRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateDefaultObjectAccessControlRequest::new)
    }
}

impl ::protobuf::Clear for UpdateDefaultObjectAccessControlRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.entity.clear();
        self.object_access_control.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateDefaultObjectAccessControlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateDefaultObjectAccessControlRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteNotificationRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub notification: ::std::string::String,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteNotificationRequest {
    fn default() -> &'a DeleteNotificationRequest {
        <DeleteNotificationRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteNotificationRequest {
    pub fn new() -> DeleteNotificationRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string notification = 2;


    pub fn get_notification(&self) -> &str {
        &self.notification
    }
    pub fn clear_notification(&mut self) {
        self.notification.clear();
    }

    // Param is passed by value, moved
    pub fn set_notification(&mut self, v: ::std::string::String) {
        self.notification = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notification(&mut self) -> &mut ::std::string::String {
        &mut self.notification
    }

    // Take field
    pub fn take_notification(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.notification, ::std::string::String::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 4;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for DeleteNotificationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.notification)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.notification.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.notification);
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.notification.is_empty() {
            os.write_string(2, &self.notification)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteNotificationRequest {
        DeleteNotificationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &DeleteNotificationRequest| { &m.bucket },
                |m: &mut DeleteNotificationRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "notification",
                |m: &DeleteNotificationRequest| { &m.notification },
                |m: &mut DeleteNotificationRequest| { &mut m.notification },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &DeleteNotificationRequest| { &m.common_request_params },
                |m: &mut DeleteNotificationRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteNotificationRequest>(
                "DeleteNotificationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteNotificationRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteNotificationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteNotificationRequest::new)
    }
}

impl ::protobuf::Clear for DeleteNotificationRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.notification.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteNotificationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteNotificationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetNotificationRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub notification: ::std::string::String,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetNotificationRequest {
    fn default() -> &'a GetNotificationRequest {
        <GetNotificationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetNotificationRequest {
    pub fn new() -> GetNotificationRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string notification = 2;


    pub fn get_notification(&self) -> &str {
        &self.notification
    }
    pub fn clear_notification(&mut self) {
        self.notification.clear();
    }

    // Param is passed by value, moved
    pub fn set_notification(&mut self, v: ::std::string::String) {
        self.notification = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notification(&mut self) -> &mut ::std::string::String {
        &mut self.notification
    }

    // Take field
    pub fn take_notification(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.notification, ::std::string::String::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 4;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for GetNotificationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.notification)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.notification.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.notification);
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.notification.is_empty() {
            os.write_string(2, &self.notification)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetNotificationRequest {
        GetNotificationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &GetNotificationRequest| { &m.bucket },
                |m: &mut GetNotificationRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "notification",
                |m: &GetNotificationRequest| { &m.notification },
                |m: &mut GetNotificationRequest| { &mut m.notification },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &GetNotificationRequest| { &m.common_request_params },
                |m: &mut GetNotificationRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetNotificationRequest>(
                "GetNotificationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetNotificationRequest {
        static instance: ::protobuf::rt::LazyV2<GetNotificationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetNotificationRequest::new)
    }
}

impl ::protobuf::Clear for GetNotificationRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.notification.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetNotificationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetNotificationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InsertNotificationRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub notification: ::protobuf::SingularPtrField<super::storage_resources::Notification>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InsertNotificationRequest {
    fn default() -> &'a InsertNotificationRequest {
        <InsertNotificationRequest as ::protobuf::Message>::default_instance()
    }
}

impl InsertNotificationRequest {
    pub fn new() -> InsertNotificationRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // .google.storage.v1.Notification notification = 3;


    pub fn get_notification(&self) -> &super::storage_resources::Notification {
        self.notification.as_ref().unwrap_or_else(|| <super::storage_resources::Notification as ::protobuf::Message>::default_instance())
    }
    pub fn clear_notification(&mut self) {
        self.notification.clear();
    }

    pub fn has_notification(&self) -> bool {
        self.notification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification(&mut self, v: super::storage_resources::Notification) {
        self.notification = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notification(&mut self) -> &mut super::storage_resources::Notification {
        if self.notification.is_none() {
            self.notification.set_default();
        }
        self.notification.as_mut().unwrap()
    }

    // Take field
    pub fn take_notification(&mut self) -> super::storage_resources::Notification {
        self.notification.take().unwrap_or_else(|| super::storage_resources::Notification::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 4;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for InsertNotificationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.notification {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.notification)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if let Some(ref v) = self.notification.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if let Some(ref v) = self.notification.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InsertNotificationRequest {
        InsertNotificationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &InsertNotificationRequest| { &m.bucket },
                |m: &mut InsertNotificationRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::Notification>>(
                "notification",
                |m: &InsertNotificationRequest| { &m.notification },
                |m: &mut InsertNotificationRequest| { &mut m.notification },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &InsertNotificationRequest| { &m.common_request_params },
                |m: &mut InsertNotificationRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InsertNotificationRequest>(
                "InsertNotificationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InsertNotificationRequest {
        static instance: ::protobuf::rt::LazyV2<InsertNotificationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InsertNotificationRequest::new)
    }
}

impl ::protobuf::Clear for InsertNotificationRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.notification.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InsertNotificationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InsertNotificationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListNotificationsRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListNotificationsRequest {
    fn default() -> &'a ListNotificationsRequest {
        <ListNotificationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListNotificationsRequest {
    pub fn new() -> ListNotificationsRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 3;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for ListNotificationsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListNotificationsRequest {
        ListNotificationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &ListNotificationsRequest| { &m.bucket },
                |m: &mut ListNotificationsRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &ListNotificationsRequest| { &m.common_request_params },
                |m: &mut ListNotificationsRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListNotificationsRequest>(
                "ListNotificationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListNotificationsRequest {
        static instance: ::protobuf::rt::LazyV2<ListNotificationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListNotificationsRequest::new)
    }
}

impl ::protobuf::Clear for ListNotificationsRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListNotificationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListNotificationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteObjectAccessControlRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub entity: ::std::string::String,
    pub object: ::std::string::String,
    pub generation: i64,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteObjectAccessControlRequest {
    fn default() -> &'a DeleteObjectAccessControlRequest {
        <DeleteObjectAccessControlRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteObjectAccessControlRequest {
    pub fn new() -> DeleteObjectAccessControlRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string entity = 2;


    pub fn get_entity(&self) -> &str {
        &self.entity
    }
    pub fn clear_entity(&mut self) {
        self.entity.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: ::std::string::String) {
        self.entity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity(&mut self) -> &mut ::std::string::String {
        &mut self.entity
    }

    // Take field
    pub fn take_entity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity, ::std::string::String::new())
    }

    // string object = 3;


    pub fn get_object(&self) -> &str {
        &self.object
    }
    pub fn clear_object(&mut self) {
        self.object.clear();
    }

    // Param is passed by value, moved
    pub fn set_object(&mut self, v: ::std::string::String) {
        self.object = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object(&mut self) -> &mut ::std::string::String {
        &mut self.object
    }

    // Take field
    pub fn take_object(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object, ::std::string::String::new())
    }

    // int64 generation = 4;


    pub fn get_generation(&self) -> i64 {
        self.generation
    }
    pub fn clear_generation(&mut self) {
        self.generation = 0;
    }

    // Param is passed by value, moved
    pub fn set_generation(&mut self, v: i64) {
        self.generation = v;
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 6;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for DeleteObjectAccessControlRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entity)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.generation = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.entity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.entity);
        }
        if !self.object.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.object);
        }
        if self.generation != 0 {
            my_size += ::protobuf::rt::value_size(4, self.generation, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.entity.is_empty() {
            os.write_string(2, &self.entity)?;
        }
        if !self.object.is_empty() {
            os.write_string(3, &self.object)?;
        }
        if self.generation != 0 {
            os.write_int64(4, self.generation)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteObjectAccessControlRequest {
        DeleteObjectAccessControlRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &DeleteObjectAccessControlRequest| { &m.bucket },
                |m: &mut DeleteObjectAccessControlRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entity",
                |m: &DeleteObjectAccessControlRequest| { &m.entity },
                |m: &mut DeleteObjectAccessControlRequest| { &mut m.entity },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object",
                |m: &DeleteObjectAccessControlRequest| { &m.object },
                |m: &mut DeleteObjectAccessControlRequest| { &mut m.object },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "generation",
                |m: &DeleteObjectAccessControlRequest| { &m.generation },
                |m: &mut DeleteObjectAccessControlRequest| { &mut m.generation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &DeleteObjectAccessControlRequest| { &m.common_request_params },
                |m: &mut DeleteObjectAccessControlRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteObjectAccessControlRequest>(
                "DeleteObjectAccessControlRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteObjectAccessControlRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteObjectAccessControlRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteObjectAccessControlRequest::new)
    }
}

impl ::protobuf::Clear for DeleteObjectAccessControlRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.entity.clear();
        self.object.clear();
        self.generation = 0;
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteObjectAccessControlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteObjectAccessControlRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetObjectAccessControlRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub entity: ::std::string::String,
    pub object: ::std::string::String,
    pub generation: i64,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetObjectAccessControlRequest {
    fn default() -> &'a GetObjectAccessControlRequest {
        <GetObjectAccessControlRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetObjectAccessControlRequest {
    pub fn new() -> GetObjectAccessControlRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string entity = 2;


    pub fn get_entity(&self) -> &str {
        &self.entity
    }
    pub fn clear_entity(&mut self) {
        self.entity.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: ::std::string::String) {
        self.entity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity(&mut self) -> &mut ::std::string::String {
        &mut self.entity
    }

    // Take field
    pub fn take_entity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity, ::std::string::String::new())
    }

    // string object = 3;


    pub fn get_object(&self) -> &str {
        &self.object
    }
    pub fn clear_object(&mut self) {
        self.object.clear();
    }

    // Param is passed by value, moved
    pub fn set_object(&mut self, v: ::std::string::String) {
        self.object = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object(&mut self) -> &mut ::std::string::String {
        &mut self.object
    }

    // Take field
    pub fn take_object(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object, ::std::string::String::new())
    }

    // int64 generation = 4;


    pub fn get_generation(&self) -> i64 {
        self.generation
    }
    pub fn clear_generation(&mut self) {
        self.generation = 0;
    }

    // Param is passed by value, moved
    pub fn set_generation(&mut self, v: i64) {
        self.generation = v;
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 6;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for GetObjectAccessControlRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entity)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.generation = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.entity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.entity);
        }
        if !self.object.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.object);
        }
        if self.generation != 0 {
            my_size += ::protobuf::rt::value_size(4, self.generation, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.entity.is_empty() {
            os.write_string(2, &self.entity)?;
        }
        if !self.object.is_empty() {
            os.write_string(3, &self.object)?;
        }
        if self.generation != 0 {
            os.write_int64(4, self.generation)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetObjectAccessControlRequest {
        GetObjectAccessControlRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &GetObjectAccessControlRequest| { &m.bucket },
                |m: &mut GetObjectAccessControlRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entity",
                |m: &GetObjectAccessControlRequest| { &m.entity },
                |m: &mut GetObjectAccessControlRequest| { &mut m.entity },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object",
                |m: &GetObjectAccessControlRequest| { &m.object },
                |m: &mut GetObjectAccessControlRequest| { &mut m.object },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "generation",
                |m: &GetObjectAccessControlRequest| { &m.generation },
                |m: &mut GetObjectAccessControlRequest| { &mut m.generation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &GetObjectAccessControlRequest| { &m.common_request_params },
                |m: &mut GetObjectAccessControlRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetObjectAccessControlRequest>(
                "GetObjectAccessControlRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetObjectAccessControlRequest {
        static instance: ::protobuf::rt::LazyV2<GetObjectAccessControlRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetObjectAccessControlRequest::new)
    }
}

impl ::protobuf::Clear for GetObjectAccessControlRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.entity.clear();
        self.object.clear();
        self.generation = 0;
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetObjectAccessControlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetObjectAccessControlRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InsertObjectAccessControlRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub object: ::std::string::String,
    pub generation: i64,
    pub object_access_control: ::protobuf::SingularPtrField<super::storage_resources::ObjectAccessControl>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InsertObjectAccessControlRequest {
    fn default() -> &'a InsertObjectAccessControlRequest {
        <InsertObjectAccessControlRequest as ::protobuf::Message>::default_instance()
    }
}

impl InsertObjectAccessControlRequest {
    pub fn new() -> InsertObjectAccessControlRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string object = 2;


    pub fn get_object(&self) -> &str {
        &self.object
    }
    pub fn clear_object(&mut self) {
        self.object.clear();
    }

    // Param is passed by value, moved
    pub fn set_object(&mut self, v: ::std::string::String) {
        self.object = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object(&mut self) -> &mut ::std::string::String {
        &mut self.object
    }

    // Take field
    pub fn take_object(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object, ::std::string::String::new())
    }

    // int64 generation = 3;


    pub fn get_generation(&self) -> i64 {
        self.generation
    }
    pub fn clear_generation(&mut self) {
        self.generation = 0;
    }

    // Param is passed by value, moved
    pub fn set_generation(&mut self, v: i64) {
        self.generation = v;
    }

    // .google.storage.v1.ObjectAccessControl object_access_control = 5;


    pub fn get_object_access_control(&self) -> &super::storage_resources::ObjectAccessControl {
        self.object_access_control.as_ref().unwrap_or_else(|| <super::storage_resources::ObjectAccessControl as ::protobuf::Message>::default_instance())
    }
    pub fn clear_object_access_control(&mut self) {
        self.object_access_control.clear();
    }

    pub fn has_object_access_control(&self) -> bool {
        self.object_access_control.is_some()
    }

    // Param is passed by value, moved
    pub fn set_object_access_control(&mut self, v: super::storage_resources::ObjectAccessControl) {
        self.object_access_control = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_access_control(&mut self) -> &mut super::storage_resources::ObjectAccessControl {
        if self.object_access_control.is_none() {
            self.object_access_control.set_default();
        }
        self.object_access_control.as_mut().unwrap()
    }

    // Take field
    pub fn take_object_access_control(&mut self) -> super::storage_resources::ObjectAccessControl {
        self.object_access_control.take().unwrap_or_else(|| super::storage_resources::ObjectAccessControl::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 6;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for InsertObjectAccessControlRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.object_access_control {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.generation = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.object_access_control)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.object.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.object);
        }
        if self.generation != 0 {
            my_size += ::protobuf::rt::value_size(3, self.generation, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.object_access_control.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.object.is_empty() {
            os.write_string(2, &self.object)?;
        }
        if self.generation != 0 {
            os.write_int64(3, self.generation)?;
        }
        if let Some(ref v) = self.object_access_control.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InsertObjectAccessControlRequest {
        InsertObjectAccessControlRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &InsertObjectAccessControlRequest| { &m.bucket },
                |m: &mut InsertObjectAccessControlRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object",
                |m: &InsertObjectAccessControlRequest| { &m.object },
                |m: &mut InsertObjectAccessControlRequest| { &mut m.object },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "generation",
                |m: &InsertObjectAccessControlRequest| { &m.generation },
                |m: &mut InsertObjectAccessControlRequest| { &mut m.generation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::ObjectAccessControl>>(
                "object_access_control",
                |m: &InsertObjectAccessControlRequest| { &m.object_access_control },
                |m: &mut InsertObjectAccessControlRequest| { &mut m.object_access_control },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &InsertObjectAccessControlRequest| { &m.common_request_params },
                |m: &mut InsertObjectAccessControlRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InsertObjectAccessControlRequest>(
                "InsertObjectAccessControlRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InsertObjectAccessControlRequest {
        static instance: ::protobuf::rt::LazyV2<InsertObjectAccessControlRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InsertObjectAccessControlRequest::new)
    }
}

impl ::protobuf::Clear for InsertObjectAccessControlRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.object.clear();
        self.generation = 0;
        self.object_access_control.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InsertObjectAccessControlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InsertObjectAccessControlRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListObjectAccessControlsRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub object: ::std::string::String,
    pub generation: i64,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListObjectAccessControlsRequest {
    fn default() -> &'a ListObjectAccessControlsRequest {
        <ListObjectAccessControlsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListObjectAccessControlsRequest {
    pub fn new() -> ListObjectAccessControlsRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string object = 2;


    pub fn get_object(&self) -> &str {
        &self.object
    }
    pub fn clear_object(&mut self) {
        self.object.clear();
    }

    // Param is passed by value, moved
    pub fn set_object(&mut self, v: ::std::string::String) {
        self.object = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object(&mut self) -> &mut ::std::string::String {
        &mut self.object
    }

    // Take field
    pub fn take_object(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object, ::std::string::String::new())
    }

    // int64 generation = 3;


    pub fn get_generation(&self) -> i64 {
        self.generation
    }
    pub fn clear_generation(&mut self) {
        self.generation = 0;
    }

    // Param is passed by value, moved
    pub fn set_generation(&mut self, v: i64) {
        self.generation = v;
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 5;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for ListObjectAccessControlsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.generation = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.object.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.object);
        }
        if self.generation != 0 {
            my_size += ::protobuf::rt::value_size(3, self.generation, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.object.is_empty() {
            os.write_string(2, &self.object)?;
        }
        if self.generation != 0 {
            os.write_int64(3, self.generation)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListObjectAccessControlsRequest {
        ListObjectAccessControlsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &ListObjectAccessControlsRequest| { &m.bucket },
                |m: &mut ListObjectAccessControlsRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object",
                |m: &ListObjectAccessControlsRequest| { &m.object },
                |m: &mut ListObjectAccessControlsRequest| { &mut m.object },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "generation",
                |m: &ListObjectAccessControlsRequest| { &m.generation },
                |m: &mut ListObjectAccessControlsRequest| { &mut m.generation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &ListObjectAccessControlsRequest| { &m.common_request_params },
                |m: &mut ListObjectAccessControlsRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListObjectAccessControlsRequest>(
                "ListObjectAccessControlsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListObjectAccessControlsRequest {
        static instance: ::protobuf::rt::LazyV2<ListObjectAccessControlsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListObjectAccessControlsRequest::new)
    }
}

impl ::protobuf::Clear for ListObjectAccessControlsRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.object.clear();
        self.generation = 0;
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListObjectAccessControlsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListObjectAccessControlsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchObjectAccessControlRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub entity: ::std::string::String,
    pub object: ::std::string::String,
    pub generation: i64,
    pub object_access_control: ::protobuf::SingularPtrField<super::storage_resources::ObjectAccessControl>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchObjectAccessControlRequest {
    fn default() -> &'a PatchObjectAccessControlRequest {
        <PatchObjectAccessControlRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchObjectAccessControlRequest {
    pub fn new() -> PatchObjectAccessControlRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string entity = 2;


    pub fn get_entity(&self) -> &str {
        &self.entity
    }
    pub fn clear_entity(&mut self) {
        self.entity.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: ::std::string::String) {
        self.entity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity(&mut self) -> &mut ::std::string::String {
        &mut self.entity
    }

    // Take field
    pub fn take_entity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity, ::std::string::String::new())
    }

    // string object = 3;


    pub fn get_object(&self) -> &str {
        &self.object
    }
    pub fn clear_object(&mut self) {
        self.object.clear();
    }

    // Param is passed by value, moved
    pub fn set_object(&mut self, v: ::std::string::String) {
        self.object = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object(&mut self) -> &mut ::std::string::String {
        &mut self.object
    }

    // Take field
    pub fn take_object(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object, ::std::string::String::new())
    }

    // int64 generation = 4;


    pub fn get_generation(&self) -> i64 {
        self.generation
    }
    pub fn clear_generation(&mut self) {
        self.generation = 0;
    }

    // Param is passed by value, moved
    pub fn set_generation(&mut self, v: i64) {
        self.generation = v;
    }

    // .google.storage.v1.ObjectAccessControl object_access_control = 5;


    pub fn get_object_access_control(&self) -> &super::storage_resources::ObjectAccessControl {
        self.object_access_control.as_ref().unwrap_or_else(|| <super::storage_resources::ObjectAccessControl as ::protobuf::Message>::default_instance())
    }
    pub fn clear_object_access_control(&mut self) {
        self.object_access_control.clear();
    }

    pub fn has_object_access_control(&self) -> bool {
        self.object_access_control.is_some()
    }

    // Param is passed by value, moved
    pub fn set_object_access_control(&mut self, v: super::storage_resources::ObjectAccessControl) {
        self.object_access_control = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_access_control(&mut self) -> &mut super::storage_resources::ObjectAccessControl {
        if self.object_access_control.is_none() {
            self.object_access_control.set_default();
        }
        self.object_access_control.as_mut().unwrap()
    }

    // Take field
    pub fn take_object_access_control(&mut self) -> super::storage_resources::ObjectAccessControl {
        self.object_access_control.take().unwrap_or_else(|| super::storage_resources::ObjectAccessControl::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 6;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }

    // .google.protobuf.FieldMask update_mask = 7;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for PatchObjectAccessControlRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.object_access_control {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entity)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.generation = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.object_access_control)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.entity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.entity);
        }
        if !self.object.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.object);
        }
        if self.generation != 0 {
            my_size += ::protobuf::rt::value_size(4, self.generation, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.object_access_control.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.entity.is_empty() {
            os.write_string(2, &self.entity)?;
        }
        if !self.object.is_empty() {
            os.write_string(3, &self.object)?;
        }
        if self.generation != 0 {
            os.write_int64(4, self.generation)?;
        }
        if let Some(ref v) = self.object_access_control.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchObjectAccessControlRequest {
        PatchObjectAccessControlRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &PatchObjectAccessControlRequest| { &m.bucket },
                |m: &mut PatchObjectAccessControlRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entity",
                |m: &PatchObjectAccessControlRequest| { &m.entity },
                |m: &mut PatchObjectAccessControlRequest| { &mut m.entity },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object",
                |m: &PatchObjectAccessControlRequest| { &m.object },
                |m: &mut PatchObjectAccessControlRequest| { &mut m.object },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "generation",
                |m: &PatchObjectAccessControlRequest| { &m.generation },
                |m: &mut PatchObjectAccessControlRequest| { &mut m.generation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::ObjectAccessControl>>(
                "object_access_control",
                |m: &PatchObjectAccessControlRequest| { &m.object_access_control },
                |m: &mut PatchObjectAccessControlRequest| { &mut m.object_access_control },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &PatchObjectAccessControlRequest| { &m.common_request_params },
                |m: &mut PatchObjectAccessControlRequest| { &mut m.common_request_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "update_mask",
                |m: &PatchObjectAccessControlRequest| { &m.update_mask },
                |m: &mut PatchObjectAccessControlRequest| { &mut m.update_mask },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchObjectAccessControlRequest>(
                "PatchObjectAccessControlRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchObjectAccessControlRequest {
        static instance: ::protobuf::rt::LazyV2<PatchObjectAccessControlRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchObjectAccessControlRequest::new)
    }
}

impl ::protobuf::Clear for PatchObjectAccessControlRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.entity.clear();
        self.object.clear();
        self.generation = 0;
        self.object_access_control.clear();
        self.common_request_params.clear();
        self.update_mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchObjectAccessControlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchObjectAccessControlRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateObjectAccessControlRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub entity: ::std::string::String,
    pub object: ::std::string::String,
    pub generation: i64,
    pub object_access_control: ::protobuf::SingularPtrField<super::storage_resources::ObjectAccessControl>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateObjectAccessControlRequest {
    fn default() -> &'a UpdateObjectAccessControlRequest {
        <UpdateObjectAccessControlRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateObjectAccessControlRequest {
    pub fn new() -> UpdateObjectAccessControlRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string entity = 2;


    pub fn get_entity(&self) -> &str {
        &self.entity
    }
    pub fn clear_entity(&mut self) {
        self.entity.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: ::std::string::String) {
        self.entity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity(&mut self) -> &mut ::std::string::String {
        &mut self.entity
    }

    // Take field
    pub fn take_entity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity, ::std::string::String::new())
    }

    // string object = 3;


    pub fn get_object(&self) -> &str {
        &self.object
    }
    pub fn clear_object(&mut self) {
        self.object.clear();
    }

    // Param is passed by value, moved
    pub fn set_object(&mut self, v: ::std::string::String) {
        self.object = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object(&mut self) -> &mut ::std::string::String {
        &mut self.object
    }

    // Take field
    pub fn take_object(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object, ::std::string::String::new())
    }

    // int64 generation = 4;


    pub fn get_generation(&self) -> i64 {
        self.generation
    }
    pub fn clear_generation(&mut self) {
        self.generation = 0;
    }

    // Param is passed by value, moved
    pub fn set_generation(&mut self, v: i64) {
        self.generation = v;
    }

    // .google.storage.v1.ObjectAccessControl object_access_control = 6;


    pub fn get_object_access_control(&self) -> &super::storage_resources::ObjectAccessControl {
        self.object_access_control.as_ref().unwrap_or_else(|| <super::storage_resources::ObjectAccessControl as ::protobuf::Message>::default_instance())
    }
    pub fn clear_object_access_control(&mut self) {
        self.object_access_control.clear();
    }

    pub fn has_object_access_control(&self) -> bool {
        self.object_access_control.is_some()
    }

    // Param is passed by value, moved
    pub fn set_object_access_control(&mut self, v: super::storage_resources::ObjectAccessControl) {
        self.object_access_control = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_access_control(&mut self) -> &mut super::storage_resources::ObjectAccessControl {
        if self.object_access_control.is_none() {
            self.object_access_control.set_default();
        }
        self.object_access_control.as_mut().unwrap()
    }

    // Take field
    pub fn take_object_access_control(&mut self) -> super::storage_resources::ObjectAccessControl {
        self.object_access_control.take().unwrap_or_else(|| super::storage_resources::ObjectAccessControl::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 7;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }

    // .google.protobuf.FieldMask update_mask = 8;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for UpdateObjectAccessControlRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.object_access_control {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entity)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.generation = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.object_access_control)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.entity.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.entity);
        }
        if !self.object.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.object);
        }
        if self.generation != 0 {
            my_size += ::protobuf::rt::value_size(4, self.generation, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.object_access_control.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.entity.is_empty() {
            os.write_string(2, &self.entity)?;
        }
        if !self.object.is_empty() {
            os.write_string(3, &self.object)?;
        }
        if self.generation != 0 {
            os.write_int64(4, self.generation)?;
        }
        if let Some(ref v) = self.object_access_control.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateObjectAccessControlRequest {
        UpdateObjectAccessControlRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &UpdateObjectAccessControlRequest| { &m.bucket },
                |m: &mut UpdateObjectAccessControlRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entity",
                |m: &UpdateObjectAccessControlRequest| { &m.entity },
                |m: &mut UpdateObjectAccessControlRequest| { &mut m.entity },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object",
                |m: &UpdateObjectAccessControlRequest| { &m.object },
                |m: &mut UpdateObjectAccessControlRequest| { &mut m.object },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "generation",
                |m: &UpdateObjectAccessControlRequest| { &m.generation },
                |m: &mut UpdateObjectAccessControlRequest| { &mut m.generation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::ObjectAccessControl>>(
                "object_access_control",
                |m: &UpdateObjectAccessControlRequest| { &m.object_access_control },
                |m: &mut UpdateObjectAccessControlRequest| { &mut m.object_access_control },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &UpdateObjectAccessControlRequest| { &m.common_request_params },
                |m: &mut UpdateObjectAccessControlRequest| { &mut m.common_request_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "update_mask",
                |m: &UpdateObjectAccessControlRequest| { &m.update_mask },
                |m: &mut UpdateObjectAccessControlRequest| { &mut m.update_mask },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateObjectAccessControlRequest>(
                "UpdateObjectAccessControlRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateObjectAccessControlRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateObjectAccessControlRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateObjectAccessControlRequest::new)
    }
}

impl ::protobuf::Clear for UpdateObjectAccessControlRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.entity.clear();
        self.object.clear();
        self.generation = 0;
        self.object_access_control.clear();
        self.common_request_params.clear();
        self.update_mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateObjectAccessControlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateObjectAccessControlRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ComposeObjectRequest {
    // message fields
    pub destination_bucket: ::std::string::String,
    pub destination_object: ::std::string::String,
    pub destination_predefined_acl: super::storage_resources::CommonEnums_PredefinedObjectAcl,
    pub destination: ::protobuf::SingularPtrField<super::storage_resources::Object>,
    pub source_objects: ::protobuf::RepeatedField<ComposeObjectRequest_SourceObjects>,
    pub if_generation_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_metageneration_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub kms_key_name: ::std::string::String,
    pub common_object_request_params: ::protobuf::SingularPtrField<CommonObjectRequestParams>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ComposeObjectRequest {
    fn default() -> &'a ComposeObjectRequest {
        <ComposeObjectRequest as ::protobuf::Message>::default_instance()
    }
}

impl ComposeObjectRequest {
    pub fn new() -> ComposeObjectRequest {
        ::std::default::Default::default()
    }

    // string destination_bucket = 1;


    pub fn get_destination_bucket(&self) -> &str {
        &self.destination_bucket
    }
    pub fn clear_destination_bucket(&mut self) {
        self.destination_bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_destination_bucket(&mut self, v: ::std::string::String) {
        self.destination_bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.destination_bucket
    }

    // Take field
    pub fn take_destination_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.destination_bucket, ::std::string::String::new())
    }

    // string destination_object = 2;


    pub fn get_destination_object(&self) -> &str {
        &self.destination_object
    }
    pub fn clear_destination_object(&mut self) {
        self.destination_object.clear();
    }

    // Param is passed by value, moved
    pub fn set_destination_object(&mut self, v: ::std::string::String) {
        self.destination_object = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination_object(&mut self) -> &mut ::std::string::String {
        &mut self.destination_object
    }

    // Take field
    pub fn take_destination_object(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.destination_object, ::std::string::String::new())
    }

    // .google.storage.v1.CommonEnums.PredefinedObjectAcl destination_predefined_acl = 3;


    pub fn get_destination_predefined_acl(&self) -> super::storage_resources::CommonEnums_PredefinedObjectAcl {
        self.destination_predefined_acl
    }
    pub fn clear_destination_predefined_acl(&mut self) {
        self.destination_predefined_acl = super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_destination_predefined_acl(&mut self, v: super::storage_resources::CommonEnums_PredefinedObjectAcl) {
        self.destination_predefined_acl = v;
    }

    // .google.storage.v1.Object destination = 11;


    pub fn get_destination(&self) -> &super::storage_resources::Object {
        self.destination.as_ref().unwrap_or_else(|| <super::storage_resources::Object as ::protobuf::Message>::default_instance())
    }
    pub fn clear_destination(&mut self) {
        self.destination.clear();
    }

    pub fn has_destination(&self) -> bool {
        self.destination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destination(&mut self, v: super::storage_resources::Object) {
        self.destination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination(&mut self) -> &mut super::storage_resources::Object {
        if self.destination.is_none() {
            self.destination.set_default();
        }
        self.destination.as_mut().unwrap()
    }

    // Take field
    pub fn take_destination(&mut self) -> super::storage_resources::Object {
        self.destination.take().unwrap_or_else(|| super::storage_resources::Object::new())
    }

    // repeated .google.storage.v1.ComposeObjectRequest.SourceObjects source_objects = 12;


    pub fn get_source_objects(&self) -> &[ComposeObjectRequest_SourceObjects] {
        &self.source_objects
    }
    pub fn clear_source_objects(&mut self) {
        self.source_objects.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_objects(&mut self, v: ::protobuf::RepeatedField<ComposeObjectRequest_SourceObjects>) {
        self.source_objects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_source_objects(&mut self) -> &mut ::protobuf::RepeatedField<ComposeObjectRequest_SourceObjects> {
        &mut self.source_objects
    }

    // Take field
    pub fn take_source_objects(&mut self) -> ::protobuf::RepeatedField<ComposeObjectRequest_SourceObjects> {
        ::std::mem::replace(&mut self.source_objects, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.Int64Value if_generation_match = 4;


    pub fn get_if_generation_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_generation_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_generation_match(&mut self) {
        self.if_generation_match.clear();
    }

    pub fn has_if_generation_match(&self) -> bool {
        self.if_generation_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_generation_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_generation_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_generation_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_generation_match.is_none() {
            self.if_generation_match.set_default();
        }
        self.if_generation_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_generation_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_generation_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_metageneration_match = 5;


    pub fn get_if_metageneration_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_metageneration_match(&mut self) {
        self.if_metageneration_match.clear();
    }

    pub fn has_if_metageneration_match(&self) -> bool {
        self.if_metageneration_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_metageneration_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_metageneration_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_metageneration_match.is_none() {
            self.if_metageneration_match.set_default();
        }
        self.if_metageneration_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_metageneration_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // string kms_key_name = 6;


    pub fn get_kms_key_name(&self) -> &str {
        &self.kms_key_name
    }
    pub fn clear_kms_key_name(&mut self) {
        self.kms_key_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_kms_key_name(&mut self, v: ::std::string::String) {
        self.kms_key_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kms_key_name(&mut self) -> &mut ::std::string::String {
        &mut self.kms_key_name
    }

    // Take field
    pub fn take_kms_key_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kms_key_name, ::std::string::String::new())
    }

    // .google.storage.v1.CommonObjectRequestParams common_object_request_params = 9;


    pub fn get_common_object_request_params(&self) -> &CommonObjectRequestParams {
        self.common_object_request_params.as_ref().unwrap_or_else(|| <CommonObjectRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_object_request_params(&mut self) {
        self.common_object_request_params.clear();
    }

    pub fn has_common_object_request_params(&self) -> bool {
        self.common_object_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_object_request_params(&mut self, v: CommonObjectRequestParams) {
        self.common_object_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_object_request_params(&mut self) -> &mut CommonObjectRequestParams {
        if self.common_object_request_params.is_none() {
            self.common_object_request_params.set_default();
        }
        self.common_object_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_object_request_params(&mut self) -> CommonObjectRequestParams {
        self.common_object_request_params.take().unwrap_or_else(|| CommonObjectRequestParams::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 10;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for ComposeObjectRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.destination {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.source_objects {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_generation_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_metageneration_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_object_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.destination_bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.destination_object)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.destination_predefined_acl, 3, &mut self.unknown_fields)?
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.destination)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.source_objects)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_generation_match)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_metageneration_match)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kms_key_name)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_object_request_params)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.destination_bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.destination_bucket);
        }
        if !self.destination_object.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.destination_object);
        }
        if self.destination_predefined_acl != super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.destination_predefined_acl);
        }
        if let Some(ref v) = self.destination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.source_objects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.if_generation_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.kms_key_name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.kms_key_name);
        }
        if let Some(ref v) = self.common_object_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.destination_bucket.is_empty() {
            os.write_string(1, &self.destination_bucket)?;
        }
        if !self.destination_object.is_empty() {
            os.write_string(2, &self.destination_object)?;
        }
        if self.destination_predefined_acl != super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.destination_predefined_acl))?;
        }
        if let Some(ref v) = self.destination.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.source_objects {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.if_generation_match.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.kms_key_name.is_empty() {
            os.write_string(6, &self.kms_key_name)?;
        }
        if let Some(ref v) = self.common_object_request_params.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ComposeObjectRequest {
        ComposeObjectRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "destination_bucket",
                |m: &ComposeObjectRequest| { &m.destination_bucket },
                |m: &mut ComposeObjectRequest| { &mut m.destination_bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "destination_object",
                |m: &ComposeObjectRequest| { &m.destination_object },
                |m: &mut ComposeObjectRequest| { &mut m.destination_object },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::storage_resources::CommonEnums_PredefinedObjectAcl>>(
                "destination_predefined_acl",
                |m: &ComposeObjectRequest| { &m.destination_predefined_acl },
                |m: &mut ComposeObjectRequest| { &mut m.destination_predefined_acl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::Object>>(
                "destination",
                |m: &ComposeObjectRequest| { &m.destination },
                |m: &mut ComposeObjectRequest| { &mut m.destination },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ComposeObjectRequest_SourceObjects>>(
                "source_objects",
                |m: &ComposeObjectRequest| { &m.source_objects },
                |m: &mut ComposeObjectRequest| { &mut m.source_objects },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_generation_match",
                |m: &ComposeObjectRequest| { &m.if_generation_match },
                |m: &mut ComposeObjectRequest| { &mut m.if_generation_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_metageneration_match",
                |m: &ComposeObjectRequest| { &m.if_metageneration_match },
                |m: &mut ComposeObjectRequest| { &mut m.if_metageneration_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kms_key_name",
                |m: &ComposeObjectRequest| { &m.kms_key_name },
                |m: &mut ComposeObjectRequest| { &mut m.kms_key_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonObjectRequestParams>>(
                "common_object_request_params",
                |m: &ComposeObjectRequest| { &m.common_object_request_params },
                |m: &mut ComposeObjectRequest| { &mut m.common_object_request_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &ComposeObjectRequest| { &m.common_request_params },
                |m: &mut ComposeObjectRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ComposeObjectRequest>(
                "ComposeObjectRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ComposeObjectRequest {
        static instance: ::protobuf::rt::LazyV2<ComposeObjectRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ComposeObjectRequest::new)
    }
}

impl ::protobuf::Clear for ComposeObjectRequest {
    fn clear(&mut self) {
        self.destination_bucket.clear();
        self.destination_object.clear();
        self.destination_predefined_acl = super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED;
        self.destination.clear();
        self.source_objects.clear();
        self.if_generation_match.clear();
        self.if_metageneration_match.clear();
        self.kms_key_name.clear();
        self.common_object_request_params.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ComposeObjectRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComposeObjectRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ComposeObjectRequest_SourceObjects {
    // message fields
    pub name: ::std::string::String,
    pub generation: i64,
    pub object_preconditions: ::protobuf::SingularPtrField<ComposeObjectRequest_SourceObjects_ObjectPreconditions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ComposeObjectRequest_SourceObjects {
    fn default() -> &'a ComposeObjectRequest_SourceObjects {
        <ComposeObjectRequest_SourceObjects as ::protobuf::Message>::default_instance()
    }
}

impl ComposeObjectRequest_SourceObjects {
    pub fn new() -> ComposeObjectRequest_SourceObjects {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // int64 generation = 2;


    pub fn get_generation(&self) -> i64 {
        self.generation
    }
    pub fn clear_generation(&mut self) {
        self.generation = 0;
    }

    // Param is passed by value, moved
    pub fn set_generation(&mut self, v: i64) {
        self.generation = v;
    }

    // .google.storage.v1.ComposeObjectRequest.SourceObjects.ObjectPreconditions object_preconditions = 3;


    pub fn get_object_preconditions(&self) -> &ComposeObjectRequest_SourceObjects_ObjectPreconditions {
        self.object_preconditions.as_ref().unwrap_or_else(|| <ComposeObjectRequest_SourceObjects_ObjectPreconditions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_object_preconditions(&mut self) {
        self.object_preconditions.clear();
    }

    pub fn has_object_preconditions(&self) -> bool {
        self.object_preconditions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_object_preconditions(&mut self, v: ComposeObjectRequest_SourceObjects_ObjectPreconditions) {
        self.object_preconditions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_preconditions(&mut self) -> &mut ComposeObjectRequest_SourceObjects_ObjectPreconditions {
        if self.object_preconditions.is_none() {
            self.object_preconditions.set_default();
        }
        self.object_preconditions.as_mut().unwrap()
    }

    // Take field
    pub fn take_object_preconditions(&mut self) -> ComposeObjectRequest_SourceObjects_ObjectPreconditions {
        self.object_preconditions.take().unwrap_or_else(|| ComposeObjectRequest_SourceObjects_ObjectPreconditions::new())
    }
}

impl ::protobuf::Message for ComposeObjectRequest_SourceObjects {
    fn is_initialized(&self) -> bool {
        for v in &self.object_preconditions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.generation = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.object_preconditions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.generation != 0 {
            my_size += ::protobuf::rt::value_size(2, self.generation, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.object_preconditions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.generation != 0 {
            os.write_int64(2, self.generation)?;
        }
        if let Some(ref v) = self.object_preconditions.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ComposeObjectRequest_SourceObjects {
        ComposeObjectRequest_SourceObjects::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ComposeObjectRequest_SourceObjects| { &m.name },
                |m: &mut ComposeObjectRequest_SourceObjects| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "generation",
                |m: &ComposeObjectRequest_SourceObjects| { &m.generation },
                |m: &mut ComposeObjectRequest_SourceObjects| { &mut m.generation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ComposeObjectRequest_SourceObjects_ObjectPreconditions>>(
                "object_preconditions",
                |m: &ComposeObjectRequest_SourceObjects| { &m.object_preconditions },
                |m: &mut ComposeObjectRequest_SourceObjects| { &mut m.object_preconditions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ComposeObjectRequest_SourceObjects>(
                "ComposeObjectRequest.SourceObjects",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ComposeObjectRequest_SourceObjects {
        static instance: ::protobuf::rt::LazyV2<ComposeObjectRequest_SourceObjects> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ComposeObjectRequest_SourceObjects::new)
    }
}

impl ::protobuf::Clear for ComposeObjectRequest_SourceObjects {
    fn clear(&mut self) {
        self.name.clear();
        self.generation = 0;
        self.object_preconditions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ComposeObjectRequest_SourceObjects {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComposeObjectRequest_SourceObjects {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ComposeObjectRequest_SourceObjects_ObjectPreconditions {
    // message fields
    pub if_generation_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ComposeObjectRequest_SourceObjects_ObjectPreconditions {
    fn default() -> &'a ComposeObjectRequest_SourceObjects_ObjectPreconditions {
        <ComposeObjectRequest_SourceObjects_ObjectPreconditions as ::protobuf::Message>::default_instance()
    }
}

impl ComposeObjectRequest_SourceObjects_ObjectPreconditions {
    pub fn new() -> ComposeObjectRequest_SourceObjects_ObjectPreconditions {
        ::std::default::Default::default()
    }

    // .google.protobuf.Int64Value if_generation_match = 1;


    pub fn get_if_generation_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_generation_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_generation_match(&mut self) {
        self.if_generation_match.clear();
    }

    pub fn has_if_generation_match(&self) -> bool {
        self.if_generation_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_generation_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_generation_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_generation_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_generation_match.is_none() {
            self.if_generation_match.set_default();
        }
        self.if_generation_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_generation_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_generation_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }
}

impl ::protobuf::Message for ComposeObjectRequest_SourceObjects_ObjectPreconditions {
    fn is_initialized(&self) -> bool {
        for v in &self.if_generation_match {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_generation_match)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.if_generation_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.if_generation_match.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ComposeObjectRequest_SourceObjects_ObjectPreconditions {
        ComposeObjectRequest_SourceObjects_ObjectPreconditions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_generation_match",
                |m: &ComposeObjectRequest_SourceObjects_ObjectPreconditions| { &m.if_generation_match },
                |m: &mut ComposeObjectRequest_SourceObjects_ObjectPreconditions| { &mut m.if_generation_match },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ComposeObjectRequest_SourceObjects_ObjectPreconditions>(
                "ComposeObjectRequest.SourceObjects.ObjectPreconditions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ComposeObjectRequest_SourceObjects_ObjectPreconditions {
        static instance: ::protobuf::rt::LazyV2<ComposeObjectRequest_SourceObjects_ObjectPreconditions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ComposeObjectRequest_SourceObjects_ObjectPreconditions::new)
    }
}

impl ::protobuf::Clear for ComposeObjectRequest_SourceObjects_ObjectPreconditions {
    fn clear(&mut self) {
        self.if_generation_match.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ComposeObjectRequest_SourceObjects_ObjectPreconditions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComposeObjectRequest_SourceObjects_ObjectPreconditions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CopyObjectRequest {
    // message fields
    pub destination_bucket: ::std::string::String,
    pub destination_object: ::std::string::String,
    pub destination_predefined_acl: super::storage_resources::CommonEnums_PredefinedObjectAcl,
    pub if_generation_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_generation_not_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_metageneration_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_metageneration_not_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_source_generation_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_source_generation_not_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_source_metageneration_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_source_metageneration_not_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub projection: super::storage_resources::CommonEnums_Projection,
    pub source_bucket: ::std::string::String,
    pub source_object: ::std::string::String,
    pub source_generation: i64,
    pub destination: ::protobuf::SingularPtrField<super::storage_resources::Object>,
    pub destination_kms_key_name: ::std::string::String,
    pub common_object_request_params: ::protobuf::SingularPtrField<CommonObjectRequestParams>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CopyObjectRequest {
    fn default() -> &'a CopyObjectRequest {
        <CopyObjectRequest as ::protobuf::Message>::default_instance()
    }
}

impl CopyObjectRequest {
    pub fn new() -> CopyObjectRequest {
        ::std::default::Default::default()
    }

    // string destination_bucket = 1;


    pub fn get_destination_bucket(&self) -> &str {
        &self.destination_bucket
    }
    pub fn clear_destination_bucket(&mut self) {
        self.destination_bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_destination_bucket(&mut self, v: ::std::string::String) {
        self.destination_bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.destination_bucket
    }

    // Take field
    pub fn take_destination_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.destination_bucket, ::std::string::String::new())
    }

    // string destination_object = 2;


    pub fn get_destination_object(&self) -> &str {
        &self.destination_object
    }
    pub fn clear_destination_object(&mut self) {
        self.destination_object.clear();
    }

    // Param is passed by value, moved
    pub fn set_destination_object(&mut self, v: ::std::string::String) {
        self.destination_object = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination_object(&mut self) -> &mut ::std::string::String {
        &mut self.destination_object
    }

    // Take field
    pub fn take_destination_object(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.destination_object, ::std::string::String::new())
    }

    // .google.storage.v1.CommonEnums.PredefinedObjectAcl destination_predefined_acl = 3;


    pub fn get_destination_predefined_acl(&self) -> super::storage_resources::CommonEnums_PredefinedObjectAcl {
        self.destination_predefined_acl
    }
    pub fn clear_destination_predefined_acl(&mut self) {
        self.destination_predefined_acl = super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_destination_predefined_acl(&mut self, v: super::storage_resources::CommonEnums_PredefinedObjectAcl) {
        self.destination_predefined_acl = v;
    }

    // .google.protobuf.Int64Value if_generation_match = 4;


    pub fn get_if_generation_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_generation_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_generation_match(&mut self) {
        self.if_generation_match.clear();
    }

    pub fn has_if_generation_match(&self) -> bool {
        self.if_generation_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_generation_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_generation_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_generation_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_generation_match.is_none() {
            self.if_generation_match.set_default();
        }
        self.if_generation_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_generation_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_generation_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_generation_not_match = 5;


    pub fn get_if_generation_not_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_generation_not_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_generation_not_match(&mut self) {
        self.if_generation_not_match.clear();
    }

    pub fn has_if_generation_not_match(&self) -> bool {
        self.if_generation_not_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_generation_not_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_generation_not_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_generation_not_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_generation_not_match.is_none() {
            self.if_generation_not_match.set_default();
        }
        self.if_generation_not_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_generation_not_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_generation_not_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_metageneration_match = 6;


    pub fn get_if_metageneration_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_metageneration_match(&mut self) {
        self.if_metageneration_match.clear();
    }

    pub fn has_if_metageneration_match(&self) -> bool {
        self.if_metageneration_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_metageneration_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_metageneration_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_metageneration_match.is_none() {
            self.if_metageneration_match.set_default();
        }
        self.if_metageneration_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_metageneration_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_metageneration_not_match = 7;


    pub fn get_if_metageneration_not_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_metageneration_not_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_metageneration_not_match(&mut self) {
        self.if_metageneration_not_match.clear();
    }

    pub fn has_if_metageneration_not_match(&self) -> bool {
        self.if_metageneration_not_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_not_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_metageneration_not_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_metageneration_not_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_metageneration_not_match.is_none() {
            self.if_metageneration_not_match.set_default();
        }
        self.if_metageneration_not_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_metageneration_not_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_metageneration_not_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_source_generation_match = 8;


    pub fn get_if_source_generation_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_source_generation_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_source_generation_match(&mut self) {
        self.if_source_generation_match.clear();
    }

    pub fn has_if_source_generation_match(&self) -> bool {
        self.if_source_generation_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_source_generation_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_source_generation_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_source_generation_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_source_generation_match.is_none() {
            self.if_source_generation_match.set_default();
        }
        self.if_source_generation_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_source_generation_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_source_generation_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_source_generation_not_match = 9;


    pub fn get_if_source_generation_not_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_source_generation_not_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_source_generation_not_match(&mut self) {
        self.if_source_generation_not_match.clear();
    }

    pub fn has_if_source_generation_not_match(&self) -> bool {
        self.if_source_generation_not_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_source_generation_not_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_source_generation_not_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_source_generation_not_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_source_generation_not_match.is_none() {
            self.if_source_generation_not_match.set_default();
        }
        self.if_source_generation_not_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_source_generation_not_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_source_generation_not_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_source_metageneration_match = 10;


    pub fn get_if_source_metageneration_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_source_metageneration_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_source_metageneration_match(&mut self) {
        self.if_source_metageneration_match.clear();
    }

    pub fn has_if_source_metageneration_match(&self) -> bool {
        self.if_source_metageneration_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_source_metageneration_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_source_metageneration_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_source_metageneration_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_source_metageneration_match.is_none() {
            self.if_source_metageneration_match.set_default();
        }
        self.if_source_metageneration_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_source_metageneration_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_source_metageneration_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_source_metageneration_not_match = 11;


    pub fn get_if_source_metageneration_not_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_source_metageneration_not_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_source_metageneration_not_match(&mut self) {
        self.if_source_metageneration_not_match.clear();
    }

    pub fn has_if_source_metageneration_not_match(&self) -> bool {
        self.if_source_metageneration_not_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_source_metageneration_not_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_source_metageneration_not_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_source_metageneration_not_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_source_metageneration_not_match.is_none() {
            self.if_source_metageneration_not_match.set_default();
        }
        self.if_source_metageneration_not_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_source_metageneration_not_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_source_metageneration_not_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.storage.v1.CommonEnums.Projection projection = 12;


    pub fn get_projection(&self) -> super::storage_resources::CommonEnums_Projection {
        self.projection
    }
    pub fn clear_projection(&mut self) {
        self.projection = super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_projection(&mut self, v: super::storage_resources::CommonEnums_Projection) {
        self.projection = v;
    }

    // string source_bucket = 13;


    pub fn get_source_bucket(&self) -> &str {
        &self.source_bucket
    }
    pub fn clear_source_bucket(&mut self) {
        self.source_bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_bucket(&mut self, v: ::std::string::String) {
        self.source_bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.source_bucket
    }

    // Take field
    pub fn take_source_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_bucket, ::std::string::String::new())
    }

    // string source_object = 14;


    pub fn get_source_object(&self) -> &str {
        &self.source_object
    }
    pub fn clear_source_object(&mut self) {
        self.source_object.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_object(&mut self, v: ::std::string::String) {
        self.source_object = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_object(&mut self) -> &mut ::std::string::String {
        &mut self.source_object
    }

    // Take field
    pub fn take_source_object(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_object, ::std::string::String::new())
    }

    // int64 source_generation = 15;


    pub fn get_source_generation(&self) -> i64 {
        self.source_generation
    }
    pub fn clear_source_generation(&mut self) {
        self.source_generation = 0;
    }

    // Param is passed by value, moved
    pub fn set_source_generation(&mut self, v: i64) {
        self.source_generation = v;
    }

    // .google.storage.v1.Object destination = 17;


    pub fn get_destination(&self) -> &super::storage_resources::Object {
        self.destination.as_ref().unwrap_or_else(|| <super::storage_resources::Object as ::protobuf::Message>::default_instance())
    }
    pub fn clear_destination(&mut self) {
        self.destination.clear();
    }

    pub fn has_destination(&self) -> bool {
        self.destination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destination(&mut self, v: super::storage_resources::Object) {
        self.destination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination(&mut self) -> &mut super::storage_resources::Object {
        if self.destination.is_none() {
            self.destination.set_default();
        }
        self.destination.as_mut().unwrap()
    }

    // Take field
    pub fn take_destination(&mut self) -> super::storage_resources::Object {
        self.destination.take().unwrap_or_else(|| super::storage_resources::Object::new())
    }

    // string destination_kms_key_name = 20;


    pub fn get_destination_kms_key_name(&self) -> &str {
        &self.destination_kms_key_name
    }
    pub fn clear_destination_kms_key_name(&mut self) {
        self.destination_kms_key_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_destination_kms_key_name(&mut self, v: ::std::string::String) {
        self.destination_kms_key_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination_kms_key_name(&mut self) -> &mut ::std::string::String {
        &mut self.destination_kms_key_name
    }

    // Take field
    pub fn take_destination_kms_key_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.destination_kms_key_name, ::std::string::String::new())
    }

    // .google.storage.v1.CommonObjectRequestParams common_object_request_params = 18;


    pub fn get_common_object_request_params(&self) -> &CommonObjectRequestParams {
        self.common_object_request_params.as_ref().unwrap_or_else(|| <CommonObjectRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_object_request_params(&mut self) {
        self.common_object_request_params.clear();
    }

    pub fn has_common_object_request_params(&self) -> bool {
        self.common_object_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_object_request_params(&mut self, v: CommonObjectRequestParams) {
        self.common_object_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_object_request_params(&mut self) -> &mut CommonObjectRequestParams {
        if self.common_object_request_params.is_none() {
            self.common_object_request_params.set_default();
        }
        self.common_object_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_object_request_params(&mut self) -> CommonObjectRequestParams {
        self.common_object_request_params.take().unwrap_or_else(|| CommonObjectRequestParams::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 19;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for CopyObjectRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.if_generation_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_generation_not_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_metageneration_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_metageneration_not_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_source_generation_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_source_generation_not_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_source_metageneration_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_source_metageneration_not_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.destination {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_object_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.destination_bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.destination_object)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.destination_predefined_acl, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_generation_match)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_generation_not_match)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_metageneration_match)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_metageneration_not_match)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_source_generation_match)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_source_generation_not_match)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_source_metageneration_match)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_source_metageneration_not_match)?;
                },
                12 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.projection, 12, &mut self.unknown_fields)?
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source_bucket)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source_object)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.source_generation = tmp;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.destination)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.destination_kms_key_name)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_object_request_params)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.destination_bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.destination_bucket);
        }
        if !self.destination_object.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.destination_object);
        }
        if self.destination_predefined_acl != super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.destination_predefined_acl);
        }
        if let Some(ref v) = self.if_generation_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_generation_not_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_metageneration_not_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_source_generation_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_source_generation_not_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_source_metageneration_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_source_metageneration_not_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.projection != super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(12, self.projection);
        }
        if !self.source_bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.source_bucket);
        }
        if !self.source_object.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.source_object);
        }
        if self.source_generation != 0 {
            my_size += ::protobuf::rt::value_size(15, self.source_generation, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.destination.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.destination_kms_key_name.is_empty() {
            my_size += ::protobuf::rt::string_size(20, &self.destination_kms_key_name);
        }
        if let Some(ref v) = self.common_object_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.destination_bucket.is_empty() {
            os.write_string(1, &self.destination_bucket)?;
        }
        if !self.destination_object.is_empty() {
            os.write_string(2, &self.destination_object)?;
        }
        if self.destination_predefined_acl != super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.destination_predefined_acl))?;
        }
        if let Some(ref v) = self.if_generation_match.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_generation_not_match.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_metageneration_not_match.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_source_generation_match.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_source_generation_not_match.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_source_metageneration_match.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_source_metageneration_not_match.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.projection != super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED {
            os.write_enum(12, ::protobuf::ProtobufEnum::value(&self.projection))?;
        }
        if !self.source_bucket.is_empty() {
            os.write_string(13, &self.source_bucket)?;
        }
        if !self.source_object.is_empty() {
            os.write_string(14, &self.source_object)?;
        }
        if self.source_generation != 0 {
            os.write_int64(15, self.source_generation)?;
        }
        if let Some(ref v) = self.destination.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.destination_kms_key_name.is_empty() {
            os.write_string(20, &self.destination_kms_key_name)?;
        }
        if let Some(ref v) = self.common_object_request_params.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CopyObjectRequest {
        CopyObjectRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "destination_bucket",
                |m: &CopyObjectRequest| { &m.destination_bucket },
                |m: &mut CopyObjectRequest| { &mut m.destination_bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "destination_object",
                |m: &CopyObjectRequest| { &m.destination_object },
                |m: &mut CopyObjectRequest| { &mut m.destination_object },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::storage_resources::CommonEnums_PredefinedObjectAcl>>(
                "destination_predefined_acl",
                |m: &CopyObjectRequest| { &m.destination_predefined_acl },
                |m: &mut CopyObjectRequest| { &mut m.destination_predefined_acl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_generation_match",
                |m: &CopyObjectRequest| { &m.if_generation_match },
                |m: &mut CopyObjectRequest| { &mut m.if_generation_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_generation_not_match",
                |m: &CopyObjectRequest| { &m.if_generation_not_match },
                |m: &mut CopyObjectRequest| { &mut m.if_generation_not_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_metageneration_match",
                |m: &CopyObjectRequest| { &m.if_metageneration_match },
                |m: &mut CopyObjectRequest| { &mut m.if_metageneration_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_metageneration_not_match",
                |m: &CopyObjectRequest| { &m.if_metageneration_not_match },
                |m: &mut CopyObjectRequest| { &mut m.if_metageneration_not_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_source_generation_match",
                |m: &CopyObjectRequest| { &m.if_source_generation_match },
                |m: &mut CopyObjectRequest| { &mut m.if_source_generation_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_source_generation_not_match",
                |m: &CopyObjectRequest| { &m.if_source_generation_not_match },
                |m: &mut CopyObjectRequest| { &mut m.if_source_generation_not_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_source_metageneration_match",
                |m: &CopyObjectRequest| { &m.if_source_metageneration_match },
                |m: &mut CopyObjectRequest| { &mut m.if_source_metageneration_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_source_metageneration_not_match",
                |m: &CopyObjectRequest| { &m.if_source_metageneration_not_match },
                |m: &mut CopyObjectRequest| { &mut m.if_source_metageneration_not_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::storage_resources::CommonEnums_Projection>>(
                "projection",
                |m: &CopyObjectRequest| { &m.projection },
                |m: &mut CopyObjectRequest| { &mut m.projection },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "source_bucket",
                |m: &CopyObjectRequest| { &m.source_bucket },
                |m: &mut CopyObjectRequest| { &mut m.source_bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "source_object",
                |m: &CopyObjectRequest| { &m.source_object },
                |m: &mut CopyObjectRequest| { &mut m.source_object },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "source_generation",
                |m: &CopyObjectRequest| { &m.source_generation },
                |m: &mut CopyObjectRequest| { &mut m.source_generation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::Object>>(
                "destination",
                |m: &CopyObjectRequest| { &m.destination },
                |m: &mut CopyObjectRequest| { &mut m.destination },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "destination_kms_key_name",
                |m: &CopyObjectRequest| { &m.destination_kms_key_name },
                |m: &mut CopyObjectRequest| { &mut m.destination_kms_key_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonObjectRequestParams>>(
                "common_object_request_params",
                |m: &CopyObjectRequest| { &m.common_object_request_params },
                |m: &mut CopyObjectRequest| { &mut m.common_object_request_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &CopyObjectRequest| { &m.common_request_params },
                |m: &mut CopyObjectRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CopyObjectRequest>(
                "CopyObjectRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CopyObjectRequest {
        static instance: ::protobuf::rt::LazyV2<CopyObjectRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CopyObjectRequest::new)
    }
}

impl ::protobuf::Clear for CopyObjectRequest {
    fn clear(&mut self) {
        self.destination_bucket.clear();
        self.destination_object.clear();
        self.destination_predefined_acl = super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED;
        self.if_generation_match.clear();
        self.if_generation_not_match.clear();
        self.if_metageneration_match.clear();
        self.if_metageneration_not_match.clear();
        self.if_source_generation_match.clear();
        self.if_source_generation_not_match.clear();
        self.if_source_metageneration_match.clear();
        self.if_source_metageneration_not_match.clear();
        self.projection = super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED;
        self.source_bucket.clear();
        self.source_object.clear();
        self.source_generation = 0;
        self.destination.clear();
        self.destination_kms_key_name.clear();
        self.common_object_request_params.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CopyObjectRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CopyObjectRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteObjectRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub object: ::std::string::String,
    pub upload_id: ::std::string::String,
    pub generation: i64,
    pub if_generation_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_generation_not_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_metageneration_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_metageneration_not_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub common_object_request_params: ::protobuf::SingularPtrField<CommonObjectRequestParams>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteObjectRequest {
    fn default() -> &'a DeleteObjectRequest {
        <DeleteObjectRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteObjectRequest {
    pub fn new() -> DeleteObjectRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string object = 2;


    pub fn get_object(&self) -> &str {
        &self.object
    }
    pub fn clear_object(&mut self) {
        self.object.clear();
    }

    // Param is passed by value, moved
    pub fn set_object(&mut self, v: ::std::string::String) {
        self.object = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object(&mut self) -> &mut ::std::string::String {
        &mut self.object
    }

    // Take field
    pub fn take_object(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object, ::std::string::String::new())
    }

    // string upload_id = 3;


    pub fn get_upload_id(&self) -> &str {
        &self.upload_id
    }
    pub fn clear_upload_id(&mut self) {
        self.upload_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_upload_id(&mut self, v: ::std::string::String) {
        self.upload_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_upload_id(&mut self) -> &mut ::std::string::String {
        &mut self.upload_id
    }

    // Take field
    pub fn take_upload_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.upload_id, ::std::string::String::new())
    }

    // int64 generation = 4;


    pub fn get_generation(&self) -> i64 {
        self.generation
    }
    pub fn clear_generation(&mut self) {
        self.generation = 0;
    }

    // Param is passed by value, moved
    pub fn set_generation(&mut self, v: i64) {
        self.generation = v;
    }

    // .google.protobuf.Int64Value if_generation_match = 5;


    pub fn get_if_generation_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_generation_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_generation_match(&mut self) {
        self.if_generation_match.clear();
    }

    pub fn has_if_generation_match(&self) -> bool {
        self.if_generation_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_generation_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_generation_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_generation_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_generation_match.is_none() {
            self.if_generation_match.set_default();
        }
        self.if_generation_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_generation_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_generation_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_generation_not_match = 6;


    pub fn get_if_generation_not_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_generation_not_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_generation_not_match(&mut self) {
        self.if_generation_not_match.clear();
    }

    pub fn has_if_generation_not_match(&self) -> bool {
        self.if_generation_not_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_generation_not_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_generation_not_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_generation_not_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_generation_not_match.is_none() {
            self.if_generation_not_match.set_default();
        }
        self.if_generation_not_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_generation_not_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_generation_not_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_metageneration_match = 7;


    pub fn get_if_metageneration_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_metageneration_match(&mut self) {
        self.if_metageneration_match.clear();
    }

    pub fn has_if_metageneration_match(&self) -> bool {
        self.if_metageneration_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_metageneration_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_metageneration_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_metageneration_match.is_none() {
            self.if_metageneration_match.set_default();
        }
        self.if_metageneration_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_metageneration_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_metageneration_not_match = 8;


    pub fn get_if_metageneration_not_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_metageneration_not_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_metageneration_not_match(&mut self) {
        self.if_metageneration_not_match.clear();
    }

    pub fn has_if_metageneration_not_match(&self) -> bool {
        self.if_metageneration_not_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_not_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_metageneration_not_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_metageneration_not_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_metageneration_not_match.is_none() {
            self.if_metageneration_not_match.set_default();
        }
        self.if_metageneration_not_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_metageneration_not_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_metageneration_not_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.storage.v1.CommonObjectRequestParams common_object_request_params = 10;


    pub fn get_common_object_request_params(&self) -> &CommonObjectRequestParams {
        self.common_object_request_params.as_ref().unwrap_or_else(|| <CommonObjectRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_object_request_params(&mut self) {
        self.common_object_request_params.clear();
    }

    pub fn has_common_object_request_params(&self) -> bool {
        self.common_object_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_object_request_params(&mut self, v: CommonObjectRequestParams) {
        self.common_object_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_object_request_params(&mut self) -> &mut CommonObjectRequestParams {
        if self.common_object_request_params.is_none() {
            self.common_object_request_params.set_default();
        }
        self.common_object_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_object_request_params(&mut self) -> CommonObjectRequestParams {
        self.common_object_request_params.take().unwrap_or_else(|| CommonObjectRequestParams::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 11;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for DeleteObjectRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.if_generation_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_generation_not_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_metageneration_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_metageneration_not_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_object_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.upload_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.generation = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_generation_match)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_generation_not_match)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_metageneration_match)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_metageneration_not_match)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_object_request_params)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.object.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.object);
        }
        if !self.upload_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.upload_id);
        }
        if self.generation != 0 {
            my_size += ::protobuf::rt::value_size(4, self.generation, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.if_generation_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_generation_not_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_metageneration_not_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_object_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.object.is_empty() {
            os.write_string(2, &self.object)?;
        }
        if !self.upload_id.is_empty() {
            os.write_string(3, &self.upload_id)?;
        }
        if self.generation != 0 {
            os.write_int64(4, self.generation)?;
        }
        if let Some(ref v) = self.if_generation_match.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_generation_not_match.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_metageneration_not_match.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_object_request_params.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteObjectRequest {
        DeleteObjectRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &DeleteObjectRequest| { &m.bucket },
                |m: &mut DeleteObjectRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object",
                |m: &DeleteObjectRequest| { &m.object },
                |m: &mut DeleteObjectRequest| { &mut m.object },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "upload_id",
                |m: &DeleteObjectRequest| { &m.upload_id },
                |m: &mut DeleteObjectRequest| { &mut m.upload_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "generation",
                |m: &DeleteObjectRequest| { &m.generation },
                |m: &mut DeleteObjectRequest| { &mut m.generation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_generation_match",
                |m: &DeleteObjectRequest| { &m.if_generation_match },
                |m: &mut DeleteObjectRequest| { &mut m.if_generation_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_generation_not_match",
                |m: &DeleteObjectRequest| { &m.if_generation_not_match },
                |m: &mut DeleteObjectRequest| { &mut m.if_generation_not_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_metageneration_match",
                |m: &DeleteObjectRequest| { &m.if_metageneration_match },
                |m: &mut DeleteObjectRequest| { &mut m.if_metageneration_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_metageneration_not_match",
                |m: &DeleteObjectRequest| { &m.if_metageneration_not_match },
                |m: &mut DeleteObjectRequest| { &mut m.if_metageneration_not_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonObjectRequestParams>>(
                "common_object_request_params",
                |m: &DeleteObjectRequest| { &m.common_object_request_params },
                |m: &mut DeleteObjectRequest| { &mut m.common_object_request_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &DeleteObjectRequest| { &m.common_request_params },
                |m: &mut DeleteObjectRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteObjectRequest>(
                "DeleteObjectRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteObjectRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteObjectRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteObjectRequest::new)
    }
}

impl ::protobuf::Clear for DeleteObjectRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.object.clear();
        self.upload_id.clear();
        self.generation = 0;
        self.if_generation_match.clear();
        self.if_generation_not_match.clear();
        self.if_metageneration_match.clear();
        self.if_metageneration_not_match.clear();
        self.common_object_request_params.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteObjectRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteObjectRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetObjectMediaRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub object: ::std::string::String,
    pub generation: i64,
    pub read_offset: i64,
    pub read_limit: i64,
    pub if_generation_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_generation_not_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_metageneration_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_metageneration_not_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub common_object_request_params: ::protobuf::SingularPtrField<CommonObjectRequestParams>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetObjectMediaRequest {
    fn default() -> &'a GetObjectMediaRequest {
        <GetObjectMediaRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetObjectMediaRequest {
    pub fn new() -> GetObjectMediaRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string object = 2;


    pub fn get_object(&self) -> &str {
        &self.object
    }
    pub fn clear_object(&mut self) {
        self.object.clear();
    }

    // Param is passed by value, moved
    pub fn set_object(&mut self, v: ::std::string::String) {
        self.object = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object(&mut self) -> &mut ::std::string::String {
        &mut self.object
    }

    // Take field
    pub fn take_object(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object, ::std::string::String::new())
    }

    // int64 generation = 3;


    pub fn get_generation(&self) -> i64 {
        self.generation
    }
    pub fn clear_generation(&mut self) {
        self.generation = 0;
    }

    // Param is passed by value, moved
    pub fn set_generation(&mut self, v: i64) {
        self.generation = v;
    }

    // int64 read_offset = 4;


    pub fn get_read_offset(&self) -> i64 {
        self.read_offset
    }
    pub fn clear_read_offset(&mut self) {
        self.read_offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_read_offset(&mut self, v: i64) {
        self.read_offset = v;
    }

    // int64 read_limit = 5;


    pub fn get_read_limit(&self) -> i64 {
        self.read_limit
    }
    pub fn clear_read_limit(&mut self) {
        self.read_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_read_limit(&mut self, v: i64) {
        self.read_limit = v;
    }

    // .google.protobuf.Int64Value if_generation_match = 6;


    pub fn get_if_generation_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_generation_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_generation_match(&mut self) {
        self.if_generation_match.clear();
    }

    pub fn has_if_generation_match(&self) -> bool {
        self.if_generation_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_generation_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_generation_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_generation_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_generation_match.is_none() {
            self.if_generation_match.set_default();
        }
        self.if_generation_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_generation_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_generation_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_generation_not_match = 7;


    pub fn get_if_generation_not_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_generation_not_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_generation_not_match(&mut self) {
        self.if_generation_not_match.clear();
    }

    pub fn has_if_generation_not_match(&self) -> bool {
        self.if_generation_not_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_generation_not_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_generation_not_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_generation_not_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_generation_not_match.is_none() {
            self.if_generation_not_match.set_default();
        }
        self.if_generation_not_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_generation_not_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_generation_not_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_metageneration_match = 8;


    pub fn get_if_metageneration_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_metageneration_match(&mut self) {
        self.if_metageneration_match.clear();
    }

    pub fn has_if_metageneration_match(&self) -> bool {
        self.if_metageneration_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_metageneration_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_metageneration_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_metageneration_match.is_none() {
            self.if_metageneration_match.set_default();
        }
        self.if_metageneration_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_metageneration_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_metageneration_not_match = 9;


    pub fn get_if_metageneration_not_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_metageneration_not_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_metageneration_not_match(&mut self) {
        self.if_metageneration_not_match.clear();
    }

    pub fn has_if_metageneration_not_match(&self) -> bool {
        self.if_metageneration_not_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_not_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_metageneration_not_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_metageneration_not_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_metageneration_not_match.is_none() {
            self.if_metageneration_not_match.set_default();
        }
        self.if_metageneration_not_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_metageneration_not_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_metageneration_not_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.storage.v1.CommonObjectRequestParams common_object_request_params = 11;


    pub fn get_common_object_request_params(&self) -> &CommonObjectRequestParams {
        self.common_object_request_params.as_ref().unwrap_or_else(|| <CommonObjectRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_object_request_params(&mut self) {
        self.common_object_request_params.clear();
    }

    pub fn has_common_object_request_params(&self) -> bool {
        self.common_object_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_object_request_params(&mut self, v: CommonObjectRequestParams) {
        self.common_object_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_object_request_params(&mut self) -> &mut CommonObjectRequestParams {
        if self.common_object_request_params.is_none() {
            self.common_object_request_params.set_default();
        }
        self.common_object_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_object_request_params(&mut self) -> CommonObjectRequestParams {
        self.common_object_request_params.take().unwrap_or_else(|| CommonObjectRequestParams::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 12;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for GetObjectMediaRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.if_generation_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_generation_not_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_metageneration_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_metageneration_not_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_object_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.generation = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.read_offset = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.read_limit = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_generation_match)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_generation_not_match)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_metageneration_match)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_metageneration_not_match)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_object_request_params)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.object.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.object);
        }
        if self.generation != 0 {
            my_size += ::protobuf::rt::value_size(3, self.generation, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.read_offset != 0 {
            my_size += ::protobuf::rt::value_size(4, self.read_offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.read_limit != 0 {
            my_size += ::protobuf::rt::value_size(5, self.read_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.if_generation_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_generation_not_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_metageneration_not_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_object_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.object.is_empty() {
            os.write_string(2, &self.object)?;
        }
        if self.generation != 0 {
            os.write_int64(3, self.generation)?;
        }
        if self.read_offset != 0 {
            os.write_int64(4, self.read_offset)?;
        }
        if self.read_limit != 0 {
            os.write_int64(5, self.read_limit)?;
        }
        if let Some(ref v) = self.if_generation_match.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_generation_not_match.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_metageneration_not_match.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_object_request_params.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetObjectMediaRequest {
        GetObjectMediaRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &GetObjectMediaRequest| { &m.bucket },
                |m: &mut GetObjectMediaRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object",
                |m: &GetObjectMediaRequest| { &m.object },
                |m: &mut GetObjectMediaRequest| { &mut m.object },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "generation",
                |m: &GetObjectMediaRequest| { &m.generation },
                |m: &mut GetObjectMediaRequest| { &mut m.generation },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "read_offset",
                |m: &GetObjectMediaRequest| { &m.read_offset },
                |m: &mut GetObjectMediaRequest| { &mut m.read_offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "read_limit",
                |m: &GetObjectMediaRequest| { &m.read_limit },
                |m: &mut GetObjectMediaRequest| { &mut m.read_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_generation_match",
                |m: &GetObjectMediaRequest| { &m.if_generation_match },
                |m: &mut GetObjectMediaRequest| { &mut m.if_generation_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_generation_not_match",
                |m: &GetObjectMediaRequest| { &m.if_generation_not_match },
                |m: &mut GetObjectMediaRequest| { &mut m.if_generation_not_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_metageneration_match",
                |m: &GetObjectMediaRequest| { &m.if_metageneration_match },
                |m: &mut GetObjectMediaRequest| { &mut m.if_metageneration_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_metageneration_not_match",
                |m: &GetObjectMediaRequest| { &m.if_metageneration_not_match },
                |m: &mut GetObjectMediaRequest| { &mut m.if_metageneration_not_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonObjectRequestParams>>(
                "common_object_request_params",
                |m: &GetObjectMediaRequest| { &m.common_object_request_params },
                |m: &mut GetObjectMediaRequest| { &mut m.common_object_request_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &GetObjectMediaRequest| { &m.common_request_params },
                |m: &mut GetObjectMediaRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetObjectMediaRequest>(
                "GetObjectMediaRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetObjectMediaRequest {
        static instance: ::protobuf::rt::LazyV2<GetObjectMediaRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetObjectMediaRequest::new)
    }
}

impl ::protobuf::Clear for GetObjectMediaRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.object.clear();
        self.generation = 0;
        self.read_offset = 0;
        self.read_limit = 0;
        self.if_generation_match.clear();
        self.if_generation_not_match.clear();
        self.if_metageneration_match.clear();
        self.if_metageneration_not_match.clear();
        self.common_object_request_params.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetObjectMediaRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetObjectMediaRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetObjectRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub object: ::std::string::String,
    pub generation: i64,
    pub if_generation_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_generation_not_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_metageneration_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_metageneration_not_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub projection: super::storage_resources::CommonEnums_Projection,
    pub common_object_request_params: ::protobuf::SingularPtrField<CommonObjectRequestParams>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetObjectRequest {
    fn default() -> &'a GetObjectRequest {
        <GetObjectRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetObjectRequest {
    pub fn new() -> GetObjectRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string object = 2;


    pub fn get_object(&self) -> &str {
        &self.object
    }
    pub fn clear_object(&mut self) {
        self.object.clear();
    }

    // Param is passed by value, moved
    pub fn set_object(&mut self, v: ::std::string::String) {
        self.object = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object(&mut self) -> &mut ::std::string::String {
        &mut self.object
    }

    // Take field
    pub fn take_object(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object, ::std::string::String::new())
    }

    // int64 generation = 3;


    pub fn get_generation(&self) -> i64 {
        self.generation
    }
    pub fn clear_generation(&mut self) {
        self.generation = 0;
    }

    // Param is passed by value, moved
    pub fn set_generation(&mut self, v: i64) {
        self.generation = v;
    }

    // .google.protobuf.Int64Value if_generation_match = 4;


    pub fn get_if_generation_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_generation_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_generation_match(&mut self) {
        self.if_generation_match.clear();
    }

    pub fn has_if_generation_match(&self) -> bool {
        self.if_generation_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_generation_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_generation_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_generation_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_generation_match.is_none() {
            self.if_generation_match.set_default();
        }
        self.if_generation_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_generation_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_generation_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_generation_not_match = 5;


    pub fn get_if_generation_not_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_generation_not_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_generation_not_match(&mut self) {
        self.if_generation_not_match.clear();
    }

    pub fn has_if_generation_not_match(&self) -> bool {
        self.if_generation_not_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_generation_not_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_generation_not_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_generation_not_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_generation_not_match.is_none() {
            self.if_generation_not_match.set_default();
        }
        self.if_generation_not_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_generation_not_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_generation_not_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_metageneration_match = 6;


    pub fn get_if_metageneration_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_metageneration_match(&mut self) {
        self.if_metageneration_match.clear();
    }

    pub fn has_if_metageneration_match(&self) -> bool {
        self.if_metageneration_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_metageneration_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_metageneration_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_metageneration_match.is_none() {
            self.if_metageneration_match.set_default();
        }
        self.if_metageneration_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_metageneration_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_metageneration_not_match = 7;


    pub fn get_if_metageneration_not_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_metageneration_not_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_metageneration_not_match(&mut self) {
        self.if_metageneration_not_match.clear();
    }

    pub fn has_if_metageneration_not_match(&self) -> bool {
        self.if_metageneration_not_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_not_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_metageneration_not_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_metageneration_not_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_metageneration_not_match.is_none() {
            self.if_metageneration_not_match.set_default();
        }
        self.if_metageneration_not_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_metageneration_not_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_metageneration_not_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.storage.v1.CommonEnums.Projection projection = 8;


    pub fn get_projection(&self) -> super::storage_resources::CommonEnums_Projection {
        self.projection
    }
    pub fn clear_projection(&mut self) {
        self.projection = super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_projection(&mut self, v: super::storage_resources::CommonEnums_Projection) {
        self.projection = v;
    }

    // .google.storage.v1.CommonObjectRequestParams common_object_request_params = 10;


    pub fn get_common_object_request_params(&self) -> &CommonObjectRequestParams {
        self.common_object_request_params.as_ref().unwrap_or_else(|| <CommonObjectRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_object_request_params(&mut self) {
        self.common_object_request_params.clear();
    }

    pub fn has_common_object_request_params(&self) -> bool {
        self.common_object_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_object_request_params(&mut self, v: CommonObjectRequestParams) {
        self.common_object_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_object_request_params(&mut self) -> &mut CommonObjectRequestParams {
        if self.common_object_request_params.is_none() {
            self.common_object_request_params.set_default();
        }
        self.common_object_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_object_request_params(&mut self) -> CommonObjectRequestParams {
        self.common_object_request_params.take().unwrap_or_else(|| CommonObjectRequestParams::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 11;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for GetObjectRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.if_generation_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_generation_not_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_metageneration_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_metageneration_not_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_object_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.generation = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_generation_match)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_generation_not_match)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_metageneration_match)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_metageneration_not_match)?;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.projection, 8, &mut self.unknown_fields)?
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_object_request_params)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.object.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.object);
        }
        if self.generation != 0 {
            my_size += ::protobuf::rt::value_size(3, self.generation, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.if_generation_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_generation_not_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_metageneration_not_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.projection != super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(8, self.projection);
        }
        if let Some(ref v) = self.common_object_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.object.is_empty() {
            os.write_string(2, &self.object)?;
        }
        if self.generation != 0 {
            os.write_int64(3, self.generation)?;
        }
        if let Some(ref v) = self.if_generation_match.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_generation_not_match.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_metageneration_not_match.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.projection != super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&self.projection))?;
        }
        if let Some(ref v) = self.common_object_request_params.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetObjectRequest {
        GetObjectRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &GetObjectRequest| { &m.bucket },
                |m: &mut GetObjectRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object",
                |m: &GetObjectRequest| { &m.object },
                |m: &mut GetObjectRequest| { &mut m.object },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "generation",
                |m: &GetObjectRequest| { &m.generation },
                |m: &mut GetObjectRequest| { &mut m.generation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_generation_match",
                |m: &GetObjectRequest| { &m.if_generation_match },
                |m: &mut GetObjectRequest| { &mut m.if_generation_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_generation_not_match",
                |m: &GetObjectRequest| { &m.if_generation_not_match },
                |m: &mut GetObjectRequest| { &mut m.if_generation_not_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_metageneration_match",
                |m: &GetObjectRequest| { &m.if_metageneration_match },
                |m: &mut GetObjectRequest| { &mut m.if_metageneration_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_metageneration_not_match",
                |m: &GetObjectRequest| { &m.if_metageneration_not_match },
                |m: &mut GetObjectRequest| { &mut m.if_metageneration_not_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::storage_resources::CommonEnums_Projection>>(
                "projection",
                |m: &GetObjectRequest| { &m.projection },
                |m: &mut GetObjectRequest| { &mut m.projection },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonObjectRequestParams>>(
                "common_object_request_params",
                |m: &GetObjectRequest| { &m.common_object_request_params },
                |m: &mut GetObjectRequest| { &mut m.common_object_request_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &GetObjectRequest| { &m.common_request_params },
                |m: &mut GetObjectRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetObjectRequest>(
                "GetObjectRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetObjectRequest {
        static instance: ::protobuf::rt::LazyV2<GetObjectRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetObjectRequest::new)
    }
}

impl ::protobuf::Clear for GetObjectRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.object.clear();
        self.generation = 0;
        self.if_generation_match.clear();
        self.if_generation_not_match.clear();
        self.if_metageneration_match.clear();
        self.if_metageneration_not_match.clear();
        self.projection = super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED;
        self.common_object_request_params.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetObjectRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetObjectRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetObjectMediaResponse {
    // message fields
    pub checksummed_data: ::protobuf::SingularPtrField<super::storage_resources::ChecksummedData>,
    pub object_checksums: ::protobuf::SingularPtrField<super::storage_resources::ObjectChecksums>,
    pub content_range: ::protobuf::SingularPtrField<super::storage_resources::ContentRange>,
    pub metadata: ::protobuf::SingularPtrField<super::storage_resources::Object>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetObjectMediaResponse {
    fn default() -> &'a GetObjectMediaResponse {
        <GetObjectMediaResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetObjectMediaResponse {
    pub fn new() -> GetObjectMediaResponse {
        ::std::default::Default::default()
    }

    // .google.storage.v1.ChecksummedData checksummed_data = 1;


    pub fn get_checksummed_data(&self) -> &super::storage_resources::ChecksummedData {
        self.checksummed_data.as_ref().unwrap_or_else(|| <super::storage_resources::ChecksummedData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_checksummed_data(&mut self) {
        self.checksummed_data.clear();
    }

    pub fn has_checksummed_data(&self) -> bool {
        self.checksummed_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checksummed_data(&mut self, v: super::storage_resources::ChecksummedData) {
        self.checksummed_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_checksummed_data(&mut self) -> &mut super::storage_resources::ChecksummedData {
        if self.checksummed_data.is_none() {
            self.checksummed_data.set_default();
        }
        self.checksummed_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_checksummed_data(&mut self) -> super::storage_resources::ChecksummedData {
        self.checksummed_data.take().unwrap_or_else(|| super::storage_resources::ChecksummedData::new())
    }

    // .google.storage.v1.ObjectChecksums object_checksums = 2;


    pub fn get_object_checksums(&self) -> &super::storage_resources::ObjectChecksums {
        self.object_checksums.as_ref().unwrap_or_else(|| <super::storage_resources::ObjectChecksums as ::protobuf::Message>::default_instance())
    }
    pub fn clear_object_checksums(&mut self) {
        self.object_checksums.clear();
    }

    pub fn has_object_checksums(&self) -> bool {
        self.object_checksums.is_some()
    }

    // Param is passed by value, moved
    pub fn set_object_checksums(&mut self, v: super::storage_resources::ObjectChecksums) {
        self.object_checksums = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_checksums(&mut self) -> &mut super::storage_resources::ObjectChecksums {
        if self.object_checksums.is_none() {
            self.object_checksums.set_default();
        }
        self.object_checksums.as_mut().unwrap()
    }

    // Take field
    pub fn take_object_checksums(&mut self) -> super::storage_resources::ObjectChecksums {
        self.object_checksums.take().unwrap_or_else(|| super::storage_resources::ObjectChecksums::new())
    }

    // .google.storage.v1.ContentRange content_range = 3;


    pub fn get_content_range(&self) -> &super::storage_resources::ContentRange {
        self.content_range.as_ref().unwrap_or_else(|| <super::storage_resources::ContentRange as ::protobuf::Message>::default_instance())
    }
    pub fn clear_content_range(&mut self) {
        self.content_range.clear();
    }

    pub fn has_content_range(&self) -> bool {
        self.content_range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content_range(&mut self, v: super::storage_resources::ContentRange) {
        self.content_range = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content_range(&mut self) -> &mut super::storage_resources::ContentRange {
        if self.content_range.is_none() {
            self.content_range.set_default();
        }
        self.content_range.as_mut().unwrap()
    }

    // Take field
    pub fn take_content_range(&mut self) -> super::storage_resources::ContentRange {
        self.content_range.take().unwrap_or_else(|| super::storage_resources::ContentRange::new())
    }

    // .google.storage.v1.Object metadata = 4;


    pub fn get_metadata(&self) -> &super::storage_resources::Object {
        self.metadata.as_ref().unwrap_or_else(|| <super::storage_resources::Object as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::storage_resources::Object) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::storage_resources::Object {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::storage_resources::Object {
        self.metadata.take().unwrap_or_else(|| super::storage_resources::Object::new())
    }
}

impl ::protobuf::Message for GetObjectMediaResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.checksummed_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.object_checksums {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.content_range {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.checksummed_data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.object_checksums)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.content_range)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.checksummed_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.object_checksums.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.content_range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.checksummed_data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.object_checksums.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.content_range.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetObjectMediaResponse {
        GetObjectMediaResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::ChecksummedData>>(
                "checksummed_data",
                |m: &GetObjectMediaResponse| { &m.checksummed_data },
                |m: &mut GetObjectMediaResponse| { &mut m.checksummed_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::ObjectChecksums>>(
                "object_checksums",
                |m: &GetObjectMediaResponse| { &m.object_checksums },
                |m: &mut GetObjectMediaResponse| { &mut m.object_checksums },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::ContentRange>>(
                "content_range",
                |m: &GetObjectMediaResponse| { &m.content_range },
                |m: &mut GetObjectMediaResponse| { &mut m.content_range },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::Object>>(
                "metadata",
                |m: &GetObjectMediaResponse| { &m.metadata },
                |m: &mut GetObjectMediaResponse| { &mut m.metadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetObjectMediaResponse>(
                "GetObjectMediaResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetObjectMediaResponse {
        static instance: ::protobuf::rt::LazyV2<GetObjectMediaResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetObjectMediaResponse::new)
    }
}

impl ::protobuf::Clear for GetObjectMediaResponse {
    fn clear(&mut self) {
        self.checksummed_data.clear();
        self.object_checksums.clear();
        self.content_range.clear();
        self.metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetObjectMediaResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetObjectMediaResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InsertObjectSpec {
    // message fields
    pub resource: ::protobuf::SingularPtrField<super::storage_resources::Object>,
    pub predefined_acl: super::storage_resources::CommonEnums_PredefinedObjectAcl,
    pub if_generation_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_generation_not_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_metageneration_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_metageneration_not_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub projection: super::storage_resources::CommonEnums_Projection,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InsertObjectSpec {
    fn default() -> &'a InsertObjectSpec {
        <InsertObjectSpec as ::protobuf::Message>::default_instance()
    }
}

impl InsertObjectSpec {
    pub fn new() -> InsertObjectSpec {
        ::std::default::Default::default()
    }

    // .google.storage.v1.Object resource = 1;


    pub fn get_resource(&self) -> &super::storage_resources::Object {
        self.resource.as_ref().unwrap_or_else(|| <super::storage_resources::Object as ::protobuf::Message>::default_instance())
    }
    pub fn clear_resource(&mut self) {
        self.resource.clear();
    }

    pub fn has_resource(&self) -> bool {
        self.resource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: super::storage_resources::Object) {
        self.resource = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut super::storage_resources::Object {
        if self.resource.is_none() {
            self.resource.set_default();
        }
        self.resource.as_mut().unwrap()
    }

    // Take field
    pub fn take_resource(&mut self) -> super::storage_resources::Object {
        self.resource.take().unwrap_or_else(|| super::storage_resources::Object::new())
    }

    // .google.storage.v1.CommonEnums.PredefinedObjectAcl predefined_acl = 2;


    pub fn get_predefined_acl(&self) -> super::storage_resources::CommonEnums_PredefinedObjectAcl {
        self.predefined_acl
    }
    pub fn clear_predefined_acl(&mut self) {
        self.predefined_acl = super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_predefined_acl(&mut self, v: super::storage_resources::CommonEnums_PredefinedObjectAcl) {
        self.predefined_acl = v;
    }

    // .google.protobuf.Int64Value if_generation_match = 3;


    pub fn get_if_generation_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_generation_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_generation_match(&mut self) {
        self.if_generation_match.clear();
    }

    pub fn has_if_generation_match(&self) -> bool {
        self.if_generation_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_generation_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_generation_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_generation_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_generation_match.is_none() {
            self.if_generation_match.set_default();
        }
        self.if_generation_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_generation_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_generation_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_generation_not_match = 4;


    pub fn get_if_generation_not_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_generation_not_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_generation_not_match(&mut self) {
        self.if_generation_not_match.clear();
    }

    pub fn has_if_generation_not_match(&self) -> bool {
        self.if_generation_not_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_generation_not_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_generation_not_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_generation_not_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_generation_not_match.is_none() {
            self.if_generation_not_match.set_default();
        }
        self.if_generation_not_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_generation_not_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_generation_not_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_metageneration_match = 5;


    pub fn get_if_metageneration_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_metageneration_match(&mut self) {
        self.if_metageneration_match.clear();
    }

    pub fn has_if_metageneration_match(&self) -> bool {
        self.if_metageneration_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_metageneration_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_metageneration_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_metageneration_match.is_none() {
            self.if_metageneration_match.set_default();
        }
        self.if_metageneration_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_metageneration_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_metageneration_not_match = 6;


    pub fn get_if_metageneration_not_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_metageneration_not_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_metageneration_not_match(&mut self) {
        self.if_metageneration_not_match.clear();
    }

    pub fn has_if_metageneration_not_match(&self) -> bool {
        self.if_metageneration_not_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_not_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_metageneration_not_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_metageneration_not_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_metageneration_not_match.is_none() {
            self.if_metageneration_not_match.set_default();
        }
        self.if_metageneration_not_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_metageneration_not_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_metageneration_not_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.storage.v1.CommonEnums.Projection projection = 7;


    pub fn get_projection(&self) -> super::storage_resources::CommonEnums_Projection {
        self.projection
    }
    pub fn clear_projection(&mut self) {
        self.projection = super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_projection(&mut self, v: super::storage_resources::CommonEnums_Projection) {
        self.projection = v;
    }
}

impl ::protobuf::Message for InsertObjectSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.resource {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_generation_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_generation_not_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_metageneration_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_metageneration_not_match {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resource)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.predefined_acl, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_generation_match)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_generation_not_match)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_metageneration_match)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_metageneration_not_match)?;
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.projection, 7, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.resource.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.predefined_acl != super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(2, self.predefined_acl);
        }
        if let Some(ref v) = self.if_generation_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_generation_not_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_metageneration_not_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.projection != super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(7, self.projection);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.resource.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.predefined_acl != super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.predefined_acl))?;
        }
        if let Some(ref v) = self.if_generation_match.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_generation_not_match.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_metageneration_not_match.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.projection != super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED {
            os.write_enum(7, ::protobuf::ProtobufEnum::value(&self.projection))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InsertObjectSpec {
        InsertObjectSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::Object>>(
                "resource",
                |m: &InsertObjectSpec| { &m.resource },
                |m: &mut InsertObjectSpec| { &mut m.resource },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::storage_resources::CommonEnums_PredefinedObjectAcl>>(
                "predefined_acl",
                |m: &InsertObjectSpec| { &m.predefined_acl },
                |m: &mut InsertObjectSpec| { &mut m.predefined_acl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_generation_match",
                |m: &InsertObjectSpec| { &m.if_generation_match },
                |m: &mut InsertObjectSpec| { &mut m.if_generation_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_generation_not_match",
                |m: &InsertObjectSpec| { &m.if_generation_not_match },
                |m: &mut InsertObjectSpec| { &mut m.if_generation_not_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_metageneration_match",
                |m: &InsertObjectSpec| { &m.if_metageneration_match },
                |m: &mut InsertObjectSpec| { &mut m.if_metageneration_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_metageneration_not_match",
                |m: &InsertObjectSpec| { &m.if_metageneration_not_match },
                |m: &mut InsertObjectSpec| { &mut m.if_metageneration_not_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::storage_resources::CommonEnums_Projection>>(
                "projection",
                |m: &InsertObjectSpec| { &m.projection },
                |m: &mut InsertObjectSpec| { &mut m.projection },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InsertObjectSpec>(
                "InsertObjectSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InsertObjectSpec {
        static instance: ::protobuf::rt::LazyV2<InsertObjectSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InsertObjectSpec::new)
    }
}

impl ::protobuf::Clear for InsertObjectSpec {
    fn clear(&mut self) {
        self.resource.clear();
        self.predefined_acl = super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED;
        self.if_generation_match.clear();
        self.if_generation_not_match.clear();
        self.if_metageneration_match.clear();
        self.if_metageneration_not_match.clear();
        self.projection = super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InsertObjectSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InsertObjectSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InsertObjectRequest {
    // message fields
    pub write_offset: i64,
    pub object_checksums: ::protobuf::SingularPtrField<super::storage_resources::ObjectChecksums>,
    pub finish_write: bool,
    pub common_object_request_params: ::protobuf::SingularPtrField<CommonObjectRequestParams>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // message oneof groups
    pub first_message: ::std::option::Option<InsertObjectRequest_oneof_first_message>,
    pub data: ::std::option::Option<InsertObjectRequest_oneof_data>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InsertObjectRequest {
    fn default() -> &'a InsertObjectRequest {
        <InsertObjectRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum InsertObjectRequest_oneof_first_message {
    upload_id(::std::string::String),
    insert_object_spec(InsertObjectSpec),
}

#[derive(Clone,PartialEq,Debug)]
pub enum InsertObjectRequest_oneof_data {
    checksummed_data(super::storage_resources::ChecksummedData),
    reference(GetObjectMediaRequest),
}

impl InsertObjectRequest {
    pub fn new() -> InsertObjectRequest {
        ::std::default::Default::default()
    }

    // string upload_id = 1;


    pub fn get_upload_id(&self) -> &str {
        match self.first_message {
            ::std::option::Option::Some(InsertObjectRequest_oneof_first_message::upload_id(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_upload_id(&mut self) {
        self.first_message = ::std::option::Option::None;
    }

    pub fn has_upload_id(&self) -> bool {
        match self.first_message {
            ::std::option::Option::Some(InsertObjectRequest_oneof_first_message::upload_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_upload_id(&mut self, v: ::std::string::String) {
        self.first_message = ::std::option::Option::Some(InsertObjectRequest_oneof_first_message::upload_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_upload_id(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(InsertObjectRequest_oneof_first_message::upload_id(_)) = self.first_message {
        } else {
            self.first_message = ::std::option::Option::Some(InsertObjectRequest_oneof_first_message::upload_id(::std::string::String::new()));
        }
        match self.first_message {
            ::std::option::Option::Some(InsertObjectRequest_oneof_first_message::upload_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_upload_id(&mut self) -> ::std::string::String {
        if self.has_upload_id() {
            match self.first_message.take() {
                ::std::option::Option::Some(InsertObjectRequest_oneof_first_message::upload_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .google.storage.v1.InsertObjectSpec insert_object_spec = 2;


    pub fn get_insert_object_spec(&self) -> &InsertObjectSpec {
        match self.first_message {
            ::std::option::Option::Some(InsertObjectRequest_oneof_first_message::insert_object_spec(ref v)) => v,
            _ => <InsertObjectSpec as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_insert_object_spec(&mut self) {
        self.first_message = ::std::option::Option::None;
    }

    pub fn has_insert_object_spec(&self) -> bool {
        match self.first_message {
            ::std::option::Option::Some(InsertObjectRequest_oneof_first_message::insert_object_spec(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_insert_object_spec(&mut self, v: InsertObjectSpec) {
        self.first_message = ::std::option::Option::Some(InsertObjectRequest_oneof_first_message::insert_object_spec(v))
    }

    // Mutable pointer to the field.
    pub fn mut_insert_object_spec(&mut self) -> &mut InsertObjectSpec {
        if let ::std::option::Option::Some(InsertObjectRequest_oneof_first_message::insert_object_spec(_)) = self.first_message {
        } else {
            self.first_message = ::std::option::Option::Some(InsertObjectRequest_oneof_first_message::insert_object_spec(InsertObjectSpec::new()));
        }
        match self.first_message {
            ::std::option::Option::Some(InsertObjectRequest_oneof_first_message::insert_object_spec(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_insert_object_spec(&mut self) -> InsertObjectSpec {
        if self.has_insert_object_spec() {
            match self.first_message.take() {
                ::std::option::Option::Some(InsertObjectRequest_oneof_first_message::insert_object_spec(v)) => v,
                _ => panic!(),
            }
        } else {
            InsertObjectSpec::new()
        }
    }

    // int64 write_offset = 3;


    pub fn get_write_offset(&self) -> i64 {
        self.write_offset
    }
    pub fn clear_write_offset(&mut self) {
        self.write_offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_write_offset(&mut self, v: i64) {
        self.write_offset = v;
    }

    // .google.storage.v1.ChecksummedData checksummed_data = 4;


    pub fn get_checksummed_data(&self) -> &super::storage_resources::ChecksummedData {
        match self.data {
            ::std::option::Option::Some(InsertObjectRequest_oneof_data::checksummed_data(ref v)) => v,
            _ => <super::storage_resources::ChecksummedData as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_checksummed_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_checksummed_data(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(InsertObjectRequest_oneof_data::checksummed_data(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_checksummed_data(&mut self, v: super::storage_resources::ChecksummedData) {
        self.data = ::std::option::Option::Some(InsertObjectRequest_oneof_data::checksummed_data(v))
    }

    // Mutable pointer to the field.
    pub fn mut_checksummed_data(&mut self) -> &mut super::storage_resources::ChecksummedData {
        if let ::std::option::Option::Some(InsertObjectRequest_oneof_data::checksummed_data(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(InsertObjectRequest_oneof_data::checksummed_data(super::storage_resources::ChecksummedData::new()));
        }
        match self.data {
            ::std::option::Option::Some(InsertObjectRequest_oneof_data::checksummed_data(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_checksummed_data(&mut self) -> super::storage_resources::ChecksummedData {
        if self.has_checksummed_data() {
            match self.data.take() {
                ::std::option::Option::Some(InsertObjectRequest_oneof_data::checksummed_data(v)) => v,
                _ => panic!(),
            }
        } else {
            super::storage_resources::ChecksummedData::new()
        }
    }

    // .google.storage.v1.GetObjectMediaRequest reference = 5;


    pub fn get_reference(&self) -> &GetObjectMediaRequest {
        match self.data {
            ::std::option::Option::Some(InsertObjectRequest_oneof_data::reference(ref v)) => v,
            _ => <GetObjectMediaRequest as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_reference(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_reference(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(InsertObjectRequest_oneof_data::reference(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_reference(&mut self, v: GetObjectMediaRequest) {
        self.data = ::std::option::Option::Some(InsertObjectRequest_oneof_data::reference(v))
    }

    // Mutable pointer to the field.
    pub fn mut_reference(&mut self) -> &mut GetObjectMediaRequest {
        if let ::std::option::Option::Some(InsertObjectRequest_oneof_data::reference(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(InsertObjectRequest_oneof_data::reference(GetObjectMediaRequest::new()));
        }
        match self.data {
            ::std::option::Option::Some(InsertObjectRequest_oneof_data::reference(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_reference(&mut self) -> GetObjectMediaRequest {
        if self.has_reference() {
            match self.data.take() {
                ::std::option::Option::Some(InsertObjectRequest_oneof_data::reference(v)) => v,
                _ => panic!(),
            }
        } else {
            GetObjectMediaRequest::new()
        }
    }

    // .google.storage.v1.ObjectChecksums object_checksums = 6;


    pub fn get_object_checksums(&self) -> &super::storage_resources::ObjectChecksums {
        self.object_checksums.as_ref().unwrap_or_else(|| <super::storage_resources::ObjectChecksums as ::protobuf::Message>::default_instance())
    }
    pub fn clear_object_checksums(&mut self) {
        self.object_checksums.clear();
    }

    pub fn has_object_checksums(&self) -> bool {
        self.object_checksums.is_some()
    }

    // Param is passed by value, moved
    pub fn set_object_checksums(&mut self, v: super::storage_resources::ObjectChecksums) {
        self.object_checksums = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_checksums(&mut self) -> &mut super::storage_resources::ObjectChecksums {
        if self.object_checksums.is_none() {
            self.object_checksums.set_default();
        }
        self.object_checksums.as_mut().unwrap()
    }

    // Take field
    pub fn take_object_checksums(&mut self) -> super::storage_resources::ObjectChecksums {
        self.object_checksums.take().unwrap_or_else(|| super::storage_resources::ObjectChecksums::new())
    }

    // bool finish_write = 7;


    pub fn get_finish_write(&self) -> bool {
        self.finish_write
    }
    pub fn clear_finish_write(&mut self) {
        self.finish_write = false;
    }

    // Param is passed by value, moved
    pub fn set_finish_write(&mut self, v: bool) {
        self.finish_write = v;
    }

    // .google.storage.v1.CommonObjectRequestParams common_object_request_params = 8;


    pub fn get_common_object_request_params(&self) -> &CommonObjectRequestParams {
        self.common_object_request_params.as_ref().unwrap_or_else(|| <CommonObjectRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_object_request_params(&mut self) {
        self.common_object_request_params.clear();
    }

    pub fn has_common_object_request_params(&self) -> bool {
        self.common_object_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_object_request_params(&mut self, v: CommonObjectRequestParams) {
        self.common_object_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_object_request_params(&mut self) -> &mut CommonObjectRequestParams {
        if self.common_object_request_params.is_none() {
            self.common_object_request_params.set_default();
        }
        self.common_object_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_object_request_params(&mut self) -> CommonObjectRequestParams {
        self.common_object_request_params.take().unwrap_or_else(|| CommonObjectRequestParams::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 9;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for InsertObjectRequest {
    fn is_initialized(&self) -> bool {
        if let Some(InsertObjectRequest_oneof_first_message::insert_object_spec(ref v)) = self.first_message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(InsertObjectRequest_oneof_data::checksummed_data(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(InsertObjectRequest_oneof_data::reference(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.object_checksums {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_object_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.first_message = ::std::option::Option::Some(InsertObjectRequest_oneof_first_message::upload_id(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.first_message = ::std::option::Option::Some(InsertObjectRequest_oneof_first_message::insert_object_spec(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.write_offset = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(InsertObjectRequest_oneof_data::checksummed_data(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(InsertObjectRequest_oneof_data::reference(is.read_message()?));
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.object_checksums)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.finish_write = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_object_request_params)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.write_offset != 0 {
            my_size += ::protobuf::rt::value_size(3, self.write_offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.object_checksums.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.finish_write != false {
            my_size += 2;
        }
        if let Some(ref v) = self.common_object_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.first_message {
            match v {
                &InsertObjectRequest_oneof_first_message::upload_id(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &InsertObjectRequest_oneof_first_message::insert_object_spec(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &InsertObjectRequest_oneof_data::checksummed_data(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &InsertObjectRequest_oneof_data::reference(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.write_offset != 0 {
            os.write_int64(3, self.write_offset)?;
        }
        if let Some(ref v) = self.object_checksums.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.finish_write != false {
            os.write_bool(7, self.finish_write)?;
        }
        if let Some(ref v) = self.common_object_request_params.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.first_message {
            match v {
                &InsertObjectRequest_oneof_first_message::upload_id(ref v) => {
                    os.write_string(1, v)?;
                },
                &InsertObjectRequest_oneof_first_message::insert_object_spec(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &InsertObjectRequest_oneof_data::checksummed_data(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &InsertObjectRequest_oneof_data::reference(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InsertObjectRequest {
        InsertObjectRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "upload_id",
                InsertObjectRequest::has_upload_id,
                InsertObjectRequest::get_upload_id,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, InsertObjectSpec>(
                "insert_object_spec",
                InsertObjectRequest::has_insert_object_spec,
                InsertObjectRequest::get_insert_object_spec,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "write_offset",
                |m: &InsertObjectRequest| { &m.write_offset },
                |m: &mut InsertObjectRequest| { &mut m.write_offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::storage_resources::ChecksummedData>(
                "checksummed_data",
                InsertObjectRequest::has_checksummed_data,
                InsertObjectRequest::get_checksummed_data,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GetObjectMediaRequest>(
                "reference",
                InsertObjectRequest::has_reference,
                InsertObjectRequest::get_reference,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::ObjectChecksums>>(
                "object_checksums",
                |m: &InsertObjectRequest| { &m.object_checksums },
                |m: &mut InsertObjectRequest| { &mut m.object_checksums },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "finish_write",
                |m: &InsertObjectRequest| { &m.finish_write },
                |m: &mut InsertObjectRequest| { &mut m.finish_write },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonObjectRequestParams>>(
                "common_object_request_params",
                |m: &InsertObjectRequest| { &m.common_object_request_params },
                |m: &mut InsertObjectRequest| { &mut m.common_object_request_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &InsertObjectRequest| { &m.common_request_params },
                |m: &mut InsertObjectRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InsertObjectRequest>(
                "InsertObjectRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InsertObjectRequest {
        static instance: ::protobuf::rt::LazyV2<InsertObjectRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InsertObjectRequest::new)
    }
}

impl ::protobuf::Clear for InsertObjectRequest {
    fn clear(&mut self) {
        self.first_message = ::std::option::Option::None;
        self.first_message = ::std::option::Option::None;
        self.write_offset = 0;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.object_checksums.clear();
        self.finish_write = false;
        self.common_object_request_params.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InsertObjectRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InsertObjectRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListObjectsRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub delimiter: ::std::string::String,
    pub include_trailing_delimiter: bool,
    pub max_results: i32,
    pub page_token: ::std::string::String,
    pub prefix: ::std::string::String,
    pub projection: super::storage_resources::CommonEnums_Projection,
    pub versions: bool,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListObjectsRequest {
    fn default() -> &'a ListObjectsRequest {
        <ListObjectsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListObjectsRequest {
    pub fn new() -> ListObjectsRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string delimiter = 2;


    pub fn get_delimiter(&self) -> &str {
        &self.delimiter
    }
    pub fn clear_delimiter(&mut self) {
        self.delimiter.clear();
    }

    // Param is passed by value, moved
    pub fn set_delimiter(&mut self, v: ::std::string::String) {
        self.delimiter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delimiter(&mut self) -> &mut ::std::string::String {
        &mut self.delimiter
    }

    // Take field
    pub fn take_delimiter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.delimiter, ::std::string::String::new())
    }

    // bool include_trailing_delimiter = 3;


    pub fn get_include_trailing_delimiter(&self) -> bool {
        self.include_trailing_delimiter
    }
    pub fn clear_include_trailing_delimiter(&mut self) {
        self.include_trailing_delimiter = false;
    }

    // Param is passed by value, moved
    pub fn set_include_trailing_delimiter(&mut self, v: bool) {
        self.include_trailing_delimiter = v;
    }

    // int32 max_results = 4;


    pub fn get_max_results(&self) -> i32 {
        self.max_results
    }
    pub fn clear_max_results(&mut self) {
        self.max_results = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_results(&mut self, v: i32) {
        self.max_results = v;
    }

    // string page_token = 5;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    // string prefix = 6;


    pub fn get_prefix(&self) -> &str {
        &self.prefix
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::string::String) {
        self.prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.prefix
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prefix, ::std::string::String::new())
    }

    // .google.storage.v1.CommonEnums.Projection projection = 7;


    pub fn get_projection(&self) -> super::storage_resources::CommonEnums_Projection {
        self.projection
    }
    pub fn clear_projection(&mut self) {
        self.projection = super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_projection(&mut self, v: super::storage_resources::CommonEnums_Projection) {
        self.projection = v;
    }

    // bool versions = 9;


    pub fn get_versions(&self) -> bool {
        self.versions
    }
    pub fn clear_versions(&mut self) {
        self.versions = false;
    }

    // Param is passed by value, moved
    pub fn set_versions(&mut self, v: bool) {
        self.versions = v;
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 10;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for ListObjectsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.delimiter)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_trailing_delimiter = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_results = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.prefix)?;
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.projection, 7, &mut self.unknown_fields)?
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.versions = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.delimiter.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.delimiter);
        }
        if self.include_trailing_delimiter != false {
            my_size += 2;
        }
        if self.max_results != 0 {
            my_size += ::protobuf::rt::value_size(4, self.max_results, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.page_token);
        }
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.prefix);
        }
        if self.projection != super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(7, self.projection);
        }
        if self.versions != false {
            my_size += 2;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.delimiter.is_empty() {
            os.write_string(2, &self.delimiter)?;
        }
        if self.include_trailing_delimiter != false {
            os.write_bool(3, self.include_trailing_delimiter)?;
        }
        if self.max_results != 0 {
            os.write_int32(4, self.max_results)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(5, &self.page_token)?;
        }
        if !self.prefix.is_empty() {
            os.write_string(6, &self.prefix)?;
        }
        if self.projection != super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED {
            os.write_enum(7, ::protobuf::ProtobufEnum::value(&self.projection))?;
        }
        if self.versions != false {
            os.write_bool(9, self.versions)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListObjectsRequest {
        ListObjectsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &ListObjectsRequest| { &m.bucket },
                |m: &mut ListObjectsRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "delimiter",
                |m: &ListObjectsRequest| { &m.delimiter },
                |m: &mut ListObjectsRequest| { &mut m.delimiter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "include_trailing_delimiter",
                |m: &ListObjectsRequest| { &m.include_trailing_delimiter },
                |m: &mut ListObjectsRequest| { &mut m.include_trailing_delimiter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_results",
                |m: &ListObjectsRequest| { &m.max_results },
                |m: &mut ListObjectsRequest| { &mut m.max_results },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListObjectsRequest| { &m.page_token },
                |m: &mut ListObjectsRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "prefix",
                |m: &ListObjectsRequest| { &m.prefix },
                |m: &mut ListObjectsRequest| { &mut m.prefix },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::storage_resources::CommonEnums_Projection>>(
                "projection",
                |m: &ListObjectsRequest| { &m.projection },
                |m: &mut ListObjectsRequest| { &mut m.projection },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "versions",
                |m: &ListObjectsRequest| { &m.versions },
                |m: &mut ListObjectsRequest| { &mut m.versions },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &ListObjectsRequest| { &m.common_request_params },
                |m: &mut ListObjectsRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListObjectsRequest>(
                "ListObjectsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListObjectsRequest {
        static instance: ::protobuf::rt::LazyV2<ListObjectsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListObjectsRequest::new)
    }
}

impl ::protobuf::Clear for ListObjectsRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.delimiter.clear();
        self.include_trailing_delimiter = false;
        self.max_results = 0;
        self.page_token.clear();
        self.prefix.clear();
        self.projection = super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED;
        self.versions = false;
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListObjectsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListObjectsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryWriteStatusRequest {
    // message fields
    pub upload_id: ::std::string::String,
    pub common_object_request_params: ::protobuf::SingularPtrField<CommonObjectRequestParams>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryWriteStatusRequest {
    fn default() -> &'a QueryWriteStatusRequest {
        <QueryWriteStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryWriteStatusRequest {
    pub fn new() -> QueryWriteStatusRequest {
        ::std::default::Default::default()
    }

    // string upload_id = 1;


    pub fn get_upload_id(&self) -> &str {
        &self.upload_id
    }
    pub fn clear_upload_id(&mut self) {
        self.upload_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_upload_id(&mut self, v: ::std::string::String) {
        self.upload_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_upload_id(&mut self) -> &mut ::std::string::String {
        &mut self.upload_id
    }

    // Take field
    pub fn take_upload_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.upload_id, ::std::string::String::new())
    }

    // .google.storage.v1.CommonObjectRequestParams common_object_request_params = 2;


    pub fn get_common_object_request_params(&self) -> &CommonObjectRequestParams {
        self.common_object_request_params.as_ref().unwrap_or_else(|| <CommonObjectRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_object_request_params(&mut self) {
        self.common_object_request_params.clear();
    }

    pub fn has_common_object_request_params(&self) -> bool {
        self.common_object_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_object_request_params(&mut self, v: CommonObjectRequestParams) {
        self.common_object_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_object_request_params(&mut self) -> &mut CommonObjectRequestParams {
        if self.common_object_request_params.is_none() {
            self.common_object_request_params.set_default();
        }
        self.common_object_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_object_request_params(&mut self) -> CommonObjectRequestParams {
        self.common_object_request_params.take().unwrap_or_else(|| CommonObjectRequestParams::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 3;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for QueryWriteStatusRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.common_object_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.upload_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_object_request_params)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.upload_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.upload_id);
        }
        if let Some(ref v) = self.common_object_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.upload_id.is_empty() {
            os.write_string(1, &self.upload_id)?;
        }
        if let Some(ref v) = self.common_object_request_params.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryWriteStatusRequest {
        QueryWriteStatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "upload_id",
                |m: &QueryWriteStatusRequest| { &m.upload_id },
                |m: &mut QueryWriteStatusRequest| { &mut m.upload_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonObjectRequestParams>>(
                "common_object_request_params",
                |m: &QueryWriteStatusRequest| { &m.common_object_request_params },
                |m: &mut QueryWriteStatusRequest| { &mut m.common_object_request_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &QueryWriteStatusRequest| { &m.common_request_params },
                |m: &mut QueryWriteStatusRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryWriteStatusRequest>(
                "QueryWriteStatusRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryWriteStatusRequest {
        static instance: ::protobuf::rt::LazyV2<QueryWriteStatusRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryWriteStatusRequest::new)
    }
}

impl ::protobuf::Clear for QueryWriteStatusRequest {
    fn clear(&mut self) {
        self.upload_id.clear();
        self.common_object_request_params.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryWriteStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryWriteStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryWriteStatusResponse {
    // message fields
    pub committed_size: i64,
    pub complete: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryWriteStatusResponse {
    fn default() -> &'a QueryWriteStatusResponse {
        <QueryWriteStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryWriteStatusResponse {
    pub fn new() -> QueryWriteStatusResponse {
        ::std::default::Default::default()
    }

    // int64 committed_size = 1;


    pub fn get_committed_size(&self) -> i64 {
        self.committed_size
    }
    pub fn clear_committed_size(&mut self) {
        self.committed_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_committed_size(&mut self, v: i64) {
        self.committed_size = v;
    }

    // bool complete = 2;


    pub fn get_complete(&self) -> bool {
        self.complete
    }
    pub fn clear_complete(&mut self) {
        self.complete = false;
    }

    // Param is passed by value, moved
    pub fn set_complete(&mut self, v: bool) {
        self.complete = v;
    }
}

impl ::protobuf::Message for QueryWriteStatusResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.committed_size = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.complete = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.committed_size != 0 {
            my_size += ::protobuf::rt::value_size(1, self.committed_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.complete != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.committed_size != 0 {
            os.write_int64(1, self.committed_size)?;
        }
        if self.complete != false {
            os.write_bool(2, self.complete)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryWriteStatusResponse {
        QueryWriteStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "committed_size",
                |m: &QueryWriteStatusResponse| { &m.committed_size },
                |m: &mut QueryWriteStatusResponse| { &mut m.committed_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "complete",
                |m: &QueryWriteStatusResponse| { &m.complete },
                |m: &mut QueryWriteStatusResponse| { &mut m.complete },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryWriteStatusResponse>(
                "QueryWriteStatusResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryWriteStatusResponse {
        static instance: ::protobuf::rt::LazyV2<QueryWriteStatusResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryWriteStatusResponse::new)
    }
}

impl ::protobuf::Clear for QueryWriteStatusResponse {
    fn clear(&mut self) {
        self.committed_size = 0;
        self.complete = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryWriteStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryWriteStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RewriteObjectRequest {
    // message fields
    pub destination_bucket: ::std::string::String,
    pub destination_object: ::std::string::String,
    pub destination_kms_key_name: ::std::string::String,
    pub destination_predefined_acl: super::storage_resources::CommonEnums_PredefinedObjectAcl,
    pub if_generation_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_generation_not_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_metageneration_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_metageneration_not_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_source_generation_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_source_generation_not_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_source_metageneration_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_source_metageneration_not_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub max_bytes_rewritten_per_call: i64,
    pub projection: super::storage_resources::CommonEnums_Projection,
    pub rewrite_token: ::std::string::String,
    pub source_bucket: ::std::string::String,
    pub source_object: ::std::string::String,
    pub source_generation: i64,
    pub object: ::protobuf::SingularPtrField<super::storage_resources::Object>,
    pub copy_source_encryption_algorithm: ::std::string::String,
    pub copy_source_encryption_key: ::std::string::String,
    pub copy_source_encryption_key_sha256: ::std::string::String,
    pub common_object_request_params: ::protobuf::SingularPtrField<CommonObjectRequestParams>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RewriteObjectRequest {
    fn default() -> &'a RewriteObjectRequest {
        <RewriteObjectRequest as ::protobuf::Message>::default_instance()
    }
}

impl RewriteObjectRequest {
    pub fn new() -> RewriteObjectRequest {
        ::std::default::Default::default()
    }

    // string destination_bucket = 1;


    pub fn get_destination_bucket(&self) -> &str {
        &self.destination_bucket
    }
    pub fn clear_destination_bucket(&mut self) {
        self.destination_bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_destination_bucket(&mut self, v: ::std::string::String) {
        self.destination_bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.destination_bucket
    }

    // Take field
    pub fn take_destination_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.destination_bucket, ::std::string::String::new())
    }

    // string destination_object = 2;


    pub fn get_destination_object(&self) -> &str {
        &self.destination_object
    }
    pub fn clear_destination_object(&mut self) {
        self.destination_object.clear();
    }

    // Param is passed by value, moved
    pub fn set_destination_object(&mut self, v: ::std::string::String) {
        self.destination_object = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination_object(&mut self) -> &mut ::std::string::String {
        &mut self.destination_object
    }

    // Take field
    pub fn take_destination_object(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.destination_object, ::std::string::String::new())
    }

    // string destination_kms_key_name = 3;


    pub fn get_destination_kms_key_name(&self) -> &str {
        &self.destination_kms_key_name
    }
    pub fn clear_destination_kms_key_name(&mut self) {
        self.destination_kms_key_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_destination_kms_key_name(&mut self, v: ::std::string::String) {
        self.destination_kms_key_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination_kms_key_name(&mut self) -> &mut ::std::string::String {
        &mut self.destination_kms_key_name
    }

    // Take field
    pub fn take_destination_kms_key_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.destination_kms_key_name, ::std::string::String::new())
    }

    // .google.storage.v1.CommonEnums.PredefinedObjectAcl destination_predefined_acl = 4;


    pub fn get_destination_predefined_acl(&self) -> super::storage_resources::CommonEnums_PredefinedObjectAcl {
        self.destination_predefined_acl
    }
    pub fn clear_destination_predefined_acl(&mut self) {
        self.destination_predefined_acl = super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_destination_predefined_acl(&mut self, v: super::storage_resources::CommonEnums_PredefinedObjectAcl) {
        self.destination_predefined_acl = v;
    }

    // .google.protobuf.Int64Value if_generation_match = 5;


    pub fn get_if_generation_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_generation_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_generation_match(&mut self) {
        self.if_generation_match.clear();
    }

    pub fn has_if_generation_match(&self) -> bool {
        self.if_generation_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_generation_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_generation_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_generation_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_generation_match.is_none() {
            self.if_generation_match.set_default();
        }
        self.if_generation_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_generation_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_generation_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_generation_not_match = 6;


    pub fn get_if_generation_not_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_generation_not_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_generation_not_match(&mut self) {
        self.if_generation_not_match.clear();
    }

    pub fn has_if_generation_not_match(&self) -> bool {
        self.if_generation_not_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_generation_not_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_generation_not_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_generation_not_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_generation_not_match.is_none() {
            self.if_generation_not_match.set_default();
        }
        self.if_generation_not_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_generation_not_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_generation_not_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_metageneration_match = 7;


    pub fn get_if_metageneration_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_metageneration_match(&mut self) {
        self.if_metageneration_match.clear();
    }

    pub fn has_if_metageneration_match(&self) -> bool {
        self.if_metageneration_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_metageneration_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_metageneration_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_metageneration_match.is_none() {
            self.if_metageneration_match.set_default();
        }
        self.if_metageneration_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_metageneration_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_metageneration_not_match = 8;


    pub fn get_if_metageneration_not_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_metageneration_not_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_metageneration_not_match(&mut self) {
        self.if_metageneration_not_match.clear();
    }

    pub fn has_if_metageneration_not_match(&self) -> bool {
        self.if_metageneration_not_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_not_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_metageneration_not_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_metageneration_not_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_metageneration_not_match.is_none() {
            self.if_metageneration_not_match.set_default();
        }
        self.if_metageneration_not_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_metageneration_not_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_metageneration_not_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_source_generation_match = 9;


    pub fn get_if_source_generation_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_source_generation_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_source_generation_match(&mut self) {
        self.if_source_generation_match.clear();
    }

    pub fn has_if_source_generation_match(&self) -> bool {
        self.if_source_generation_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_source_generation_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_source_generation_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_source_generation_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_source_generation_match.is_none() {
            self.if_source_generation_match.set_default();
        }
        self.if_source_generation_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_source_generation_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_source_generation_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_source_generation_not_match = 10;


    pub fn get_if_source_generation_not_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_source_generation_not_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_source_generation_not_match(&mut self) {
        self.if_source_generation_not_match.clear();
    }

    pub fn has_if_source_generation_not_match(&self) -> bool {
        self.if_source_generation_not_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_source_generation_not_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_source_generation_not_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_source_generation_not_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_source_generation_not_match.is_none() {
            self.if_source_generation_not_match.set_default();
        }
        self.if_source_generation_not_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_source_generation_not_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_source_generation_not_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_source_metageneration_match = 11;


    pub fn get_if_source_metageneration_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_source_metageneration_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_source_metageneration_match(&mut self) {
        self.if_source_metageneration_match.clear();
    }

    pub fn has_if_source_metageneration_match(&self) -> bool {
        self.if_source_metageneration_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_source_metageneration_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_source_metageneration_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_source_metageneration_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_source_metageneration_match.is_none() {
            self.if_source_metageneration_match.set_default();
        }
        self.if_source_metageneration_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_source_metageneration_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_source_metageneration_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_source_metageneration_not_match = 12;


    pub fn get_if_source_metageneration_not_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_source_metageneration_not_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_source_metageneration_not_match(&mut self) {
        self.if_source_metageneration_not_match.clear();
    }

    pub fn has_if_source_metageneration_not_match(&self) -> bool {
        self.if_source_metageneration_not_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_source_metageneration_not_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_source_metageneration_not_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_source_metageneration_not_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_source_metageneration_not_match.is_none() {
            self.if_source_metageneration_not_match.set_default();
        }
        self.if_source_metageneration_not_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_source_metageneration_not_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_source_metageneration_not_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // int64 max_bytes_rewritten_per_call = 13;


    pub fn get_max_bytes_rewritten_per_call(&self) -> i64 {
        self.max_bytes_rewritten_per_call
    }
    pub fn clear_max_bytes_rewritten_per_call(&mut self) {
        self.max_bytes_rewritten_per_call = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_bytes_rewritten_per_call(&mut self, v: i64) {
        self.max_bytes_rewritten_per_call = v;
    }

    // .google.storage.v1.CommonEnums.Projection projection = 14;


    pub fn get_projection(&self) -> super::storage_resources::CommonEnums_Projection {
        self.projection
    }
    pub fn clear_projection(&mut self) {
        self.projection = super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_projection(&mut self, v: super::storage_resources::CommonEnums_Projection) {
        self.projection = v;
    }

    // string rewrite_token = 15;


    pub fn get_rewrite_token(&self) -> &str {
        &self.rewrite_token
    }
    pub fn clear_rewrite_token(&mut self) {
        self.rewrite_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_rewrite_token(&mut self, v: ::std::string::String) {
        self.rewrite_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rewrite_token(&mut self) -> &mut ::std::string::String {
        &mut self.rewrite_token
    }

    // Take field
    pub fn take_rewrite_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rewrite_token, ::std::string::String::new())
    }

    // string source_bucket = 16;


    pub fn get_source_bucket(&self) -> &str {
        &self.source_bucket
    }
    pub fn clear_source_bucket(&mut self) {
        self.source_bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_bucket(&mut self, v: ::std::string::String) {
        self.source_bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.source_bucket
    }

    // Take field
    pub fn take_source_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_bucket, ::std::string::String::new())
    }

    // string source_object = 17;


    pub fn get_source_object(&self) -> &str {
        &self.source_object
    }
    pub fn clear_source_object(&mut self) {
        self.source_object.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_object(&mut self, v: ::std::string::String) {
        self.source_object = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_object(&mut self) -> &mut ::std::string::String {
        &mut self.source_object
    }

    // Take field
    pub fn take_source_object(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_object, ::std::string::String::new())
    }

    // int64 source_generation = 18;


    pub fn get_source_generation(&self) -> i64 {
        self.source_generation
    }
    pub fn clear_source_generation(&mut self) {
        self.source_generation = 0;
    }

    // Param is passed by value, moved
    pub fn set_source_generation(&mut self, v: i64) {
        self.source_generation = v;
    }

    // .google.storage.v1.Object object = 20;


    pub fn get_object(&self) -> &super::storage_resources::Object {
        self.object.as_ref().unwrap_or_else(|| <super::storage_resources::Object as ::protobuf::Message>::default_instance())
    }
    pub fn clear_object(&mut self) {
        self.object.clear();
    }

    pub fn has_object(&self) -> bool {
        self.object.is_some()
    }

    // Param is passed by value, moved
    pub fn set_object(&mut self, v: super::storage_resources::Object) {
        self.object = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object(&mut self) -> &mut super::storage_resources::Object {
        if self.object.is_none() {
            self.object.set_default();
        }
        self.object.as_mut().unwrap()
    }

    // Take field
    pub fn take_object(&mut self) -> super::storage_resources::Object {
        self.object.take().unwrap_or_else(|| super::storage_resources::Object::new())
    }

    // string copy_source_encryption_algorithm = 21;


    pub fn get_copy_source_encryption_algorithm(&self) -> &str {
        &self.copy_source_encryption_algorithm
    }
    pub fn clear_copy_source_encryption_algorithm(&mut self) {
        self.copy_source_encryption_algorithm.clear();
    }

    // Param is passed by value, moved
    pub fn set_copy_source_encryption_algorithm(&mut self, v: ::std::string::String) {
        self.copy_source_encryption_algorithm = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_copy_source_encryption_algorithm(&mut self) -> &mut ::std::string::String {
        &mut self.copy_source_encryption_algorithm
    }

    // Take field
    pub fn take_copy_source_encryption_algorithm(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.copy_source_encryption_algorithm, ::std::string::String::new())
    }

    // string copy_source_encryption_key = 22;


    pub fn get_copy_source_encryption_key(&self) -> &str {
        &self.copy_source_encryption_key
    }
    pub fn clear_copy_source_encryption_key(&mut self) {
        self.copy_source_encryption_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_copy_source_encryption_key(&mut self, v: ::std::string::String) {
        self.copy_source_encryption_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_copy_source_encryption_key(&mut self) -> &mut ::std::string::String {
        &mut self.copy_source_encryption_key
    }

    // Take field
    pub fn take_copy_source_encryption_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.copy_source_encryption_key, ::std::string::String::new())
    }

    // string copy_source_encryption_key_sha256 = 23;


    pub fn get_copy_source_encryption_key_sha256(&self) -> &str {
        &self.copy_source_encryption_key_sha256
    }
    pub fn clear_copy_source_encryption_key_sha256(&mut self) {
        self.copy_source_encryption_key_sha256.clear();
    }

    // Param is passed by value, moved
    pub fn set_copy_source_encryption_key_sha256(&mut self, v: ::std::string::String) {
        self.copy_source_encryption_key_sha256 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_copy_source_encryption_key_sha256(&mut self) -> &mut ::std::string::String {
        &mut self.copy_source_encryption_key_sha256
    }

    // Take field
    pub fn take_copy_source_encryption_key_sha256(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.copy_source_encryption_key_sha256, ::std::string::String::new())
    }

    // .google.storage.v1.CommonObjectRequestParams common_object_request_params = 24;


    pub fn get_common_object_request_params(&self) -> &CommonObjectRequestParams {
        self.common_object_request_params.as_ref().unwrap_or_else(|| <CommonObjectRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_object_request_params(&mut self) {
        self.common_object_request_params.clear();
    }

    pub fn has_common_object_request_params(&self) -> bool {
        self.common_object_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_object_request_params(&mut self, v: CommonObjectRequestParams) {
        self.common_object_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_object_request_params(&mut self) -> &mut CommonObjectRequestParams {
        if self.common_object_request_params.is_none() {
            self.common_object_request_params.set_default();
        }
        self.common_object_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_object_request_params(&mut self) -> CommonObjectRequestParams {
        self.common_object_request_params.take().unwrap_or_else(|| CommonObjectRequestParams::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 25;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for RewriteObjectRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.if_generation_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_generation_not_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_metageneration_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_metageneration_not_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_source_generation_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_source_generation_not_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_source_metageneration_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_source_metageneration_not_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.object {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_object_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.destination_bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.destination_object)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.destination_kms_key_name)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.destination_predefined_acl, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_generation_match)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_generation_not_match)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_metageneration_match)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_metageneration_not_match)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_source_generation_match)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_source_generation_not_match)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_source_metageneration_match)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_source_metageneration_not_match)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_bytes_rewritten_per_call = tmp;
                },
                14 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.projection, 14, &mut self.unknown_fields)?
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rewrite_token)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source_bucket)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source_object)?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.source_generation = tmp;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.object)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.copy_source_encryption_algorithm)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.copy_source_encryption_key)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.copy_source_encryption_key_sha256)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_object_request_params)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.destination_bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.destination_bucket);
        }
        if !self.destination_object.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.destination_object);
        }
        if !self.destination_kms_key_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.destination_kms_key_name);
        }
        if self.destination_predefined_acl != super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.destination_predefined_acl);
        }
        if let Some(ref v) = self.if_generation_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_generation_not_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_metageneration_not_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_source_generation_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_source_generation_not_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_source_metageneration_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_source_metageneration_not_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.max_bytes_rewritten_per_call != 0 {
            my_size += ::protobuf::rt::value_size(13, self.max_bytes_rewritten_per_call, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.projection != super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(14, self.projection);
        }
        if !self.rewrite_token.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.rewrite_token);
        }
        if !self.source_bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.source_bucket);
        }
        if !self.source_object.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.source_object);
        }
        if self.source_generation != 0 {
            my_size += ::protobuf::rt::value_size(18, self.source_generation, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.object.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.copy_source_encryption_algorithm.is_empty() {
            my_size += ::protobuf::rt::string_size(21, &self.copy_source_encryption_algorithm);
        }
        if !self.copy_source_encryption_key.is_empty() {
            my_size += ::protobuf::rt::string_size(22, &self.copy_source_encryption_key);
        }
        if !self.copy_source_encryption_key_sha256.is_empty() {
            my_size += ::protobuf::rt::string_size(23, &self.copy_source_encryption_key_sha256);
        }
        if let Some(ref v) = self.common_object_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.destination_bucket.is_empty() {
            os.write_string(1, &self.destination_bucket)?;
        }
        if !self.destination_object.is_empty() {
            os.write_string(2, &self.destination_object)?;
        }
        if !self.destination_kms_key_name.is_empty() {
            os.write_string(3, &self.destination_kms_key_name)?;
        }
        if self.destination_predefined_acl != super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.destination_predefined_acl))?;
        }
        if let Some(ref v) = self.if_generation_match.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_generation_not_match.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_metageneration_not_match.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_source_generation_match.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_source_generation_not_match.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_source_metageneration_match.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_source_metageneration_not_match.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.max_bytes_rewritten_per_call != 0 {
            os.write_int64(13, self.max_bytes_rewritten_per_call)?;
        }
        if self.projection != super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED {
            os.write_enum(14, ::protobuf::ProtobufEnum::value(&self.projection))?;
        }
        if !self.rewrite_token.is_empty() {
            os.write_string(15, &self.rewrite_token)?;
        }
        if !self.source_bucket.is_empty() {
            os.write_string(16, &self.source_bucket)?;
        }
        if !self.source_object.is_empty() {
            os.write_string(17, &self.source_object)?;
        }
        if self.source_generation != 0 {
            os.write_int64(18, self.source_generation)?;
        }
        if let Some(ref v) = self.object.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.copy_source_encryption_algorithm.is_empty() {
            os.write_string(21, &self.copy_source_encryption_algorithm)?;
        }
        if !self.copy_source_encryption_key.is_empty() {
            os.write_string(22, &self.copy_source_encryption_key)?;
        }
        if !self.copy_source_encryption_key_sha256.is_empty() {
            os.write_string(23, &self.copy_source_encryption_key_sha256)?;
        }
        if let Some(ref v) = self.common_object_request_params.as_ref() {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RewriteObjectRequest {
        RewriteObjectRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "destination_bucket",
                |m: &RewriteObjectRequest| { &m.destination_bucket },
                |m: &mut RewriteObjectRequest| { &mut m.destination_bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "destination_object",
                |m: &RewriteObjectRequest| { &m.destination_object },
                |m: &mut RewriteObjectRequest| { &mut m.destination_object },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "destination_kms_key_name",
                |m: &RewriteObjectRequest| { &m.destination_kms_key_name },
                |m: &mut RewriteObjectRequest| { &mut m.destination_kms_key_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::storage_resources::CommonEnums_PredefinedObjectAcl>>(
                "destination_predefined_acl",
                |m: &RewriteObjectRequest| { &m.destination_predefined_acl },
                |m: &mut RewriteObjectRequest| { &mut m.destination_predefined_acl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_generation_match",
                |m: &RewriteObjectRequest| { &m.if_generation_match },
                |m: &mut RewriteObjectRequest| { &mut m.if_generation_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_generation_not_match",
                |m: &RewriteObjectRequest| { &m.if_generation_not_match },
                |m: &mut RewriteObjectRequest| { &mut m.if_generation_not_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_metageneration_match",
                |m: &RewriteObjectRequest| { &m.if_metageneration_match },
                |m: &mut RewriteObjectRequest| { &mut m.if_metageneration_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_metageneration_not_match",
                |m: &RewriteObjectRequest| { &m.if_metageneration_not_match },
                |m: &mut RewriteObjectRequest| { &mut m.if_metageneration_not_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_source_generation_match",
                |m: &RewriteObjectRequest| { &m.if_source_generation_match },
                |m: &mut RewriteObjectRequest| { &mut m.if_source_generation_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_source_generation_not_match",
                |m: &RewriteObjectRequest| { &m.if_source_generation_not_match },
                |m: &mut RewriteObjectRequest| { &mut m.if_source_generation_not_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_source_metageneration_match",
                |m: &RewriteObjectRequest| { &m.if_source_metageneration_match },
                |m: &mut RewriteObjectRequest| { &mut m.if_source_metageneration_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_source_metageneration_not_match",
                |m: &RewriteObjectRequest| { &m.if_source_metageneration_not_match },
                |m: &mut RewriteObjectRequest| { &mut m.if_source_metageneration_not_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "max_bytes_rewritten_per_call",
                |m: &RewriteObjectRequest| { &m.max_bytes_rewritten_per_call },
                |m: &mut RewriteObjectRequest| { &mut m.max_bytes_rewritten_per_call },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::storage_resources::CommonEnums_Projection>>(
                "projection",
                |m: &RewriteObjectRequest| { &m.projection },
                |m: &mut RewriteObjectRequest| { &mut m.projection },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rewrite_token",
                |m: &RewriteObjectRequest| { &m.rewrite_token },
                |m: &mut RewriteObjectRequest| { &mut m.rewrite_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "source_bucket",
                |m: &RewriteObjectRequest| { &m.source_bucket },
                |m: &mut RewriteObjectRequest| { &mut m.source_bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "source_object",
                |m: &RewriteObjectRequest| { &m.source_object },
                |m: &mut RewriteObjectRequest| { &mut m.source_object },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "source_generation",
                |m: &RewriteObjectRequest| { &m.source_generation },
                |m: &mut RewriteObjectRequest| { &mut m.source_generation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::Object>>(
                "object",
                |m: &RewriteObjectRequest| { &m.object },
                |m: &mut RewriteObjectRequest| { &mut m.object },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "copy_source_encryption_algorithm",
                |m: &RewriteObjectRequest| { &m.copy_source_encryption_algorithm },
                |m: &mut RewriteObjectRequest| { &mut m.copy_source_encryption_algorithm },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "copy_source_encryption_key",
                |m: &RewriteObjectRequest| { &m.copy_source_encryption_key },
                |m: &mut RewriteObjectRequest| { &mut m.copy_source_encryption_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "copy_source_encryption_key_sha256",
                |m: &RewriteObjectRequest| { &m.copy_source_encryption_key_sha256 },
                |m: &mut RewriteObjectRequest| { &mut m.copy_source_encryption_key_sha256 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonObjectRequestParams>>(
                "common_object_request_params",
                |m: &RewriteObjectRequest| { &m.common_object_request_params },
                |m: &mut RewriteObjectRequest| { &mut m.common_object_request_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &RewriteObjectRequest| { &m.common_request_params },
                |m: &mut RewriteObjectRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RewriteObjectRequest>(
                "RewriteObjectRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RewriteObjectRequest {
        static instance: ::protobuf::rt::LazyV2<RewriteObjectRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RewriteObjectRequest::new)
    }
}

impl ::protobuf::Clear for RewriteObjectRequest {
    fn clear(&mut self) {
        self.destination_bucket.clear();
        self.destination_object.clear();
        self.destination_kms_key_name.clear();
        self.destination_predefined_acl = super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED;
        self.if_generation_match.clear();
        self.if_generation_not_match.clear();
        self.if_metageneration_match.clear();
        self.if_metageneration_not_match.clear();
        self.if_source_generation_match.clear();
        self.if_source_generation_not_match.clear();
        self.if_source_metageneration_match.clear();
        self.if_source_metageneration_not_match.clear();
        self.max_bytes_rewritten_per_call = 0;
        self.projection = super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED;
        self.rewrite_token.clear();
        self.source_bucket.clear();
        self.source_object.clear();
        self.source_generation = 0;
        self.object.clear();
        self.copy_source_encryption_algorithm.clear();
        self.copy_source_encryption_key.clear();
        self.copy_source_encryption_key_sha256.clear();
        self.common_object_request_params.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RewriteObjectRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RewriteObjectRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RewriteResponse {
    // message fields
    pub total_bytes_rewritten: i64,
    pub object_size: i64,
    pub done: bool,
    pub rewrite_token: ::std::string::String,
    pub resource: ::protobuf::SingularPtrField<super::storage_resources::Object>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RewriteResponse {
    fn default() -> &'a RewriteResponse {
        <RewriteResponse as ::protobuf::Message>::default_instance()
    }
}

impl RewriteResponse {
    pub fn new() -> RewriteResponse {
        ::std::default::Default::default()
    }

    // int64 total_bytes_rewritten = 1;


    pub fn get_total_bytes_rewritten(&self) -> i64 {
        self.total_bytes_rewritten
    }
    pub fn clear_total_bytes_rewritten(&mut self) {
        self.total_bytes_rewritten = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_bytes_rewritten(&mut self, v: i64) {
        self.total_bytes_rewritten = v;
    }

    // int64 object_size = 2;


    pub fn get_object_size(&self) -> i64 {
        self.object_size
    }
    pub fn clear_object_size(&mut self) {
        self.object_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_object_size(&mut self, v: i64) {
        self.object_size = v;
    }

    // bool done = 3;


    pub fn get_done(&self) -> bool {
        self.done
    }
    pub fn clear_done(&mut self) {
        self.done = false;
    }

    // Param is passed by value, moved
    pub fn set_done(&mut self, v: bool) {
        self.done = v;
    }

    // string rewrite_token = 4;


    pub fn get_rewrite_token(&self) -> &str {
        &self.rewrite_token
    }
    pub fn clear_rewrite_token(&mut self) {
        self.rewrite_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_rewrite_token(&mut self, v: ::std::string::String) {
        self.rewrite_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rewrite_token(&mut self) -> &mut ::std::string::String {
        &mut self.rewrite_token
    }

    // Take field
    pub fn take_rewrite_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rewrite_token, ::std::string::String::new())
    }

    // .google.storage.v1.Object resource = 5;


    pub fn get_resource(&self) -> &super::storage_resources::Object {
        self.resource.as_ref().unwrap_or_else(|| <super::storage_resources::Object as ::protobuf::Message>::default_instance())
    }
    pub fn clear_resource(&mut self) {
        self.resource.clear();
    }

    pub fn has_resource(&self) -> bool {
        self.resource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: super::storage_resources::Object) {
        self.resource = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut super::storage_resources::Object {
        if self.resource.is_none() {
            self.resource.set_default();
        }
        self.resource.as_mut().unwrap()
    }

    // Take field
    pub fn take_resource(&mut self) -> super::storage_resources::Object {
        self.resource.take().unwrap_or_else(|| super::storage_resources::Object::new())
    }
}

impl ::protobuf::Message for RewriteResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.resource {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_bytes_rewritten = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.object_size = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.done = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rewrite_token)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resource)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.total_bytes_rewritten != 0 {
            my_size += ::protobuf::rt::value_size(1, self.total_bytes_rewritten, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.object_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.object_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.done != false {
            my_size += 2;
        }
        if !self.rewrite_token.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.rewrite_token);
        }
        if let Some(ref v) = self.resource.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.total_bytes_rewritten != 0 {
            os.write_int64(1, self.total_bytes_rewritten)?;
        }
        if self.object_size != 0 {
            os.write_int64(2, self.object_size)?;
        }
        if self.done != false {
            os.write_bool(3, self.done)?;
        }
        if !self.rewrite_token.is_empty() {
            os.write_string(4, &self.rewrite_token)?;
        }
        if let Some(ref v) = self.resource.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RewriteResponse {
        RewriteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "total_bytes_rewritten",
                |m: &RewriteResponse| { &m.total_bytes_rewritten },
                |m: &mut RewriteResponse| { &mut m.total_bytes_rewritten },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "object_size",
                |m: &RewriteResponse| { &m.object_size },
                |m: &mut RewriteResponse| { &mut m.object_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "done",
                |m: &RewriteResponse| { &m.done },
                |m: &mut RewriteResponse| { &mut m.done },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rewrite_token",
                |m: &RewriteResponse| { &m.rewrite_token },
                |m: &mut RewriteResponse| { &mut m.rewrite_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::Object>>(
                "resource",
                |m: &RewriteResponse| { &m.resource },
                |m: &mut RewriteResponse| { &mut m.resource },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RewriteResponse>(
                "RewriteResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RewriteResponse {
        static instance: ::protobuf::rt::LazyV2<RewriteResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RewriteResponse::new)
    }
}

impl ::protobuf::Clear for RewriteResponse {
    fn clear(&mut self) {
        self.total_bytes_rewritten = 0;
        self.object_size = 0;
        self.done = false;
        self.rewrite_token.clear();
        self.resource.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RewriteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RewriteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartResumableWriteRequest {
    // message fields
    pub insert_object_spec: ::protobuf::SingularPtrField<InsertObjectSpec>,
    pub common_object_request_params: ::protobuf::SingularPtrField<CommonObjectRequestParams>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartResumableWriteRequest {
    fn default() -> &'a StartResumableWriteRequest {
        <StartResumableWriteRequest as ::protobuf::Message>::default_instance()
    }
}

impl StartResumableWriteRequest {
    pub fn new() -> StartResumableWriteRequest {
        ::std::default::Default::default()
    }

    // .google.storage.v1.InsertObjectSpec insert_object_spec = 1;


    pub fn get_insert_object_spec(&self) -> &InsertObjectSpec {
        self.insert_object_spec.as_ref().unwrap_or_else(|| <InsertObjectSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_insert_object_spec(&mut self) {
        self.insert_object_spec.clear();
    }

    pub fn has_insert_object_spec(&self) -> bool {
        self.insert_object_spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_insert_object_spec(&mut self, v: InsertObjectSpec) {
        self.insert_object_spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_insert_object_spec(&mut self) -> &mut InsertObjectSpec {
        if self.insert_object_spec.is_none() {
            self.insert_object_spec.set_default();
        }
        self.insert_object_spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_insert_object_spec(&mut self) -> InsertObjectSpec {
        self.insert_object_spec.take().unwrap_or_else(|| InsertObjectSpec::new())
    }

    // .google.storage.v1.CommonObjectRequestParams common_object_request_params = 3;


    pub fn get_common_object_request_params(&self) -> &CommonObjectRequestParams {
        self.common_object_request_params.as_ref().unwrap_or_else(|| <CommonObjectRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_object_request_params(&mut self) {
        self.common_object_request_params.clear();
    }

    pub fn has_common_object_request_params(&self) -> bool {
        self.common_object_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_object_request_params(&mut self, v: CommonObjectRequestParams) {
        self.common_object_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_object_request_params(&mut self) -> &mut CommonObjectRequestParams {
        if self.common_object_request_params.is_none() {
            self.common_object_request_params.set_default();
        }
        self.common_object_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_object_request_params(&mut self) -> CommonObjectRequestParams {
        self.common_object_request_params.take().unwrap_or_else(|| CommonObjectRequestParams::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 4;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for StartResumableWriteRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.insert_object_spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_object_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.insert_object_spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_object_request_params)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.insert_object_spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_object_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.insert_object_spec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_object_request_params.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartResumableWriteRequest {
        StartResumableWriteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InsertObjectSpec>>(
                "insert_object_spec",
                |m: &StartResumableWriteRequest| { &m.insert_object_spec },
                |m: &mut StartResumableWriteRequest| { &mut m.insert_object_spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonObjectRequestParams>>(
                "common_object_request_params",
                |m: &StartResumableWriteRequest| { &m.common_object_request_params },
                |m: &mut StartResumableWriteRequest| { &mut m.common_object_request_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &StartResumableWriteRequest| { &m.common_request_params },
                |m: &mut StartResumableWriteRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StartResumableWriteRequest>(
                "StartResumableWriteRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StartResumableWriteRequest {
        static instance: ::protobuf::rt::LazyV2<StartResumableWriteRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StartResumableWriteRequest::new)
    }
}

impl ::protobuf::Clear for StartResumableWriteRequest {
    fn clear(&mut self) {
        self.insert_object_spec.clear();
        self.common_object_request_params.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartResumableWriteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartResumableWriteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartResumableWriteResponse {
    // message fields
    pub upload_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartResumableWriteResponse {
    fn default() -> &'a StartResumableWriteResponse {
        <StartResumableWriteResponse as ::protobuf::Message>::default_instance()
    }
}

impl StartResumableWriteResponse {
    pub fn new() -> StartResumableWriteResponse {
        ::std::default::Default::default()
    }

    // string upload_id = 1;


    pub fn get_upload_id(&self) -> &str {
        &self.upload_id
    }
    pub fn clear_upload_id(&mut self) {
        self.upload_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_upload_id(&mut self, v: ::std::string::String) {
        self.upload_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_upload_id(&mut self) -> &mut ::std::string::String {
        &mut self.upload_id
    }

    // Take field
    pub fn take_upload_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.upload_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for StartResumableWriteResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.upload_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.upload_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.upload_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.upload_id.is_empty() {
            os.write_string(1, &self.upload_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartResumableWriteResponse {
        StartResumableWriteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "upload_id",
                |m: &StartResumableWriteResponse| { &m.upload_id },
                |m: &mut StartResumableWriteResponse| { &mut m.upload_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StartResumableWriteResponse>(
                "StartResumableWriteResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StartResumableWriteResponse {
        static instance: ::protobuf::rt::LazyV2<StartResumableWriteResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StartResumableWriteResponse::new)
    }
}

impl ::protobuf::Clear for StartResumableWriteResponse {
    fn clear(&mut self) {
        self.upload_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartResumableWriteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartResumableWriteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchObjectRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub object: ::std::string::String,
    pub generation: i64,
    pub if_generation_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_generation_not_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_metageneration_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_metageneration_not_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub predefined_acl: super::storage_resources::CommonEnums_PredefinedObjectAcl,
    pub projection: super::storage_resources::CommonEnums_Projection,
    pub metadata: ::protobuf::SingularPtrField<super::storage_resources::Object>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    pub common_object_request_params: ::protobuf::SingularPtrField<CommonObjectRequestParams>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchObjectRequest {
    fn default() -> &'a PatchObjectRequest {
        <PatchObjectRequest as ::protobuf::Message>::default_instance()
    }
}

impl PatchObjectRequest {
    pub fn new() -> PatchObjectRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string object = 2;


    pub fn get_object(&self) -> &str {
        &self.object
    }
    pub fn clear_object(&mut self) {
        self.object.clear();
    }

    // Param is passed by value, moved
    pub fn set_object(&mut self, v: ::std::string::String) {
        self.object = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object(&mut self) -> &mut ::std::string::String {
        &mut self.object
    }

    // Take field
    pub fn take_object(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object, ::std::string::String::new())
    }

    // int64 generation = 3;


    pub fn get_generation(&self) -> i64 {
        self.generation
    }
    pub fn clear_generation(&mut self) {
        self.generation = 0;
    }

    // Param is passed by value, moved
    pub fn set_generation(&mut self, v: i64) {
        self.generation = v;
    }

    // .google.protobuf.Int64Value if_generation_match = 4;


    pub fn get_if_generation_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_generation_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_generation_match(&mut self) {
        self.if_generation_match.clear();
    }

    pub fn has_if_generation_match(&self) -> bool {
        self.if_generation_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_generation_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_generation_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_generation_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_generation_match.is_none() {
            self.if_generation_match.set_default();
        }
        self.if_generation_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_generation_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_generation_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_generation_not_match = 5;


    pub fn get_if_generation_not_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_generation_not_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_generation_not_match(&mut self) {
        self.if_generation_not_match.clear();
    }

    pub fn has_if_generation_not_match(&self) -> bool {
        self.if_generation_not_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_generation_not_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_generation_not_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_generation_not_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_generation_not_match.is_none() {
            self.if_generation_not_match.set_default();
        }
        self.if_generation_not_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_generation_not_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_generation_not_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_metageneration_match = 6;


    pub fn get_if_metageneration_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_metageneration_match(&mut self) {
        self.if_metageneration_match.clear();
    }

    pub fn has_if_metageneration_match(&self) -> bool {
        self.if_metageneration_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_metageneration_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_metageneration_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_metageneration_match.is_none() {
            self.if_metageneration_match.set_default();
        }
        self.if_metageneration_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_metageneration_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_metageneration_not_match = 7;


    pub fn get_if_metageneration_not_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_metageneration_not_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_metageneration_not_match(&mut self) {
        self.if_metageneration_not_match.clear();
    }

    pub fn has_if_metageneration_not_match(&self) -> bool {
        self.if_metageneration_not_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_not_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_metageneration_not_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_metageneration_not_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_metageneration_not_match.is_none() {
            self.if_metageneration_not_match.set_default();
        }
        self.if_metageneration_not_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_metageneration_not_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_metageneration_not_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.storage.v1.CommonEnums.PredefinedObjectAcl predefined_acl = 8;


    pub fn get_predefined_acl(&self) -> super::storage_resources::CommonEnums_PredefinedObjectAcl {
        self.predefined_acl
    }
    pub fn clear_predefined_acl(&mut self) {
        self.predefined_acl = super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_predefined_acl(&mut self, v: super::storage_resources::CommonEnums_PredefinedObjectAcl) {
        self.predefined_acl = v;
    }

    // .google.storage.v1.CommonEnums.Projection projection = 9;


    pub fn get_projection(&self) -> super::storage_resources::CommonEnums_Projection {
        self.projection
    }
    pub fn clear_projection(&mut self) {
        self.projection = super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_projection(&mut self, v: super::storage_resources::CommonEnums_Projection) {
        self.projection = v;
    }

    // .google.storage.v1.Object metadata = 11;


    pub fn get_metadata(&self) -> &super::storage_resources::Object {
        self.metadata.as_ref().unwrap_or_else(|| <super::storage_resources::Object as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::storage_resources::Object) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::storage_resources::Object {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::storage_resources::Object {
        self.metadata.take().unwrap_or_else(|| super::storage_resources::Object::new())
    }

    // .google.protobuf.FieldMask update_mask = 12;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }

    // .google.storage.v1.CommonObjectRequestParams common_object_request_params = 13;


    pub fn get_common_object_request_params(&self) -> &CommonObjectRequestParams {
        self.common_object_request_params.as_ref().unwrap_or_else(|| <CommonObjectRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_object_request_params(&mut self) {
        self.common_object_request_params.clear();
    }

    pub fn has_common_object_request_params(&self) -> bool {
        self.common_object_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_object_request_params(&mut self, v: CommonObjectRequestParams) {
        self.common_object_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_object_request_params(&mut self) -> &mut CommonObjectRequestParams {
        if self.common_object_request_params.is_none() {
            self.common_object_request_params.set_default();
        }
        self.common_object_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_object_request_params(&mut self) -> CommonObjectRequestParams {
        self.common_object_request_params.take().unwrap_or_else(|| CommonObjectRequestParams::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 14;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for PatchObjectRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.if_generation_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_generation_not_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_metageneration_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_metageneration_not_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_object_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.generation = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_generation_match)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_generation_not_match)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_metageneration_match)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_metageneration_not_match)?;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.predefined_acl, 8, &mut self.unknown_fields)?
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.projection, 9, &mut self.unknown_fields)?
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_object_request_params)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.object.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.object);
        }
        if self.generation != 0 {
            my_size += ::protobuf::rt::value_size(3, self.generation, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.if_generation_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_generation_not_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_metageneration_not_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.predefined_acl != super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(8, self.predefined_acl);
        }
        if self.projection != super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(9, self.projection);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_object_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.object.is_empty() {
            os.write_string(2, &self.object)?;
        }
        if self.generation != 0 {
            os.write_int64(3, self.generation)?;
        }
        if let Some(ref v) = self.if_generation_match.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_generation_not_match.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_metageneration_not_match.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.predefined_acl != super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&self.predefined_acl))?;
        }
        if self.projection != super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&self.projection))?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_object_request_params.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchObjectRequest {
        PatchObjectRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &PatchObjectRequest| { &m.bucket },
                |m: &mut PatchObjectRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object",
                |m: &PatchObjectRequest| { &m.object },
                |m: &mut PatchObjectRequest| { &mut m.object },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "generation",
                |m: &PatchObjectRequest| { &m.generation },
                |m: &mut PatchObjectRequest| { &mut m.generation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_generation_match",
                |m: &PatchObjectRequest| { &m.if_generation_match },
                |m: &mut PatchObjectRequest| { &mut m.if_generation_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_generation_not_match",
                |m: &PatchObjectRequest| { &m.if_generation_not_match },
                |m: &mut PatchObjectRequest| { &mut m.if_generation_not_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_metageneration_match",
                |m: &PatchObjectRequest| { &m.if_metageneration_match },
                |m: &mut PatchObjectRequest| { &mut m.if_metageneration_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_metageneration_not_match",
                |m: &PatchObjectRequest| { &m.if_metageneration_not_match },
                |m: &mut PatchObjectRequest| { &mut m.if_metageneration_not_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::storage_resources::CommonEnums_PredefinedObjectAcl>>(
                "predefined_acl",
                |m: &PatchObjectRequest| { &m.predefined_acl },
                |m: &mut PatchObjectRequest| { &mut m.predefined_acl },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::storage_resources::CommonEnums_Projection>>(
                "projection",
                |m: &PatchObjectRequest| { &m.projection },
                |m: &mut PatchObjectRequest| { &mut m.projection },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::Object>>(
                "metadata",
                |m: &PatchObjectRequest| { &m.metadata },
                |m: &mut PatchObjectRequest| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "update_mask",
                |m: &PatchObjectRequest| { &m.update_mask },
                |m: &mut PatchObjectRequest| { &mut m.update_mask },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonObjectRequestParams>>(
                "common_object_request_params",
                |m: &PatchObjectRequest| { &m.common_object_request_params },
                |m: &mut PatchObjectRequest| { &mut m.common_object_request_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &PatchObjectRequest| { &m.common_request_params },
                |m: &mut PatchObjectRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchObjectRequest>(
                "PatchObjectRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchObjectRequest {
        static instance: ::protobuf::rt::LazyV2<PatchObjectRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchObjectRequest::new)
    }
}

impl ::protobuf::Clear for PatchObjectRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.object.clear();
        self.generation = 0;
        self.if_generation_match.clear();
        self.if_generation_not_match.clear();
        self.if_metageneration_match.clear();
        self.if_metageneration_not_match.clear();
        self.predefined_acl = super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED;
        self.projection = super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED;
        self.metadata.clear();
        self.update_mask.clear();
        self.common_object_request_params.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchObjectRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchObjectRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateObjectRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub object: ::std::string::String,
    pub generation: i64,
    pub if_generation_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_generation_not_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_metageneration_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub if_metageneration_not_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int64Value>,
    pub predefined_acl: super::storage_resources::CommonEnums_PredefinedObjectAcl,
    pub projection: super::storage_resources::CommonEnums_Projection,
    pub metadata: ::protobuf::SingularPtrField<super::storage_resources::Object>,
    pub common_object_request_params: ::protobuf::SingularPtrField<CommonObjectRequestParams>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateObjectRequest {
    fn default() -> &'a UpdateObjectRequest {
        <UpdateObjectRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateObjectRequest {
    pub fn new() -> UpdateObjectRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // string object = 2;


    pub fn get_object(&self) -> &str {
        &self.object
    }
    pub fn clear_object(&mut self) {
        self.object.clear();
    }

    // Param is passed by value, moved
    pub fn set_object(&mut self, v: ::std::string::String) {
        self.object = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object(&mut self) -> &mut ::std::string::String {
        &mut self.object
    }

    // Take field
    pub fn take_object(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object, ::std::string::String::new())
    }

    // int64 generation = 3;


    pub fn get_generation(&self) -> i64 {
        self.generation
    }
    pub fn clear_generation(&mut self) {
        self.generation = 0;
    }

    // Param is passed by value, moved
    pub fn set_generation(&mut self, v: i64) {
        self.generation = v;
    }

    // .google.protobuf.Int64Value if_generation_match = 4;


    pub fn get_if_generation_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_generation_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_generation_match(&mut self) {
        self.if_generation_match.clear();
    }

    pub fn has_if_generation_match(&self) -> bool {
        self.if_generation_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_generation_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_generation_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_generation_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_generation_match.is_none() {
            self.if_generation_match.set_default();
        }
        self.if_generation_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_generation_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_generation_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_generation_not_match = 5;


    pub fn get_if_generation_not_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_generation_not_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_generation_not_match(&mut self) {
        self.if_generation_not_match.clear();
    }

    pub fn has_if_generation_not_match(&self) -> bool {
        self.if_generation_not_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_generation_not_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_generation_not_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_generation_not_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_generation_not_match.is_none() {
            self.if_generation_not_match.set_default();
        }
        self.if_generation_not_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_generation_not_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_generation_not_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_metageneration_match = 6;


    pub fn get_if_metageneration_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_metageneration_match(&mut self) {
        self.if_metageneration_match.clear();
    }

    pub fn has_if_metageneration_match(&self) -> bool {
        self.if_metageneration_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_metageneration_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_metageneration_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_metageneration_match.is_none() {
            self.if_metageneration_match.set_default();
        }
        self.if_metageneration_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_metageneration_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_metageneration_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.protobuf.Int64Value if_metageneration_not_match = 7;


    pub fn get_if_metageneration_not_match(&self) -> &::protobuf::well_known_types::Int64Value {
        self.if_metageneration_not_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Int64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_if_metageneration_not_match(&mut self) {
        self.if_metageneration_not_match.clear();
    }

    pub fn has_if_metageneration_not_match(&self) -> bool {
        self.if_metageneration_not_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_if_metageneration_not_match(&mut self, v: ::protobuf::well_known_types::Int64Value) {
        self.if_metageneration_not_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_if_metageneration_not_match(&mut self) -> &mut ::protobuf::well_known_types::Int64Value {
        if self.if_metageneration_not_match.is_none() {
            self.if_metageneration_not_match.set_default();
        }
        self.if_metageneration_not_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_if_metageneration_not_match(&mut self) -> ::protobuf::well_known_types::Int64Value {
        self.if_metageneration_not_match.take().unwrap_or_else(|| ::protobuf::well_known_types::Int64Value::new())
    }

    // .google.storage.v1.CommonEnums.PredefinedObjectAcl predefined_acl = 8;


    pub fn get_predefined_acl(&self) -> super::storage_resources::CommonEnums_PredefinedObjectAcl {
        self.predefined_acl
    }
    pub fn clear_predefined_acl(&mut self) {
        self.predefined_acl = super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_predefined_acl(&mut self, v: super::storage_resources::CommonEnums_PredefinedObjectAcl) {
        self.predefined_acl = v;
    }

    // .google.storage.v1.CommonEnums.Projection projection = 9;


    pub fn get_projection(&self) -> super::storage_resources::CommonEnums_Projection {
        self.projection
    }
    pub fn clear_projection(&mut self) {
        self.projection = super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_projection(&mut self, v: super::storage_resources::CommonEnums_Projection) {
        self.projection = v;
    }

    // .google.storage.v1.Object metadata = 11;


    pub fn get_metadata(&self) -> &super::storage_resources::Object {
        self.metadata.as_ref().unwrap_or_else(|| <super::storage_resources::Object as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::storage_resources::Object) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::storage_resources::Object {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::storage_resources::Object {
        self.metadata.take().unwrap_or_else(|| super::storage_resources::Object::new())
    }

    // .google.storage.v1.CommonObjectRequestParams common_object_request_params = 12;


    pub fn get_common_object_request_params(&self) -> &CommonObjectRequestParams {
        self.common_object_request_params.as_ref().unwrap_or_else(|| <CommonObjectRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_object_request_params(&mut self) {
        self.common_object_request_params.clear();
    }

    pub fn has_common_object_request_params(&self) -> bool {
        self.common_object_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_object_request_params(&mut self, v: CommonObjectRequestParams) {
        self.common_object_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_object_request_params(&mut self) -> &mut CommonObjectRequestParams {
        if self.common_object_request_params.is_none() {
            self.common_object_request_params.set_default();
        }
        self.common_object_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_object_request_params(&mut self) -> CommonObjectRequestParams {
        self.common_object_request_params.take().unwrap_or_else(|| CommonObjectRequestParams::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 13;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for UpdateObjectRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.if_generation_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_generation_not_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_metageneration_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.if_metageneration_not_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_object_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.generation = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_generation_match)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_generation_not_match)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_metageneration_match)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.if_metageneration_not_match)?;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.predefined_acl, 8, &mut self.unknown_fields)?
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.projection, 9, &mut self.unknown_fields)?
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_object_request_params)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.object.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.object);
        }
        if self.generation != 0 {
            my_size += ::protobuf::rt::value_size(3, self.generation, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.if_generation_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_generation_not_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.if_metageneration_not_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.predefined_acl != super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(8, self.predefined_acl);
        }
        if self.projection != super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(9, self.projection);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_object_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.object.is_empty() {
            os.write_string(2, &self.object)?;
        }
        if self.generation != 0 {
            os.write_int64(3, self.generation)?;
        }
        if let Some(ref v) = self.if_generation_match.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_generation_not_match.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_metageneration_match.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.if_metageneration_not_match.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.predefined_acl != super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&self.predefined_acl))?;
        }
        if self.projection != super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&self.projection))?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_object_request_params.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateObjectRequest {
        UpdateObjectRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &UpdateObjectRequest| { &m.bucket },
                |m: &mut UpdateObjectRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object",
                |m: &UpdateObjectRequest| { &m.object },
                |m: &mut UpdateObjectRequest| { &mut m.object },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "generation",
                |m: &UpdateObjectRequest| { &m.generation },
                |m: &mut UpdateObjectRequest| { &mut m.generation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_generation_match",
                |m: &UpdateObjectRequest| { &m.if_generation_match },
                |m: &mut UpdateObjectRequest| { &mut m.if_generation_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_generation_not_match",
                |m: &UpdateObjectRequest| { &m.if_generation_not_match },
                |m: &mut UpdateObjectRequest| { &mut m.if_generation_not_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_metageneration_match",
                |m: &UpdateObjectRequest| { &m.if_metageneration_match },
                |m: &mut UpdateObjectRequest| { &mut m.if_metageneration_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int64Value>>(
                "if_metageneration_not_match",
                |m: &UpdateObjectRequest| { &m.if_metageneration_not_match },
                |m: &mut UpdateObjectRequest| { &mut m.if_metageneration_not_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::storage_resources::CommonEnums_PredefinedObjectAcl>>(
                "predefined_acl",
                |m: &UpdateObjectRequest| { &m.predefined_acl },
                |m: &mut UpdateObjectRequest| { &mut m.predefined_acl },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::storage_resources::CommonEnums_Projection>>(
                "projection",
                |m: &UpdateObjectRequest| { &m.projection },
                |m: &mut UpdateObjectRequest| { &mut m.projection },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::Object>>(
                "metadata",
                |m: &UpdateObjectRequest| { &m.metadata },
                |m: &mut UpdateObjectRequest| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonObjectRequestParams>>(
                "common_object_request_params",
                |m: &UpdateObjectRequest| { &m.common_object_request_params },
                |m: &mut UpdateObjectRequest| { &mut m.common_object_request_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &UpdateObjectRequest| { &m.common_request_params },
                |m: &mut UpdateObjectRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateObjectRequest>(
                "UpdateObjectRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateObjectRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateObjectRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateObjectRequest::new)
    }
}

impl ::protobuf::Clear for UpdateObjectRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.object.clear();
        self.generation = 0;
        self.if_generation_match.clear();
        self.if_generation_not_match.clear();
        self.if_metageneration_match.clear();
        self.if_metageneration_not_match.clear();
        self.predefined_acl = super::storage_resources::CommonEnums_PredefinedObjectAcl::PREDEFINED_OBJECT_ACL_UNSPECIFIED;
        self.projection = super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED;
        self.metadata.clear();
        self.common_object_request_params.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateObjectRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateObjectRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WatchAllObjectsRequest {
    // message fields
    pub bucket: ::std::string::String,
    pub versions: bool,
    pub delimiter: ::std::string::String,
    pub max_results: i32,
    pub prefix: ::std::string::String,
    pub include_trailing_delimiter: bool,
    pub page_token: ::std::string::String,
    pub projection: super::storage_resources::CommonEnums_Projection,
    pub channel: ::protobuf::SingularPtrField<super::storage_resources::Channel>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WatchAllObjectsRequest {
    fn default() -> &'a WatchAllObjectsRequest {
        <WatchAllObjectsRequest as ::protobuf::Message>::default_instance()
    }
}

impl WatchAllObjectsRequest {
    pub fn new() -> WatchAllObjectsRequest {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // bool versions = 2;


    pub fn get_versions(&self) -> bool {
        self.versions
    }
    pub fn clear_versions(&mut self) {
        self.versions = false;
    }

    // Param is passed by value, moved
    pub fn set_versions(&mut self, v: bool) {
        self.versions = v;
    }

    // string delimiter = 3;


    pub fn get_delimiter(&self) -> &str {
        &self.delimiter
    }
    pub fn clear_delimiter(&mut self) {
        self.delimiter.clear();
    }

    // Param is passed by value, moved
    pub fn set_delimiter(&mut self, v: ::std::string::String) {
        self.delimiter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delimiter(&mut self) -> &mut ::std::string::String {
        &mut self.delimiter
    }

    // Take field
    pub fn take_delimiter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.delimiter, ::std::string::String::new())
    }

    // int32 max_results = 4;


    pub fn get_max_results(&self) -> i32 {
        self.max_results
    }
    pub fn clear_max_results(&mut self) {
        self.max_results = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_results(&mut self, v: i32) {
        self.max_results = v;
    }

    // string prefix = 5;


    pub fn get_prefix(&self) -> &str {
        &self.prefix
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::string::String) {
        self.prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.prefix
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prefix, ::std::string::String::new())
    }

    // bool include_trailing_delimiter = 6;


    pub fn get_include_trailing_delimiter(&self) -> bool {
        self.include_trailing_delimiter
    }
    pub fn clear_include_trailing_delimiter(&mut self) {
        self.include_trailing_delimiter = false;
    }

    // Param is passed by value, moved
    pub fn set_include_trailing_delimiter(&mut self, v: bool) {
        self.include_trailing_delimiter = v;
    }

    // string page_token = 7;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    // .google.storage.v1.CommonEnums.Projection projection = 8;


    pub fn get_projection(&self) -> super::storage_resources::CommonEnums_Projection {
        self.projection
    }
    pub fn clear_projection(&mut self) {
        self.projection = super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_projection(&mut self, v: super::storage_resources::CommonEnums_Projection) {
        self.projection = v;
    }

    // .google.storage.v1.Channel channel = 10;


    pub fn get_channel(&self) -> &super::storage_resources::Channel {
        self.channel.as_ref().unwrap_or_else(|| <super::storage_resources::Channel as ::protobuf::Message>::default_instance())
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: super::storage_resources::Channel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut super::storage_resources::Channel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> super::storage_resources::Channel {
        self.channel.take().unwrap_or_else(|| super::storage_resources::Channel::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 11;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for WatchAllObjectsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.versions = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.delimiter)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_results = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.prefix)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_trailing_delimiter = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.projection, 8, &mut self.unknown_fields)?
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if self.versions != false {
            my_size += 2;
        }
        if !self.delimiter.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.delimiter);
        }
        if self.max_results != 0 {
            my_size += ::protobuf::rt::value_size(4, self.max_results, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.prefix);
        }
        if self.include_trailing_delimiter != false {
            my_size += 2;
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.page_token);
        }
        if self.projection != super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(8, self.projection);
        }
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if self.versions != false {
            os.write_bool(2, self.versions)?;
        }
        if !self.delimiter.is_empty() {
            os.write_string(3, &self.delimiter)?;
        }
        if self.max_results != 0 {
            os.write_int32(4, self.max_results)?;
        }
        if !self.prefix.is_empty() {
            os.write_string(5, &self.prefix)?;
        }
        if self.include_trailing_delimiter != false {
            os.write_bool(6, self.include_trailing_delimiter)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(7, &self.page_token)?;
        }
        if self.projection != super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&self.projection))?;
        }
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WatchAllObjectsRequest {
        WatchAllObjectsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bucket",
                |m: &WatchAllObjectsRequest| { &m.bucket },
                |m: &mut WatchAllObjectsRequest| { &mut m.bucket },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "versions",
                |m: &WatchAllObjectsRequest| { &m.versions },
                |m: &mut WatchAllObjectsRequest| { &mut m.versions },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "delimiter",
                |m: &WatchAllObjectsRequest| { &m.delimiter },
                |m: &mut WatchAllObjectsRequest| { &mut m.delimiter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_results",
                |m: &WatchAllObjectsRequest| { &m.max_results },
                |m: &mut WatchAllObjectsRequest| { &mut m.max_results },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "prefix",
                |m: &WatchAllObjectsRequest| { &m.prefix },
                |m: &mut WatchAllObjectsRequest| { &mut m.prefix },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "include_trailing_delimiter",
                |m: &WatchAllObjectsRequest| { &m.include_trailing_delimiter },
                |m: &mut WatchAllObjectsRequest| { &mut m.include_trailing_delimiter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &WatchAllObjectsRequest| { &m.page_token },
                |m: &mut WatchAllObjectsRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::storage_resources::CommonEnums_Projection>>(
                "projection",
                |m: &WatchAllObjectsRequest| { &m.projection },
                |m: &mut WatchAllObjectsRequest| { &mut m.projection },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::Channel>>(
                "channel",
                |m: &WatchAllObjectsRequest| { &m.channel },
                |m: &mut WatchAllObjectsRequest| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &WatchAllObjectsRequest| { &m.common_request_params },
                |m: &mut WatchAllObjectsRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WatchAllObjectsRequest>(
                "WatchAllObjectsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WatchAllObjectsRequest {
        static instance: ::protobuf::rt::LazyV2<WatchAllObjectsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WatchAllObjectsRequest::new)
    }
}

impl ::protobuf::Clear for WatchAllObjectsRequest {
    fn clear(&mut self) {
        self.bucket.clear();
        self.versions = false;
        self.delimiter.clear();
        self.max_results = 0;
        self.prefix.clear();
        self.include_trailing_delimiter = false;
        self.page_token.clear();
        self.projection = super::storage_resources::CommonEnums_Projection::PROJECTION_UNSPECIFIED;
        self.channel.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WatchAllObjectsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WatchAllObjectsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetProjectServiceAccountRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetProjectServiceAccountRequest {
    fn default() -> &'a GetProjectServiceAccountRequest {
        <GetProjectServiceAccountRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetProjectServiceAccountRequest {
    pub fn new() -> GetProjectServiceAccountRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 3;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for GetProjectServiceAccountRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetProjectServiceAccountRequest {
        GetProjectServiceAccountRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &GetProjectServiceAccountRequest| { &m.project_id },
                |m: &mut GetProjectServiceAccountRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &GetProjectServiceAccountRequest| { &m.common_request_params },
                |m: &mut GetProjectServiceAccountRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetProjectServiceAccountRequest>(
                "GetProjectServiceAccountRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetProjectServiceAccountRequest {
        static instance: ::protobuf::rt::LazyV2<GetProjectServiceAccountRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetProjectServiceAccountRequest::new)
    }
}

impl ::protobuf::Clear for GetProjectServiceAccountRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetProjectServiceAccountRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetProjectServiceAccountRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateHmacKeyRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub service_account_email: ::std::string::String,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateHmacKeyRequest {
    fn default() -> &'a CreateHmacKeyRequest {
        <CreateHmacKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateHmacKeyRequest {
    pub fn new() -> CreateHmacKeyRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string service_account_email = 2;


    pub fn get_service_account_email(&self) -> &str {
        &self.service_account_email
    }
    pub fn clear_service_account_email(&mut self) {
        self.service_account_email.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_account_email(&mut self, v: ::std::string::String) {
        self.service_account_email = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_account_email(&mut self) -> &mut ::std::string::String {
        &mut self.service_account_email
    }

    // Take field
    pub fn take_service_account_email(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_account_email, ::std::string::String::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 3;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for CreateHmacKeyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_account_email)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.service_account_email.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.service_account_email);
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.service_account_email.is_empty() {
            os.write_string(2, &self.service_account_email)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateHmacKeyRequest {
        CreateHmacKeyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &CreateHmacKeyRequest| { &m.project_id },
                |m: &mut CreateHmacKeyRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_account_email",
                |m: &CreateHmacKeyRequest| { &m.service_account_email },
                |m: &mut CreateHmacKeyRequest| { &mut m.service_account_email },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &CreateHmacKeyRequest| { &m.common_request_params },
                |m: &mut CreateHmacKeyRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateHmacKeyRequest>(
                "CreateHmacKeyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateHmacKeyRequest {
        static instance: ::protobuf::rt::LazyV2<CreateHmacKeyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateHmacKeyRequest::new)
    }
}

impl ::protobuf::Clear for CreateHmacKeyRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.service_account_email.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateHmacKeyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateHmacKeyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateHmacKeyResponse {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::storage_resources::HmacKeyMetadata>,
    pub secret: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateHmacKeyResponse {
    fn default() -> &'a CreateHmacKeyResponse {
        <CreateHmacKeyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateHmacKeyResponse {
    pub fn new() -> CreateHmacKeyResponse {
        ::std::default::Default::default()
    }

    // .google.storage.v1.HmacKeyMetadata metadata = 1;


    pub fn get_metadata(&self) -> &super::storage_resources::HmacKeyMetadata {
        self.metadata.as_ref().unwrap_or_else(|| <super::storage_resources::HmacKeyMetadata as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::storage_resources::HmacKeyMetadata) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::storage_resources::HmacKeyMetadata {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::storage_resources::HmacKeyMetadata {
        self.metadata.take().unwrap_or_else(|| super::storage_resources::HmacKeyMetadata::new())
    }

    // string secret = 2;


    pub fn get_secret(&self) -> &str {
        &self.secret
    }
    pub fn clear_secret(&mut self) {
        self.secret.clear();
    }

    // Param is passed by value, moved
    pub fn set_secret(&mut self, v: ::std::string::String) {
        self.secret = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret(&mut self) -> &mut ::std::string::String {
        &mut self.secret
    }

    // Take field
    pub fn take_secret(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.secret, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateHmacKeyResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.secret)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.secret.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.secret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.secret.is_empty() {
            os.write_string(2, &self.secret)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateHmacKeyResponse {
        CreateHmacKeyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::HmacKeyMetadata>>(
                "metadata",
                |m: &CreateHmacKeyResponse| { &m.metadata },
                |m: &mut CreateHmacKeyResponse| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "secret",
                |m: &CreateHmacKeyResponse| { &m.secret },
                |m: &mut CreateHmacKeyResponse| { &mut m.secret },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateHmacKeyResponse>(
                "CreateHmacKeyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateHmacKeyResponse {
        static instance: ::protobuf::rt::LazyV2<CreateHmacKeyResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateHmacKeyResponse::new)
    }
}

impl ::protobuf::Clear for CreateHmacKeyResponse {
    fn clear(&mut self) {
        self.metadata.clear();
        self.secret.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateHmacKeyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateHmacKeyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteHmacKeyRequest {
    // message fields
    pub access_id: ::std::string::String,
    pub project_id: ::std::string::String,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteHmacKeyRequest {
    fn default() -> &'a DeleteHmacKeyRequest {
        <DeleteHmacKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteHmacKeyRequest {
    pub fn new() -> DeleteHmacKeyRequest {
        ::std::default::Default::default()
    }

    // string access_id = 1;


    pub fn get_access_id(&self) -> &str {
        &self.access_id
    }
    pub fn clear_access_id(&mut self) {
        self.access_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_access_id(&mut self, v: ::std::string::String) {
        self.access_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_access_id(&mut self) -> &mut ::std::string::String {
        &mut self.access_id
    }

    // Take field
    pub fn take_access_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.access_id, ::std::string::String::new())
    }

    // string project_id = 2;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 3;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for DeleteHmacKeyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.access_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.access_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.access_id);
        }
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.project_id);
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.access_id.is_empty() {
            os.write_string(1, &self.access_id)?;
        }
        if !self.project_id.is_empty() {
            os.write_string(2, &self.project_id)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteHmacKeyRequest {
        DeleteHmacKeyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "access_id",
                |m: &DeleteHmacKeyRequest| { &m.access_id },
                |m: &mut DeleteHmacKeyRequest| { &mut m.access_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &DeleteHmacKeyRequest| { &m.project_id },
                |m: &mut DeleteHmacKeyRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &DeleteHmacKeyRequest| { &m.common_request_params },
                |m: &mut DeleteHmacKeyRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteHmacKeyRequest>(
                "DeleteHmacKeyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteHmacKeyRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteHmacKeyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteHmacKeyRequest::new)
    }
}

impl ::protobuf::Clear for DeleteHmacKeyRequest {
    fn clear(&mut self) {
        self.access_id.clear();
        self.project_id.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteHmacKeyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteHmacKeyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetHmacKeyRequest {
    // message fields
    pub access_id: ::std::string::String,
    pub project_id: ::std::string::String,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetHmacKeyRequest {
    fn default() -> &'a GetHmacKeyRequest {
        <GetHmacKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetHmacKeyRequest {
    pub fn new() -> GetHmacKeyRequest {
        ::std::default::Default::default()
    }

    // string access_id = 1;


    pub fn get_access_id(&self) -> &str {
        &self.access_id
    }
    pub fn clear_access_id(&mut self) {
        self.access_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_access_id(&mut self, v: ::std::string::String) {
        self.access_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_access_id(&mut self) -> &mut ::std::string::String {
        &mut self.access_id
    }

    // Take field
    pub fn take_access_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.access_id, ::std::string::String::new())
    }

    // string project_id = 2;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 3;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for GetHmacKeyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.access_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.access_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.access_id);
        }
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.project_id);
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.access_id.is_empty() {
            os.write_string(1, &self.access_id)?;
        }
        if !self.project_id.is_empty() {
            os.write_string(2, &self.project_id)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetHmacKeyRequest {
        GetHmacKeyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "access_id",
                |m: &GetHmacKeyRequest| { &m.access_id },
                |m: &mut GetHmacKeyRequest| { &mut m.access_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &GetHmacKeyRequest| { &m.project_id },
                |m: &mut GetHmacKeyRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &GetHmacKeyRequest| { &m.common_request_params },
                |m: &mut GetHmacKeyRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetHmacKeyRequest>(
                "GetHmacKeyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetHmacKeyRequest {
        static instance: ::protobuf::rt::LazyV2<GetHmacKeyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetHmacKeyRequest::new)
    }
}

impl ::protobuf::Clear for GetHmacKeyRequest {
    fn clear(&mut self) {
        self.access_id.clear();
        self.project_id.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetHmacKeyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetHmacKeyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListHmacKeysRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub service_account_email: ::std::string::String,
    pub show_deleted_keys: bool,
    pub max_results: i32,
    pub page_token: ::std::string::String,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListHmacKeysRequest {
    fn default() -> &'a ListHmacKeysRequest {
        <ListHmacKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListHmacKeysRequest {
    pub fn new() -> ListHmacKeysRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string service_account_email = 2;


    pub fn get_service_account_email(&self) -> &str {
        &self.service_account_email
    }
    pub fn clear_service_account_email(&mut self) {
        self.service_account_email.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_account_email(&mut self, v: ::std::string::String) {
        self.service_account_email = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_account_email(&mut self) -> &mut ::std::string::String {
        &mut self.service_account_email
    }

    // Take field
    pub fn take_service_account_email(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_account_email, ::std::string::String::new())
    }

    // bool show_deleted_keys = 3;


    pub fn get_show_deleted_keys(&self) -> bool {
        self.show_deleted_keys
    }
    pub fn clear_show_deleted_keys(&mut self) {
        self.show_deleted_keys = false;
    }

    // Param is passed by value, moved
    pub fn set_show_deleted_keys(&mut self, v: bool) {
        self.show_deleted_keys = v;
    }

    // int32 max_results = 4;


    pub fn get_max_results(&self) -> i32 {
        self.max_results
    }
    pub fn clear_max_results(&mut self) {
        self.max_results = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_results(&mut self, v: i32) {
        self.max_results = v;
    }

    // string page_token = 5;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 6;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for ListHmacKeysRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_account_email)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.show_deleted_keys = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_results = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.service_account_email.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.service_account_email);
        }
        if self.show_deleted_keys != false {
            my_size += 2;
        }
        if self.max_results != 0 {
            my_size += ::protobuf::rt::value_size(4, self.max_results, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.page_token);
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.service_account_email.is_empty() {
            os.write_string(2, &self.service_account_email)?;
        }
        if self.show_deleted_keys != false {
            os.write_bool(3, self.show_deleted_keys)?;
        }
        if self.max_results != 0 {
            os.write_int32(4, self.max_results)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(5, &self.page_token)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListHmacKeysRequest {
        ListHmacKeysRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &ListHmacKeysRequest| { &m.project_id },
                |m: &mut ListHmacKeysRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_account_email",
                |m: &ListHmacKeysRequest| { &m.service_account_email },
                |m: &mut ListHmacKeysRequest| { &mut m.service_account_email },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "show_deleted_keys",
                |m: &ListHmacKeysRequest| { &m.show_deleted_keys },
                |m: &mut ListHmacKeysRequest| { &mut m.show_deleted_keys },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_results",
                |m: &ListHmacKeysRequest| { &m.max_results },
                |m: &mut ListHmacKeysRequest| { &mut m.max_results },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListHmacKeysRequest| { &m.page_token },
                |m: &mut ListHmacKeysRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &ListHmacKeysRequest| { &m.common_request_params },
                |m: &mut ListHmacKeysRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListHmacKeysRequest>(
                "ListHmacKeysRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListHmacKeysRequest {
        static instance: ::protobuf::rt::LazyV2<ListHmacKeysRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListHmacKeysRequest::new)
    }
}

impl ::protobuf::Clear for ListHmacKeysRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.service_account_email.clear();
        self.show_deleted_keys = false;
        self.max_results = 0;
        self.page_token.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListHmacKeysRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListHmacKeysRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListHmacKeysResponse {
    // message fields
    pub next_page_token: ::std::string::String,
    pub items: ::protobuf::RepeatedField<super::storage_resources::HmacKeyMetadata>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListHmacKeysResponse {
    fn default() -> &'a ListHmacKeysResponse {
        <ListHmacKeysResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListHmacKeysResponse {
    pub fn new() -> ListHmacKeysResponse {
        ::std::default::Default::default()
    }

    // string next_page_token = 1;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }

    // repeated .google.storage.v1.HmacKeyMetadata items = 2;


    pub fn get_items(&self) -> &[super::storage_resources::HmacKeyMetadata] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<super::storage_resources::HmacKeyMetadata>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<super::storage_resources::HmacKeyMetadata> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<super::storage_resources::HmacKeyMetadata> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListHmacKeysResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.next_page_token);
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.next_page_token.is_empty() {
            os.write_string(1, &self.next_page_token)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListHmacKeysResponse {
        ListHmacKeysResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListHmacKeysResponse| { &m.next_page_token },
                |m: &mut ListHmacKeysResponse| { &mut m.next_page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::HmacKeyMetadata>>(
                "items",
                |m: &ListHmacKeysResponse| { &m.items },
                |m: &mut ListHmacKeysResponse| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListHmacKeysResponse>(
                "ListHmacKeysResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListHmacKeysResponse {
        static instance: ::protobuf::rt::LazyV2<ListHmacKeysResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListHmacKeysResponse::new)
    }
}

impl ::protobuf::Clear for ListHmacKeysResponse {
    fn clear(&mut self) {
        self.next_page_token.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListHmacKeysResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListHmacKeysResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateHmacKeyRequest {
    // message fields
    pub access_id: ::std::string::String,
    pub project_id: ::std::string::String,
    pub metadata: ::protobuf::SingularPtrField<super::storage_resources::HmacKeyMetadata>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateHmacKeyRequest {
    fn default() -> &'a UpdateHmacKeyRequest {
        <UpdateHmacKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateHmacKeyRequest {
    pub fn new() -> UpdateHmacKeyRequest {
        ::std::default::Default::default()
    }

    // string access_id = 1;


    pub fn get_access_id(&self) -> &str {
        &self.access_id
    }
    pub fn clear_access_id(&mut self) {
        self.access_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_access_id(&mut self, v: ::std::string::String) {
        self.access_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_access_id(&mut self) -> &mut ::std::string::String {
        &mut self.access_id
    }

    // Take field
    pub fn take_access_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.access_id, ::std::string::String::new())
    }

    // string project_id = 2;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // .google.storage.v1.HmacKeyMetadata metadata = 3;


    pub fn get_metadata(&self) -> &super::storage_resources::HmacKeyMetadata {
        self.metadata.as_ref().unwrap_or_else(|| <super::storage_resources::HmacKeyMetadata as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::storage_resources::HmacKeyMetadata) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::storage_resources::HmacKeyMetadata {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::storage_resources::HmacKeyMetadata {
        self.metadata.take().unwrap_or_else(|| super::storage_resources::HmacKeyMetadata::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 5;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for UpdateHmacKeyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.access_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.access_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.access_id);
        }
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.project_id);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.access_id.is_empty() {
            os.write_string(1, &self.access_id)?;
        }
        if !self.project_id.is_empty() {
            os.write_string(2, &self.project_id)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateHmacKeyRequest {
        UpdateHmacKeyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "access_id",
                |m: &UpdateHmacKeyRequest| { &m.access_id },
                |m: &mut UpdateHmacKeyRequest| { &mut m.access_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &UpdateHmacKeyRequest| { &m.project_id },
                |m: &mut UpdateHmacKeyRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::storage_resources::HmacKeyMetadata>>(
                "metadata",
                |m: &UpdateHmacKeyRequest| { &m.metadata },
                |m: &mut UpdateHmacKeyRequest| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &UpdateHmacKeyRequest| { &m.common_request_params },
                |m: &mut UpdateHmacKeyRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateHmacKeyRequest>(
                "UpdateHmacKeyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateHmacKeyRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateHmacKeyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateHmacKeyRequest::new)
    }
}

impl ::protobuf::Clear for UpdateHmacKeyRequest {
    fn clear(&mut self) {
        self.access_id.clear();
        self.project_id.clear();
        self.metadata.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateHmacKeyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateHmacKeyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetIamPolicyRequest {
    // message fields
    pub iam_request: ::protobuf::SingularPtrField<super::iam_policy::GetIamPolicyRequest>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetIamPolicyRequest {
    fn default() -> &'a GetIamPolicyRequest {
        <GetIamPolicyRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetIamPolicyRequest {
    pub fn new() -> GetIamPolicyRequest {
        ::std::default::Default::default()
    }

    // .google.iam.v1.GetIamPolicyRequest iam_request = 1;


    pub fn get_iam_request(&self) -> &super::iam_policy::GetIamPolicyRequest {
        self.iam_request.as_ref().unwrap_or_else(|| <super::iam_policy::GetIamPolicyRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_iam_request(&mut self) {
        self.iam_request.clear();
    }

    pub fn has_iam_request(&self) -> bool {
        self.iam_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iam_request(&mut self, v: super::iam_policy::GetIamPolicyRequest) {
        self.iam_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iam_request(&mut self) -> &mut super::iam_policy::GetIamPolicyRequest {
        if self.iam_request.is_none() {
            self.iam_request.set_default();
        }
        self.iam_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_iam_request(&mut self) -> super::iam_policy::GetIamPolicyRequest {
        self.iam_request.take().unwrap_or_else(|| super::iam_policy::GetIamPolicyRequest::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 2;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for GetIamPolicyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.iam_request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.iam_request)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.iam_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.iam_request.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetIamPolicyRequest {
        GetIamPolicyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::iam_policy::GetIamPolicyRequest>>(
                "iam_request",
                |m: &GetIamPolicyRequest| { &m.iam_request },
                |m: &mut GetIamPolicyRequest| { &mut m.iam_request },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &GetIamPolicyRequest| { &m.common_request_params },
                |m: &mut GetIamPolicyRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetIamPolicyRequest>(
                "GetIamPolicyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetIamPolicyRequest {
        static instance: ::protobuf::rt::LazyV2<GetIamPolicyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetIamPolicyRequest::new)
    }
}

impl ::protobuf::Clear for GetIamPolicyRequest {
    fn clear(&mut self) {
        self.iam_request.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetIamPolicyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIamPolicyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetIamPolicyRequest {
    // message fields
    pub iam_request: ::protobuf::SingularPtrField<super::iam_policy::SetIamPolicyRequest>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetIamPolicyRequest {
    fn default() -> &'a SetIamPolicyRequest {
        <SetIamPolicyRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetIamPolicyRequest {
    pub fn new() -> SetIamPolicyRequest {
        ::std::default::Default::default()
    }

    // .google.iam.v1.SetIamPolicyRequest iam_request = 1;


    pub fn get_iam_request(&self) -> &super::iam_policy::SetIamPolicyRequest {
        self.iam_request.as_ref().unwrap_or_else(|| <super::iam_policy::SetIamPolicyRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_iam_request(&mut self) {
        self.iam_request.clear();
    }

    pub fn has_iam_request(&self) -> bool {
        self.iam_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iam_request(&mut self, v: super::iam_policy::SetIamPolicyRequest) {
        self.iam_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iam_request(&mut self) -> &mut super::iam_policy::SetIamPolicyRequest {
        if self.iam_request.is_none() {
            self.iam_request.set_default();
        }
        self.iam_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_iam_request(&mut self) -> super::iam_policy::SetIamPolicyRequest {
        self.iam_request.take().unwrap_or_else(|| super::iam_policy::SetIamPolicyRequest::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 2;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for SetIamPolicyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.iam_request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.iam_request)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.iam_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.iam_request.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetIamPolicyRequest {
        SetIamPolicyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::iam_policy::SetIamPolicyRequest>>(
                "iam_request",
                |m: &SetIamPolicyRequest| { &m.iam_request },
                |m: &mut SetIamPolicyRequest| { &mut m.iam_request },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &SetIamPolicyRequest| { &m.common_request_params },
                |m: &mut SetIamPolicyRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetIamPolicyRequest>(
                "SetIamPolicyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetIamPolicyRequest {
        static instance: ::protobuf::rt::LazyV2<SetIamPolicyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetIamPolicyRequest::new)
    }
}

impl ::protobuf::Clear for SetIamPolicyRequest {
    fn clear(&mut self) {
        self.iam_request.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetIamPolicyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetIamPolicyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestIamPermissionsRequest {
    // message fields
    pub iam_request: ::protobuf::SingularPtrField<super::iam_policy::TestIamPermissionsRequest>,
    pub common_request_params: ::protobuf::SingularPtrField<CommonRequestParams>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TestIamPermissionsRequest {
    fn default() -> &'a TestIamPermissionsRequest {
        <TestIamPermissionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl TestIamPermissionsRequest {
    pub fn new() -> TestIamPermissionsRequest {
        ::std::default::Default::default()
    }

    // .google.iam.v1.TestIamPermissionsRequest iam_request = 1;


    pub fn get_iam_request(&self) -> &super::iam_policy::TestIamPermissionsRequest {
        self.iam_request.as_ref().unwrap_or_else(|| <super::iam_policy::TestIamPermissionsRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_iam_request(&mut self) {
        self.iam_request.clear();
    }

    pub fn has_iam_request(&self) -> bool {
        self.iam_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iam_request(&mut self, v: super::iam_policy::TestIamPermissionsRequest) {
        self.iam_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iam_request(&mut self) -> &mut super::iam_policy::TestIamPermissionsRequest {
        if self.iam_request.is_none() {
            self.iam_request.set_default();
        }
        self.iam_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_iam_request(&mut self) -> super::iam_policy::TestIamPermissionsRequest {
        self.iam_request.take().unwrap_or_else(|| super::iam_policy::TestIamPermissionsRequest::new())
    }

    // .google.storage.v1.CommonRequestParams common_request_params = 2;


    pub fn get_common_request_params(&self) -> &CommonRequestParams {
        self.common_request_params.as_ref().unwrap_or_else(|| <CommonRequestParams as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common_request_params(&mut self) {
        self.common_request_params.clear();
    }

    pub fn has_common_request_params(&self) -> bool {
        self.common_request_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_request_params(&mut self, v: CommonRequestParams) {
        self.common_request_params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_request_params(&mut self) -> &mut CommonRequestParams {
        if self.common_request_params.is_none() {
            self.common_request_params.set_default();
        }
        self.common_request_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_request_params(&mut self) -> CommonRequestParams {
        self.common_request_params.take().unwrap_or_else(|| CommonRequestParams::new())
    }
}

impl ::protobuf::Message for TestIamPermissionsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.iam_request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.common_request_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.iam_request)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common_request_params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.iam_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.iam_request.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.common_request_params.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestIamPermissionsRequest {
        TestIamPermissionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::iam_policy::TestIamPermissionsRequest>>(
                "iam_request",
                |m: &TestIamPermissionsRequest| { &m.iam_request },
                |m: &mut TestIamPermissionsRequest| { &mut m.iam_request },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonRequestParams>>(
                "common_request_params",
                |m: &TestIamPermissionsRequest| { &m.common_request_params },
                |m: &mut TestIamPermissionsRequest| { &mut m.common_request_params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TestIamPermissionsRequest>(
                "TestIamPermissionsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TestIamPermissionsRequest {
        static instance: ::protobuf::rt::LazyV2<TestIamPermissionsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TestIamPermissionsRequest::new)
    }
}

impl ::protobuf::Clear for TestIamPermissionsRequest {
    fn clear(&mut self) {
        self.iam_request.clear();
        self.common_request_params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestIamPermissionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestIamPermissionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommonObjectRequestParams {
    // message fields
    pub encryption_algorithm: ::std::string::String,
    pub encryption_key: ::std::string::String,
    pub encryption_key_sha256: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommonObjectRequestParams {
    fn default() -> &'a CommonObjectRequestParams {
        <CommonObjectRequestParams as ::protobuf::Message>::default_instance()
    }
}

impl CommonObjectRequestParams {
    pub fn new() -> CommonObjectRequestParams {
        ::std::default::Default::default()
    }

    // string encryption_algorithm = 1;


    pub fn get_encryption_algorithm(&self) -> &str {
        &self.encryption_algorithm
    }
    pub fn clear_encryption_algorithm(&mut self) {
        self.encryption_algorithm.clear();
    }

    // Param is passed by value, moved
    pub fn set_encryption_algorithm(&mut self, v: ::std::string::String) {
        self.encryption_algorithm = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_algorithm(&mut self) -> &mut ::std::string::String {
        &mut self.encryption_algorithm
    }

    // Take field
    pub fn take_encryption_algorithm(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.encryption_algorithm, ::std::string::String::new())
    }

    // string encryption_key = 2;


    pub fn get_encryption_key(&self) -> &str {
        &self.encryption_key
    }
    pub fn clear_encryption_key(&mut self) {
        self.encryption_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_encryption_key(&mut self, v: ::std::string::String) {
        self.encryption_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_key(&mut self) -> &mut ::std::string::String {
        &mut self.encryption_key
    }

    // Take field
    pub fn take_encryption_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.encryption_key, ::std::string::String::new())
    }

    // string encryption_key_sha256 = 3;


    pub fn get_encryption_key_sha256(&self) -> &str {
        &self.encryption_key_sha256
    }
    pub fn clear_encryption_key_sha256(&mut self) {
        self.encryption_key_sha256.clear();
    }

    // Param is passed by value, moved
    pub fn set_encryption_key_sha256(&mut self, v: ::std::string::String) {
        self.encryption_key_sha256 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_key_sha256(&mut self) -> &mut ::std::string::String {
        &mut self.encryption_key_sha256
    }

    // Take field
    pub fn take_encryption_key_sha256(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.encryption_key_sha256, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CommonObjectRequestParams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.encryption_algorithm)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.encryption_key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.encryption_key_sha256)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.encryption_algorithm.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.encryption_algorithm);
        }
        if !self.encryption_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.encryption_key);
        }
        if !self.encryption_key_sha256.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.encryption_key_sha256);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.encryption_algorithm.is_empty() {
            os.write_string(1, &self.encryption_algorithm)?;
        }
        if !self.encryption_key.is_empty() {
            os.write_string(2, &self.encryption_key)?;
        }
        if !self.encryption_key_sha256.is_empty() {
            os.write_string(3, &self.encryption_key_sha256)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommonObjectRequestParams {
        CommonObjectRequestParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "encryption_algorithm",
                |m: &CommonObjectRequestParams| { &m.encryption_algorithm },
                |m: &mut CommonObjectRequestParams| { &mut m.encryption_algorithm },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "encryption_key",
                |m: &CommonObjectRequestParams| { &m.encryption_key },
                |m: &mut CommonObjectRequestParams| { &mut m.encryption_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "encryption_key_sha256",
                |m: &CommonObjectRequestParams| { &m.encryption_key_sha256 },
                |m: &mut CommonObjectRequestParams| { &mut m.encryption_key_sha256 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommonObjectRequestParams>(
                "CommonObjectRequestParams",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommonObjectRequestParams {
        static instance: ::protobuf::rt::LazyV2<CommonObjectRequestParams> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommonObjectRequestParams::new)
    }
}

impl ::protobuf::Clear for CommonObjectRequestParams {
    fn clear(&mut self) {
        self.encryption_algorithm.clear();
        self.encryption_key.clear();
        self.encryption_key_sha256.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommonObjectRequestParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommonObjectRequestParams {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommonRequestParams {
    // message fields
    pub user_project: ::std::string::String,
    pub quota_user: ::std::string::String,
    pub fields: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommonRequestParams {
    fn default() -> &'a CommonRequestParams {
        <CommonRequestParams as ::protobuf::Message>::default_instance()
    }
}

impl CommonRequestParams {
    pub fn new() -> CommonRequestParams {
        ::std::default::Default::default()
    }

    // string user_project = 1;


    pub fn get_user_project(&self) -> &str {
        &self.user_project
    }
    pub fn clear_user_project(&mut self) {
        self.user_project.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_project(&mut self, v: ::std::string::String) {
        self.user_project = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_project(&mut self) -> &mut ::std::string::String {
        &mut self.user_project
    }

    // Take field
    pub fn take_user_project(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_project, ::std::string::String::new())
    }

    // string quota_user = 2;


    pub fn get_quota_user(&self) -> &str {
        &self.quota_user
    }
    pub fn clear_quota_user(&mut self) {
        self.quota_user.clear();
    }

    // Param is passed by value, moved
    pub fn set_quota_user(&mut self, v: ::std::string::String) {
        self.quota_user = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quota_user(&mut self) -> &mut ::std::string::String {
        &mut self.quota_user
    }

    // Take field
    pub fn take_quota_user(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.quota_user, ::std::string::String::new())
    }

    // .google.protobuf.FieldMask fields = 4;


    pub fn get_fields(&self) -> &::protobuf::well_known_types::FieldMask {
        self.fields.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FieldMask as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fields(&mut self) {
        self.fields.clear();
    }

    pub fn has_fields(&self) -> bool {
        self.fields.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fields(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.fields = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fields(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.fields.is_none() {
            self.fields.set_default();
        }
        self.fields.as_mut().unwrap()
    }

    // Take field
    pub fn take_fields(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.fields.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for CommonRequestParams {
    fn is_initialized(&self) -> bool {
        for v in &self.fields {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_project)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.quota_user)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fields)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.user_project.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.user_project);
        }
        if !self.quota_user.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.quota_user);
        }
        if let Some(ref v) = self.fields.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.user_project.is_empty() {
            os.write_string(1, &self.user_project)?;
        }
        if !self.quota_user.is_empty() {
            os.write_string(2, &self.quota_user)?;
        }
        if let Some(ref v) = self.fields.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommonRequestParams {
        CommonRequestParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_project",
                |m: &CommonRequestParams| { &m.user_project },
                |m: &mut CommonRequestParams| { &mut m.user_project },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "quota_user",
                |m: &CommonRequestParams| { &m.quota_user },
                |m: &mut CommonRequestParams| { &mut m.quota_user },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                "fields",
                |m: &CommonRequestParams| { &m.fields },
                |m: &mut CommonRequestParams| { &mut m.fields },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommonRequestParams>(
                "CommonRequestParams",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommonRequestParams {
        static instance: ::protobuf::rt::LazyV2<CommonRequestParams> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommonRequestParams::new)
    }
}

impl ::protobuf::Clear for CommonRequestParams {
    fn clear(&mut self) {
        self.user_project.clear();
        self.quota_user.clear();
        self.fields.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommonRequestParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommonRequestParams {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServiceConstants {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServiceConstants {
    fn default() -> &'a ServiceConstants {
        <ServiceConstants as ::protobuf::Message>::default_instance()
    }
}

impl ServiceConstants {
    pub fn new() -> ServiceConstants {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ServiceConstants {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServiceConstants {
        ServiceConstants::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServiceConstants>(
                "ServiceConstants",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServiceConstants {
        static instance: ::protobuf::rt::LazyV2<ServiceConstants> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServiceConstants::new)
    }
}

impl ::protobuf::Clear for ServiceConstants {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServiceConstants {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceConstants {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

// Note: you cannot use pattern matching for enums with allow_alias option
#[derive(Clone,Eq,Debug)]
pub enum ServiceConstants_Values {
    VALUES_UNSPECIFIED, // 0
    MAX_READ_CHUNK_BYTES, // 2097152
    MAX_WRITE_CHUNK_BYTES, // 2097152
    MAX_OBJECT_SIZE_MB, // 5242880
    MAX_CUSTOM_METADATA_FIELD_NAME_BYTES, // 1024
    MAX_CUSTOM_METADATA_FIELD_VALUE_BYTES, // 4096
    MAX_CUSTOM_METADATA_TOTAL_SIZE_BYTES, // 8192
    MAX_BUCKET_METADATA_TOTAL_SIZE_BYTES, // 20480
    MAX_NOTIFICATION_CONFIGS_PER_BUCKET, // 100
    MAX_LIFECYCLE_RULES_PER_BUCKET, // 100
    MAX_NOTIFICATION_CUSTOM_ATTRIBUTES, // 5
    MAX_NOTIFICATION_CUSTOM_ATTRIBUTE_KEY_LENGTH, // 256
    MAX_NOTIFICATION_CUSTOM_ATTRIBUTE_VALUE_LENGTH, // 1024
    MAX_LABELS_ENTRIES_COUNT, // 64
    MAX_LABELS_KEY_VALUE_LENGTH, // 63
    MAX_LABELS_KEY_VALUE_BYTES, // 128
    MAX_OBJECT_IDS_PER_DELETE_OBJECTS_REQUEST, // 1000
    SPLIT_TOKEN_MAX_VALID_DAYS, // 14
}

impl ::std::cmp::PartialEq for ServiceConstants_Values {
    fn eq(&self, other: &Self) -> bool {
        ::protobuf::ProtobufEnum::value(self) == ::protobuf::ProtobufEnum::value(other)
    }
}

impl ::std::hash::Hash for ServiceConstants_Values {
    fn hash<H : ::std::hash::Hasher>(&self, state: &mut H) {
        state.write_i32(::protobuf::ProtobufEnum::value(self))
    }
}

impl ::protobuf::ProtobufEnum for ServiceConstants_Values {
    fn value(&self) -> i32 {
        match *self {
            ServiceConstants_Values::VALUES_UNSPECIFIED => 0,
            ServiceConstants_Values::MAX_READ_CHUNK_BYTES => 2097152,
            ServiceConstants_Values::MAX_WRITE_CHUNK_BYTES => 2097152,
            ServiceConstants_Values::MAX_OBJECT_SIZE_MB => 5242880,
            ServiceConstants_Values::MAX_CUSTOM_METADATA_FIELD_NAME_BYTES => 1024,
            ServiceConstants_Values::MAX_CUSTOM_METADATA_FIELD_VALUE_BYTES => 4096,
            ServiceConstants_Values::MAX_CUSTOM_METADATA_TOTAL_SIZE_BYTES => 8192,
            ServiceConstants_Values::MAX_BUCKET_METADATA_TOTAL_SIZE_BYTES => 20480,
            ServiceConstants_Values::MAX_NOTIFICATION_CONFIGS_PER_BUCKET => 100,
            ServiceConstants_Values::MAX_LIFECYCLE_RULES_PER_BUCKET => 100,
            ServiceConstants_Values::MAX_NOTIFICATION_CUSTOM_ATTRIBUTES => 5,
            ServiceConstants_Values::MAX_NOTIFICATION_CUSTOM_ATTRIBUTE_KEY_LENGTH => 256,
            ServiceConstants_Values::MAX_NOTIFICATION_CUSTOM_ATTRIBUTE_VALUE_LENGTH => 1024,
            ServiceConstants_Values::MAX_LABELS_ENTRIES_COUNT => 64,
            ServiceConstants_Values::MAX_LABELS_KEY_VALUE_LENGTH => 63,
            ServiceConstants_Values::MAX_LABELS_KEY_VALUE_BYTES => 128,
            ServiceConstants_Values::MAX_OBJECT_IDS_PER_DELETE_OBJECTS_REQUEST => 1000,
            ServiceConstants_Values::SPLIT_TOKEN_MAX_VALID_DAYS => 14,
        }
    }

    fn from_i32(value: i32) -> ::std::option::Option<ServiceConstants_Values> {
        match value {
            0 => ::std::option::Option::Some(ServiceConstants_Values::VALUES_UNSPECIFIED),
            2097152 => ::std::option::Option::Some(ServiceConstants_Values::MAX_READ_CHUNK_BYTES),
            5242880 => ::std::option::Option::Some(ServiceConstants_Values::MAX_OBJECT_SIZE_MB),
            1024 => ::std::option::Option::Some(ServiceConstants_Values::MAX_CUSTOM_METADATA_FIELD_NAME_BYTES),
            4096 => ::std::option::Option::Some(ServiceConstants_Values::MAX_CUSTOM_METADATA_FIELD_VALUE_BYTES),
            8192 => ::std::option::Option::Some(ServiceConstants_Values::MAX_CUSTOM_METADATA_TOTAL_SIZE_BYTES),
            20480 => ::std::option::Option::Some(ServiceConstants_Values::MAX_BUCKET_METADATA_TOTAL_SIZE_BYTES),
            100 => ::std::option::Option::Some(ServiceConstants_Values::MAX_NOTIFICATION_CONFIGS_PER_BUCKET),
            5 => ::std::option::Option::Some(ServiceConstants_Values::MAX_NOTIFICATION_CUSTOM_ATTRIBUTES),
            256 => ::std::option::Option::Some(ServiceConstants_Values::MAX_NOTIFICATION_CUSTOM_ATTRIBUTE_KEY_LENGTH),
            64 => ::std::option::Option::Some(ServiceConstants_Values::MAX_LABELS_ENTRIES_COUNT),
            63 => ::std::option::Option::Some(ServiceConstants_Values::MAX_LABELS_KEY_VALUE_LENGTH),
            128 => ::std::option::Option::Some(ServiceConstants_Values::MAX_LABELS_KEY_VALUE_BYTES),
            1000 => ::std::option::Option::Some(ServiceConstants_Values::MAX_OBJECT_IDS_PER_DELETE_OBJECTS_REQUEST),
            14 => ::std::option::Option::Some(ServiceConstants_Values::SPLIT_TOKEN_MAX_VALID_DAYS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ServiceConstants_Values] = &[
            ServiceConstants_Values::VALUES_UNSPECIFIED,
            ServiceConstants_Values::MAX_READ_CHUNK_BYTES,
            ServiceConstants_Values::MAX_WRITE_CHUNK_BYTES,
            ServiceConstants_Values::MAX_OBJECT_SIZE_MB,
            ServiceConstants_Values::MAX_CUSTOM_METADATA_FIELD_NAME_BYTES,
            ServiceConstants_Values::MAX_CUSTOM_METADATA_FIELD_VALUE_BYTES,
            ServiceConstants_Values::MAX_CUSTOM_METADATA_TOTAL_SIZE_BYTES,
            ServiceConstants_Values::MAX_BUCKET_METADATA_TOTAL_SIZE_BYTES,
            ServiceConstants_Values::MAX_NOTIFICATION_CONFIGS_PER_BUCKET,
            ServiceConstants_Values::MAX_LIFECYCLE_RULES_PER_BUCKET,
            ServiceConstants_Values::MAX_NOTIFICATION_CUSTOM_ATTRIBUTES,
            ServiceConstants_Values::MAX_NOTIFICATION_CUSTOM_ATTRIBUTE_KEY_LENGTH,
            ServiceConstants_Values::MAX_NOTIFICATION_CUSTOM_ATTRIBUTE_VALUE_LENGTH,
            ServiceConstants_Values::MAX_LABELS_ENTRIES_COUNT,
            ServiceConstants_Values::MAX_LABELS_KEY_VALUE_LENGTH,
            ServiceConstants_Values::MAX_LABELS_KEY_VALUE_BYTES,
            ServiceConstants_Values::MAX_OBJECT_IDS_PER_DELETE_OBJECTS_REQUEST,
            ServiceConstants_Values::SPLIT_TOKEN_MAX_VALID_DAYS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ServiceConstants_Values>("ServiceConstants.Values", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ServiceConstants_Values {
}

impl ::std::default::Default for ServiceConstants_Values {
    fn default() -> Self {
        ServiceConstants_Values::VALUES_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceConstants_Values {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1fgoogle/storage/v1/storage.proto\x12\x11google.storage.v1\x1a\x1fgo\
    ogle/api/field_behavior.proto\x1a\x1egoogle/iam/v1/iam_policy.proto\x1a\
    \x1agoogle/iam/v1/policy.proto\x1a\x1bgoogle/protobuf/empty.proto\x1a\
    \x20google/protobuf/field_mask.proto\x1a\x1egoogle/protobuf/wrappers.pro\
    to\x1a)google/storage/v1/storage_resources.proto\x1a\x17google/api/clien\
    t.proto\"\xb8\x01\n\x20DeleteBucketAccessControlRequest\x12\x1b\n\x06buc\
    ket\x18\x01\x20\x01(\tR\x06bucketB\x03\xe0A\x02\x12\x1b\n\x06entity\x18\
    \x02\x20\x01(\tR\x06entityB\x03\xe0A\x02\x12Z\n\x15common_request_params\
    \x18\x04\x20\x01(\x0b2&.google.storage.v1.CommonRequestParamsR\x13common\
    RequestParams\"\xb5\x01\n\x1dGetBucketAccessControlRequest\x12\x1b\n\x06\
    bucket\x18\x01\x20\x01(\tR\x06bucketB\x03\xe0A\x02\x12\x1b\n\x06entity\
    \x18\x02\x20\x01(\tR\x06entityB\x03\xe0A\x02\x12Z\n\x15common_request_pa\
    rams\x18\x04\x20\x01(\x0b2&.google.storage.v1.CommonRequestParamsR\x13co\
    mmonRequestParams\"\xf7\x01\n\x20InsertBucketAccessControlRequest\x12\
    \x1b\n\x06bucket\x18\x01\x20\x01(\tR\x06bucketB\x03\xe0A\x02\x12Z\n\x15b\
    ucket_access_control\x18\x03\x20\x01(\x0b2&.google.storage.v1.BucketAcce\
    ssControlR\x13bucketAccessControl\x12Z\n\x15common_request_params\x18\
    \x04\x20\x01(\x0b2&.google.storage.v1.CommonRequestParamsR\x13commonRequ\
    estParams\"\x9a\x01\n\x1fListBucketAccessControlsRequest\x12\x1b\n\x06bu\
    cket\x18\x01\x20\x01(\tR\x06bucketB\x03\xe0A\x02\x12Z\n\x15common_reques\
    t_params\x18\x03\x20\x01(\x0b2&.google.storage.v1.CommonRequestParamsR\
    \x13commonRequestParams\"\xd0\x02\n\x1fPatchBucketAccessControlRequest\
    \x12\x1b\n\x06bucket\x18\x01\x20\x01(\tR\x06bucketB\x03\xe0A\x02\x12\x1b\
    \n\x06entity\x18\x02\x20\x01(\tR\x06entityB\x03\xe0A\x02\x12Z\n\x15bucke\
    t_access_control\x18\x04\x20\x01(\x0b2&.google.storage.v1.BucketAccessCo\
    ntrolR\x13bucketAccessControl\x12;\n\x0bupdate_mask\x18\x05\x20\x01(\x0b\
    2\x1a.google.protobuf.FieldMaskR\nupdateMask\x12Z\n\x15common_request_pa\
    rams\x18\x06\x20\x01(\x0b2&.google.storage.v1.CommonRequestParamsR\x13co\
    mmonRequestParams\"\x94\x02\n\x20UpdateBucketAccessControlRequest\x12\
    \x1b\n\x06bucket\x18\x01\x20\x01(\tR\x06bucketB\x03\xe0A\x02\x12\x1b\n\
    \x06entity\x18\x02\x20\x01(\tR\x06entityB\x03\xe0A\x02\x12Z\n\x15bucket_\
    access_control\x18\x04\x20\x01(\x0b2&.google.storage.v1.BucketAccessCont\
    rolR\x13bucketAccessControl\x12Z\n\x15common_request_params\x18\x05\x20\
    \x01(\x0b2&.google.storage.v1.CommonRequestParamsR\x13commonRequestParam\
    s\"\xbf\x02\n\x13DeleteBucketRequest\x12\x1b\n\x06bucket\x18\x01\x20\x01\
    (\tR\x06bucketB\x03\xe0A\x02\x12S\n\x17if_metageneration_match\x18\x02\
    \x20\x01(\x0b2\x1b.google.protobuf.Int64ValueR\x15ifMetagenerationMatch\
    \x12Z\n\x1bif_metageneration_not_match\x18\x03\x20\x01(\x0b2\x1b.google.\
    protobuf.Int64ValueR\x18ifMetagenerationNotMatch\x12Z\n\x15common_reques\
    t_params\x18\x05\x20\x01(\x0b2&.google.storage.v1.CommonRequestParamsR\
    \x13commonRequestParams\"\x87\x03\n\x10GetBucketRequest\x12\x1b\n\x06buc\
    ket\x18\x01\x20\x01(\tR\x06bucketB\x03\xe0A\x02\x12S\n\x17if_metagenerat\
    ion_match\x18\x02\x20\x01(\x0b2\x1b.google.protobuf.Int64ValueR\x15ifMet\
    agenerationMatch\x12Z\n\x1bif_metageneration_not_match\x18\x03\x20\x01(\
    \x0b2\x1b.google.protobuf.Int64ValueR\x18ifMetagenerationNotMatch\x12I\n\
    \nprojection\x18\x04\x20\x01(\x0e2).google.storage.v1.CommonEnums.Projec\
    tionR\nprojection\x12Z\n\x15common_request_params\x18\x06\x20\x01(\x0b2&\
    .google.storage.v1.CommonRequestParamsR\x13commonRequestParams\"\xe0\x03\
    \n\x13InsertBucketRequest\x12Y\n\x0epredefined_acl\x18\x01\x20\x01(\x0e2\
    2.google.storage.v1.CommonEnums.PredefinedBucketAclR\rpredefinedAcl\x12u\
    \n\x1dpredefined_default_object_acl\x18\x02\x20\x01(\x0e22.google.storag\
    e.v1.CommonEnums.PredefinedObjectAclR\x1apredefinedDefaultObjectAcl\x12\
    \x1d\n\x07project\x18\x03\x20\x01(\tR\x07projectB\x03\xe0A\x02\x12I\n\np\
    rojection\x18\x04\x20\x01(\x0e2).google.storage.v1.CommonEnums.Projectio\
    nR\nprojection\x121\n\x06bucket\x18\x06\x20\x01(\x0b2\x19.google.storage\
    .v1.BucketR\x06bucket\x12Z\n\x15common_request_params\x18\x07\x20\x01(\
    \x0b2&.google.storage.v1.CommonRequestParamsR\x13commonRequestParams\"\
    \x8e\x01\n\x13ListChannelsRequest\x12\x1b\n\x06bucket\x18\x01\x20\x01(\t\
    R\x06bucketB\x03\xe0A\x02\x12Z\n\x15common_request_params\x18\x03\x20\
    \x01(\x0b2&.google.storage.v1.CommonRequestParamsR\x13commonRequestParam\
    s\"\xb2\x02\n\x12ListBucketsRequest\x12\x1f\n\x0bmax_results\x18\x01\x20\
    \x01(\x05R\nmaxResults\x12\x1d\n\npage_token\x18\x02\x20\x01(\tR\tpageTo\
    ken\x12\x16\n\x06prefix\x18\x03\x20\x01(\tR\x06prefix\x12\x1d\n\x07proje\
    ct\x18\x04\x20\x01(\tR\x07projectB\x03\xe0A\x02\x12I\n\nprojection\x18\
    \x05\x20\x01(\x0e2).google.storage.v1.CommonEnums.ProjectionR\nprojectio\
    n\x12Z\n\x15common_request_params\x18\x07\x20\x01(\x0b2&.google.storage.\
    v1.CommonRequestParamsR\x13commonRequestParams\"\xcd\x01\n\x1aLockRetent\
    ionPolicyRequest\x12\x1b\n\x06bucket\x18\x01\x20\x01(\tR\x06bucketB\x03\
    \xe0A\x02\x126\n\x17if_metageneration_match\x18\x02\x20\x01(\x03R\x15ifM\
    etagenerationMatch\x12Z\n\x15common_request_params\x18\x04\x20\x01(\x0b2\
    &.google.storage.v1.CommonRequestParamsR\x13commonRequestParams\"\xcf\
    \x05\n\x12PatchBucketRequest\x12\x1b\n\x06bucket\x18\x01\x20\x01(\tR\x06\
    bucketB\x03\xe0A\x02\x12S\n\x17if_metageneration_match\x18\x02\x20\x01(\
    \x0b2\x1b.google.protobuf.Int64ValueR\x15ifMetagenerationMatch\x12Z\n\
    \x1bif_metageneration_not_match\x18\x03\x20\x01(\x0b2\x1b.google.protobu\
    f.Int64ValueR\x18ifMetagenerationNotMatch\x12Y\n\x0epredefined_acl\x18\
    \x04\x20\x01(\x0e22.google.storage.v1.CommonEnums.PredefinedBucketAclR\r\
    predefinedAcl\x12u\n\x1dpredefined_default_object_acl\x18\x05\x20\x01(\
    \x0e22.google.storage.v1.CommonEnums.PredefinedObjectAclR\x1apredefinedD\
    efaultObjectAcl\x12I\n\nprojection\x18\x06\x20\x01(\x0e2).google.storage\
    .v1.CommonEnums.ProjectionR\nprojection\x125\n\x08metadata\x18\x08\x20\
    \x01(\x0b2\x19.google.storage.v1.BucketR\x08metadata\x12;\n\x0bupdate_ma\
    sk\x18\t\x20\x01(\x0b2\x1a.google.protobuf.FieldMaskR\nupdateMask\x12Z\n\
    \x15common_request_params\x18\n\x20\x01(\x0b2&.google.storage.v1.CommonR\
    equestParamsR\x13commonRequestParams\"\x93\x05\n\x13UpdateBucketRequest\
    \x12\x1b\n\x06bucket\x18\x01\x20\x01(\tR\x06bucketB\x03\xe0A\x02\x12S\n\
    \x17if_metageneration_match\x18\x02\x20\x01(\x0b2\x1b.google.protobuf.In\
    t64ValueR\x15ifMetagenerationMatch\x12Z\n\x1bif_metageneration_not_match\
    \x18\x03\x20\x01(\x0b2\x1b.google.protobuf.Int64ValueR\x18ifMetagenerati\
    onNotMatch\x12Y\n\x0epredefined_acl\x18\x04\x20\x01(\x0e22.google.storag\
    e.v1.CommonEnums.PredefinedBucketAclR\rpredefinedAcl\x12u\n\x1dpredefine\
    d_default_object_acl\x18\x05\x20\x01(\x0e22.google.storage.v1.CommonEnum\
    s.PredefinedObjectAclR\x1apredefinedDefaultObjectAcl\x12I\n\nprojection\
    \x18\x06\x20\x01(\x0e2).google.storage.v1.CommonEnums.ProjectionR\nproje\
    ction\x125\n\x08metadata\x18\x08\x20\x01(\x0b2\x19.google.storage.v1.Buc\
    ketR\x08metadata\x12Z\n\x15common_request_params\x18\t\x20\x01(\x0b2&.go\
    ogle.storage.v1.CommonRequestParamsR\x13commonRequestParams\"\xa6\x01\n\
    \x12StopChannelRequest\x124\n\x07channel\x18\x01\x20\x01(\x0b2\x1a.googl\
    e.storage.v1.ChannelR\x07channel\x12Z\n\x15common_request_params\x18\x02\
    \x20\x01(\x0b2&.google.storage.v1.CommonRequestParamsR\x13commonRequestP\
    arams\"\xbf\x01\n'DeleteDefaultObjectAccessControlRequest\x12\x1b\n\x06b\
    ucket\x18\x01\x20\x01(\tR\x06bucketB\x03\xe0A\x02\x12\x1b\n\x06entity\
    \x18\x02\x20\x01(\tR\x06entityB\x03\xe0A\x02\x12Z\n\x15common_request_pa\
    rams\x18\x04\x20\x01(\x0b2&.google.storage.v1.CommonRequestParamsR\x13co\
    mmonRequestParams\"\xbc\x01\n$GetDefaultObjectAccessControlRequest\x12\
    \x1b\n\x06bucket\x18\x01\x20\x01(\tR\x06bucketB\x03\xe0A\x02\x12\x1b\n\
    \x06entity\x18\x02\x20\x01(\tR\x06entityB\x03\xe0A\x02\x12Z\n\x15common_\
    request_params\x18\x04\x20\x01(\x0b2&.google.storage.v1.CommonRequestPar\
    amsR\x13commonRequestParams\"\xfe\x01\n'InsertDefaultObjectAccessControl\
    Request\x12\x1b\n\x06bucket\x18\x01\x20\x01(\tR\x06bucketB\x03\xe0A\x02\
    \x12Z\n\x15object_access_control\x18\x03\x20\x01(\x0b2&.google.storage.v\
    1.ObjectAccessControlR\x13objectAccessControl\x12Z\n\x15common_request_p\
    arams\x18\x04\x20\x01(\x0b2&.google.storage.v1.CommonRequestParamsR\x13c\
    ommonRequestParams\"\xd2\x02\n&ListDefaultObjectAccessControlsRequest\
    \x12\x1b\n\x06bucket\x18\x01\x20\x01(\tR\x06bucketB\x03\xe0A\x02\x12S\n\
    \x17if_metageneration_match\x18\x02\x20\x01(\x0b2\x1b.google.protobuf.In\
    t64ValueR\x15ifMetagenerationMatch\x12Z\n\x1bif_metageneration_not_match\
    \x18\x03\x20\x01(\x0b2\x1b.google.protobuf.Int64ValueR\x18ifMetagenerati\
    onNotMatch\x12Z\n\x15common_request_params\x18\x05\x20\x01(\x0b2&.google\
    .storage.v1.CommonRequestParamsR\x13commonRequestParams\"\xd7\x02\n&Patc\
    hDefaultObjectAccessControlRequest\x12\x1b\n\x06bucket\x18\x01\x20\x01(\
    \tR\x06bucketB\x03\xe0A\x02\x12\x1b\n\x06entity\x18\x02\x20\x01(\tR\x06e\
    ntityB\x03\xe0A\x02\x12Z\n\x15object_access_control\x18\x04\x20\x01(\x0b\
    2&.google.storage.v1.ObjectAccessControlR\x13objectAccessControl\x12;\n\
    \x0bupdate_mask\x18\x05\x20\x01(\x0b2\x1a.google.protobuf.FieldMaskR\nup\
    dateMask\x12Z\n\x15common_request_params\x18\x06\x20\x01(\x0b2&.google.s\
    torage.v1.CommonRequestParamsR\x13commonRequestParams\"\x9b\x02\n'Update\
    DefaultObjectAccessControlRequest\x12\x1b\n\x06bucket\x18\x01\x20\x01(\t\
    R\x06bucketB\x03\xe0A\x02\x12\x1b\n\x06entity\x18\x02\x20\x01(\tR\x06ent\
    ityB\x03\xe0A\x02\x12Z\n\x15object_access_control\x18\x04\x20\x01(\x0b2&\
    .google.storage.v1.ObjectAccessControlR\x13objectAccessControl\x12Z\n\
    \x15common_request_params\x18\x05\x20\x01(\x0b2&.google.storage.v1.Commo\
    nRequestParamsR\x13commonRequestParams\"\xbd\x01\n\x19DeleteNotification\
    Request\x12\x1b\n\x06bucket\x18\x01\x20\x01(\tR\x06bucketB\x03\xe0A\x02\
    \x12'\n\x0cnotification\x18\x02\x20\x01(\tR\x0cnotificationB\x03\xe0A\
    \x02\x12Z\n\x15common_request_params\x18\x04\x20\x01(\x0b2&.google.stora\
    ge.v1.CommonRequestParamsR\x13commonRequestParams\"\xba\x01\n\x16GetNoti\
    ficationRequest\x12\x1b\n\x06bucket\x18\x01\x20\x01(\tR\x06bucketB\x03\
    \xe0A\x02\x12'\n\x0cnotification\x18\x02\x20\x01(\tR\x0cnotificationB\
    \x03\xe0A\x02\x12Z\n\x15common_request_params\x18\x04\x20\x01(\x0b2&.goo\
    gle.storage.v1.CommonRequestParamsR\x13commonRequestParams\"\xd9\x01\n\
    \x19InsertNotificationRequest\x12\x1b\n\x06bucket\x18\x01\x20\x01(\tR\
    \x06bucketB\x03\xe0A\x02\x12C\n\x0cnotification\x18\x03\x20\x01(\x0b2\
    \x1f.google.storage.v1.NotificationR\x0cnotification\x12Z\n\x15common_re\
    quest_params\x18\x04\x20\x01(\x0b2&.google.storage.v1.CommonRequestParam\
    sR\x13commonRequestParams\"\x93\x01\n\x18ListNotificationsRequest\x12\
    \x1b\n\x06bucket\x18\x01\x20\x01(\tR\x06bucketB\x03\xe0A\x02\x12Z\n\x15c\
    ommon_request_params\x18\x03\x20\x01(\x0b2&.google.storage.v1.CommonRequ\
    estParamsR\x13commonRequestParams\"\xf5\x01\n\x20DeleteObjectAccessContr\
    olRequest\x12\x1b\n\x06bucket\x18\x01\x20\x01(\tR\x06bucketB\x03\xe0A\
    \x02\x12\x1b\n\x06entity\x18\x02\x20\x01(\tR\x06entityB\x03\xe0A\x02\x12\
    \x1b\n\x06object\x18\x03\x20\x01(\tR\x06objectB\x03\xe0A\x02\x12\x1e\n\n\
    generation\x18\x04\x20\x01(\x03R\ngeneration\x12Z\n\x15common_request_pa\
    rams\x18\x06\x20\x01(\x0b2&.google.storage.v1.CommonRequestParamsR\x13co\
    mmonRequestParams\"\xf2\x01\n\x1dGetObjectAccessControlRequest\x12\x1b\n\
    \x06bucket\x18\x01\x20\x01(\tR\x06bucketB\x03\xe0A\x02\x12\x1b\n\x06enti\
    ty\x18\x02\x20\x01(\tR\x06entityB\x03\xe0A\x02\x12\x1b\n\x06object\x18\
    \x03\x20\x01(\tR\x06objectB\x03\xe0A\x02\x12\x1e\n\ngeneration\x18\x04\
    \x20\x01(\x03R\ngeneration\x12Z\n\x15common_request_params\x18\x06\x20\
    \x01(\x0b2&.google.storage.v1.CommonRequestParamsR\x13commonRequestParam\
    s\"\xb4\x02\n\x20InsertObjectAccessControlRequest\x12\x1b\n\x06bucket\
    \x18\x01\x20\x01(\tR\x06bucketB\x03\xe0A\x02\x12\x1b\n\x06object\x18\x02\
    \x20\x01(\tR\x06objectB\x03\xe0A\x02\x12\x1e\n\ngeneration\x18\x03\x20\
    \x01(\x03R\ngeneration\x12Z\n\x15object_access_control\x18\x05\x20\x01(\
    \x0b2&.google.storage.v1.ObjectAccessControlR\x13objectAccessControl\x12\
    Z\n\x15common_request_params\x18\x06\x20\x01(\x0b2&.google.storage.v1.Co\
    mmonRequestParamsR\x13commonRequestParams\"\xd7\x01\n\x1fListObjectAcces\
    sControlsRequest\x12\x1b\n\x06bucket\x18\x01\x20\x01(\tR\x06bucketB\x03\
    \xe0A\x02\x12\x1b\n\x06object\x18\x02\x20\x01(\tR\x06objectB\x03\xe0A\
    \x02\x12\x1e\n\ngeneration\x18\x03\x20\x01(\x03R\ngeneration\x12Z\n\x15c\
    ommon_request_params\x18\x05\x20\x01(\x0b2&.google.storage.v1.CommonRequ\
    estParamsR\x13commonRequestParams\"\x8d\x03\n\x1fPatchObjectAccessContro\
    lRequest\x12\x1b\n\x06bucket\x18\x01\x20\x01(\tR\x06bucketB\x03\xe0A\x02\
    \x12\x1b\n\x06entity\x18\x02\x20\x01(\tR\x06entityB\x03\xe0A\x02\x12\x1b\
    \n\x06object\x18\x03\x20\x01(\tR\x06objectB\x03\xe0A\x02\x12\x1e\n\ngene\
    ration\x18\x04\x20\x01(\x03R\ngeneration\x12Z\n\x15object_access_control\
    \x18\x05\x20\x01(\x0b2&.google.storage.v1.ObjectAccessControlR\x13object\
    AccessControl\x12Z\n\x15common_request_params\x18\x06\x20\x01(\x0b2&.goo\
    gle.storage.v1.CommonRequestParamsR\x13commonRequestParams\x12;\n\x0bupd\
    ate_mask\x18\x07\x20\x01(\x0b2\x1a.google.protobuf.FieldMaskR\nupdateMas\
    k\"\x8e\x03\n\x20UpdateObjectAccessControlRequest\x12\x1b\n\x06bucket\
    \x18\x01\x20\x01(\tR\x06bucketB\x03\xe0A\x02\x12\x1b\n\x06entity\x18\x02\
    \x20\x01(\tR\x06entityB\x03\xe0A\x02\x12\x1b\n\x06object\x18\x03\x20\x01\
    (\tR\x06objectB\x03\xe0A\x02\x12\x1e\n\ngeneration\x18\x04\x20\x01(\x03R\
    \ngeneration\x12Z\n\x15object_access_control\x18\x06\x20\x01(\x0b2&.goog\
    le.storage.v1.ObjectAccessControlR\x13objectAccessControl\x12Z\n\x15comm\
    on_request_params\x18\x07\x20\x01(\x0b2&.google.storage.v1.CommonRequest\
    ParamsR\x13commonRequestParams\x12;\n\x0bupdate_mask\x18\x08\x20\x01(\
    \x0b2\x1a.google.protobuf.FieldMaskR\nupdateMask\"\xc2\x08\n\x14ComposeO\
    bjectRequest\x122\n\x12destination_bucket\x18\x01\x20\x01(\tR\x11destina\
    tionBucketB\x03\xe0A\x02\x122\n\x12destination_object\x18\x02\x20\x01(\t\
    R\x11destinationObjectB\x03\xe0A\x02\x12p\n\x1adestination_predefined_ac\
    l\x18\x03\x20\x01(\x0e22.google.storage.v1.CommonEnums.PredefinedObjectA\
    clR\x18destinationPredefinedAcl\x12;\n\x0bdestination\x18\x0b\x20\x01(\
    \x0b2\x19.google.storage.v1.ObjectR\x0bdestination\x12\\\n\x0esource_obj\
    ects\x18\x0c\x20\x03(\x0b25.google.storage.v1.ComposeObjectRequest.Sourc\
    eObjectsR\rsourceObjects\x12K\n\x13if_generation_match\x18\x04\x20\x01(\
    \x0b2\x1b.google.protobuf.Int64ValueR\x11ifGenerationMatch\x12S\n\x17if_\
    metageneration_match\x18\x05\x20\x01(\x0b2\x1b.google.protobuf.Int64Valu\
    eR\x15ifMetagenerationMatch\x12\x20\n\x0ckms_key_name\x18\x06\x20\x01(\t\
    R\nkmsKeyName\x12m\n\x1ccommon_object_request_params\x18\t\x20\x01(\x0b2\
    ,.google.storage.v1.CommonObjectRequestParamsR\x19commonObjectRequestPar\
    ams\x12Z\n\x15common_request_params\x18\n\x20\x01(\x0b2&.google.storage.\
    v1.CommonRequestParamsR\x13commonRequestParams\x1a\xa5\x02\n\rSourceObje\
    cts\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x1e\n\ngeneration\
    \x18\x02\x20\x01(\x03R\ngeneration\x12|\n\x14object_preconditions\x18\
    \x03\x20\x01(\x0b2I.google.storage.v1.ComposeObjectRequest.SourceObjects\
    .ObjectPreconditionsR\x13objectPreconditions\x1ab\n\x13ObjectPreconditio\
    ns\x12K\n\x13if_generation_match\x18\x01\x20\x01(\x0b2\x1b.google.protob\
    uf.Int64ValueR\x11ifGenerationMatch\"\xd2\x0b\n\x11CopyObjectRequest\x12\
    2\n\x12destination_bucket\x18\x01\x20\x01(\tR\x11destinationBucketB\x03\
    \xe0A\x02\x122\n\x12destination_object\x18\x02\x20\x01(\tR\x11destinatio\
    nObjectB\x03\xe0A\x02\x12p\n\x1adestination_predefined_acl\x18\x03\x20\
    \x01(\x0e22.google.storage.v1.CommonEnums.PredefinedObjectAclR\x18destin\
    ationPredefinedAcl\x12K\n\x13if_generation_match\x18\x04\x20\x01(\x0b2\
    \x1b.google.protobuf.Int64ValueR\x11ifGenerationMatch\x12R\n\x17if_gener\
    ation_not_match\x18\x05\x20\x01(\x0b2\x1b.google.protobuf.Int64ValueR\
    \x14ifGenerationNotMatch\x12S\n\x17if_metageneration_match\x18\x06\x20\
    \x01(\x0b2\x1b.google.protobuf.Int64ValueR\x15ifMetagenerationMatch\x12Z\
    \n\x1bif_metageneration_not_match\x18\x07\x20\x01(\x0b2\x1b.google.proto\
    buf.Int64ValueR\x18ifMetagenerationNotMatch\x12X\n\x1aif_source_generati\
    on_match\x18\x08\x20\x01(\x0b2\x1b.google.protobuf.Int64ValueR\x17ifSour\
    ceGenerationMatch\x12_\n\x1eif_source_generation_not_match\x18\t\x20\x01\
    (\x0b2\x1b.google.protobuf.Int64ValueR\x1aifSourceGenerationNotMatch\x12\
    `\n\x1eif_source_metageneration_match\x18\n\x20\x01(\x0b2\x1b.google.pro\
    tobuf.Int64ValueR\x1bifSourceMetagenerationMatch\x12g\n\"if_source_metag\
    eneration_not_match\x18\x0b\x20\x01(\x0b2\x1b.google.protobuf.Int64Value\
    R\x1eifSourceMetagenerationNotMatch\x12I\n\nprojection\x18\x0c\x20\x01(\
    \x0e2).google.storage.v1.CommonEnums.ProjectionR\nprojection\x12(\n\rsou\
    rce_bucket\x18\r\x20\x01(\tR\x0csourceBucketB\x03\xe0A\x02\x12(\n\rsourc\
    e_object\x18\x0e\x20\x01(\tR\x0csourceObjectB\x03\xe0A\x02\x12+\n\x11sou\
    rce_generation\x18\x0f\x20\x01(\x03R\x10sourceGeneration\x12;\n\x0bdesti\
    nation\x18\x11\x20\x01(\x0b2\x19.google.storage.v1.ObjectR\x0bdestinatio\
    n\x127\n\x18destination_kms_key_name\x18\x14\x20\x01(\tR\x15destinationK\
    msKeyName\x12m\n\x1ccommon_object_request_params\x18\x12\x20\x01(\x0b2,.\
    google.storage.v1.CommonObjectRequestParamsR\x19commonObjectRequestParam\
    s\x12Z\n\x15common_request_params\x18\x13\x20\x01(\x0b2&.google.storage.\
    v1.CommonRequestParamsR\x13commonRequestParams\"\xa9\x05\n\x13DeleteObje\
    ctRequest\x12\x1b\n\x06bucket\x18\x01\x20\x01(\tR\x06bucketB\x03\xe0A\
    \x02\x12\x1b\n\x06object\x18\x02\x20\x01(\tR\x06objectB\x03\xe0A\x02\x12\
    \x1b\n\tupload_id\x18\x03\x20\x01(\tR\x08uploadId\x12\x1e\n\ngeneration\
    \x18\x04\x20\x01(\x03R\ngeneration\x12K\n\x13if_generation_match\x18\x05\
    \x20\x01(\x0b2\x1b.google.protobuf.Int64ValueR\x11ifGenerationMatch\x12R\
    \n\x17if_generation_not_match\x18\x06\x20\x01(\x0b2\x1b.google.protobuf.\
    Int64ValueR\x14ifGenerationNotMatch\x12S\n\x17if_metageneration_match\
    \x18\x07\x20\x01(\x0b2\x1b.google.protobuf.Int64ValueR\x15ifMetagenerati\
    onMatch\x12Z\n\x1bif_metageneration_not_match\x18\x08\x20\x01(\x0b2\x1b.\
    google.protobuf.Int64ValueR\x18ifMetagenerationNotMatch\x12m\n\x1ccommon\
    _object_request_params\x18\n\x20\x01(\x0b2,.google.storage.v1.CommonObje\
    ctRequestParamsR\x19commonObjectRequestParams\x12Z\n\x15common_request_p\
    arams\x18\x0b\x20\x01(\x0b2&.google.storage.v1.CommonRequestParamsR\x13c\
    ommonRequestParams\"\xc4\x05\n\x15GetObjectMediaRequest\x12\x16\n\x06buc\
    ket\x18\x01\x20\x01(\tR\x06bucket\x12\x16\n\x06object\x18\x02\x20\x01(\t\
    R\x06object\x12\x1e\n\ngeneration\x18\x03\x20\x01(\x03R\ngeneration\x12\
    \x1f\n\x0bread_offset\x18\x04\x20\x01(\x03R\nreadOffset\x12\x1d\n\nread_\
    limit\x18\x05\x20\x01(\x03R\treadLimit\x12K\n\x13if_generation_match\x18\
    \x06\x20\x01(\x0b2\x1b.google.protobuf.Int64ValueR\x11ifGenerationMatch\
    \x12R\n\x17if_generation_not_match\x18\x07\x20\x01(\x0b2\x1b.google.prot\
    obuf.Int64ValueR\x14ifGenerationNotMatch\x12S\n\x17if_metageneration_mat\
    ch\x18\x08\x20\x01(\x0b2\x1b.google.protobuf.Int64ValueR\x15ifMetagenera\
    tionMatch\x12Z\n\x1bif_metageneration_not_match\x18\t\x20\x01(\x0b2\x1b.\
    google.protobuf.Int64ValueR\x18ifMetagenerationNotMatch\x12m\n\x1ccommon\
    _object_request_params\x18\x0b\x20\x01(\x0b2,.google.storage.v1.CommonOb\
    jectRequestParamsR\x19commonObjectRequestParams\x12Z\n\x15common_request\
    _params\x18\x0c\x20\x01(\x0b2&.google.storage.v1.CommonRequestParamsR\
    \x13commonRequestParams\"\xd4\x05\n\x10GetObjectRequest\x12\x1b\n\x06buc\
    ket\x18\x01\x20\x01(\tR\x06bucketB\x03\xe0A\x02\x12\x1b\n\x06object\x18\
    \x02\x20\x01(\tR\x06objectB\x03\xe0A\x02\x12\x1e\n\ngeneration\x18\x03\
    \x20\x01(\x03R\ngeneration\x12K\n\x13if_generation_match\x18\x04\x20\x01\
    (\x0b2\x1b.google.protobuf.Int64ValueR\x11ifGenerationMatch\x12R\n\x17if\
    _generation_not_match\x18\x05\x20\x01(\x0b2\x1b.google.protobuf.Int64Val\
    ueR\x14ifGenerationNotMatch\x12S\n\x17if_metageneration_match\x18\x06\
    \x20\x01(\x0b2\x1b.google.protobuf.Int64ValueR\x15ifMetagenerationMatch\
    \x12Z\n\x1bif_metageneration_not_match\x18\x07\x20\x01(\x0b2\x1b.google.\
    protobuf.Int64ValueR\x18ifMetagenerationNotMatch\x12I\n\nprojection\x18\
    \x08\x20\x01(\x0e2).google.storage.v1.CommonEnums.ProjectionR\nprojectio\
    n\x12m\n\x1ccommon_object_request_params\x18\n\x20\x01(\x0b2,.google.sto\
    rage.v1.CommonObjectRequestParamsR\x19commonObjectRequestParams\x12Z\n\
    \x15common_request_params\x18\x0b\x20\x01(\x0b2&.google.storage.v1.Commo\
    nRequestParamsR\x13commonRequestParams\"\xb3\x02\n\x16GetObjectMediaResp\
    onse\x12M\n\x10checksummed_data\x18\x01\x20\x01(\x0b2\".google.storage.v\
    1.ChecksummedDataR\x0fchecksummedData\x12M\n\x10object_checksums\x18\x02\
    \x20\x01(\x0b2\".google.storage.v1.ObjectChecksumsR\x0fobjectChecksums\
    \x12D\n\rcontent_range\x18\x03\x20\x01(\x0b2\x1f.google.storage.v1.Conte\
    ntRangeR\x0ccontentRange\x125\n\x08metadata\x18\x04\x20\x01(\x0b2\x19.go\
    ogle.storage.v1.ObjectR\x08metadata\"\xc1\x04\n\x10InsertObjectSpec\x125\
    \n\x08resource\x18\x01\x20\x01(\x0b2\x19.google.storage.v1.ObjectR\x08re\
    source\x12Y\n\x0epredefined_acl\x18\x02\x20\x01(\x0e22.google.storage.v1\
    .CommonEnums.PredefinedObjectAclR\rpredefinedAcl\x12K\n\x13if_generation\
    _match\x18\x03\x20\x01(\x0b2\x1b.google.protobuf.Int64ValueR\x11ifGenera\
    tionMatch\x12R\n\x17if_generation_not_match\x18\x04\x20\x01(\x0b2\x1b.go\
    ogle.protobuf.Int64ValueR\x14ifGenerationNotMatch\x12S\n\x17if_metagener\
    ation_match\x18\x05\x20\x01(\x0b2\x1b.google.protobuf.Int64ValueR\x15ifM\
    etagenerationMatch\x12Z\n\x1bif_metageneration_not_match\x18\x06\x20\x01\
    (\x0b2\x1b.google.protobuf.Int64ValueR\x18ifMetagenerationNotMatch\x12I\
    \n\nprojection\x18\x07\x20\x01(\x0e2).google.storage.v1.CommonEnums.Proj\
    ectionR\nprojection\"\xa2\x05\n\x13InsertObjectRequest\x12\x1d\n\tupload\
    _id\x18\x01\x20\x01(\tH\0R\x08uploadId\x12S\n\x12insert_object_spec\x18\
    \x02\x20\x01(\x0b2#.google.storage.v1.InsertObjectSpecH\0R\x10insertObje\
    ctSpec\x12&\n\x0cwrite_offset\x18\x03\x20\x01(\x03R\x0bwriteOffsetB\x03\
    \xe0A\x02\x12O\n\x10checksummed_data\x18\x04\x20\x01(\x0b2\".google.stor\
    age.v1.ChecksummedDataH\x01R\x0fchecksummedData\x12H\n\treference\x18\
    \x05\x20\x01(\x0b2(.google.storage.v1.GetObjectMediaRequestH\x01R\trefer\
    ence\x12M\n\x10object_checksums\x18\x06\x20\x01(\x0b2\".google.storage.v\
    1.ObjectChecksumsR\x0fobjectChecksums\x12!\n\x0cfinish_write\x18\x07\x20\
    \x01(\x08R\x0bfinishWrite\x12m\n\x1ccommon_object_request_params\x18\x08\
    \x20\x01(\x0b2,.google.storage.v1.CommonObjectRequestParamsR\x19commonOb\
    jectRequestParams\x12Z\n\x15common_request_params\x18\t\x20\x01(\x0b2&.g\
    oogle.storage.v1.CommonRequestParamsR\x13commonRequestParamsB\x0f\n\rfir\
    st_messageB\x06\n\x04data\"\xa8\x03\n\x12ListObjectsRequest\x12\x1b\n\
    \x06bucket\x18\x01\x20\x01(\tR\x06bucketB\x03\xe0A\x02\x12\x1c\n\tdelimi\
    ter\x18\x02\x20\x01(\tR\tdelimiter\x12<\n\x1ainclude_trailing_delimiter\
    \x18\x03\x20\x01(\x08R\x18includeTrailingDelimiter\x12\x1f\n\x0bmax_resu\
    lts\x18\x04\x20\x01(\x05R\nmaxResults\x12\x1d\n\npage_token\x18\x05\x20\
    \x01(\tR\tpageToken\x12\x16\n\x06prefix\x18\x06\x20\x01(\tR\x06prefix\
    \x12I\n\nprojection\x18\x07\x20\x01(\x0e2).google.storage.v1.CommonEnums\
    .ProjectionR\nprojection\x12\x1a\n\x08versions\x18\t\x20\x01(\x08R\x08ve\
    rsions\x12Z\n\x15common_request_params\x18\n\x20\x01(\x0b2&.google.stora\
    ge.v1.CommonRequestParamsR\x13commonRequestParams\"\x86\x02\n\x17QueryWr\
    iteStatusRequest\x12\x20\n\tupload_id\x18\x01\x20\x01(\tR\x08uploadIdB\
    \x03\xe0A\x02\x12m\n\x1ccommon_object_request_params\x18\x02\x20\x01(\
    \x0b2,.google.storage.v1.CommonObjectRequestParamsR\x19commonObjectReque\
    stParams\x12Z\n\x15common_request_params\x18\x03\x20\x01(\x0b2&.google.s\
    torage.v1.CommonRequestParamsR\x13commonRequestParams\"]\n\x18QueryWrite\
    StatusResponse\x12%\n\x0ecommitted_size\x18\x01\x20\x01(\x03R\rcommitted\
    Size\x12\x1a\n\x08complete\x18\x02\x20\x01(\x08R\x08complete\"\x80\x0e\n\
    \x14RewriteObjectRequest\x122\n\x12destination_bucket\x18\x01\x20\x01(\t\
    R\x11destinationBucketB\x03\xe0A\x02\x122\n\x12destination_object\x18\
    \x02\x20\x01(\tR\x11destinationObjectB\x03\xe0A\x02\x127\n\x18destinatio\
    n_kms_key_name\x18\x03\x20\x01(\tR\x15destinationKmsKeyName\x12p\n\x1ade\
    stination_predefined_acl\x18\x04\x20\x01(\x0e22.google.storage.v1.Common\
    Enums.PredefinedObjectAclR\x18destinationPredefinedAcl\x12K\n\x13if_gene\
    ration_match\x18\x05\x20\x01(\x0b2\x1b.google.protobuf.Int64ValueR\x11if\
    GenerationMatch\x12R\n\x17if_generation_not_match\x18\x06\x20\x01(\x0b2\
    \x1b.google.protobuf.Int64ValueR\x14ifGenerationNotMatch\x12S\n\x17if_me\
    tageneration_match\x18\x07\x20\x01(\x0b2\x1b.google.protobuf.Int64ValueR\
    \x15ifMetagenerationMatch\x12Z\n\x1bif_metageneration_not_match\x18\x08\
    \x20\x01(\x0b2\x1b.google.protobuf.Int64ValueR\x18ifMetagenerationNotMat\
    ch\x12X\n\x1aif_source_generation_match\x18\t\x20\x01(\x0b2\x1b.google.p\
    rotobuf.Int64ValueR\x17ifSourceGenerationMatch\x12_\n\x1eif_source_gener\
    ation_not_match\x18\n\x20\x01(\x0b2\x1b.google.protobuf.Int64ValueR\x1ai\
    fSourceGenerationNotMatch\x12`\n\x1eif_source_metageneration_match\x18\
    \x0b\x20\x01(\x0b2\x1b.google.protobuf.Int64ValueR\x1bifSourceMetagenera\
    tionMatch\x12g\n\"if_source_metageneration_not_match\x18\x0c\x20\x01(\
    \x0b2\x1b.google.protobuf.Int64ValueR\x1eifSourceMetagenerationNotMatch\
    \x12>\n\x1cmax_bytes_rewritten_per_call\x18\r\x20\x01(\x03R\x18maxBytesR\
    ewrittenPerCall\x12I\n\nprojection\x18\x0e\x20\x01(\x0e2).google.storage\
    .v1.CommonEnums.ProjectionR\nprojection\x12#\n\rrewrite_token\x18\x0f\
    \x20\x01(\tR\x0crewriteToken\x12(\n\rsource_bucket\x18\x10\x20\x01(\tR\
    \x0csourceBucketB\x03\xe0A\x02\x12(\n\rsource_object\x18\x11\x20\x01(\tR\
    \x0csourceObjectB\x03\xe0A\x02\x12+\n\x11source_generation\x18\x12\x20\
    \x01(\x03R\x10sourceGeneration\x121\n\x06object\x18\x14\x20\x01(\x0b2\
    \x19.google.storage.v1.ObjectR\x06object\x12G\n\x20copy_source_encryptio\
    n_algorithm\x18\x15\x20\x01(\tR\x1dcopySourceEncryptionAlgorithm\x12;\n\
    \x1acopy_source_encryption_key\x18\x16\x20\x01(\tR\x17copySourceEncrypti\
    onKey\x12H\n!copy_source_encryption_key_sha256\x18\x17\x20\x01(\tR\x1dco\
    pySourceEncryptionKeySha256\x12m\n\x1ccommon_object_request_params\x18\
    \x18\x20\x01(\x0b2,.google.storage.v1.CommonObjectRequestParamsR\x19comm\
    onObjectRequestParams\x12Z\n\x15common_request_params\x18\x19\x20\x01(\
    \x0b2&.google.storage.v1.CommonRequestParamsR\x13commonRequestParams\"\
    \xd6\x01\n\x0fRewriteResponse\x122\n\x15total_bytes_rewritten\x18\x01\
    \x20\x01(\x03R\x13totalBytesRewritten\x12\x1f\n\x0bobject_size\x18\x02\
    \x20\x01(\x03R\nobjectSize\x12\x12\n\x04done\x18\x03\x20\x01(\x08R\x04do\
    ne\x12#\n\rrewrite_token\x18\x04\x20\x01(\tR\x0crewriteToken\x125\n\x08r\
    esource\x18\x05\x20\x01(\x0b2\x19.google.storage.v1.ObjectR\x08resource\
    \"\xba\x02\n\x1aStartResumableWriteRequest\x12Q\n\x12insert_object_spec\
    \x18\x01\x20\x01(\x0b2#.google.storage.v1.InsertObjectSpecR\x10insertObj\
    ectSpec\x12m\n\x1ccommon_object_request_params\x18\x03\x20\x01(\x0b2,.go\
    ogle.storage.v1.CommonObjectRequestParamsR\x19commonObjectRequestParams\
    \x12Z\n\x15common_request_params\x18\x04\x20\x01(\x0b2&.google.storage.v\
    1.CommonRequestParamsR\x13commonRequestParams\":\n\x1bStartResumableWrit\
    eResponse\x12\x1b\n\tupload_id\x18\x01\x20\x01(\tR\x08uploadId\"\xa5\x07\
    \n\x12PatchObjectRequest\x12\x1b\n\x06bucket\x18\x01\x20\x01(\tR\x06buck\
    etB\x03\xe0A\x02\x12\x1b\n\x06object\x18\x02\x20\x01(\tR\x06objectB\x03\
    \xe0A\x02\x12\x1e\n\ngeneration\x18\x03\x20\x01(\x03R\ngeneration\x12K\n\
    \x13if_generation_match\x18\x04\x20\x01(\x0b2\x1b.google.protobuf.Int64V\
    alueR\x11ifGenerationMatch\x12R\n\x17if_generation_not_match\x18\x05\x20\
    \x01(\x0b2\x1b.google.protobuf.Int64ValueR\x14ifGenerationNotMatch\x12S\
    \n\x17if_metageneration_match\x18\x06\x20\x01(\x0b2\x1b.google.protobuf.\
    Int64ValueR\x15ifMetagenerationMatch\x12Z\n\x1bif_metageneration_not_mat\
    ch\x18\x07\x20\x01(\x0b2\x1b.google.protobuf.Int64ValueR\x18ifMetagenera\
    tionNotMatch\x12Y\n\x0epredefined_acl\x18\x08\x20\x01(\x0e22.google.stor\
    age.v1.CommonEnums.PredefinedObjectAclR\rpredefinedAcl\x12I\n\nprojectio\
    n\x18\t\x20\x01(\x0e2).google.storage.v1.CommonEnums.ProjectionR\nprojec\
    tion\x125\n\x08metadata\x18\x0b\x20\x01(\x0b2\x19.google.storage.v1.Obje\
    ctR\x08metadata\x12;\n\x0bupdate_mask\x18\x0c\x20\x01(\x0b2\x1a.google.p\
    rotobuf.FieldMaskR\nupdateMask\x12m\n\x1ccommon_object_request_params\
    \x18\r\x20\x01(\x0b2,.google.storage.v1.CommonObjectRequestParamsR\x19co\
    mmonObjectRequestParams\x12Z\n\x15common_request_params\x18\x0e\x20\x01(\
    \x0b2&.google.storage.v1.CommonRequestParamsR\x13commonRequestParams\"\
    \xe9\x06\n\x13UpdateObjectRequest\x12\x1b\n\x06bucket\x18\x01\x20\x01(\t\
    R\x06bucketB\x03\xe0A\x02\x12\x1b\n\x06object\x18\x02\x20\x01(\tR\x06obj\
    ectB\x03\xe0A\x02\x12\x1e\n\ngeneration\x18\x03\x20\x01(\x03R\ngeneratio\
    n\x12K\n\x13if_generation_match\x18\x04\x20\x01(\x0b2\x1b.google.protobu\
    f.Int64ValueR\x11ifGenerationMatch\x12R\n\x17if_generation_not_match\x18\
    \x05\x20\x01(\x0b2\x1b.google.protobuf.Int64ValueR\x14ifGenerationNotMat\
    ch\x12S\n\x17if_metageneration_match\x18\x06\x20\x01(\x0b2\x1b.google.pr\
    otobuf.Int64ValueR\x15ifMetagenerationMatch\x12Z\n\x1bif_metageneration_\
    not_match\x18\x07\x20\x01(\x0b2\x1b.google.protobuf.Int64ValueR\x18ifMet\
    agenerationNotMatch\x12Y\n\x0epredefined_acl\x18\x08\x20\x01(\x0e22.goog\
    le.storage.v1.CommonEnums.PredefinedObjectAclR\rpredefinedAcl\x12I\n\npr\
    ojection\x18\t\x20\x01(\x0e2).google.storage.v1.CommonEnums.ProjectionR\
    \nprojection\x125\n\x08metadata\x18\x0b\x20\x01(\x0b2\x19.google.storage\
    .v1.ObjectR\x08metadata\x12m\n\x1ccommon_object_request_params\x18\x0c\
    \x20\x01(\x0b2,.google.storage.v1.CommonObjectRequestParamsR\x19commonOb\
    jectRequestParams\x12Z\n\x15common_request_params\x18\r\x20\x01(\x0b2&.g\
    oogle.storage.v1.CommonRequestParamsR\x13commonRequestParams\"\xdd\x03\n\
    \x16WatchAllObjectsRequest\x12\x16\n\x06bucket\x18\x01\x20\x01(\tR\x06bu\
    cket\x12\x1a\n\x08versions\x18\x02\x20\x01(\x08R\x08versions\x12\x1c\n\t\
    delimiter\x18\x03\x20\x01(\tR\tdelimiter\x12\x1f\n\x0bmax_results\x18\
    \x04\x20\x01(\x05R\nmaxResults\x12\x16\n\x06prefix\x18\x05\x20\x01(\tR\
    \x06prefix\x12<\n\x1ainclude_trailing_delimiter\x18\x06\x20\x01(\x08R\
    \x18includeTrailingDelimiter\x12\x1d\n\npage_token\x18\x07\x20\x01(\tR\t\
    pageToken\x12I\n\nprojection\x18\x08\x20\x01(\x0e2).google.storage.v1.Co\
    mmonEnums.ProjectionR\nprojection\x124\n\x07channel\x18\n\x20\x01(\x0b2\
    \x1a.google.storage.v1.ChannelR\x07channel\x12Z\n\x15common_request_para\
    ms\x18\x0b\x20\x01(\x0b2&.google.storage.v1.CommonRequestParamsR\x13comm\
    onRequestParams\"\xa1\x01\n\x1fGetProjectServiceAccountRequest\x12\"\n\n\
    project_id\x18\x01\x20\x01(\tR\tprojectIdB\x03\xe0A\x02\x12Z\n\x15common\
    _request_params\x18\x03\x20\x01(\x0b2&.google.storage.v1.CommonRequestPa\
    ramsR\x13commonRequestParams\"\xcf\x01\n\x14CreateHmacKeyRequest\x12\"\n\
    \nproject_id\x18\x01\x20\x01(\tR\tprojectIdB\x03\xe0A\x02\x127\n\x15serv\
    ice_account_email\x18\x02\x20\x01(\tR\x13serviceAccountEmailB\x03\xe0A\
    \x02\x12Z\n\x15common_request_params\x18\x03\x20\x01(\x0b2&.google.stora\
    ge.v1.CommonRequestParamsR\x13commonRequestParams\"o\n\x15CreateHmacKeyR\
    esponse\x12>\n\x08metadata\x18\x01\x20\x01(\x0b2\".google.storage.v1.Hma\
    cKeyMetadataR\x08metadata\x12\x16\n\x06secret\x18\x02\x20\x01(\tR\x06sec\
    ret\"\xb8\x01\n\x14DeleteHmacKeyRequest\x12\x20\n\taccess_id\x18\x01\x20\
    \x01(\tR\x08accessIdB\x03\xe0A\x02\x12\"\n\nproject_id\x18\x02\x20\x01(\
    \tR\tprojectIdB\x03\xe0A\x02\x12Z\n\x15common_request_params\x18\x03\x20\
    \x01(\x0b2&.google.storage.v1.CommonRequestParamsR\x13commonRequestParam\
    s\"\xb5\x01\n\x11GetHmacKeyRequest\x12\x20\n\taccess_id\x18\x01\x20\x01(\
    \tR\x08accessIdB\x03\xe0A\x02\x12\"\n\nproject_id\x18\x02\x20\x01(\tR\tp\
    rojectIdB\x03\xe0A\x02\x12Z\n\x15common_request_params\x18\x03\x20\x01(\
    \x0b2&.google.storage.v1.CommonRequestParamsR\x13commonRequestParams\"\
    \xb5\x02\n\x13ListHmacKeysRequest\x12\"\n\nproject_id\x18\x01\x20\x01(\t\
    R\tprojectIdB\x03\xe0A\x02\x122\n\x15service_account_email\x18\x02\x20\
    \x01(\tR\x13serviceAccountEmail\x12*\n\x11show_deleted_keys\x18\x03\x20\
    \x01(\x08R\x0fshowDeletedKeys\x12\x1f\n\x0bmax_results\x18\x04\x20\x01(\
    \x05R\nmaxResults\x12\x1d\n\npage_token\x18\x05\x20\x01(\tR\tpageToken\
    \x12Z\n\x15common_request_params\x18\x06\x20\x01(\x0b2&.google.storage.v\
    1.CommonRequestParamsR\x13commonRequestParams\"x\n\x14ListHmacKeysRespon\
    se\x12&\n\x0fnext_page_token\x18\x01\x20\x01(\tR\rnextPageToken\x128\n\
    \x05items\x18\x02\x20\x03(\x0b2\".google.storage.v1.HmacKeyMetadataR\x05\
    items\"\xfd\x01\n\x14UpdateHmacKeyRequest\x12\x20\n\taccess_id\x18\x01\
    \x20\x01(\tR\x08accessIdB\x03\xe0A\x02\x12\"\n\nproject_id\x18\x02\x20\
    \x01(\tR\tprojectIdB\x03\xe0A\x02\x12C\n\x08metadata\x18\x03\x20\x01(\
    \x0b2\".google.storage.v1.HmacKeyMetadataR\x08metadataB\x03\xe0A\x02\x12\
    Z\n\x15common_request_params\x18\x05\x20\x01(\x0b2&.google.storage.v1.Co\
    mmonRequestParamsR\x13commonRequestParams\"\xb6\x01\n\x13GetIamPolicyReq\
    uest\x12C\n\x0biam_request\x18\x01\x20\x01(\x0b2\".google.iam.v1.GetIamP\
    olicyRequestR\niamRequest\x12Z\n\x15common_request_params\x18\x02\x20\
    \x01(\x0b2&.google.storage.v1.CommonRequestParamsR\x13commonRequestParam\
    s\"\xb6\x01\n\x13SetIamPolicyRequest\x12C\n\x0biam_request\x18\x01\x20\
    \x01(\x0b2\".google.iam.v1.SetIamPolicyRequestR\niamRequest\x12Z\n\x15co\
    mmon_request_params\x18\x02\x20\x01(\x0b2&.google.storage.v1.CommonReque\
    stParamsR\x13commonRequestParams\"\xc2\x01\n\x19TestIamPermissionsReques\
    t\x12I\n\x0biam_request\x18\x01\x20\x01(\x0b2(.google.iam.v1.TestIamPerm\
    issionsRequestR\niamRequest\x12Z\n\x15common_request_params\x18\x02\x20\
    \x01(\x0b2&.google.storage.v1.CommonRequestParamsR\x13commonRequestParam\
    s\"\xa9\x01\n\x19CommonObjectRequestParams\x121\n\x14encryption_algorith\
    m\x18\x01\x20\x01(\tR\x13encryptionAlgorithm\x12%\n\x0eencryption_key\
    \x18\x02\x20\x01(\tR\rencryptionKey\x122\n\x15encryption_key_sha256\x18\
    \x03\x20\x01(\tR\x13encryptionKeySha256\"\x90\x01\n\x13CommonRequestPara\
    ms\x12&\n\x0cuser_project\x18\x01\x20\x01(\tR\x0buserProjectB\x03\xe0A\
    \x02\x12\x1d\n\nquota_user\x18\x02\x20\x01(\tR\tquotaUser\x122\n\x06fiel\
    ds\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.FieldMaskR\x06fields\"\xca\
    \x05\n\x10ServiceConstants\"\xb5\x05\n\x06Values\x12\x16\n\x12VALUES_UNS\
    PECIFIED\x10\0\x12\x1b\n\x14MAX_READ_CHUNK_BYTES\x10\x80\x80\x80\x01\x12\
    \x1c\n\x15MAX_WRITE_CHUNK_BYTES\x10\x80\x80\x80\x01\x12\x19\n\x12MAX_OBJ\
    ECT_SIZE_MB\x10\x80\x80\xc0\x02\x12)\n$MAX_CUSTOM_METADATA_FIELD_NAME_BY\
    TES\x10\x80\x08\x12*\n%MAX_CUSTOM_METADATA_FIELD_VALUE_BYTES\x10\x80\x20\
    \x12)\n$MAX_CUSTOM_METADATA_TOTAL_SIZE_BYTES\x10\x80@\x12*\n$MAX_BUCKET_\
    METADATA_TOTAL_SIZE_BYTES\x10\x80\xa0\x01\x12'\n#MAX_NOTIFICATION_CONFIG\
    S_PER_BUCKET\x10d\x12\"\n\x1eMAX_LIFECYCLE_RULES_PER_BUCKET\x10d\x12&\n\
    \"MAX_NOTIFICATION_CUSTOM_ATTRIBUTES\x10\x05\x121\n,MAX_NOTIFICATION_CUS\
    TOM_ATTRIBUTE_KEY_LENGTH\x10\x80\x02\x123\n.MAX_NOTIFICATION_CUSTOM_ATTR\
    IBUTE_VALUE_LENGTH\x10\x80\x08\x12\x1c\n\x18MAX_LABELS_ENTRIES_COUNT\x10\
    @\x12\x1f\n\x1bMAX_LABELS_KEY_VALUE_LENGTH\x10?\x12\x1f\n\x1aMAX_LABELS_\
    KEY_VALUE_BYTES\x10\x80\x01\x12.\n)MAX_OBJECT_IDS_PER_DELETE_OBJECTS_REQ\
    UEST\x10\xe8\x07\x12\x1e\n\x1aSPLIT_TOKEN_MAX_VALID_DAYS\x10\x0e\x1a\x02\
    \x10\x012\x960\n\x07Storage\x12j\n\x19DeleteBucketAccessControl\x123.goo\
    gle.storage.v1.DeleteBucketAccessControlRequest\x1a\x16.google.protobuf.\
    Empty\"\0\x12t\n\x16GetBucketAccessControl\x120.google.storage.v1.GetBuc\
    ketAccessControlRequest\x1a&.google.storage.v1.BucketAccessControl\"\0\
    \x12z\n\x19InsertBucketAccessControl\x123.google.storage.v1.InsertBucket\
    AccessControlRequest\x1a&.google.storage.v1.BucketAccessControl\"\0\x12\
    \x85\x01\n\x18ListBucketAccessControls\x122.google.storage.v1.ListBucket\
    AccessControlsRequest\x1a3.google.storage.v1.ListBucketAccessControlsRes\
    ponse\"\0\x12z\n\x19UpdateBucketAccessControl\x123.google.storage.v1.Upd\
    ateBucketAccessControlRequest\x1a&.google.storage.v1.BucketAccessControl\
    \"\0\x12x\n\x18PatchBucketAccessControl\x122.google.storage.v1.PatchBuck\
    etAccessControlRequest\x1a&.google.storage.v1.BucketAccessControl\"\0\
    \x12P\n\x0cDeleteBucket\x12&.google.storage.v1.DeleteBucketRequest\x1a\
    \x16.google.protobuf.Empty\"\0\x12M\n\tGetBucket\x12#.google.storage.v1.\
    GetBucketRequest\x1a\x19.google.storage.v1.Bucket\"\0\x12S\n\x0cInsertBu\
    cket\x12&.google.storage.v1.InsertBucketRequest\x1a\x19.google.storage.v\
    1.Bucket\"\0\x12a\n\x0cListChannels\x12&.google.storage.v1.ListChannelsR\
    equest\x1a'.google.storage.v1.ListChannelsResponse\"\0\x12^\n\x0bListBuc\
    kets\x12%.google.storage.v1.ListBucketsRequest\x1a&.google.storage.v1.Li\
    stBucketsResponse\"\0\x12g\n\x19LockBucketRetentionPolicy\x12-.google.st\
    orage.v1.LockRetentionPolicyRequest\x1a\x19.google.storage.v1.Bucket\"\0\
    \x12U\n\x12GetBucketIamPolicy\x12&.google.storage.v1.GetIamPolicyRequest\
    \x1a\x15.google.iam.v1.Policy\"\0\x12U\n\x12SetBucketIamPolicy\x12&.goog\
    le.storage.v1.SetIamPolicyRequest\x1a\x15.google.iam.v1.Policy\"\0\x12u\
    \n\x18TestBucketIamPermissions\x12,.google.storage.v1.TestIamPermissions\
    Request\x1a).google.iam.v1.TestIamPermissionsResponse\"\0\x12Q\n\x0bPatc\
    hBucket\x12%.google.storage.v1.PatchBucketRequest\x1a\x19.google.storage\
    .v1.Bucket\"\0\x12S\n\x0cUpdateBucket\x12&.google.storage.v1.UpdateBucke\
    tRequest\x1a\x19.google.storage.v1.Bucket\"\0\x12N\n\x0bStopChannel\x12%\
    .google.storage.v1.StopChannelRequest\x1a\x16.google.protobuf.Empty\"\0\
    \x12x\n\x20DeleteDefaultObjectAccessControl\x12:.google.storage.v1.Delet\
    eDefaultObjectAccessControlRequest\x1a\x16.google.protobuf.Empty\"\0\x12\
    \x82\x01\n\x1dGetDefaultObjectAccessControl\x127.google.storage.v1.GetDe\
    faultObjectAccessControlRequest\x1a&.google.storage.v1.ObjectAccessContr\
    ol\"\0\x12\x88\x01\n\x20InsertDefaultObjectAccessControl\x12:.google.sto\
    rage.v1.InsertDefaultObjectAccessControlRequest\x1a&.google.storage.v1.O\
    bjectAccessControl\"\0\x12\x93\x01\n\x1fListDefaultObjectAccessControls\
    \x129.google.storage.v1.ListDefaultObjectAccessControlsRequest\x1a3.goog\
    le.storage.v1.ListObjectAccessControlsResponse\"\0\x12\x86\x01\n\x1fPatc\
    hDefaultObjectAccessControl\x129.google.storage.v1.PatchDefaultObjectAcc\
    essControlRequest\x1a&.google.storage.v1.ObjectAccessControl\"\0\x12\x88\
    \x01\n\x20UpdateDefaultObjectAccessControl\x12:.google.storage.v1.Update\
    DefaultObjectAccessControlRequest\x1a&.google.storage.v1.ObjectAccessCon\
    trol\"\0\x12\\\n\x12DeleteNotification\x12,.google.storage.v1.DeleteNoti\
    ficationRequest\x1a\x16.google.protobuf.Empty\"\0\x12_\n\x0fGetNotificat\
    ion\x12).google.storage.v1.GetNotificationRequest\x1a\x1f.google.storage\
    .v1.Notification\"\0\x12e\n\x12InsertNotification\x12,.google.storage.v1\
    .InsertNotificationRequest\x1a\x1f.google.storage.v1.Notification\"\0\
    \x12p\n\x11ListNotifications\x12+.google.storage.v1.ListNotificationsReq\
    uest\x1a,.google.storage.v1.ListNotificationsResponse\"\0\x12j\n\x19Dele\
    teObjectAccessControl\x123.google.storage.v1.DeleteObjectAccessControlRe\
    quest\x1a\x16.google.protobuf.Empty\"\0\x12t\n\x16GetObjectAccessControl\
    \x120.google.storage.v1.GetObjectAccessControlRequest\x1a&.google.storag\
    e.v1.ObjectAccessControl\"\0\x12z\n\x19InsertObjectAccessControl\x123.go\
    ogle.storage.v1.InsertObjectAccessControlRequest\x1a&.google.storage.v1.\
    ObjectAccessControl\"\0\x12\x85\x01\n\x18ListObjectAccessControls\x122.g\
    oogle.storage.v1.ListObjectAccessControlsRequest\x1a3.google.storage.v1.\
    ListObjectAccessControlsResponse\"\0\x12x\n\x18PatchObjectAccessControl\
    \x122.google.storage.v1.PatchObjectAccessControlRequest\x1a&.google.stor\
    age.v1.ObjectAccessControl\"\0\x12z\n\x19UpdateObjectAccessControl\x123.\
    google.storage.v1.UpdateObjectAccessControlRequest\x1a&.google.storage.v\
    1.ObjectAccessControl\"\0\x12U\n\rComposeObject\x12'.google.storage.v1.C\
    omposeObjectRequest\x1a\x19.google.storage.v1.Object\"\0\x12O\n\nCopyObj\
    ect\x12$.google.storage.v1.CopyObjectRequest\x1a\x19.google.storage.v1.O\
    bject\"\0\x12P\n\x0cDeleteObject\x12&.google.storage.v1.DeleteObjectRequ\
    est\x1a\x16.google.protobuf.Empty\"\0\x12M\n\tGetObject\x12#.google.stor\
    age.v1.GetObjectRequest\x1a\x19.google.storage.v1.Object\"\0\x12i\n\x0eG\
    etObjectMedia\x12(.google.storage.v1.GetObjectMediaRequest\x1a).google.s\
    torage.v1.GetObjectMediaResponse\"\00\x01\x12U\n\x0cInsertObject\x12&.go\
    ogle.storage.v1.InsertObjectRequest\x1a\x19.google.storage.v1.Object\"\0\
    (\x01\x12^\n\x0bListObjects\x12%.google.storage.v1.ListObjectsRequest\
    \x1a&.google.storage.v1.ListObjectsResponse\"\0\x12^\n\rRewriteObject\
    \x12'.google.storage.v1.RewriteObjectRequest\x1a\".google.storage.v1.Rew\
    riteResponse\"\0\x12v\n\x13StartResumableWrite\x12-.google.storage.v1.St\
    artResumableWriteRequest\x1a..google.storage.v1.StartResumableWriteRespo\
    nse\"\0\x12m\n\x10QueryWriteStatus\x12*.google.storage.v1.QueryWriteStat\
    usRequest\x1a+.google.storage.v1.QueryWriteStatusResponse\"\0\x12Q\n\x0b\
    PatchObject\x12%.google.storage.v1.PatchObjectRequest\x1a\x19.google.sto\
    rage.v1.Object\"\0\x12S\n\x0cUpdateObject\x12&.google.storage.v1.UpdateO\
    bjectRequest\x1a\x19.google.storage.v1.Object\"\0\x12U\n\x12GetObjectIam\
    Policy\x12&.google.storage.v1.GetIamPolicyRequest\x1a\x15.google.iam.v1.\
    Policy\"\0\x12U\n\x12SetObjectIamPolicy\x12&.google.storage.v1.SetIamPol\
    icyRequest\x1a\x15.google.iam.v1.Policy\"\0\x12u\n\x18TestObjectIamPermi\
    ssions\x12,.google.storage.v1.TestIamPermissionsRequest\x1a).google.iam.\
    v1.TestIamPermissionsResponse\"\0\x12Z\n\x0fWatchAllObjects\x12).google.\
    storage.v1.WatchAllObjectsRequest\x1a\x1a.google.storage.v1.Channel\"\0\
    \x12l\n\x11GetServiceAccount\x122.google.storage.v1.GetProjectServiceAcc\
    ountRequest\x1a!.google.storage.v1.ServiceAccount\"\0\x12d\n\rCreateHmac\
    Key\x12'.google.storage.v1.CreateHmacKeyRequest\x1a(.google.storage.v1.C\
    reateHmacKeyResponse\"\0\x12R\n\rDeleteHmacKey\x12'.google.storage.v1.De\
    leteHmacKeyRequest\x1a\x16.google.protobuf.Empty\"\0\x12X\n\nGetHmacKey\
    \x12$.google.storage.v1.GetHmacKeyRequest\x1a\".google.storage.v1.HmacKe\
    yMetadata\"\0\x12a\n\x0cListHmacKeys\x12&.google.storage.v1.ListHmacKeys\
    Request\x1a'.google.storage.v1.ListHmacKeysResponse\"\0\x12^\n\rUpdateHm\
    acKey\x12'.google.storage.v1.UpdateHmacKeyRequest\x1a\".google.storage.v\
    1.HmacKeyMetadata\"\0\x1a\xa7\x02\xcaA\x16storage.googleapis.com\xd2A\
    \x8a\x02https://www.googleapis.com/auth/cloud-platform,https://www.googl\
    eapis.com/auth/cloud-platform.read-only,https://www.googleapis.com/auth/\
    devstorage.full_control,https://www.googleapis.com/auth/devstorage.read_\
    only,https://www.googleapis.com/auth/devstorage.read_writeBS\n\x15com.go\
    ogle.storage.v1P\x01Z8google.golang.org/genproto/googleapis/storage/v1;s\
    torageJ\xe5\x84\x05\n\x07\x12\x05\x0e\0\xbc\x0f\x01\n\xbc\x04\n\x01\x0c\
    \x12\x03\x0e\0\x122\xb1\x04\x20Copyright\x202020\x20Google\x20LLC\n\n\
    \x20Licensed\x20under\x20the\x20Apache\x20License,\x20Version\x202.0\x20\
    (the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\x20file\x20e\
    xcept\x20in\x20compliance\x20with\x20the\x20License.\n\x20You\x20may\x20\
    obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\x20\
    \x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\x20required\
    \x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\x20s\
    oftware\n\x20distributed\x20under\x20the\x20License\x20is\x20distributed\
    \x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\
    \x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\x20impli\
    ed.\n\x20See\x20the\x20License\x20for\x20the\x20specific\x20language\x20\
    governing\x20permissions\x20and\n\x20limitations\x20under\x20the\x20Lice\
    nse.\n\n\x08\n\x01\x02\x12\x03\x10\0\x1a\n\t\n\x02\x03\0\x12\x03\x12\0)\
    \n\t\n\x02\x03\x01\x12\x03\x13\0(\n\t\n\x02\x03\x02\x12\x03\x14\0$\n\t\n\
    \x02\x03\x03\x12\x03\x15\0%\n\t\n\x02\x03\x04\x12\x03\x16\0*\n\t\n\x02\
    \x03\x05\x12\x03\x17\0(\n\t\n\x02\x03\x06\x12\x03\x18\03\n\t\n\x02\x03\
    \x07\x12\x03\x19\0!\n\x08\n\x01\x08\x12\x03\x1b\0O\n\t\n\x02\x08\x0b\x12\
    \x03\x1b\0O\n\x08\n\x01\x08\x12\x03\x1c\0\"\n\t\n\x02\x08\n\x12\x03\x1c\
    \0\"\n\x08\n\x01\x08\x12\x03\x1d\0.\n\t\n\x02\x08\x01\x12\x03\x1d\0.\n6\
    \n\x02\x06\0\x12\x05\x20\0\xcd\x02\x01\x1a)\x20Manages\x20Google\x20Clou\
    d\x20Storage\x20resources.\n\n\n\n\x03\x06\0\x01\x12\x03\x20\x08\x0f\n\n\
    \n\x03\x06\0\x03\x12\x03!\x02>\n\x0c\n\x05\x06\0\x03\x99\x08\x12\x03!\
    \x02>\n\x0b\n\x03\x06\0\x03\x12\x04\"\x02'>\n\r\n\x05\x06\0\x03\x9a\x08\
    \x12\x04\"\x02'>\nd\n\x04\x06\0\x02\0\x12\x04+\x02,\x03\x1aV\x20Permanen\
    tly\x20deletes\x20the\x20ACL\x20entry\x20for\x20the\x20specified\x20enti\
    ty\x20on\x20the\x20specified\n\x20bucket.\n\n\x0c\n\x05\x06\0\x02\0\x01\
    \x12\x03+\x06\x1f\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03+\x20@\n\x0c\n\x05\
    \x06\0\x02\0\x03\x12\x03+K`\nW\n\x04\x06\0\x02\x01\x12\x04/\x020\x03\x1a\
    I\x20Returns\x20the\x20ACL\x20entry\x20for\x20the\x20specified\x20entity\
    \x20on\x20the\x20specified\x20bucket.\n\n\x0c\n\x05\x06\0\x02\x01\x01\
    \x12\x03/\x06\x1c\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03/\x1d:\n\x0c\n\
    \x05\x06\0\x02\x01\x03\x12\x03/EX\n@\n\x04\x06\0\x02\x02\x12\x043\x024\
    \x03\x1a2\x20Creates\x20a\x20new\x20ACL\x20entry\x20on\x20the\x20specifi\
    ed\x20bucket.\n\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x033\x06\x1f\n\x0c\n\
    \x05\x06\0\x02\x02\x02\x12\x033\x20@\n\x0c\n\x05\x06\0\x02\x02\x03\x12\
    \x033K^\n>\n\x04\x06\0\x02\x03\x12\x047\x028\x03\x1a0\x20Retrieves\x20AC\
    L\x20entries\x20on\x20the\x20specified\x20bucket.\n\n\x0c\n\x05\x06\0\
    \x02\x03\x01\x12\x037\x06\x1e\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x037\x1f\
    >\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x037Ii\n\xaa\x01\n\x04\x06\0\x02\x04\
    \x12\x04=\x02>\x03\x1a\x9b\x01\x20Updates\x20an\x20ACL\x20entry\x20on\
    \x20the\x20specified\x20bucket.\x20Equivalent\x20to\n\x20PatchBucketAcce\
    ssControl,\x20but\x20all\x20unspecified\x20fields\x20will\x20be\n\x20res\
    et\x20to\x20their\x20default\x20values.\n\n\x0c\n\x05\x06\0\x02\x04\x01\
    \x12\x03=\x06\x1f\n\x0c\n\x05\x06\0\x02\x04\x02\x12\x03=\x20@\n\x0c\n\
    \x05\x06\0\x02\x04\x03\x12\x03=K^\n=\n\x04\x06\0\x02\x05\x12\x04A\x02B\
    \x03\x1a/\x20Updates\x20an\x20ACL\x20entry\x20on\x20the\x20specified\x20\
    bucket.\n\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03A\x06\x1e\n\x0c\n\x05\x06\
    \0\x02\x05\x02\x12\x03A\x1f>\n\x0c\n\x05\x06\0\x02\x05\x03\x12\x03AI\\\n\
    4\n\x04\x06\0\x02\x06\x12\x04E\x02F\x03\x1a&\x20Permanently\x20deletes\
    \x20an\x20empty\x20bucket.\n\n\x0c\n\x05\x06\0\x02\x06\x01\x12\x03E\x06\
    \x12\n\x0c\n\x05\x06\0\x02\x06\x02\x12\x03E\x13&\n\x0c\n\x05\x06\0\x02\
    \x06\x03\x12\x03E1F\n:\n\x04\x06\0\x02\x07\x12\x04I\x02J\x03\x1a,\x20Ret\
    urns\x20metadata\x20for\x20the\x20specified\x20bucket.\n\n\x0c\n\x05\x06\
    \0\x02\x07\x01\x12\x03I\x06\x0f\n\x0c\n\x05\x06\0\x02\x07\x02\x12\x03I\
    \x10\x20\n\x0c\n\x05\x06\0\x02\x07\x03\x12\x03I+1\n%\n\x04\x06\0\x02\x08\
    \x12\x04M\x02N\x03\x1a\x17\x20Creates\x20a\x20new\x20bucket.\n\n\x0c\n\
    \x05\x06\0\x02\x08\x01\x12\x03M\x06\x12\n\x0c\n\x05\x06\0\x02\x08\x02\
    \x12\x03M\x13&\n\x0c\n\x05\x06\0\x02\x08\x03\x12\x03M17\nP\n\x04\x06\0\
    \x02\t\x12\x04Q\x02R\x03\x1aB\x20List\x20active\x20object\x20change\x20n\
    otification\x20channels\x20for\x20this\x20bucket.\n\n\x0c\n\x05\x06\0\
    \x02\t\x01\x12\x03Q\x06\x12\n\x0c\n\x05\x06\0\x02\t\x02\x12\x03Q\x13&\n\
    \x0c\n\x05\x06\0\x02\t\x03\x12\x03Q1E\n@\n\x04\x06\0\x02\n\x12\x04U\x02V\
    \x03\x1a2\x20Retrieves\x20a\x20list\x20of\x20buckets\x20for\x20a\x20give\
    n\x20project.\n\n\x0c\n\x05\x06\0\x02\n\x01\x12\x03U\x06\x11\n\x0c\n\x05\
    \x06\0\x02\n\x02\x12\x03U\x12$\n\x0c\n\x05\x06\0\x02\n\x03\x12\x03U/B\n3\
    \n\x04\x06\0\x02\x0b\x12\x04Y\x02Z\x03\x1a%\x20Locks\x20retention\x20pol\
    icy\x20on\x20a\x20bucket.\n\n\x0c\n\x05\x06\0\x02\x0b\x01\x12\x03Y\x06\
    \x1f\n\x0c\n\x05\x06\0\x02\x0b\x02\x12\x03Y\x20:\n\x0c\n\x05\x06\0\x02\
    \x0b\x03\x12\x03YEK\n=\n\x04\x06\0\x02\x0c\x12\x04]\x02^\x03\x1a/\x20Get\
    s\x20the\x20IAM\x20policy\x20for\x20the\x20specified\x20bucket.\n\n\x0c\
    \n\x05\x06\0\x02\x0c\x01\x12\x03]\x06\x18\n\x0c\n\x05\x06\0\x02\x0c\x02\
    \x12\x03]\x19,\n\x0c\n\x05\x06\0\x02\x0c\x03\x12\x03]7K\n?\n\x04\x06\0\
    \x02\r\x12\x04a\x02b\x03\x1a1\x20Updates\x20an\x20IAM\x20policy\x20for\
    \x20the\x20specified\x20bucket.\n\n\x0c\n\x05\x06\0\x02\r\x01\x12\x03a\
    \x06\x18\n\x0c\n\x05\x06\0\x02\r\x02\x12\x03a\x19,\n\x0c\n\x05\x06\0\x02\
    \r\x03\x12\x03a7K\nm\n\x04\x06\0\x02\x0e\x12\x04f\x02g\x03\x1a_\x20Tests\
    \x20a\x20set\x20of\x20permissions\x20on\x20the\x20given\x20bucket\x20to\
    \x20see\x20which,\x20if\n\x20any,\x20are\x20held\x20by\x20the\x20caller.\
    \n\n\x0c\n\x05\x06\0\x02\x0e\x01\x12\x03f\x06\x1e\n\x0c\n\x05\x06\0\x02\
    \x0e\x02\x12\x03f\x1f8\n\x0c\n\x05\x06\0\x02\x0e\x03\x12\x03fCk\n\x9b\
    \x01\n\x04\x06\0\x02\x0f\x12\x04k\x02l\x03\x1a\x8c\x01\x20Updates\x20a\
    \x20bucket.\x20Changes\x20to\x20the\x20bucket\x20will\x20be\x20readable\
    \x20immediately\x20after\n\x20writing,\x20but\x20configuration\x20change\
    s\x20may\x20take\x20time\x20to\x20propagate.\n\n\x0c\n\x05\x06\0\x02\x0f\
    \x01\x12\x03k\x06\x11\n\x0c\n\x05\x06\0\x02\x0f\x02\x12\x03k\x12$\n\x0c\
    \n\x05\x06\0\x02\x0f\x03\x12\x03k/5\n\xcd\x02\n\x04\x06\0\x02\x10\x12\
    \x04s\x02t\x03\x1a\xbe\x02\x20Updates\x20a\x20bucket.\x20Equivalent\x20t\
    o\x20PatchBucket,\x20but\x20always\x20replaces\x20all\n\x20mutatable\x20\
    fields\x20of\x20the\x20bucket\x20with\x20new\x20values,\x20reverting\x20\
    all\n\x20unspecified\x20fields\x20to\x20their\x20default\x20values.\n\
    \x20Like\x20PatchBucket,\x20Changes\x20to\x20the\x20bucket\x20will\x20be\
    \x20readable\x20immediately\x20after\n\x20writing,\x20but\x20configurati\
    on\x20changes\x20may\x20take\x20time\x20to\x20propagate.\n\n\x0c\n\x05\
    \x06\0\x02\x10\x01\x12\x03s\x06\x12\n\x0c\n\x05\x06\0\x02\x10\x02\x12\
    \x03s\x13&\n\x0c\n\x05\x06\0\x02\x10\x03\x12\x03s17\n\xf9\x01\n\x04\x06\
    \0\x02\x11\x12\x04z\x02{\x03\x1a\xea\x01\x20Halts\x20\"Object\x20Change\
    \x20Notification\"\x20push\x20messagages.\n\x20See\x20https://cloud.goog\
    le.com/storage/docs/object-change-notification\n\x20Note:\x20this\x20is\
    \x20not\x20related\x20to\x20the\x20newer\x20\"Notifications\"\x20resourc\
    e,\x20which\n\x20are\x20stopped\x20using\x20DeleteNotification.\n\n\x0c\
    \n\x05\x06\0\x02\x11\x01\x12\x03z\x06\x11\n\x0c\n\x05\x06\0\x02\x11\x02\
    \x12\x03z\x12$\n\x0c\n\x05\x06\0\x02\x11\x03\x12\x03z/D\nt\n\x04\x06\0\
    \x02\x12\x12\x05\x7f\x02\x80\x01\x03\x1ae\x20Permanently\x20deletes\x20t\
    he\x20default\x20object\x20ACL\x20entry\x20for\x20the\x20specified\x20en\
    tity\n\x20on\x20the\x20specified\x20bucket.\n\n\x0c\n\x05\x06\0\x02\x12\
    \x01\x12\x03\x7f\x06&\n\x0c\n\x05\x06\0\x02\x12\x02\x12\x03\x7f'N\n\x0c\
    \n\x05\x06\0\x02\x12\x03\x12\x03\x7fYn\ni\n\x04\x06\0\x02\x13\x12\x06\
    \x84\x01\x02\x85\x01\x03\x1aY\x20Returns\x20the\x20default\x20object\x20\
    ACL\x20entry\x20for\x20the\x20specified\x20entity\x20on\x20the\n\x20spec\
    ified\x20bucket.\n\n\r\n\x05\x06\0\x02\x13\x01\x12\x04\x84\x01\x06#\n\r\
    \n\x05\x06\0\x02\x13\x02\x12\x04\x84\x01$H\n\r\n\x05\x06\0\x02\x13\x03\
    \x12\x04\x84\x01Sf\nQ\n\x04\x06\0\x02\x14\x12\x06\x88\x01\x02\x89\x01\
    \x03\x1aA\x20Creates\x20a\x20new\x20default\x20object\x20ACL\x20entry\
    \x20on\x20the\x20specified\x20bucket.\n\n\r\n\x05\x06\0\x02\x14\x01\x12\
    \x04\x88\x01\x06&\n\r\n\x05\x06\0\x02\x14\x02\x12\x04\x88\x01'N\n\r\n\
    \x05\x06\0\x02\x14\x03\x12\x04\x88\x01Yl\nO\n\x04\x06\0\x02\x15\x12\x06\
    \x8c\x01\x02\x8d\x01\x03\x1a?\x20Retrieves\x20default\x20object\x20ACL\
    \x20entries\x20on\x20the\x20specified\x20bucket.\n\n\r\n\x05\x06\0\x02\
    \x15\x01\x12\x04\x8c\x01\x06%\n\r\n\x05\x06\0\x02\x15\x02\x12\x04\x8c\
    \x01&L\n\r\n\x05\x06\0\x02\x15\x03\x12\x04\x8c\x01Ww\nM\n\x04\x06\0\x02\
    \x16\x12\x06\x90\x01\x02\x91\x01\x03\x1a=\x20Updates\x20a\x20default\x20\
    object\x20ACL\x20entry\x20on\x20the\x20specified\x20bucket.\n\n\r\n\x05\
    \x06\0\x02\x16\x01\x12\x04\x90\x01\x06%\n\r\n\x05\x06\0\x02\x16\x02\x12\
    \x04\x90\x01&L\n\r\n\x05\x06\0\x02\x16\x03\x12\x04\x90\x01Wj\n\xbc\x01\n\
    \x04\x06\0\x02\x17\x12\x06\x96\x01\x02\x97\x01\x03\x1a\xab\x01\x20Update\
    s\x20a\x20default\x20object\x20ACL\x20entry\x20on\x20the\x20specified\
    \x20bucket.\x20Equivalent\x20to\n\x20PatchDefaultObjectAccessControl,\
    \x20but\x20modifies\x20all\x20unspecified\x20fields\x20to\n\x20their\x20\
    default\x20values.\n\n\r\n\x05\x06\0\x02\x17\x01\x12\x04\x96\x01\x06&\n\
    \r\n\x05\x06\0\x02\x17\x02\x12\x04\x96\x01'N\n\r\n\x05\x06\0\x02\x17\x03\
    \x12\x04\x96\x01Yl\n\xaf\x01\n\x04\x06\0\x02\x18\x12\x06\x9c\x01\x02\x9d\
    \x01\x03\x1a\x9e\x01\x20Permanently\x20deletes\x20a\x20notification\x20s\
    ubscription.\n\x20Note:\x20Older,\x20\"Object\x20Change\x20Notification\
    \"\x20push\x20subscriptions\x20should\x20be\n\x20deleted\x20using\x20Sto\
    pChannel\x20instead.\n\n\r\n\x05\x06\0\x02\x18\x01\x12\x04\x9c\x01\x06\
    \x18\n\r\n\x05\x06\0\x02\x18\x02\x12\x04\x9c\x01\x192\n\r\n\x05\x06\0\
    \x02\x18\x03\x12\x04\x9c\x01=R\n4\n\x04\x06\0\x02\x19\x12\x06\xa0\x01\
    \x02\xa1\x01\x03\x1a$\x20View\x20a\x20notification\x20configuration.\n\n\
    \r\n\x05\x06\0\x02\x19\x01\x12\x04\xa0\x01\x06\x15\n\r\n\x05\x06\0\x02\
    \x19\x02\x12\x04\xa0\x01\x16,\n\r\n\x05\x06\0\x02\x19\x03\x12\x04\xa0\
    \x017C\n\xea\x01\n\x04\x06\0\x02\x1a\x12\x06\xa7\x01\x02\xa8\x01\x03\x1a\
    \xd9\x01\x20Creates\x20a\x20notification\x20subscription\x20for\x20a\x20\
    given\x20bucket.\n\x20These\x20notifications,\x20when\x20triggered,\x20p\
    ublish\x20messages\x20to\x20the\x20specified\n\x20Cloud\x20Pub/Sub\x20to\
    pics.\n\x20See\x20https://cloud.google.com/storage/docs/pubsub-notificat\
    ions.\n\n\r\n\x05\x06\0\x02\x1a\x01\x12\x04\xa7\x01\x06\x18\n\r\n\x05\
    \x06\0\x02\x1a\x02\x12\x04\xa7\x01\x192\n\r\n\x05\x06\0\x02\x1a\x03\x12\
    \x04\xa7\x01=I\nT\n\x04\x06\0\x02\x1b\x12\x06\xab\x01\x02\xac\x01\x03\
    \x1aD\x20Retrieves\x20a\x20list\x20of\x20notification\x20subscriptions\
    \x20for\x20a\x20given\x20bucket.\n\n\r\n\x05\x06\0\x02\x1b\x01\x12\x04\
    \xab\x01\x06\x17\n\r\n\x05\x06\0\x02\x1b\x02\x12\x04\xab\x01\x180\n\r\n\
    \x05\x06\0\x02\x1b\x03\x12\x04\xab\x01;T\nf\n\x04\x06\0\x02\x1c\x12\x06\
    \xb0\x01\x02\xb1\x01\x03\x1aV\x20Permanently\x20deletes\x20the\x20ACL\
    \x20entry\x20for\x20the\x20specified\x20entity\x20on\x20the\x20specified\
    \n\x20object.\n\n\r\n\x05\x06\0\x02\x1c\x01\x12\x04\xb0\x01\x06\x1f\n\r\
    \n\x05\x06\0\x02\x1c\x02\x12\x04\xb0\x01\x20@\n\r\n\x05\x06\0\x02\x1c\
    \x03\x12\x04\xb0\x01K`\nY\n\x04\x06\0\x02\x1d\x12\x06\xb4\x01\x02\xb5\
    \x01\x03\x1aI\x20Returns\x20the\x20ACL\x20entry\x20for\x20the\x20specifi\
    ed\x20entity\x20on\x20the\x20specified\x20object.\n\n\r\n\x05\x06\0\x02\
    \x1d\x01\x12\x04\xb4\x01\x06\x1c\n\r\n\x05\x06\0\x02\x1d\x02\x12\x04\xb4\
    \x01\x1d:\n\r\n\x05\x06\0\x02\x1d\x03\x12\x04\xb4\x01EX\nB\n\x04\x06\0\
    \x02\x1e\x12\x06\xb8\x01\x02\xb9\x01\x03\x1a2\x20Creates\x20a\x20new\x20\
    ACL\x20entry\x20on\x20the\x20specified\x20object.\n\n\r\n\x05\x06\0\x02\
    \x1e\x01\x12\x04\xb8\x01\x06\x1f\n\r\n\x05\x06\0\x02\x1e\x02\x12\x04\xb8\
    \x01\x20@\n\r\n\x05\x06\0\x02\x1e\x03\x12\x04\xb8\x01K^\n@\n\x04\x06\0\
    \x02\x1f\x12\x06\xbc\x01\x02\xbd\x01\x03\x1a0\x20Retrieves\x20ACL\x20ent\
    ries\x20on\x20the\x20specified\x20object.\n\n\r\n\x05\x06\0\x02\x1f\x01\
    \x12\x04\xbc\x01\x06\x1e\n\r\n\x05\x06\0\x02\x1f\x02\x12\x04\xbc\x01\x1f\
    >\n\r\n\x05\x06\0\x02\x1f\x03\x12\x04\xbc\x01Ii\n\xd3\x01\n\x04\x06\0\
    \x02\x20\x12\x06\xc2\x01\x02\xc3\x01\x03\x1a\xc2\x01\x20Patches\x20an\
    \x20ACL\x20entry\x20on\x20the\x20specified\x20object.\x20\x20Patch\x20is\
    \x20similar\x20to\x20update,\n\x20but\x20only\x20applies\x20or\x20append\
    s\x20the\x20specified\x20fields\x20in\x20the\n\x20object_access_control\
    \x20object.\x20\x20Other\x20fields\x20are\x20unaffected.\n\n\r\n\x05\x06\
    \0\x02\x20\x01\x12\x04\xc2\x01\x06\x1e\n\r\n\x05\x06\0\x02\x20\x02\x12\
    \x04\xc2\x01\x1f>\n\r\n\x05\x06\0\x02\x20\x03\x12\x04\xc2\x01I\\\n?\n\
    \x04\x06\0\x02!\x12\x06\xc6\x01\x02\xc7\x01\x03\x1a/\x20Updates\x20an\
    \x20ACL\x20entry\x20on\x20the\x20specified\x20object.\n\n\r\n\x05\x06\0\
    \x02!\x01\x12\x04\xc6\x01\x06\x1f\n\r\n\x05\x06\0\x02!\x02\x12\x04\xc6\
    \x01\x20@\n\r\n\x05\x06\0\x02!\x03\x12\x04\xc6\x01K^\n`\n\x04\x06\0\x02\
    \"\x12\x06\xcb\x01\x02\xcc\x01\x03\x1aP\x20Concatenates\x20a\x20list\x20\
    of\x20existing\x20objects\x20into\x20a\x20new\x20object\x20in\x20the\x20\
    same\n\x20bucket.\n\n\r\n\x05\x06\0\x02\"\x01\x12\x04\xcb\x01\x06\x13\n\
    \r\n\x05\x06\0\x02\"\x02\x12\x04\xcb\x01\x14(\n\r\n\x05\x06\0\x02\"\x03\
    \x12\x04\xcb\x0139\na\n\x04\x06\0\x02#\x12\x06\xd0\x01\x02\xd1\x01\x03\
    \x1aQ\x20Copies\x20a\x20source\x20object\x20to\x20a\x20destination\x20ob\
    ject.\x20Optionally\x20overrides\n\x20metadata.\n\n\r\n\x05\x06\0\x02#\
    \x01\x12\x04\xd0\x01\x06\x10\n\r\n\x05\x06\0\x02#\x02\x12\x04\xd0\x01\
    \x11\"\n\r\n\x05\x06\0\x02#\x03\x12\x04\xd0\x01-3\n\xa7\x01\n\x04\x06\0\
    \x02$\x12\x06\xd6\x01\x02\xd7\x01\x03\x1a\x96\x01\x20Deletes\x20an\x20ob\
    ject\x20and\x20its\x20metadata.\x20Deletions\x20are\x20permanent\x20if\
    \x20versioning\n\x20is\x20not\x20enabled\x20for\x20the\x20bucket,\x20or\
    \x20if\x20the\x20`generation`\x20parameter\n\x20is\x20used.\n\n\r\n\x05\
    \x06\0\x02$\x01\x12\x04\xd6\x01\x06\x12\n\r\n\x05\x06\0\x02$\x02\x12\x04\
    \xd6\x01\x13&\n\r\n\x05\x06\0\x02$\x03\x12\x04\xd6\x011F\n1\n\x04\x06\0\
    \x02%\x12\x06\xda\x01\x02\xdb\x01\x03\x1a!\x20Retrieves\x20an\x20object'\
    s\x20metadata.\n\n\r\n\x05\x06\0\x02%\x01\x12\x04\xda\x01\x06\x0f\n\r\n\
    \x05\x06\0\x02%\x02\x12\x04\xda\x01\x10\x20\n\r\n\x05\x06\0\x02%\x03\x12\
    \x04\xda\x01+1\n)\n\x04\x06\0\x02&\x12\x06\xde\x01\x02\xdf\x01\x03\x1a\
    \x19\x20Reads\x20an\x20object's\x20data.\n\n\r\n\x05\x06\0\x02&\x01\x12\
    \x04\xde\x01\x06\x14\n\r\n\x05\x06\0\x02&\x02\x12\x04\xde\x01\x15*\n\r\n\
    \x05\x06\0\x02&\x06\x12\x04\xde\x015;\n\r\n\x05\x06\0\x02&\x03\x12\x04\
    \xde\x01<R\n\xde\n\n\x04\x06\0\x02'\x12\x06\xf9\x01\x02\xfa\x01\x03\x1a\
    \xcd\n\x20Stores\x20a\x20new\x20object\x20and\x20metadata.\n\n\x20An\x20\
    object\x20can\x20be\x20written\x20either\x20in\x20a\x20single\x20message\
    \x20stream\x20or\x20in\x20a\n\x20resumable\x20sequence\x20of\x20message\
    \x20streams.\x20To\x20write\x20using\x20a\x20single\x20stream,\n\x20the\
    \x20client\x20should\x20include\x20in\x20the\x20first\x20message\x20of\
    \x20the\x20stream\x20an\n\x20`InsertObjectSpec`\x20describing\x20the\x20\
    destination\x20bucket,\x20object,\x20and\x20any\n\x20preconditions.\x20A\
    dditionally,\x20the\x20final\x20message\x20must\x20set\x20'finish_write'\
    \x20to\n\x20true,\x20or\x20else\x20it\x20is\x20an\x20error.\n\n\x20For\
    \x20a\x20resumable\x20write,\x20the\x20client\x20should\x20instead\x20ca\
    ll\n\x20`StartResumableWrite()`\x20and\x20provide\x20that\x20method\x20a\
    n\x20`InsertObjectSpec.`\n\x20They\x20should\x20then\x20attach\x20the\
    \x20returned\x20`upload_id`\x20to\x20the\x20first\x20message\x20of\n\x20\
    each\x20following\x20call\x20to\x20`Insert`.\x20If\x20there\x20is\x20an\
    \x20error\x20or\x20the\x20connection\x20is\n\x20broken\x20during\x20the\
    \x20resumable\x20`Insert()`,\x20the\x20client\x20should\x20check\x20the\
    \x20status\n\x20of\x20the\x20`Insert()`\x20by\x20calling\x20`QueryWriteS\
    tatus()`\x20and\x20continue\x20writing\x20from\n\x20the\x20returned\x20`\
    committed_size`.\x20This\x20may\x20be\x20less\x20than\x20the\x20amount\
    \x20of\x20data\x20the\n\x20client\x20previously\x20sent.\n\n\x20The\x20s\
    ervice\x20will\x20not\x20view\x20the\x20object\x20as\x20complete\x20unti\
    l\x20the\x20client\x20has\n\x20sent\x20an\x20`Insert`\x20with\x20`finish\
    _write`\x20set\x20to\x20`true`.\x20Sending\x20any\n\x20requests\x20on\
    \x20a\x20stream\x20after\x20sending\x20a\x20request\x20with\x20`finish_w\
    rite`\x20set\x20to\n\x20`true`\x20will\x20cause\x20an\x20error.\x20The\
    \x20client\x20**should**\x20check\x20the\n\x20`Object`\x20it\x20receives\
    \x20to\x20determine\x20how\x20much\x20data\x20the\x20service\x20was\n\
    \x20able\x20to\x20commit\x20and\x20whether\x20the\x20service\x20views\
    \x20the\x20object\x20as\x20complete.\n\n\r\n\x05\x06\0\x02'\x01\x12\x04\
    \xf9\x01\x06\x12\n\r\n\x05\x06\0\x02'\x05\x12\x04\xf9\x01\x13\x19\n\r\n\
    \x05\x06\0\x02'\x02\x12\x04\xf9\x01\x1a-\n\r\n\x05\x06\0\x02'\x03\x12\
    \x04\xf9\x018>\nD\n\x04\x06\0\x02(\x12\x06\xfd\x01\x02\xfe\x01\x03\x1a4\
    \x20Retrieves\x20a\x20list\x20of\x20objects\x20matching\x20the\x20criter\
    ia.\n\n\r\n\x05\x06\0\x02(\x01\x12\x04\xfd\x01\x06\x11\n\r\n\x05\x06\0\
    \x02(\x02\x12\x04\xfd\x01\x12$\n\r\n\x05\x06\0\x02(\x03\x12\x04\xfd\x01/\
    B\nc\n\x04\x06\0\x02)\x12\x06\x82\x02\x02\x83\x02\x03\x1aS\x20Rewrites\
    \x20a\x20source\x20object\x20to\x20a\x20destination\x20object.\x20Option\
    ally\x20overrides\n\x20metadata.\n\n\r\n\x05\x06\0\x02)\x01\x12\x04\x82\
    \x02\x06\x13\n\r\n\x05\x06\0\x02)\x02\x12\x04\x82\x02\x14(\n\r\n\x05\x06\
    \0\x02)\x03\x12\x04\x82\x023B\n\xac\x01\n\x04\x06\0\x02*\x12\x06\x88\x02\
    \x02\x89\x02\x03\x1a\x9b\x01\x20Starts\x20a\x20resumable\x20write.\x20Ho\
    w\x20long\x20the\x20write\x20operation\x20remains\x20valid,\x20and\n\x20\
    what\x20happens\x20when\x20the\x20write\x20operation\x20becomes\x20inval\
    id,\x20are\n\x20service-dependent.\n\n\r\n\x05\x06\0\x02*\x01\x12\x04\
    \x88\x02\x06\x19\n\r\n\x05\x06\0\x02*\x02\x12\x04\x88\x02\x1a4\n\r\n\x05\
    \x06\0\x02*\x03\x12\x04\x88\x02?Z\n\xbe\x05\n\x04\x06\0\x02+\x12\x06\x98\
    \x02\x02\x99\x02\x03\x1a\xad\x05\x20Determines\x20the\x20`committed_size\
    `\x20for\x20an\x20object\x20that\x20is\x20being\x20written,\x20which\n\
    \x20can\x20then\x20be\x20used\x20as\x20the\x20`write_offset`\x20for\x20t\
    he\x20next\x20`Write()`\x20call.\n\n\x20If\x20the\x20object\x20does\x20n\
    ot\x20exist\x20(i.e.,\x20the\x20object\x20has\x20been\x20deleted,\x20or\
    \x20the\n\x20first\x20`Write()`\x20has\x20not\x20yet\x20reached\x20the\
    \x20service),\x20this\x20method\x20returns\x20the\n\x20error\x20`NOT_FOU\
    ND`.\n\n\x20The\x20client\x20**may**\x20call\x20`QueryWriteStatus()`\x20\
    at\x20any\x20time\x20to\x20determine\x20how\n\x20much\x20data\x20has\x20\
    been\x20processed\x20for\x20this\x20object.\x20This\x20is\x20useful\x20i\
    f\x20the\n\x20client\x20is\x20buffering\x20data\x20and\x20needs\x20to\
    \x20know\x20which\x20data\x20can\x20be\x20safely\n\x20evicted.\x20For\
    \x20any\x20sequence\x20of\x20`QueryWriteStatus()`\x20calls\x20for\x20a\
    \x20given\n\x20object\x20name,\x20the\x20sequence\x20of\x20returned\x20`\
    committed_size`\x20values\x20will\x20be\n\x20non-decreasing.\n\n\r\n\x05\
    \x06\0\x02+\x01\x12\x04\x98\x02\x06\x16\n\r\n\x05\x06\0\x02+\x02\x12\x04\
    \x98\x02\x17.\n\r\n\x05\x06\0\x02+\x03\x12\x04\x98\x029Q\n/\n\x04\x06\0\
    \x02,\x12\x06\x9c\x02\x02\x9d\x02\x03\x1a\x1f\x20Updates\x20an\x20object\
    's\x20metadata.\n\n\r\n\x05\x06\0\x02,\x01\x12\x04\x9c\x02\x06\x11\n\r\n\
    \x05\x06\0\x02,\x02\x12\x04\x9c\x02\x12$\n\r\n\x05\x06\0\x02,\x03\x12\
    \x04\x9c\x02/5\n\xcf\x01\n\x04\x06\0\x02-\x12\x06\xa2\x02\x02\xa3\x02\
    \x03\x1a\xbe\x01\x20Updates\x20an\x20object's\x20metadata.\x20Equivalent\
    \x20to\x20PatchObject,\x20but\x20always\n\x20replaces\x20all\x20mutatabl\
    e\x20fields\x20of\x20the\x20bucket\x20with\x20new\x20values,\x20revertin\
    g\x20all\n\x20unspecified\x20fields\x20to\x20their\x20default\x20values.\
    \n\n\r\n\x05\x06\0\x02-\x01\x12\x04\xa2\x02\x06\x12\n\r\n\x05\x06\0\x02-\
    \x02\x12\x04\xa2\x02\x13&\n\r\n\x05\x06\0\x02-\x03\x12\x04\xa2\x0217\n?\
    \n\x04\x06\0\x02.\x12\x06\xa6\x02\x02\xa7\x02\x03\x1a/\x20Gets\x20the\
    \x20IAM\x20policy\x20for\x20the\x20specified\x20object.\n\n\r\n\x05\x06\
    \0\x02.\x01\x12\x04\xa6\x02\x06\x18\n\r\n\x05\x06\0\x02.\x02\x12\x04\xa6\
    \x02\x19,\n\r\n\x05\x06\0\x02.\x03\x12\x04\xa6\x027K\nA\n\x04\x06\0\x02/\
    \x12\x06\xaa\x02\x02\xab\x02\x03\x1a1\x20Updates\x20an\x20IAM\x20policy\
    \x20for\x20the\x20specified\x20object.\n\n\r\n\x05\x06\0\x02/\x01\x12\
    \x04\xaa\x02\x06\x18\n\r\n\x05\x06\0\x02/\x02\x12\x04\xaa\x02\x19,\n\r\n\
    \x05\x06\0\x02/\x03\x12\x04\xaa\x027K\no\n\x04\x06\0\x020\x12\x06\xaf\
    \x02\x02\xb0\x02\x03\x1a_\x20Tests\x20a\x20set\x20of\x20permissions\x20o\
    n\x20the\x20given\x20object\x20to\x20see\x20which,\x20if\n\x20any,\x20ar\
    e\x20held\x20by\x20the\x20caller.\n\n\r\n\x05\x06\0\x020\x01\x12\x04\xaf\
    \x02\x06\x1e\n\r\n\x05\x06\0\x020\x02\x12\x04\xaf\x02\x1f8\n\r\n\x05\x06\
    \0\x020\x03\x12\x04\xaf\x02Ck\n?\n\x04\x06\0\x021\x12\x06\xb3\x02\x02\
    \xb4\x02\x03\x1a/\x20Watch\x20for\x20changes\x20on\x20all\x20objects\x20\
    in\x20a\x20bucket.\n\n\r\n\x05\x06\0\x021\x01\x12\x04\xb3\x02\x06\x15\n\
    \r\n\x05\x06\0\x021\x02\x12\x04\xb3\x02\x16,\n\r\n\x05\x06\0\x021\x03\
    \x12\x04\xb3\x027>\nY\n\x04\x06\0\x022\x12\x06\xb7\x02\x02\xb8\x02\x03\
    \x1aI\x20Retrieves\x20the\x20name\x20of\x20a\x20project's\x20Google\x20C\
    loud\x20Storage\x20service\x20account.\n\n\r\n\x05\x06\0\x022\x01\x12\
    \x04\xb7\x02\x06\x17\n\r\n\x05\x06\0\x022\x02\x12\x04\xb7\x02\x187\n\r\n\
    \x05\x06\0\x022\x03\x12\x04\xb7\x02BP\nG\n\x04\x06\0\x023\x12\x06\xbb\
    \x02\x02\xbc\x02\x03\x1a7\x20Creates\x20a\x20new\x20HMAC\x20key\x20for\
    \x20the\x20given\x20service\x20account.\n\n\r\n\x05\x06\0\x023\x01\x12\
    \x04\xbb\x02\x06\x13\n\r\n\x05\x06\0\x023\x02\x12\x04\xbb\x02\x14(\n\r\n\
    \x05\x06\0\x023\x03\x12\x04\xbb\x023H\nN\n\x04\x06\0\x024\x12\x06\xbf\
    \x02\x02\xc0\x02\x03\x1a>\x20Deletes\x20a\x20given\x20HMAC\x20key.\x20\
    \x20Key\x20must\x20be\x20in\x20an\x20INACTIVE\x20state.\n\n\r\n\x05\x06\
    \0\x024\x01\x12\x04\xbf\x02\x06\x13\n\r\n\x05\x06\0\x024\x02\x12\x04\xbf\
    \x02\x14(\n\r\n\x05\x06\0\x024\x03\x12\x04\xbf\x023H\nF\n\x04\x06\0\x025\
    \x12\x06\xc3\x02\x02\xc4\x02\x03\x1a6\x20Gets\x20an\x20existing\x20HMAC\
    \x20key\x20metadata\x20for\x20the\x20given\x20id.\n\n\r\n\x05\x06\0\x025\
    \x01\x12\x04\xc3\x02\x06\x10\n\r\n\x05\x06\0\x025\x02\x12\x04\xc3\x02\
    \x11\"\n\r\n\x05\x06\0\x025\x03\x12\x04\xc3\x02-<\n]\n\x04\x06\0\x026\
    \x12\x06\xc7\x02\x02\xc8\x02\x03\x1aM\x20Lists\x20HMAC\x20keys\x20under\
    \x20a\x20given\x20project\x20with\x20the\x20additional\x20filters\x20pro\
    vided.\n\n\r\n\x05\x06\0\x026\x01\x12\x04\xc7\x02\x06\x12\n\r\n\x05\x06\
    \0\x026\x02\x12\x04\xc7\x02\x13&\n\r\n\x05\x06\0\x026\x03\x12\x04\xc7\
    \x021E\nM\n\x04\x06\0\x027\x12\x06\xcb\x02\x02\xcc\x02\x03\x1a=\x20Updat\
    es\x20a\x20given\x20HMAC\x20key\x20state\x20between\x20ACTIVE\x20and\x20\
    INACTIVE.\n\n\r\n\x05\x06\0\x027\x01\x12\x04\xcb\x02\x06\x13\n\r\n\x05\
    \x06\0\x027\x02\x12\x04\xcb\x02\x14(\n\r\n\x05\x06\0\x027\x03\x12\x04\
    \xcb\x023B\n>\n\x02\x04\0\x12\x06\xd0\x02\0\xdf\x02\x01\x1a0\x20Request\
    \x20message\x20for\x20DeleteBucketAccessControl.\n\n\x0b\n\x03\x04\0\x01\
    \x12\x04\xd0\x02\x08(\n+\n\x04\x04\0\x02\0\x12\x04\xd2\x02\x02=\x1a\x1d\
    \x20Required.\x20Name\x20of\x20a\x20bucket.\n\n\x0f\n\x05\x04\0\x02\0\
    \x04\x12\x06\xd2\x02\x02\xd0\x02*\n\r\n\x05\x04\0\x02\0\x05\x12\x04\xd2\
    \x02\x02\x08\n\r\n\x05\x04\0\x02\0\x01\x12\x04\xd2\x02\t\x0f\n\r\n\x05\
    \x04\0\x02\0\x03\x12\x04\xd2\x02\x12\x13\n\r\n\x05\x04\0\x02\0\x08\x12\
    \x04\xd2\x02\x14<\n\x10\n\x08\x04\0\x02\0\x08\x9c\x08\0\x12\x04\xd2\x02\
    \x15;\n\xd0\x01\n\x04\x04\0\x02\x01\x12\x04\xdb\x02\x02=\x1a\xc1\x01\x20\
    Required.\x20The\x20entity\x20holding\x20the\x20permission.\x20Can\x20be\
    \x20one\x20of:\n\x20*\x20`user-`*userId*\n\x20*\x20`user-`*emailAddress*\
    \n\x20*\x20`group-`*groupId*\n\x20*\x20`group-`*emailAddress*\n\x20*\x20\
    `allUsers`\n\x20*\x20`allAuthenticatedUsers`\n\n\x0f\n\x05\x04\0\x02\x01\
    \x04\x12\x06\xdb\x02\x02\xd2\x02=\n\r\n\x05\x04\0\x02\x01\x05\x12\x04\
    \xdb\x02\x02\x08\n\r\n\x05\x04\0\x02\x01\x01\x12\x04\xdb\x02\t\x0f\n\r\n\
    \x05\x04\0\x02\x01\x03\x12\x04\xdb\x02\x12\x13\n\r\n\x05\x04\0\x02\x01\
    \x08\x12\x04\xdb\x02\x14<\n\x10\n\x08\x04\0\x02\x01\x08\x9c\x08\0\x12\
    \x04\xdb\x02\x15;\nG\n\x04\x04\0\x02\x02\x12\x04\xde\x02\x020\x1a9\x20A\
    \x20set\x20of\x20parameters\x20common\x20to\x20all\x20Storage\x20API\x20\
    requests.\n\n\x0f\n\x05\x04\0\x02\x02\x04\x12\x06\xde\x02\x02\xdb\x02=\n\
    \r\n\x05\x04\0\x02\x02\x06\x12\x04\xde\x02\x02\x15\n\r\n\x05\x04\0\x02\
    \x02\x01\x12\x04\xde\x02\x16+\n\r\n\x05\x04\0\x02\x02\x03\x12\x04\xde\
    \x02./\n;\n\x02\x04\x01\x12\x06\xe2\x02\0\xf1\x02\x01\x1a-\x20Request\
    \x20message\x20for\x20GetBucketAccessControl.\n\n\x0b\n\x03\x04\x01\x01\
    \x12\x04\xe2\x02\x08%\n+\n\x04\x04\x01\x02\0\x12\x04\xe4\x02\x02=\x1a\
    \x1d\x20Required.\x20Name\x20of\x20a\x20bucket.\n\n\x0f\n\x05\x04\x01\
    \x02\0\x04\x12\x06\xe4\x02\x02\xe2\x02'\n\r\n\x05\x04\x01\x02\0\x05\x12\
    \x04\xe4\x02\x02\x08\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\xe4\x02\t\x0f\n\
    \r\n\x05\x04\x01\x02\0\x03\x12\x04\xe4\x02\x12\x13\n\r\n\x05\x04\x01\x02\
    \0\x08\x12\x04\xe4\x02\x14<\n\x10\n\x08\x04\x01\x02\0\x08\x9c\x08\0\x12\
    \x04\xe4\x02\x15;\n\xd0\x01\n\x04\x04\x01\x02\x01\x12\x04\xed\x02\x02=\
    \x1a\xc1\x01\x20Required.\x20The\x20entity\x20holding\x20the\x20permissi\
    on.\x20Can\x20be\x20one\x20of:\n\x20*\x20`user-`*userId*\n\x20*\x20`user\
    -`*emailAddress*\n\x20*\x20`group-`*groupId*\n\x20*\x20`group-`*emailAdd\
    ress*\n\x20*\x20`allUsers`\n\x20*\x20`allAuthenticatedUsers`\n\n\x0f\n\
    \x05\x04\x01\x02\x01\x04\x12\x06\xed\x02\x02\xe4\x02=\n\r\n\x05\x04\x01\
    \x02\x01\x05\x12\x04\xed\x02\x02\x08\n\r\n\x05\x04\x01\x02\x01\x01\x12\
    \x04\xed\x02\t\x0f\n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\xed\x02\x12\x13\
    \n\r\n\x05\x04\x01\x02\x01\x08\x12\x04\xed\x02\x14<\n\x10\n\x08\x04\x01\
    \x02\x01\x08\x9c\x08\0\x12\x04\xed\x02\x15;\nG\n\x04\x04\x01\x02\x02\x12\
    \x04\xf0\x02\x020\x1a9\x20A\x20set\x20of\x20parameters\x20common\x20to\
    \x20all\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04\x01\x02\x02\x04\
    \x12\x06\xf0\x02\x02\xed\x02=\n\r\n\x05\x04\x01\x02\x02\x06\x12\x04\xf0\
    \x02\x02\x15\n\r\n\x05\x04\x01\x02\x02\x01\x12\x04\xf0\x02\x16+\n\r\n\
    \x05\x04\x01\x02\x02\x03\x12\x04\xf0\x02./\n>\n\x02\x04\x02\x12\x06\xf4\
    \x02\0\xfd\x02\x01\x1a0\x20Request\x20message\x20for\x20InsertBucketAcce\
    ssControl.\n\n\x0b\n\x03\x04\x02\x01\x12\x04\xf4\x02\x08(\n+\n\x04\x04\
    \x02\x02\0\x12\x04\xf6\x02\x02=\x1a\x1d\x20Required.\x20Name\x20of\x20a\
    \x20bucket.\n\n\x0f\n\x05\x04\x02\x02\0\x04\x12\x06\xf6\x02\x02\xf4\x02*\
    \n\r\n\x05\x04\x02\x02\0\x05\x12\x04\xf6\x02\x02\x08\n\r\n\x05\x04\x02\
    \x02\0\x01\x12\x04\xf6\x02\t\x0f\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\xf6\
    \x02\x12\x13\n\r\n\x05\x04\x02\x02\0\x08\x12\x04\xf6\x02\x14<\n\x10\n\
    \x08\x04\x02\x02\0\x08\x9c\x08\0\x12\x04\xf6\x02\x15;\nK\n\x04\x04\x02\
    \x02\x01\x12\x04\xf9\x02\x020\x1a=\x20Properties\x20of\x20the\x20new\x20\
    bucket\x20access\x20control\x20being\x20inserted.\n\n\x0f\n\x05\x04\x02\
    \x02\x01\x04\x12\x06\xf9\x02\x02\xf6\x02=\n\r\n\x05\x04\x02\x02\x01\x06\
    \x12\x04\xf9\x02\x02\x15\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\xf9\x02\
    \x16+\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\xf9\x02./\nG\n\x04\x04\x02\
    \x02\x02\x12\x04\xfc\x02\x020\x1a9\x20A\x20set\x20of\x20parameters\x20co\
    mmon\x20to\x20all\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04\x02\
    \x02\x02\x04\x12\x06\xfc\x02\x02\xf9\x020\n\r\n\x05\x04\x02\x02\x02\x06\
    \x12\x04\xfc\x02\x02\x15\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\xfc\x02\
    \x16+\n\r\n\x05\x04\x02\x02\x02\x03\x12\x04\xfc\x02./\n<\n\x02\x04\x03\
    \x12\x06\x80\x03\0\x86\x03\x01\x1a.\x20Request\x20message\x20for\x20List\
    BucketAccessControl.\n\n\x0b\n\x03\x04\x03\x01\x12\x04\x80\x03\x08'\n+\n\
    \x04\x04\x03\x02\0\x12\x04\x82\x03\x02=\x1a\x1d\x20Required.\x20Name\x20\
    of\x20a\x20bucket.\n\n\x0f\n\x05\x04\x03\x02\0\x04\x12\x06\x82\x03\x02\
    \x80\x03)\n\r\n\x05\x04\x03\x02\0\x05\x12\x04\x82\x03\x02\x08\n\r\n\x05\
    \x04\x03\x02\0\x01\x12\x04\x82\x03\t\x0f\n\r\n\x05\x04\x03\x02\0\x03\x12\
    \x04\x82\x03\x12\x13\n\r\n\x05\x04\x03\x02\0\x08\x12\x04\x82\x03\x14<\n\
    \x10\n\x08\x04\x03\x02\0\x08\x9c\x08\0\x12\x04\x82\x03\x15;\nG\n\x04\x04\
    \x03\x02\x01\x12\x04\x85\x03\x020\x1a9\x20A\x20set\x20of\x20parameters\
    \x20common\x20to\x20all\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04\
    \x03\x02\x01\x04\x12\x06\x85\x03\x02\x82\x03=\n\r\n\x05\x04\x03\x02\x01\
    \x06\x12\x04\x85\x03\x02\x15\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\x85\
    \x03\x16+\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\x85\x03./\n5\n\x02\x04\
    \x04\x12\x06\x89\x03\0\xa6\x03\x01\x1a'\x20Request\x20for\x20PatchBucket\
    AccessControl.\n\n\x0b\n\x03\x04\x04\x01\x12\x04\x89\x03\x08'\n+\n\x04\
    \x04\x04\x02\0\x12\x04\x8b\x03\x02=\x1a\x1d\x20Required.\x20Name\x20of\
    \x20a\x20bucket.\n\n\x0f\n\x05\x04\x04\x02\0\x04\x12\x06\x8b\x03\x02\x89\
    \x03)\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\x8b\x03\x02\x08\n\r\n\x05\x04\
    \x04\x02\0\x01\x12\x04\x8b\x03\t\x0f\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\
    \x8b\x03\x12\x13\n\r\n\x05\x04\x04\x02\0\x08\x12\x04\x8b\x03\x14<\n\x10\
    \n\x08\x04\x04\x02\0\x08\x9c\x08\0\x12\x04\x8b\x03\x15;\n\xd0\x01\n\x04\
    \x04\x04\x02\x01\x12\x04\x94\x03\x02=\x1a\xc1\x01\x20Required.\x20The\
    \x20entity\x20holding\x20the\x20permission.\x20Can\x20be\x20one\x20of:\n\
    \x20*\x20`user-`*userId*\n\x20*\x20`user-`*emailAddress*\n\x20*\x20`grou\
    p-`*groupId*\n\x20*\x20`group-`*emailAddress*\n\x20*\x20`allUsers`\n\x20\
    *\x20`allAuthenticatedUsers`\n\n\x0f\n\x05\x04\x04\x02\x01\x04\x12\x06\
    \x94\x03\x02\x8b\x03=\n\r\n\x05\x04\x04\x02\x01\x05\x12\x04\x94\x03\x02\
    \x08\n\r\n\x05\x04\x04\x02\x01\x01\x12\x04\x94\x03\t\x0f\n\r\n\x05\x04\
    \x04\x02\x01\x03\x12\x04\x94\x03\x12\x13\n\r\n\x05\x04\x04\x02\x01\x08\
    \x12\x04\x94\x03\x14<\n\x10\n\x08\x04\x04\x02\x01\x08\x9c\x08\0\x12\x04\
    \x94\x03\x15;\n5\n\x04\x04\x04\x02\x02\x12\x04\x97\x03\x020\x1a'\x20The\
    \x20BucketAccessControl\x20for\x20updating.\n\n\x0f\n\x05\x04\x04\x02\
    \x02\x04\x12\x06\x97\x03\x02\x94\x03=\n\r\n\x05\x04\x04\x02\x02\x06\x12\
    \x04\x97\x03\x02\x15\n\r\n\x05\x04\x04\x02\x02\x01\x12\x04\x97\x03\x16+\
    \n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\x97\x03./\n\xa3\x02\n\x04\x04\x04\
    \x02\x03\x12\x04\xa2\x03\x02,\x1a\x94\x02\x20List\x20of\x20fields\x20to\
    \x20be\x20updated.\n\n\x20To\x20specify\x20ALL\x20fields,\x20equivalent\
    \x20to\x20the\x20JSON\x20API's\x20\"update\"\x20function,\n\x20specify\
    \x20a\x20single\x20field\x20with\x20the\x20value\x20`*`.\n\n\n\x20Not\
    \x20specifying\x20any\x20fields\x20is\x20an\x20error.\n\x20Not\x20specif\
    ying\x20a\x20field\x20while\x20setting\x20that\x20field\x20to\x20a\x20no\
    n-default\x20value\x20is\n\x20an\x20error.\n\n\x0f\n\x05\x04\x04\x02\x03\
    \x04\x12\x06\xa2\x03\x02\x97\x030\n\r\n\x05\x04\x04\x02\x03\x06\x12\x04\
    \xa2\x03\x02\x1b\n\r\n\x05\x04\x04\x02\x03\x01\x12\x04\xa2\x03\x1c'\n\r\
    \n\x05\x04\x04\x02\x03\x03\x12\x04\xa2\x03*+\nG\n\x04\x04\x04\x02\x04\
    \x12\x04\xa5\x03\x020\x1a9\x20A\x20set\x20of\x20parameters\x20common\x20\
    to\x20all\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04\x04\x02\x04\
    \x04\x12\x06\xa5\x03\x02\xa2\x03,\n\r\n\x05\x04\x04\x02\x04\x06\x12\x04\
    \xa5\x03\x02\x15\n\r\n\x05\x04\x04\x02\x04\x01\x12\x04\xa5\x03\x16+\n\r\
    \n\x05\x04\x04\x02\x04\x03\x12\x04\xa5\x03./\n6\n\x02\x04\x05\x12\x06\
    \xa9\x03\0\xbb\x03\x01\x1a(\x20Request\x20for\x20UpdateBucketAccessContr\
    ol.\n\n\x0b\n\x03\x04\x05\x01\x12\x04\xa9\x03\x08(\n+\n\x04\x04\x05\x02\
    \0\x12\x04\xab\x03\x02=\x1a\x1d\x20Required.\x20Name\x20of\x20a\x20bucke\
    t.\n\n\x0f\n\x05\x04\x05\x02\0\x04\x12\x06\xab\x03\x02\xa9\x03*\n\r\n\
    \x05\x04\x05\x02\0\x05\x12\x04\xab\x03\x02\x08\n\r\n\x05\x04\x05\x02\0\
    \x01\x12\x04\xab\x03\t\x0f\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xab\x03\
    \x12\x13\n\r\n\x05\x04\x05\x02\0\x08\x12\x04\xab\x03\x14<\n\x10\n\x08\
    \x04\x05\x02\0\x08\x9c\x08\0\x12\x04\xab\x03\x15;\n\xd0\x01\n\x04\x04\
    \x05\x02\x01\x12\x04\xb4\x03\x02=\x1a\xc1\x01\x20Required.\x20The\x20ent\
    ity\x20holding\x20the\x20permission.\x20Can\x20be\x20one\x20of:\n\x20*\
    \x20`user-`*userId*\n\x20*\x20`user-`*emailAddress*\n\x20*\x20`group-`*g\
    roupId*\n\x20*\x20`group-`*emailAddress*\n\x20*\x20`allUsers`\n\x20*\x20\
    `allAuthenticatedUsers`\n\n\x0f\n\x05\x04\x05\x02\x01\x04\x12\x06\xb4\
    \x03\x02\xab\x03=\n\r\n\x05\x04\x05\x02\x01\x05\x12\x04\xb4\x03\x02\x08\
    \n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\xb4\x03\t\x0f\n\r\n\x05\x04\x05\
    \x02\x01\x03\x12\x04\xb4\x03\x12\x13\n\r\n\x05\x04\x05\x02\x01\x08\x12\
    \x04\xb4\x03\x14<\n\x10\n\x08\x04\x05\x02\x01\x08\x9c\x08\0\x12\x04\xb4\
    \x03\x15;\n5\n\x04\x04\x05\x02\x02\x12\x04\xb7\x03\x020\x1a'\x20The\x20B\
    ucketAccessControl\x20for\x20updating.\n\n\x0f\n\x05\x04\x05\x02\x02\x04\
    \x12\x06\xb7\x03\x02\xb4\x03=\n\r\n\x05\x04\x05\x02\x02\x06\x12\x04\xb7\
    \x03\x02\x15\n\r\n\x05\x04\x05\x02\x02\x01\x12\x04\xb7\x03\x16+\n\r\n\
    \x05\x04\x05\x02\x02\x03\x12\x04\xb7\x03./\nG\n\x04\x04\x05\x02\x03\x12\
    \x04\xba\x03\x020\x1a9\x20A\x20set\x20of\x20parameters\x20common\x20to\
    \x20all\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04\x05\x02\x03\x04\
    \x12\x06\xba\x03\x02\xb7\x030\n\r\n\x05\x04\x05\x02\x03\x06\x12\x04\xba\
    \x03\x02\x15\n\r\n\x05\x04\x05\x02\x03\x01\x12\x04\xba\x03\x16+\n\r\n\
    \x05\x04\x05\x02\x03\x03\x12\x04\xba\x03./\n1\n\x02\x04\x06\x12\x06\xbe\
    \x03\0\xcb\x03\x01\x1a#\x20Request\x20message\x20for\x20DeleteBucket.\n\
    \n\x0b\n\x03\x04\x06\x01\x12\x04\xbe\x03\x08\x1b\n+\n\x04\x04\x06\x02\0\
    \x12\x04\xc0\x03\x02=\x1a\x1d\x20Required.\x20Name\x20of\x20a\x20bucket.\
    \n\n\x0f\n\x05\x04\x06\x02\0\x04\x12\x06\xc0\x03\x02\xbe\x03\x1d\n\r\n\
    \x05\x04\x06\x02\0\x05\x12\x04\xc0\x03\x02\x08\n\r\n\x05\x04\x06\x02\0\
    \x01\x12\x04\xc0\x03\t\x0f\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xc0\x03\
    \x12\x13\n\r\n\x05\x04\x06\x02\0\x08\x12\x04\xc0\x03\x14<\n\x10\n\x08\
    \x04\x06\x02\0\x08\x9c\x08\0\x12\x04\xc0\x03\x15;\nY\n\x04\x04\x06\x02\
    \x01\x12\x04\xc3\x03\x029\x1aK\x20If\x20set,\x20only\x20deletes\x20the\
    \x20bucket\x20if\x20its\x20metageneration\x20matches\x20this\x20value.\n\
    \n\x0f\n\x05\x04\x06\x02\x01\x04\x12\x06\xc3\x03\x02\xc0\x03=\n\r\n\x05\
    \x04\x06\x02\x01\x06\x12\x04\xc3\x03\x02\x1c\n\r\n\x05\x04\x06\x02\x01\
    \x01\x12\x04\xc3\x03\x1d4\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xc3\x037\
    8\na\n\x04\x04\x06\x02\x02\x12\x04\xc7\x03\x02=\x1aS\x20If\x20set,\x20on\
    ly\x20deletes\x20the\x20bucket\x20if\x20its\x20metageneration\x20does\
    \x20not\x20match\x20this\n\x20value.\n\n\x0f\n\x05\x04\x06\x02\x02\x04\
    \x12\x06\xc7\x03\x02\xc3\x039\n\r\n\x05\x04\x06\x02\x02\x06\x12\x04\xc7\
    \x03\x02\x1c\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\xc7\x03\x1d8\n\r\n\
    \x05\x04\x06\x02\x02\x03\x12\x04\xc7\x03;<\nG\n\x04\x04\x06\x02\x03\x12\
    \x04\xca\x03\x020\x1a9\x20A\x20set\x20of\x20parameters\x20common\x20to\
    \x20all\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04\x06\x02\x03\x04\
    \x12\x06\xca\x03\x02\xc7\x03=\n\r\n\x05\x04\x06\x02\x03\x06\x12\x04\xca\
    \x03\x02\x15\n\r\n\x05\x04\x06\x02\x03\x01\x12\x04\xca\x03\x16+\n\r\n\
    \x05\x04\x06\x02\x03\x03\x12\x04\xca\x03./\n.\n\x02\x04\x07\x12\x06\xce\
    \x03\0\xdf\x03\x01\x1a\x20\x20Request\x20message\x20for\x20GetBucket.\n\
    \n\x0b\n\x03\x04\x07\x01\x12\x04\xce\x03\x08\x18\n+\n\x04\x04\x07\x02\0\
    \x12\x04\xd0\x03\x02=\x1a\x1d\x20Required.\x20Name\x20of\x20a\x20bucket.\
    \n\n\x0f\n\x05\x04\x07\x02\0\x04\x12\x06\xd0\x03\x02\xce\x03\x1a\n\r\n\
    \x05\x04\x07\x02\0\x05\x12\x04\xd0\x03\x02\x08\n\r\n\x05\x04\x07\x02\0\
    \x01\x12\x04\xd0\x03\t\x0f\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xd0\x03\
    \x12\x13\n\r\n\x05\x04\x07\x02\0\x08\x12\x04\xd0\x03\x14<\n\x10\n\x08\
    \x04\x07\x02\0\x08\x9c\x08\0\x12\x04\xd0\x03\x15;\n\x8c\x01\n\x04\x04\
    \x07\x02\x01\x12\x04\xd4\x03\x029\x1a~\x20Makes\x20the\x20return\x20of\
    \x20the\x20bucket\x20metadata\x20conditional\x20on\x20whether\x20the\x20\
    bucket's\n\x20current\x20metageneration\x20matches\x20the\x20given\x20va\
    lue.\n\n\x0f\n\x05\x04\x07\x02\x01\x04\x12\x06\xd4\x03\x02\xd0\x03=\n\r\
    \n\x05\x04\x07\x02\x01\x06\x12\x04\xd4\x03\x02\x1c\n\r\n\x05\x04\x07\x02\
    \x01\x01\x12\x04\xd4\x03\x1d4\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\xd4\
    \x0378\n\x94\x01\n\x04\x04\x07\x02\x02\x12\x04\xd8\x03\x02=\x1a\x85\x01\
    \x20Makes\x20the\x20return\x20of\x20the\x20bucket\x20metadata\x20conditi\
    onal\x20on\x20whether\x20the\x20bucket's\n\x20current\x20metageneration\
    \x20does\x20not\x20match\x20the\x20given\x20value.\n\n\x0f\n\x05\x04\x07\
    \x02\x02\x04\x12\x06\xd8\x03\x02\xd4\x039\n\r\n\x05\x04\x07\x02\x02\x06\
    \x12\x04\xd8\x03\x02\x1c\n\r\n\x05\x04\x07\x02\x02\x01\x12\x04\xd8\x03\
    \x1d8\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\xd8\x03;<\nB\n\x04\x04\x07\
    \x02\x03\x12\x04\xdb\x03\x02(\x1a4\x20Set\x20of\x20properties\x20to\x20r\
    eturn.\x20Defaults\x20to\x20`NO_ACL`.\n\n\x0f\n\x05\x04\x07\x02\x03\x04\
    \x12\x06\xdb\x03\x02\xd8\x03=\n\r\n\x05\x04\x07\x02\x03\x06\x12\x04\xdb\
    \x03\x02\x18\n\r\n\x05\x04\x07\x02\x03\x01\x12\x04\xdb\x03\x19#\n\r\n\
    \x05\x04\x07\x02\x03\x03\x12\x04\xdb\x03&'\nG\n\x04\x04\x07\x02\x04\x12\
    \x04\xde\x03\x020\x1a9\x20A\x20set\x20of\x20parameters\x20common\x20to\
    \x20all\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04\x07\x02\x04\x04\
    \x12\x06\xde\x03\x02\xdb\x03(\n\r\n\x05\x04\x07\x02\x04\x06\x12\x04\xde\
    \x03\x02\x15\n\r\n\x05\x04\x07\x02\x04\x01\x12\x04\xde\x03\x16+\n\r\n\
    \x05\x04\x07\x02\x04\x03\x12\x04\xde\x03./\n1\n\x02\x04\x08\x12\x06\xe2\
    \x03\0\xf6\x03\x01\x1a#\x20Request\x20message\x20for\x20InsertBucket.\n\
    \n\x0b\n\x03\x04\x08\x01\x12\x04\xe2\x03\x08\x1b\nI\n\x04\x04\x08\x02\0\
    \x12\x04\xe4\x03\x025\x1a;\x20Apply\x20a\x20predefined\x20set\x20of\x20a\
    ccess\x20controls\x20to\x20this\x20bucket.\n\n\x0f\n\x05\x04\x08\x02\0\
    \x04\x12\x06\xe4\x03\x02\xe2\x03\x1d\n\r\n\x05\x04\x08\x02\0\x06\x12\x04\
    \xe4\x03\x02!\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xe4\x03\"0\n\r\n\x05\
    \x04\x08\x02\0\x03\x12\x04\xe4\x0334\nX\n\x04\x04\x08\x02\x01\x12\x04\
    \xe7\x03\x02D\x1aJ\x20Apply\x20a\x20predefined\x20set\x20of\x20default\
    \x20object\x20access\x20controls\x20to\x20this\x20bucket.\n\n\x0f\n\x05\
    \x04\x08\x02\x01\x04\x12\x06\xe7\x03\x02\xe4\x035\n\r\n\x05\x04\x08\x02\
    \x01\x06\x12\x04\xe7\x03\x02!\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xe7\
    \x03\"?\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\xe7\x03BC\n9\n\x04\x04\x08\
    \x02\x02\x12\x04\xea\x03\x02>\x1a+\x20Required.\x20A\x20valid\x20API\x20\
    project\x20identifier.\n\n\x0f\n\x05\x04\x08\x02\x02\x04\x12\x06\xea\x03\
    \x02\xe7\x03D\n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\xea\x03\x02\x08\n\r\
    \n\x05\x04\x08\x02\x02\x01\x12\x04\xea\x03\t\x10\n\r\n\x05\x04\x08\x02\
    \x02\x03\x12\x04\xea\x03\x13\x14\n\r\n\x05\x04\x08\x02\x02\x08\x12\x04\
    \xea\x03\x15=\n\x10\n\x08\x04\x08\x02\x02\x08\x9c\x08\0\x12\x04\xea\x03\
    \x16<\n\xae\x01\n\x04\x04\x08\x02\x03\x12\x04\xef\x03\x02(\x1a\x9f\x01\
    \x20Set\x20of\x20properties\x20to\x20return.\x20Defaults\x20to\x20`NO_AC\
    L`,\x20unless\x20the\n\x20bucket\x20resource\x20specifies\x20`acl`\x20or\
    \x20`defaultObjectAcl`\n\x20properties,\x20when\x20it\x20defaults\x20to\
    \x20`FULL`.\n\n\x0f\n\x05\x04\x08\x02\x03\x04\x12\x06\xef\x03\x02\xea\
    \x03>\n\r\n\x05\x04\x08\x02\x03\x06\x12\x04\xef\x03\x02\x18\n\r\n\x05\
    \x04\x08\x02\x03\x01\x12\x04\xef\x03\x19#\n\r\n\x05\x04\x08\x02\x03\x03\
    \x12\x04\xef\x03&'\nP\n\x04\x04\x08\x02\x04\x12\x04\xf2\x03\x02\x14\x1aB\
    \x20Properties\x20of\x20the\x20new\x20bucket\x20being\x20inserted,\x20in\
    cluding\x20its\x20name.\n\n\x0f\n\x05\x04\x08\x02\x04\x04\x12\x06\xf2\
    \x03\x02\xef\x03(\n\r\n\x05\x04\x08\x02\x04\x06\x12\x04\xf2\x03\x02\x08\
    \n\r\n\x05\x04\x08\x02\x04\x01\x12\x04\xf2\x03\t\x0f\n\r\n\x05\x04\x08\
    \x02\x04\x03\x12\x04\xf2\x03\x12\x13\nG\n\x04\x04\x08\x02\x05\x12\x04\
    \xf5\x03\x020\x1a9\x20A\x20set\x20of\x20parameters\x20common\x20to\x20al\
    l\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04\x08\x02\x05\x04\x12\
    \x06\xf5\x03\x02\xf2\x03\x14\n\r\n\x05\x04\x08\x02\x05\x06\x12\x04\xf5\
    \x03\x02\x15\n\r\n\x05\x04\x08\x02\x05\x01\x12\x04\xf5\x03\x16+\n\r\n\
    \x05\x04\x08\x02\x05\x03\x12\x04\xf5\x03./\n1\n\x02\x04\t\x12\x06\xf9\
    \x03\0\xff\x03\x01\x1a#\x20Request\x20message\x20for\x20ListChannels.\n\
    \n\x0b\n\x03\x04\t\x01\x12\x04\xf9\x03\x08\x1b\n+\n\x04\x04\t\x02\0\x12\
    \x04\xfb\x03\x02=\x1a\x1d\x20Required.\x20Name\x20of\x20a\x20bucket.\n\n\
    \x0f\n\x05\x04\t\x02\0\x04\x12\x06\xfb\x03\x02\xf9\x03\x1d\n\r\n\x05\x04\
    \t\x02\0\x05\x12\x04\xfb\x03\x02\x08\n\r\n\x05\x04\t\x02\0\x01\x12\x04\
    \xfb\x03\t\x0f\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xfb\x03\x12\x13\n\r\n\
    \x05\x04\t\x02\0\x08\x12\x04\xfb\x03\x14<\n\x10\n\x08\x04\t\x02\0\x08\
    \x9c\x08\0\x12\x04\xfb\x03\x15;\nG\n\x04\x04\t\x02\x01\x12\x04\xfe\x03\
    \x020\x1a9\x20A\x20set\x20of\x20parameters\x20common\x20to\x20all\x20Sto\
    rage\x20API\x20requests.\n\n\x0f\n\x05\x04\t\x02\x01\x04\x12\x06\xfe\x03\
    \x02\xfb\x03=\n\r\n\x05\x04\t\x02\x01\x06\x12\x04\xfe\x03\x02\x15\n\r\n\
    \x05\x04\t\x02\x01\x01\x12\x04\xfe\x03\x16+\n\r\n\x05\x04\t\x02\x01\x03\
    \x12\x04\xfe\x03./\n0\n\x02\x04\n\x12\x06\x82\x04\0\x96\x04\x01\x1a\"\
    \x20Request\x20message\x20for\x20ListBuckets.\n\n\x0b\n\x03\x04\n\x01\
    \x12\x04\x82\x04\x08\x1a\n\x95\x01\n\x04\x04\n\x02\0\x12\x04\x85\x04\x02\
    \x18\x1a\x86\x01\x20Maximum\x20number\x20of\x20buckets\x20to\x20return\
    \x20in\x20a\x20single\x20response.\x20The\x20service\x20will\n\x20use\
    \x20this\x20parameter\x20or\x201,000\x20items,\x20whichever\x20is\x20sma\
    ller.\n\n\x0f\n\x05\x04\n\x02\0\x04\x12\x06\x85\x04\x02\x82\x04\x1c\n\r\
    \n\x05\x04\n\x02\0\x05\x12\x04\x85\x04\x02\x07\n\r\n\x05\x04\n\x02\0\x01\
    \x12\x04\x85\x04\x08\x13\n\r\n\x05\x04\n\x02\0\x03\x12\x04\x85\x04\x16\
    \x17\ni\n\x04\x04\n\x02\x01\x12\x04\x89\x04\x02\x18\x1a[\x20A\x20previou\
    sly-returned\x20page\x20token\x20representing\x20part\x20of\x20the\x20la\
    rger\x20set\x20of\n\x20results\x20to\x20view.\n\n\x0f\n\x05\x04\n\x02\
    \x01\x04\x12\x06\x89\x04\x02\x85\x04\x18\n\r\n\x05\x04\n\x02\x01\x05\x12\
    \x04\x89\x04\x02\x08\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\x89\x04\t\x13\n\
    \r\n\x05\x04\n\x02\x01\x03\x12\x04\x89\x04\x16\x17\nM\n\x04\x04\n\x02\
    \x02\x12\x04\x8c\x04\x02\x14\x1a?\x20Filter\x20results\x20to\x20buckets\
    \x20whose\x20names\x20begin\x20with\x20this\x20prefix.\n\n\x0f\n\x05\x04\
    \n\x02\x02\x04\x12\x06\x8c\x04\x02\x89\x04\x18\n\r\n\x05\x04\n\x02\x02\
    \x05\x12\x04\x8c\x04\x02\x08\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\x8c\x04\
    \t\x0f\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\x8c\x04\x12\x13\n9\n\x04\x04\
    \n\x02\x03\x12\x04\x8f\x04\x02>\x1a+\x20Required.\x20A\x20valid\x20API\
    \x20project\x20identifier.\n\n\x0f\n\x05\x04\n\x02\x03\x04\x12\x06\x8f\
    \x04\x02\x8c\x04\x14\n\r\n\x05\x04\n\x02\x03\x05\x12\x04\x8f\x04\x02\x08\
    \n\r\n\x05\x04\n\x02\x03\x01\x12\x04\x8f\x04\t\x10\n\r\n\x05\x04\n\x02\
    \x03\x03\x12\x04\x8f\x04\x13\x14\n\r\n\x05\x04\n\x02\x03\x08\x12\x04\x8f\
    \x04\x15=\n\x10\n\x08\x04\n\x02\x03\x08\x9c\x08\0\x12\x04\x8f\x04\x16<\n\
    B\n\x04\x04\n\x02\x04\x12\x04\x92\x04\x02(\x1a4\x20Set\x20of\x20properti\
    es\x20to\x20return.\x20Defaults\x20to\x20`NO_ACL`.\n\n\x0f\n\x05\x04\n\
    \x02\x04\x04\x12\x06\x92\x04\x02\x8f\x04>\n\r\n\x05\x04\n\x02\x04\x06\
    \x12\x04\x92\x04\x02\x18\n\r\n\x05\x04\n\x02\x04\x01\x12\x04\x92\x04\x19\
    #\n\r\n\x05\x04\n\x02\x04\x03\x12\x04\x92\x04&'\nG\n\x04\x04\n\x02\x05\
    \x12\x04\x95\x04\x020\x1a9\x20A\x20set\x20of\x20parameters\x20common\x20\
    to\x20all\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04\n\x02\x05\x04\
    \x12\x06\x95\x04\x02\x92\x04(\n\r\n\x05\x04\n\x02\x05\x06\x12\x04\x95\
    \x04\x02\x15\n\r\n\x05\x04\n\x02\x05\x01\x12\x04\x95\x04\x16+\n\r\n\x05\
    \x04\n\x02\x05\x03\x12\x04\x95\x04./\n8\n\x02\x04\x0b\x12\x06\x99\x04\0\
    \xa3\x04\x01\x1a*\x20Request\x20message\x20for\x20LockRetentionPolicy.\n\
    \n\x0b\n\x03\x04\x0b\x01\x12\x04\x99\x04\x08\"\n+\n\x04\x04\x0b\x02\0\
    \x12\x04\x9b\x04\x02=\x1a\x1d\x20Required.\x20Name\x20of\x20a\x20bucket.\
    \n\n\x0f\n\x05\x04\x0b\x02\0\x04\x12\x06\x9b\x04\x02\x99\x04$\n\r\n\x05\
    \x04\x0b\x02\0\x05\x12\x04\x9b\x04\x02\x08\n\r\n\x05\x04\x0b\x02\0\x01\
    \x12\x04\x9b\x04\t\x0f\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\x9b\x04\x12\
    \x13\n\r\n\x05\x04\x0b\x02\0\x08\x12\x04\x9b\x04\x14<\n\x10\n\x08\x04\
    \x0b\x02\0\x08\x9c\x08\0\x12\x04\x9b\x04\x15;\n\x86\x01\n\x04\x04\x0b\
    \x02\x01\x12\x04\x9f\x04\x02$\x1ax\x20Makes\x20the\x20operation\x20condi\
    tional\x20on\x20whether\x20bucket's\x20current\x20metageneration\n\x20ma\
    tches\x20the\x20given\x20value.\x20Must\x20be\x20positive.\n\n\x0f\n\x05\
    \x04\x0b\x02\x01\x04\x12\x06\x9f\x04\x02\x9b\x04=\n\r\n\x05\x04\x0b\x02\
    \x01\x05\x12\x04\x9f\x04\x02\x07\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\
    \x9f\x04\x08\x1f\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\x9f\x04\"#\nG\n\
    \x04\x04\x0b\x02\x02\x12\x04\xa2\x04\x020\x1a9\x20A\x20set\x20of\x20para\
    meters\x20common\x20to\x20all\x20Storage\x20API\x20requests.\n\n\x0f\n\
    \x05\x04\x0b\x02\x02\x04\x12\x06\xa2\x04\x02\x9f\x04$\n\r\n\x05\x04\x0b\
    \x02\x02\x06\x12\x04\xa2\x04\x02\x15\n\r\n\x05\x04\x0b\x02\x02\x01\x12\
    \x04\xa2\x04\x16+\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\xa2\x04./\n/\n\
    \x02\x04\x0c\x12\x06\xa6\x04\0\xcc\x04\x01\x1a!\x20Request\x20for\x20Pat\
    chBucket\x20method.\n\n\x0b\n\x03\x04\x0c\x01\x12\x04\xa6\x04\x08\x1a\n+\
    \n\x04\x04\x0c\x02\0\x12\x04\xa8\x04\x02=\x1a\x1d\x20Required.\x20Name\
    \x20of\x20a\x20bucket.\n\n\x0f\n\x05\x04\x0c\x02\0\x04\x12\x06\xa8\x04\
    \x02\xa6\x04\x1c\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\xa8\x04\x02\x08\n\r\
    \n\x05\x04\x0c\x02\0\x01\x12\x04\xa8\x04\t\x0f\n\r\n\x05\x04\x0c\x02\0\
    \x03\x12\x04\xa8\x04\x12\x13\n\r\n\x05\x04\x0c\x02\0\x08\x12\x04\xa8\x04\
    \x14<\n\x10\n\x08\x04\x0c\x02\0\x08\x9c\x08\0\x12\x04\xa8\x04\x15;\n\x8c\
    \x01\n\x04\x04\x0c\x02\x01\x12\x04\xac\x04\x029\x1a~\x20Makes\x20the\x20\
    return\x20of\x20the\x20bucket\x20metadata\x20conditional\x20on\x20whethe\
    r\x20the\x20bucket's\n\x20current\x20metageneration\x20matches\x20the\
    \x20given\x20value.\n\n\x0f\n\x05\x04\x0c\x02\x01\x04\x12\x06\xac\x04\
    \x02\xa8\x04=\n\r\n\x05\x04\x0c\x02\x01\x06\x12\x04\xac\x04\x02\x1c\n\r\
    \n\x05\x04\x0c\x02\x01\x01\x12\x04\xac\x04\x1d4\n\r\n\x05\x04\x0c\x02\
    \x01\x03\x12\x04\xac\x0478\n\x94\x01\n\x04\x04\x0c\x02\x02\x12\x04\xb0\
    \x04\x02=\x1a\x85\x01\x20Makes\x20the\x20return\x20of\x20the\x20bucket\
    \x20metadata\x20conditional\x20on\x20whether\x20the\x20bucket's\n\x20cur\
    rent\x20metageneration\x20does\x20not\x20match\x20the\x20given\x20value.\
    \n\n\x0f\n\x05\x04\x0c\x02\x02\x04\x12\x06\xb0\x04\x02\xac\x049\n\r\n\
    \x05\x04\x0c\x02\x02\x06\x12\x04\xb0\x04\x02\x1c\n\r\n\x05\x04\x0c\x02\
    \x02\x01\x12\x04\xb0\x04\x1d8\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\xb0\
    \x04;<\nI\n\x04\x04\x0c\x02\x03\x12\x04\xb3\x04\x025\x1a;\x20Apply\x20a\
    \x20predefined\x20set\x20of\x20access\x20controls\x20to\x20this\x20bucke\
    t.\n\n\x0f\n\x05\x04\x0c\x02\x03\x04\x12\x06\xb3\x04\x02\xb0\x04=\n\r\n\
    \x05\x04\x0c\x02\x03\x06\x12\x04\xb3\x04\x02!\n\r\n\x05\x04\x0c\x02\x03\
    \x01\x12\x04\xb3\x04\"0\n\r\n\x05\x04\x0c\x02\x03\x03\x12\x04\xb3\x0434\
    \nX\n\x04\x04\x0c\x02\x04\x12\x04\xb6\x04\x02D\x1aJ\x20Apply\x20a\x20pre\
    defined\x20set\x20of\x20default\x20object\x20access\x20controls\x20to\
    \x20this\x20bucket.\n\n\x0f\n\x05\x04\x0c\x02\x04\x04\x12\x06\xb6\x04\
    \x02\xb3\x045\n\r\n\x05\x04\x0c\x02\x04\x06\x12\x04\xb6\x04\x02!\n\r\n\
    \x05\x04\x0c\x02\x04\x01\x12\x04\xb6\x04\"?\n\r\n\x05\x04\x0c\x02\x04\
    \x03\x12\x04\xb6\x04BC\n@\n\x04\x04\x0c\x02\x05\x12\x04\xb9\x04\x02(\x1a\
    2\x20Set\x20of\x20properties\x20to\x20return.\x20Defaults\x20to\x20`FULL\
    `.\n\n\x0f\n\x05\x04\x0c\x02\x05\x04\x12\x06\xb9\x04\x02\xb6\x04D\n\r\n\
    \x05\x04\x0c\x02\x05\x06\x12\x04\xb9\x04\x02\x18\n\r\n\x05\x04\x0c\x02\
    \x05\x01\x12\x04\xb9\x04\x19#\n\r\n\x05\x04\x0c\x02\x05\x03\x12\x04\xb9\
    \x04&'\n1\n\x04\x04\x0c\x02\x06\x12\x04\xbc\x04\x02\x16\x1a#\x20The\x20B\
    ucket\x20metadata\x20for\x20updating.\n\n\x0f\n\x05\x04\x0c\x02\x06\x04\
    \x12\x06\xbc\x04\x02\xb9\x04(\n\r\n\x05\x04\x0c\x02\x06\x06\x12\x04\xbc\
    \x04\x02\x08\n\r\n\x05\x04\x0c\x02\x06\x01\x12\x04\xbc\x04\t\x11\n\r\n\
    \x05\x04\x0c\x02\x06\x03\x12\x04\xbc\x04\x14\x15\n\xbd\x03\n\x04\x04\x0c\
    \x02\x07\x12\x04\xc8\x04\x02,\x1a\xae\x03\x20List\x20of\x20fields\x20to\
    \x20be\x20updated.\n\n\x20To\x20specify\x20ALL\x20fields,\x20equivalent\
    \x20to\x20the\x20JSON\x20API's\x20\"update\"\x20function,\n\x20specify\
    \x20a\x20single\x20field\x20with\x20the\x20value\x20`*`.\x20Note:\x20not\
    \x20recommended.\x20If\x20a\x20new\n\x20field\x20is\x20introduced\x20at\
    \x20a\x20later\x20time,\x20an\x20older\x20client\x20updating\x20with\x20\
    the\x20`*`\n\x20may\x20accidentally\x20reset\x20the\x20new\x20field's\
    \x20value.\n\n\x20Not\x20specifying\x20any\x20fields\x20is\x20an\x20erro\
    r.\n\x20Not\x20specifying\x20a\x20field\x20while\x20setting\x20that\x20f\
    ield\x20to\x20a\x20non-default\x20value\x20is\n\x20an\x20error.\n\n\x0f\
    \n\x05\x04\x0c\x02\x07\x04\x12\x06\xc8\x04\x02\xbc\x04\x16\n\r\n\x05\x04\
    \x0c\x02\x07\x06\x12\x04\xc8\x04\x02\x1b\n\r\n\x05\x04\x0c\x02\x07\x01\
    \x12\x04\xc8\x04\x1c'\n\r\n\x05\x04\x0c\x02\x07\x03\x12\x04\xc8\x04*+\nG\
    \n\x04\x04\x0c\x02\x08\x12\x04\xcb\x04\x021\x1a9\x20A\x20set\x20of\x20pa\
    rameters\x20common\x20to\x20all\x20Storage\x20API\x20requests.\n\n\x0f\n\
    \x05\x04\x0c\x02\x08\x04\x12\x06\xcb\x04\x02\xc8\x04,\n\r\n\x05\x04\x0c\
    \x02\x08\x06\x12\x04\xcb\x04\x02\x15\n\r\n\x05\x04\x0c\x02\x08\x01\x12\
    \x04\xcb\x04\x16+\n\r\n\x05\x04\x0c\x02\x08\x03\x12\x04\xcb\x04.0\n0\n\
    \x02\x04\r\x12\x06\xcf\x04\0\xe9\x04\x01\x1a\"\x20Request\x20for\x20Upda\
    teBucket\x20method.\n\n\x0b\n\x03\x04\r\x01\x12\x04\xcf\x04\x08\x1b\n+\n\
    \x04\x04\r\x02\0\x12\x04\xd1\x04\x02=\x1a\x1d\x20Required.\x20Name\x20of\
    \x20a\x20bucket.\n\n\x0f\n\x05\x04\r\x02\0\x04\x12\x06\xd1\x04\x02\xcf\
    \x04\x1d\n\r\n\x05\x04\r\x02\0\x05\x12\x04\xd1\x04\x02\x08\n\r\n\x05\x04\
    \r\x02\0\x01\x12\x04\xd1\x04\t\x0f\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xd1\
    \x04\x12\x13\n\r\n\x05\x04\r\x02\0\x08\x12\x04\xd1\x04\x14<\n\x10\n\x08\
    \x04\r\x02\0\x08\x9c\x08\0\x12\x04\xd1\x04\x15;\n\x8c\x01\n\x04\x04\r\
    \x02\x01\x12\x04\xd5\x04\x029\x1a~\x20Makes\x20the\x20return\x20of\x20th\
    e\x20bucket\x20metadata\x20conditional\x20on\x20whether\x20the\x20bucket\
    's\n\x20current\x20metageneration\x20matches\x20the\x20given\x20value.\n\
    \n\x0f\n\x05\x04\r\x02\x01\x04\x12\x06\xd5\x04\x02\xd1\x04=\n\r\n\x05\
    \x04\r\x02\x01\x06\x12\x04\xd5\x04\x02\x1c\n\r\n\x05\x04\r\x02\x01\x01\
    \x12\x04\xd5\x04\x1d4\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xd5\x0478\n\
    \x94\x01\n\x04\x04\r\x02\x02\x12\x04\xd9\x04\x02=\x1a\x85\x01\x20Makes\
    \x20the\x20return\x20of\x20the\x20bucket\x20metadata\x20conditional\x20o\
    n\x20whether\x20the\x20bucket's\n\x20current\x20metageneration\x20does\
    \x20not\x20match\x20the\x20given\x20value.\n\n\x0f\n\x05\x04\r\x02\x02\
    \x04\x12\x06\xd9\x04\x02\xd5\x049\n\r\n\x05\x04\r\x02\x02\x06\x12\x04\
    \xd9\x04\x02\x1c\n\r\n\x05\x04\r\x02\x02\x01\x12\x04\xd9\x04\x1d8\n\r\n\
    \x05\x04\r\x02\x02\x03\x12\x04\xd9\x04;<\nI\n\x04\x04\r\x02\x03\x12\x04\
    \xdc\x04\x025\x1a;\x20Apply\x20a\x20predefined\x20set\x20of\x20access\
    \x20controls\x20to\x20this\x20bucket.\n\n\x0f\n\x05\x04\r\x02\x03\x04\
    \x12\x06\xdc\x04\x02\xd9\x04=\n\r\n\x05\x04\r\x02\x03\x06\x12\x04\xdc\
    \x04\x02!\n\r\n\x05\x04\r\x02\x03\x01\x12\x04\xdc\x04\"0\n\r\n\x05\x04\r\
    \x02\x03\x03\x12\x04\xdc\x0434\nX\n\x04\x04\r\x02\x04\x12\x04\xdf\x04\
    \x02D\x1aJ\x20Apply\x20a\x20predefined\x20set\x20of\x20default\x20object\
    \x20access\x20controls\x20to\x20this\x20bucket.\n\n\x0f\n\x05\x04\r\x02\
    \x04\x04\x12\x06\xdf\x04\x02\xdc\x045\n\r\n\x05\x04\r\x02\x04\x06\x12\
    \x04\xdf\x04\x02!\n\r\n\x05\x04\r\x02\x04\x01\x12\x04\xdf\x04\"?\n\r\n\
    \x05\x04\r\x02\x04\x03\x12\x04\xdf\x04BC\n@\n\x04\x04\r\x02\x05\x12\x04\
    \xe2\x04\x02(\x1a2\x20Set\x20of\x20properties\x20to\x20return.\x20Defaul\
    ts\x20to\x20`FULL`.\n\n\x0f\n\x05\x04\r\x02\x05\x04\x12\x06\xe2\x04\x02\
    \xdf\x04D\n\r\n\x05\x04\r\x02\x05\x06\x12\x04\xe2\x04\x02\x18\n\r\n\x05\
    \x04\r\x02\x05\x01\x12\x04\xe2\x04\x19#\n\r\n\x05\x04\r\x02\x05\x03\x12\
    \x04\xe2\x04&'\n1\n\x04\x04\r\x02\x06\x12\x04\xe5\x04\x02\x16\x1a#\x20Th\
    e\x20Bucket\x20metadata\x20for\x20updating.\n\n\x0f\n\x05\x04\r\x02\x06\
    \x04\x12\x06\xe5\x04\x02\xe2\x04(\n\r\n\x05\x04\r\x02\x06\x06\x12\x04\
    \xe5\x04\x02\x08\n\r\n\x05\x04\r\x02\x06\x01\x12\x04\xe5\x04\t\x11\n\r\n\
    \x05\x04\r\x02\x06\x03\x12\x04\xe5\x04\x14\x15\nG\n\x04\x04\r\x02\x07\
    \x12\x04\xe8\x04\x020\x1a9\x20A\x20set\x20of\x20parameters\x20common\x20\
    to\x20all\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04\r\x02\x07\x04\
    \x12\x06\xe8\x04\x02\xe5\x04\x16\n\r\n\x05\x04\r\x02\x07\x06\x12\x04\xe8\
    \x04\x02\x15\n\r\n\x05\x04\r\x02\x07\x01\x12\x04\xe8\x04\x16+\n\r\n\x05\
    \x04\r\x02\x07\x03\x12\x04\xe8\x04./\n0\n\x02\x04\x0e\x12\x06\xec\x04\0\
    \xf2\x04\x01\x1a\"\x20Request\x20message\x20for\x20StopChannel.\n\n\x0b\
    \n\x03\x04\x0e\x01\x12\x04\xec\x04\x08\x1a\n*\n\x04\x04\x0e\x02\0\x12\
    \x04\xee\x04\x02\x16\x1a\x1c\x20The\x20channel\x20to\x20be\x20stopped.\n\
    \n\x0f\n\x05\x04\x0e\x02\0\x04\x12\x06\xee\x04\x02\xec\x04\x1c\n\r\n\x05\
    \x04\x0e\x02\0\x06\x12\x04\xee\x04\x02\t\n\r\n\x05\x04\x0e\x02\0\x01\x12\
    \x04\xee\x04\n\x11\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xee\x04\x14\x15\n\
    G\n\x04\x04\x0e\x02\x01\x12\x04\xf1\x04\x020\x1a9\x20A\x20set\x20of\x20p\
    arameters\x20common\x20to\x20all\x20Storage\x20API\x20requests.\n\n\x0f\
    \n\x05\x04\x0e\x02\x01\x04\x12\x06\xf1\x04\x02\xee\x04\x16\n\r\n\x05\x04\
    \x0e\x02\x01\x06\x12\x04\xf1\x04\x02\x15\n\r\n\x05\x04\x0e\x02\x01\x01\
    \x12\x04\xf1\x04\x16+\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xf1\x04./\nE\
    \n\x02\x04\x0f\x12\x06\xf5\x04\0\x84\x05\x01\x1a7\x20Request\x20message\
    \x20for\x20DeleteDefaultObjectAccessControl.\n\n\x0b\n\x03\x04\x0f\x01\
    \x12\x04\xf5\x04\x08/\n+\n\x04\x04\x0f\x02\0\x12\x04\xf7\x04\x02=\x1a\
    \x1d\x20Required.\x20Name\x20of\x20a\x20bucket.\n\n\x0f\n\x05\x04\x0f\
    \x02\0\x04\x12\x06\xf7\x04\x02\xf5\x041\n\r\n\x05\x04\x0f\x02\0\x05\x12\
    \x04\xf7\x04\x02\x08\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xf7\x04\t\x0f\n\
    \r\n\x05\x04\x0f\x02\0\x03\x12\x04\xf7\x04\x12\x13\n\r\n\x05\x04\x0f\x02\
    \0\x08\x12\x04\xf7\x04\x14<\n\x10\n\x08\x04\x0f\x02\0\x08\x9c\x08\0\x12\
    \x04\xf7\x04\x15;\n\xd0\x01\n\x04\x04\x0f\x02\x01\x12\x04\x80\x05\x02=\
    \x1a\xc1\x01\x20Required.\x20The\x20entity\x20holding\x20the\x20permissi\
    on.\x20Can\x20be\x20one\x20of:\n\x20*\x20`user-`*userId*\n\x20*\x20`user\
    -`*emailAddress*\n\x20*\x20`group-`*groupId*\n\x20*\x20`group-`*emailAdd\
    ress*\n\x20*\x20`allUsers`\n\x20*\x20`allAuthenticatedUsers`\n\n\x0f\n\
    \x05\x04\x0f\x02\x01\x04\x12\x06\x80\x05\x02\xf7\x04=\n\r\n\x05\x04\x0f\
    \x02\x01\x05\x12\x04\x80\x05\x02\x08\n\r\n\x05\x04\x0f\x02\x01\x01\x12\
    \x04\x80\x05\t\x0f\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\x80\x05\x12\x13\
    \n\r\n\x05\x04\x0f\x02\x01\x08\x12\x04\x80\x05\x14<\n\x10\n\x08\x04\x0f\
    \x02\x01\x08\x9c\x08\0\x12\x04\x80\x05\x15;\nG\n\x04\x04\x0f\x02\x02\x12\
    \x04\x83\x05\x020\x1a9\x20A\x20set\x20of\x20parameters\x20common\x20to\
    \x20all\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04\x0f\x02\x02\x04\
    \x12\x06\x83\x05\x02\x80\x05=\n\r\n\x05\x04\x0f\x02\x02\x06\x12\x04\x83\
    \x05\x02\x15\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\x83\x05\x16+\n\r\n\
    \x05\x04\x0f\x02\x02\x03\x12\x04\x83\x05./\nB\n\x02\x04\x10\x12\x06\x87\
    \x05\0\x96\x05\x01\x1a4\x20Request\x20message\x20for\x20GetDefaultObject\
    AccessControl.\n\n\x0b\n\x03\x04\x10\x01\x12\x04\x87\x05\x08,\n+\n\x04\
    \x04\x10\x02\0\x12\x04\x89\x05\x02=\x1a\x1d\x20Required.\x20Name\x20of\
    \x20a\x20bucket.\n\n\x0f\n\x05\x04\x10\x02\0\x04\x12\x06\x89\x05\x02\x87\
    \x05.\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\x89\x05\x02\x08\n\r\n\x05\x04\
    \x10\x02\0\x01\x12\x04\x89\x05\t\x0f\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\
    \x89\x05\x12\x13\n\r\n\x05\x04\x10\x02\0\x08\x12\x04\x89\x05\x14<\n\x10\
    \n\x08\x04\x10\x02\0\x08\x9c\x08\0\x12\x04\x89\x05\x15;\n\xd0\x01\n\x04\
    \x04\x10\x02\x01\x12\x04\x92\x05\x02=\x1a\xc1\x01\x20Required.\x20The\
    \x20entity\x20holding\x20the\x20permission.\x20Can\x20be\x20one\x20of:\n\
    \x20*\x20`user-`*userId*\n\x20*\x20`user-`*emailAddress*\n\x20*\x20`grou\
    p-`*groupId*\n\x20*\x20`group-`*emailAddress*\n\x20*\x20`allUsers`\n\x20\
    *\x20`allAuthenticatedUsers`\n\n\x0f\n\x05\x04\x10\x02\x01\x04\x12\x06\
    \x92\x05\x02\x89\x05=\n\r\n\x05\x04\x10\x02\x01\x05\x12\x04\x92\x05\x02\
    \x08\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\x92\x05\t\x0f\n\r\n\x05\x04\
    \x10\x02\x01\x03\x12\x04\x92\x05\x12\x13\n\r\n\x05\x04\x10\x02\x01\x08\
    \x12\x04\x92\x05\x14<\n\x10\n\x08\x04\x10\x02\x01\x08\x9c\x08\0\x12\x04\
    \x92\x05\x15;\nG\n\x04\x04\x10\x02\x02\x12\x04\x95\x05\x020\x1a9\x20A\
    \x20set\x20of\x20parameters\x20common\x20to\x20all\x20Storage\x20API\x20\
    requests.\n\n\x0f\n\x05\x04\x10\x02\x02\x04\x12\x06\x95\x05\x02\x92\x05=\
    \n\r\n\x05\x04\x10\x02\x02\x06\x12\x04\x95\x05\x02\x15\n\r\n\x05\x04\x10\
    \x02\x02\x01\x12\x04\x95\x05\x16+\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\
    \x95\x05./\nE\n\x02\x04\x11\x12\x06\x99\x05\0\xa2\x05\x01\x1a7\x20Reques\
    t\x20message\x20for\x20InsertDefaultObjectAccessControl.\n\n\x0b\n\x03\
    \x04\x11\x01\x12\x04\x99\x05\x08/\n+\n\x04\x04\x11\x02\0\x12\x04\x9b\x05\
    \x02=\x1a\x1d\x20Required.\x20Name\x20of\x20a\x20bucket.\n\n\x0f\n\x05\
    \x04\x11\x02\0\x04\x12\x06\x9b\x05\x02\x99\x051\n\r\n\x05\x04\x11\x02\0\
    \x05\x12\x04\x9b\x05\x02\x08\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\x9b\x05\
    \t\x0f\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\x9b\x05\x12\x13\n\r\n\x05\x04\
    \x11\x02\0\x08\x12\x04\x9b\x05\x14<\n\x10\n\x08\x04\x11\x02\0\x08\x9c\
    \x08\0\x12\x04\x9b\x05\x15;\nG\n\x04\x04\x11\x02\x01\x12\x04\x9e\x05\x02\
    0\x1a9\x20Properties\x20of\x20the\x20object\x20access\x20control\x20bein\
    g\x20inserted.\n\n\x0f\n\x05\x04\x11\x02\x01\x04\x12\x06\x9e\x05\x02\x9b\
    \x05=\n\r\n\x05\x04\x11\x02\x01\x06\x12\x04\x9e\x05\x02\x15\n\r\n\x05\
    \x04\x11\x02\x01\x01\x12\x04\x9e\x05\x16+\n\r\n\x05\x04\x11\x02\x01\x03\
    \x12\x04\x9e\x05./\nG\n\x04\x04\x11\x02\x02\x12\x04\xa1\x05\x020\x1a9\
    \x20A\x20set\x20of\x20parameters\x20common\x20to\x20all\x20Storage\x20AP\
    I\x20requests.\n\n\x0f\n\x05\x04\x11\x02\x02\x04\x12\x06\xa1\x05\x02\x9e\
    \x050\n\r\n\x05\x04\x11\x02\x02\x06\x12\x04\xa1\x05\x02\x15\n\r\n\x05\
    \x04\x11\x02\x02\x01\x12\x04\xa1\x05\x16+\n\r\n\x05\x04\x11\x02\x02\x03\
    \x12\x04\xa1\x05./\nD\n\x02\x04\x12\x12\x06\xa5\x05\0\xb3\x05\x01\x1a6\
    \x20Request\x20message\x20for\x20ListDefaultObjectAccessControls.\n\n\
    \x0b\n\x03\x04\x12\x01\x12\x04\xa5\x05\x08.\n+\n\x04\x04\x12\x02\0\x12\
    \x04\xa7\x05\x02=\x1a\x1d\x20Required.\x20Name\x20of\x20a\x20bucket.\n\n\
    \x0f\n\x05\x04\x12\x02\0\x04\x12\x06\xa7\x05\x02\xa5\x050\n\r\n\x05\x04\
    \x12\x02\0\x05\x12\x04\xa7\x05\x02\x08\n\r\n\x05\x04\x12\x02\0\x01\x12\
    \x04\xa7\x05\t\x0f\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xa7\x05\x12\x13\n\
    \r\n\x05\x04\x12\x02\0\x08\x12\x04\xa7\x05\x14<\n\x10\n\x08\x04\x12\x02\
    \0\x08\x9c\x08\0\x12\x04\xa7\x05\x15;\nw\n\x04\x04\x12\x02\x01\x12\x04\
    \xab\x05\x029\x1ai\x20If\x20present,\x20only\x20return\x20default\x20ACL\
    \x20listing\x20if\x20the\x20bucket's\x20current\n\x20metageneration\x20m\
    atches\x20this\x20value.\n\n\x0f\n\x05\x04\x12\x02\x01\x04\x12\x06\xab\
    \x05\x02\xa7\x05=\n\r\n\x05\x04\x12\x02\x01\x06\x12\x04\xab\x05\x02\x1c\
    \n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xab\x05\x1d4\n\r\n\x05\x04\x12\
    \x02\x01\x03\x12\x04\xab\x0578\n\x83\x01\n\x04\x04\x12\x02\x02\x12\x04\
    \xaf\x05\x02=\x1au\x20If\x20present,\x20only\x20return\x20default\x20ACL\
    \x20listing\x20if\x20the\x20bucket's\x20current\n\x20metageneration\x20d\
    oes\x20not\x20match\x20the\x20given\x20value.\n\n\x0f\n\x05\x04\x12\x02\
    \x02\x04\x12\x06\xaf\x05\x02\xab\x059\n\r\n\x05\x04\x12\x02\x02\x06\x12\
    \x04\xaf\x05\x02\x1c\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\xaf\x05\x1d8\
    \n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\xaf\x05;<\nG\n\x04\x04\x12\x02\
    \x03\x12\x04\xb2\x05\x020\x1a9\x20A\x20set\x20of\x20parameters\x20common\
    \x20to\x20all\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04\x12\x02\
    \x03\x04\x12\x06\xb2\x05\x02\xaf\x05=\n\r\n\x05\x04\x12\x02\x03\x06\x12\
    \x04\xb2\x05\x02\x15\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\xb2\x05\x16+\
    \n\r\n\x05\x04\x12\x02\x03\x03\x12\x04\xb2\x05./\nD\n\x02\x04\x13\x12\
    \x06\xb6\x05\0\xd4\x05\x01\x1a6\x20Request\x20message\x20for\x20PatchDef\
    aultObjectAccessControl.\n\n\x0b\n\x03\x04\x13\x01\x12\x04\xb6\x05\x08.\
    \n+\n\x04\x04\x13\x02\0\x12\x04\xb8\x05\x02=\x1a\x1d\x20Required.\x20Nam\
    e\x20of\x20a\x20bucket.\n\n\x0f\n\x05\x04\x13\x02\0\x04\x12\x06\xb8\x05\
    \x02\xb6\x050\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xb8\x05\x02\x08\n\r\n\
    \x05\x04\x13\x02\0\x01\x12\x04\xb8\x05\t\x0f\n\r\n\x05\x04\x13\x02\0\x03\
    \x12\x04\xb8\x05\x12\x13\n\r\n\x05\x04\x13\x02\0\x08\x12\x04\xb8\x05\x14\
    <\n\x10\n\x08\x04\x13\x02\0\x08\x9c\x08\0\x12\x04\xb8\x05\x15;\n\xd0\x01\
    \n\x04\x04\x13\x02\x01\x12\x04\xc1\x05\x02=\x1a\xc1\x01\x20Required.\x20\
    The\x20entity\x20holding\x20the\x20permission.\x20Can\x20be\x20one\x20of\
    :\n\x20*\x20`user-`*userId*\n\x20*\x20`user-`*emailAddress*\n\x20*\x20`g\
    roup-`*groupId*\n\x20*\x20`group-`*emailAddress*\n\x20*\x20`allUsers`\n\
    \x20*\x20`allAuthenticatedUsers`\n\n\x0f\n\x05\x04\x13\x02\x01\x04\x12\
    \x06\xc1\x05\x02\xb8\x05=\n\r\n\x05\x04\x13\x02\x01\x05\x12\x04\xc1\x05\
    \x02\x08\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xc1\x05\t\x0f\n\r\n\x05\
    \x04\x13\x02\x01\x03\x12\x04\xc1\x05\x12\x13\n\r\n\x05\x04\x13\x02\x01\
    \x08\x12\x04\xc1\x05\x14<\n\x10\n\x08\x04\x13\x02\x01\x08\x9c\x08\0\x12\
    \x04\xc1\x05\x15;\n5\n\x04\x04\x13\x02\x02\x12\x04\xc4\x05\x020\x1a'\x20\
    The\x20ObjectAccessControl\x20for\x20updating.\n\n\x0f\n\x05\x04\x13\x02\
    \x02\x04\x12\x06\xc4\x05\x02\xc1\x05=\n\r\n\x05\x04\x13\x02\x02\x06\x12\
    \x04\xc4\x05\x02\x15\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\xc4\x05\x16+\
    \n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\xc4\x05./\n\xbd\x03\n\x04\x04\x13\
    \x02\x03\x12\x04\xd0\x05\x02,\x1a\xae\x03\x20List\x20of\x20fields\x20to\
    \x20be\x20updated.\n\n\x20To\x20specify\x20ALL\x20fields,\x20equivalent\
    \x20to\x20the\x20JSON\x20API's\x20\"update\"\x20function,\n\x20specify\
    \x20a\x20single\x20field\x20with\x20the\x20value\x20`*`.\x20Note:\x20not\
    \x20recommended.\x20If\x20a\x20new\n\x20field\x20is\x20introduced\x20at\
    \x20a\x20later\x20time,\x20an\x20older\x20client\x20updating\x20with\x20\
    the\x20`*`\n\x20may\x20accidentally\x20reset\x20the\x20new\x20field's\
    \x20value.\n\n\x20Not\x20specifying\x20any\x20fields\x20is\x20an\x20erro\
    r.\n\x20Not\x20specifying\x20a\x20field\x20while\x20setting\x20that\x20f\
    ield\x20to\x20a\x20non-default\x20value\x20is\n\x20an\x20error.\n\n\x0f\
    \n\x05\x04\x13\x02\x03\x04\x12\x06\xd0\x05\x02\xc4\x050\n\r\n\x05\x04\
    \x13\x02\x03\x06\x12\x04\xd0\x05\x02\x1b\n\r\n\x05\x04\x13\x02\x03\x01\
    \x12\x04\xd0\x05\x1c'\n\r\n\x05\x04\x13\x02\x03\x03\x12\x04\xd0\x05*+\nG\
    \n\x04\x04\x13\x02\x04\x12\x04\xd3\x05\x020\x1a9\x20A\x20set\x20of\x20pa\
    rameters\x20common\x20to\x20all\x20Storage\x20API\x20requests.\n\n\x0f\n\
    \x05\x04\x13\x02\x04\x04\x12\x06\xd3\x05\x02\xd0\x05,\n\r\n\x05\x04\x13\
    \x02\x04\x06\x12\x04\xd3\x05\x02\x15\n\r\n\x05\x04\x13\x02\x04\x01\x12\
    \x04\xd3\x05\x16+\n\r\n\x05\x04\x13\x02\x04\x03\x12\x04\xd3\x05./\nE\n\
    \x02\x04\x14\x12\x06\xd7\x05\0\xe9\x05\x01\x1a7\x20Request\x20message\
    \x20for\x20UpdateDefaultObjectAccessControl.\n\n\x0b\n\x03\x04\x14\x01\
    \x12\x04\xd7\x05\x08/\n+\n\x04\x04\x14\x02\0\x12\x04\xd9\x05\x02=\x1a\
    \x1d\x20Required.\x20Name\x20of\x20a\x20bucket.\n\n\x0f\n\x05\x04\x14\
    \x02\0\x04\x12\x06\xd9\x05\x02\xd7\x051\n\r\n\x05\x04\x14\x02\0\x05\x12\
    \x04\xd9\x05\x02\x08\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xd9\x05\t\x0f\n\
    \r\n\x05\x04\x14\x02\0\x03\x12\x04\xd9\x05\x12\x13\n\r\n\x05\x04\x14\x02\
    \0\x08\x12\x04\xd9\x05\x14<\n\x10\n\x08\x04\x14\x02\0\x08\x9c\x08\0\x12\
    \x04\xd9\x05\x15;\n\xd0\x01\n\x04\x04\x14\x02\x01\x12\x04\xe2\x05\x02=\
    \x1a\xc1\x01\x20Required.\x20The\x20entity\x20holding\x20the\x20permissi\
    on.\x20Can\x20be\x20one\x20of:\n\x20*\x20`user-`*userId*\n\x20*\x20`user\
    -`*emailAddress*\n\x20*\x20`group-`*groupId*\n\x20*\x20`group-`*emailAdd\
    ress*\n\x20*\x20`allUsers`\n\x20*\x20`allAuthenticatedUsers`\n\n\x0f\n\
    \x05\x04\x14\x02\x01\x04\x12\x06\xe2\x05\x02\xd9\x05=\n\r\n\x05\x04\x14\
    \x02\x01\x05\x12\x04\xe2\x05\x02\x08\n\r\n\x05\x04\x14\x02\x01\x01\x12\
    \x04\xe2\x05\t\x0f\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\xe2\x05\x12\x13\
    \n\r\n\x05\x04\x14\x02\x01\x08\x12\x04\xe2\x05\x14<\n\x10\n\x08\x04\x14\
    \x02\x01\x08\x9c\x08\0\x12\x04\xe2\x05\x15;\n5\n\x04\x04\x14\x02\x02\x12\
    \x04\xe5\x05\x020\x1a'\x20The\x20ObjectAccessControl\x20for\x20updating.\
    \n\n\x0f\n\x05\x04\x14\x02\x02\x04\x12\x06\xe5\x05\x02\xe2\x05=\n\r\n\
    \x05\x04\x14\x02\x02\x06\x12\x04\xe5\x05\x02\x15\n\r\n\x05\x04\x14\x02\
    \x02\x01\x12\x04\xe5\x05\x16+\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\xe5\
    \x05./\nG\n\x04\x04\x14\x02\x03\x12\x04\xe8\x05\x020\x1a9\x20A\x20set\
    \x20of\x20parameters\x20common\x20to\x20all\x20Storage\x20API\x20request\
    s.\n\n\x0f\n\x05\x04\x14\x02\x03\x04\x12\x06\xe8\x05\x02\xe5\x050\n\r\n\
    \x05\x04\x14\x02\x03\x06\x12\x04\xe8\x05\x02\x15\n\r\n\x05\x04\x14\x02\
    \x03\x01\x12\x04\xe8\x05\x16+\n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\xe8\
    \x05./\n7\n\x02\x04\x15\x12\x06\xec\x05\0\xf5\x05\x01\x1a)\x20Request\
    \x20message\x20for\x20DeleteNotification.\n\n\x0b\n\x03\x04\x15\x01\x12\
    \x04\xec\x05\x08!\n@\n\x04\x04\x15\x02\0\x12\x04\xee\x05\x02=\x1a2\x20Re\
    quired.\x20The\x20parent\x20bucket\x20of\x20the\x20notification.\n\n\x0f\
    \n\x05\x04\x15\x02\0\x04\x12\x06\xee\x05\x02\xec\x05#\n\r\n\x05\x04\x15\
    \x02\0\x05\x12\x04\xee\x05\x02\x08\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\
    \xee\x05\t\x0f\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xee\x05\x12\x13\n\r\n\
    \x05\x04\x15\x02\0\x08\x12\x04\xee\x05\x14<\n\x10\n\x08\x04\x15\x02\0\
    \x08\x9c\x08\0\x12\x04\xee\x05\x15;\n;\n\x04\x04\x15\x02\x01\x12\x04\xf1\
    \x05\x02C\x1a-\x20Required.\x20ID\x20of\x20the\x20notification\x20to\x20\
    delete.\n\n\x0f\n\x05\x04\x15\x02\x01\x04\x12\x06\xf1\x05\x02\xee\x05=\n\
    \r\n\x05\x04\x15\x02\x01\x05\x12\x04\xf1\x05\x02\x08\n\r\n\x05\x04\x15\
    \x02\x01\x01\x12\x04\xf1\x05\t\x15\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\
    \xf1\x05\x18\x19\n\r\n\x05\x04\x15\x02\x01\x08\x12\x04\xf1\x05\x1aB\n\
    \x10\n\x08\x04\x15\x02\x01\x08\x9c\x08\0\x12\x04\xf1\x05\x1bA\nG\n\x04\
    \x04\x15\x02\x02\x12\x04\xf4\x05\x020\x1a9\x20A\x20set\x20of\x20paramete\
    rs\x20common\x20to\x20all\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\
    \x04\x15\x02\x02\x04\x12\x06\xf4\x05\x02\xf1\x05C\n\r\n\x05\x04\x15\x02\
    \x02\x06\x12\x04\xf4\x05\x02\x15\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\
    \xf4\x05\x16+\n\r\n\x05\x04\x15\x02\x02\x03\x12\x04\xf4\x05./\n4\n\x02\
    \x04\x16\x12\x06\xf8\x05\0\x82\x06\x01\x1a&\x20Request\x20message\x20for\
    \x20GetNotification.\n\n\x0b\n\x03\x04\x16\x01\x12\x04\xf8\x05\x08\x1e\n\
    @\n\x04\x04\x16\x02\0\x12\x04\xfa\x05\x02=\x1a2\x20Required.\x20The\x20p\
    arent\x20bucket\x20of\x20the\x20notification.\n\n\x0f\n\x05\x04\x16\x02\
    \0\x04\x12\x06\xfa\x05\x02\xf8\x05\x20\n\r\n\x05\x04\x16\x02\0\x05\x12\
    \x04\xfa\x05\x02\x08\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xfa\x05\t\x0f\n\
    \r\n\x05\x04\x16\x02\0\x03\x12\x04\xfa\x05\x12\x13\n\r\n\x05\x04\x16\x02\
    \0\x08\x12\x04\xfa\x05\x14<\n\x10\n\x08\x04\x16\x02\0\x08\x9c\x08\0\x12\
    \x04\xfa\x05\x15;\n5\n\x04\x04\x16\x02\x01\x12\x04\xfe\x05\x02C\x1a'\x20\
    Required.\x20Notification\x20ID.\n\x20Required.\n\n\x0f\n\x05\x04\x16\
    \x02\x01\x04\x12\x06\xfe\x05\x02\xfa\x05=\n\r\n\x05\x04\x16\x02\x01\x05\
    \x12\x04\xfe\x05\x02\x08\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\xfe\x05\t\
    \x15\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\xfe\x05\x18\x19\n\r\n\x05\x04\
    \x16\x02\x01\x08\x12\x04\xfe\x05\x1aB\n\x10\n\x08\x04\x16\x02\x01\x08\
    \x9c\x08\0\x12\x04\xfe\x05\x1bA\nG\n\x04\x04\x16\x02\x02\x12\x04\x81\x06\
    \x020\x1a9\x20A\x20set\x20of\x20parameters\x20common\x20to\x20all\x20Sto\
    rage\x20API\x20requests.\n\n\x0f\n\x05\x04\x16\x02\x02\x04\x12\x06\x81\
    \x06\x02\xfe\x05C\n\r\n\x05\x04\x16\x02\x02\x06\x12\x04\x81\x06\x02\x15\
    \n\r\n\x05\x04\x16\x02\x02\x01\x12\x04\x81\x06\x16+\n\r\n\x05\x04\x16\
    \x02\x02\x03\x12\x04\x81\x06./\n7\n\x02\x04\x17\x12\x06\x85\x06\0\x8e\
    \x06\x01\x1a)\x20Request\x20message\x20for\x20InsertNotification.\n\n\
    \x0b\n\x03\x04\x17\x01\x12\x04\x85\x06\x08!\n@\n\x04\x04\x17\x02\0\x12\
    \x04\x87\x06\x02=\x1a2\x20Required.\x20The\x20parent\x20bucket\x20of\x20\
    the\x20notification.\n\n\x0f\n\x05\x04\x17\x02\0\x04\x12\x06\x87\x06\x02\
    \x85\x06#\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\x87\x06\x02\x08\n\r\n\x05\
    \x04\x17\x02\0\x01\x12\x04\x87\x06\t\x0f\n\r\n\x05\x04\x17\x02\0\x03\x12\
    \x04\x87\x06\x12\x13\n\r\n\x05\x04\x17\x02\0\x08\x12\x04\x87\x06\x14<\n\
    \x10\n\x08\x04\x17\x02\0\x08\x9c\x08\0\x12\x04\x87\x06\x15;\n>\n\x04\x04\
    \x17\x02\x01\x12\x04\x8a\x06\x02\x20\x1a0\x20Properties\x20of\x20the\x20\
    notification\x20to\x20be\x20inserted.\n\n\x0f\n\x05\x04\x17\x02\x01\x04\
    \x12\x06\x8a\x06\x02\x87\x06=\n\r\n\x05\x04\x17\x02\x01\x06\x12\x04\x8a\
    \x06\x02\x0e\n\r\n\x05\x04\x17\x02\x01\x01\x12\x04\x8a\x06\x0f\x1b\n\r\n\
    \x05\x04\x17\x02\x01\x03\x12\x04\x8a\x06\x1e\x1f\nG\n\x04\x04\x17\x02\
    \x02\x12\x04\x8d\x06\x020\x1a9\x20A\x20set\x20of\x20parameters\x20common\
    \x20to\x20all\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04\x17\x02\
    \x02\x04\x12\x06\x8d\x06\x02\x8a\x06\x20\n\r\n\x05\x04\x17\x02\x02\x06\
    \x12\x04\x8d\x06\x02\x15\n\r\n\x05\x04\x17\x02\x02\x01\x12\x04\x8d\x06\
    \x16+\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\x8d\x06./\n6\n\x02\x04\x18\
    \x12\x06\x91\x06\0\x97\x06\x01\x1a(\x20Request\x20message\x20for\x20List\
    Notifications.\n\n\x0b\n\x03\x04\x18\x01\x12\x04\x91\x06\x08\x20\n@\n\
    \x04\x04\x18\x02\0\x12\x04\x93\x06\x02=\x1a2\x20Required.\x20Name\x20of\
    \x20a\x20Google\x20Cloud\x20Storage\x20bucket.\n\n\x0f\n\x05\x04\x18\x02\
    \0\x04\x12\x06\x93\x06\x02\x91\x06\"\n\r\n\x05\x04\x18\x02\0\x05\x12\x04\
    \x93\x06\x02\x08\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\x93\x06\t\x0f\n\r\n\
    \x05\x04\x18\x02\0\x03\x12\x04\x93\x06\x12\x13\n\r\n\x05\x04\x18\x02\0\
    \x08\x12\x04\x93\x06\x14<\n\x10\n\x08\x04\x18\x02\0\x08\x9c\x08\0\x12\
    \x04\x93\x06\x15;\nG\n\x04\x04\x18\x02\x01\x12\x04\x96\x06\x020\x1a9\x20\
    A\x20set\x20of\x20parameters\x20common\x20to\x20all\x20Storage\x20API\
    \x20requests.\n\n\x0f\n\x05\x04\x18\x02\x01\x04\x12\x06\x96\x06\x02\x93\
    \x06=\n\r\n\x05\x04\x18\x02\x01\x06\x12\x04\x96\x06\x02\x15\n\r\n\x05\
    \x04\x18\x02\x01\x01\x12\x04\x96\x06\x16+\n\r\n\x05\x04\x18\x02\x01\x03\
    \x12\x04\x96\x06./\n>\n\x02\x04\x19\x12\x06\x9a\x06\0\xb0\x06\x01\x1a0\
    \x20Request\x20message\x20for\x20DeleteObjectAccessControl.\n\n\x0b\n\
    \x03\x04\x19\x01\x12\x04\x9a\x06\x08(\n+\n\x04\x04\x19\x02\0\x12\x04\x9c\
    \x06\x02=\x1a\x1d\x20Required.\x20Name\x20of\x20a\x20bucket.\n\n\x0f\n\
    \x05\x04\x19\x02\0\x04\x12\x06\x9c\x06\x02\x9a\x06*\n\r\n\x05\x04\x19\
    \x02\0\x05\x12\x04\x9c\x06\x02\x08\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\
    \x9c\x06\t\x0f\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\x9c\x06\x12\x13\n\r\n\
    \x05\x04\x19\x02\0\x08\x12\x04\x9c\x06\x14<\n\x10\n\x08\x04\x19\x02\0\
    \x08\x9c\x08\0\x12\x04\x9c\x06\x15;\n\xd0\x01\n\x04\x04\x19\x02\x01\x12\
    \x04\xa5\x06\x02=\x1a\xc1\x01\x20Required.\x20The\x20entity\x20holding\
    \x20the\x20permission.\x20Can\x20be\x20one\x20of:\n\x20*\x20`user-`*user\
    Id*\n\x20*\x20`user-`*emailAddress*\n\x20*\x20`group-`*groupId*\n\x20*\
    \x20`group-`*emailAddress*\n\x20*\x20`allUsers`\n\x20*\x20`allAuthentica\
    tedUsers`\n\n\x0f\n\x05\x04\x19\x02\x01\x04\x12\x06\xa5\x06\x02\x9c\x06=\
    \n\r\n\x05\x04\x19\x02\x01\x05\x12\x04\xa5\x06\x02\x08\n\r\n\x05\x04\x19\
    \x02\x01\x01\x12\x04\xa5\x06\t\x0f\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\
    \xa5\x06\x12\x13\n\r\n\x05\x04\x19\x02\x01\x08\x12\x04\xa5\x06\x14<\n\
    \x10\n\x08\x04\x19\x02\x01\x08\x9c\x08\0\x12\x04\xa5\x06\x15;\n-\n\x04\
    \x04\x19\x02\x02\x12\x04\xa8\x06\x02=\x1a\x1f\x20Required.\x20Name\x20of\
    \x20the\x20object.\n\n\x0f\n\x05\x04\x19\x02\x02\x04\x12\x06\xa8\x06\x02\
    \xa5\x06=\n\r\n\x05\x04\x19\x02\x02\x05\x12\x04\xa8\x06\x02\x08\n\r\n\
    \x05\x04\x19\x02\x02\x01\x12\x04\xa8\x06\t\x0f\n\r\n\x05\x04\x19\x02\x02\
    \x03\x12\x04\xa8\x06\x12\x13\n\r\n\x05\x04\x19\x02\x02\x08\x12\x04\xa8\
    \x06\x14<\n\x10\n\x08\x04\x19\x02\x02\x08\x9c\x08\0\x12\x04\xa8\x06\x15;\
    \nx\n\x04\x04\x19\x02\x03\x12\x04\xac\x06\x02\x17\x1aj\x20If\x20present,\
    \x20selects\x20a\x20specific\x20revision\x20of\x20this\x20object\x20(as\
    \x20opposed\x20to\x20the\n\x20latest\x20version,\x20the\x20default).\n\n\
    \x0f\n\x05\x04\x19\x02\x03\x04\x12\x06\xac\x06\x02\xa8\x06=\n\r\n\x05\
    \x04\x19\x02\x03\x05\x12\x04\xac\x06\x02\x07\n\r\n\x05\x04\x19\x02\x03\
    \x01\x12\x04\xac\x06\x08\x12\n\r\n\x05\x04\x19\x02\x03\x03\x12\x04\xac\
    \x06\x15\x16\nG\n\x04\x04\x19\x02\x04\x12\x04\xaf\x06\x020\x1a9\x20A\x20\
    set\x20of\x20parameters\x20common\x20to\x20all\x20Storage\x20API\x20requ\
    ests.\n\n\x0f\n\x05\x04\x19\x02\x04\x04\x12\x06\xaf\x06\x02\xac\x06\x17\
    \n\r\n\x05\x04\x19\x02\x04\x06\x12\x04\xaf\x06\x02\x15\n\r\n\x05\x04\x19\
    \x02\x04\x01\x12\x04\xaf\x06\x16+\n\r\n\x05\x04\x19\x02\x04\x03\x12\x04\
    \xaf\x06./\n;\n\x02\x04\x1a\x12\x06\xb3\x06\0\xc9\x06\x01\x1a-\x20Reques\
    t\x20message\x20for\x20GetObjectAccessControl.\n\n\x0b\n\x03\x04\x1a\x01\
    \x12\x04\xb3\x06\x08%\n+\n\x04\x04\x1a\x02\0\x12\x04\xb5\x06\x02=\x1a\
    \x1d\x20Required.\x20Name\x20of\x20a\x20bucket.\n\n\x0f\n\x05\x04\x1a\
    \x02\0\x04\x12\x06\xb5\x06\x02\xb3\x06'\n\r\n\x05\x04\x1a\x02\0\x05\x12\
    \x04\xb5\x06\x02\x08\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xb5\x06\t\x0f\n\
    \r\n\x05\x04\x1a\x02\0\x03\x12\x04\xb5\x06\x12\x13\n\r\n\x05\x04\x1a\x02\
    \0\x08\x12\x04\xb5\x06\x14<\n\x10\n\x08\x04\x1a\x02\0\x08\x9c\x08\0\x12\
    \x04\xb5\x06\x15;\n\xd0\x01\n\x04\x04\x1a\x02\x01\x12\x04\xbe\x06\x02=\
    \x1a\xc1\x01\x20Required.\x20The\x20entity\x20holding\x20the\x20permissi\
    on.\x20Can\x20be\x20one\x20of:\n\x20*\x20`user-`*userId*\n\x20*\x20`user\
    -`*emailAddress*\n\x20*\x20`group-`*groupId*\n\x20*\x20`group-`*emailAdd\
    ress*\n\x20*\x20`allUsers`\n\x20*\x20`allAuthenticatedUsers`\n\n\x0f\n\
    \x05\x04\x1a\x02\x01\x04\x12\x06\xbe\x06\x02\xb5\x06=\n\r\n\x05\x04\x1a\
    \x02\x01\x05\x12\x04\xbe\x06\x02\x08\n\r\n\x05\x04\x1a\x02\x01\x01\x12\
    \x04\xbe\x06\t\x0f\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xbe\x06\x12\x13\
    \n\r\n\x05\x04\x1a\x02\x01\x08\x12\x04\xbe\x06\x14<\n\x10\n\x08\x04\x1a\
    \x02\x01\x08\x9c\x08\0\x12\x04\xbe\x06\x15;\n-\n\x04\x04\x1a\x02\x02\x12\
    \x04\xc1\x06\x02=\x1a\x1f\x20Required.\x20Name\x20of\x20the\x20object.\n\
    \n\x0f\n\x05\x04\x1a\x02\x02\x04\x12\x06\xc1\x06\x02\xbe\x06=\n\r\n\x05\
    \x04\x1a\x02\x02\x05\x12\x04\xc1\x06\x02\x08\n\r\n\x05\x04\x1a\x02\x02\
    \x01\x12\x04\xc1\x06\t\x0f\n\r\n\x05\x04\x1a\x02\x02\x03\x12\x04\xc1\x06\
    \x12\x13\n\r\n\x05\x04\x1a\x02\x02\x08\x12\x04\xc1\x06\x14<\n\x10\n\x08\
    \x04\x1a\x02\x02\x08\x9c\x08\0\x12\x04\xc1\x06\x15;\nx\n\x04\x04\x1a\x02\
    \x03\x12\x04\xc5\x06\x02\x17\x1aj\x20If\x20present,\x20selects\x20a\x20s\
    pecific\x20revision\x20of\x20this\x20object\x20(as\x20opposed\x20to\x20t\
    he\n\x20latest\x20version,\x20the\x20default).\n\n\x0f\n\x05\x04\x1a\x02\
    \x03\x04\x12\x06\xc5\x06\x02\xc1\x06=\n\r\n\x05\x04\x1a\x02\x03\x05\x12\
    \x04\xc5\x06\x02\x07\n\r\n\x05\x04\x1a\x02\x03\x01\x12\x04\xc5\x06\x08\
    \x12\n\r\n\x05\x04\x1a\x02\x03\x03\x12\x04\xc5\x06\x15\x16\nG\n\x04\x04\
    \x1a\x02\x04\x12\x04\xc8\x06\x020\x1a9\x20A\x20set\x20of\x20parameters\
    \x20common\x20to\x20all\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04\
    \x1a\x02\x04\x04\x12\x06\xc8\x06\x02\xc5\x06\x17\n\r\n\x05\x04\x1a\x02\
    \x04\x06\x12\x04\xc8\x06\x02\x15\n\r\n\x05\x04\x1a\x02\x04\x01\x12\x04\
    \xc8\x06\x16+\n\r\n\x05\x04\x1a\x02\x04\x03\x12\x04\xc8\x06./\n>\n\x02\
    \x04\x1b\x12\x06\xcc\x06\0\xdc\x06\x01\x1a0\x20Request\x20message\x20for\
    \x20InsertObjectAccessControl.\n\n\x0b\n\x03\x04\x1b\x01\x12\x04\xcc\x06\
    \x08(\n+\n\x04\x04\x1b\x02\0\x12\x04\xce\x06\x02=\x1a\x1d\x20Required.\
    \x20Name\x20of\x20a\x20bucket.\n\n\x0f\n\x05\x04\x1b\x02\0\x04\x12\x06\
    \xce\x06\x02\xcc\x06*\n\r\n\x05\x04\x1b\x02\0\x05\x12\x04\xce\x06\x02\
    \x08\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xce\x06\t\x0f\n\r\n\x05\x04\x1b\
    \x02\0\x03\x12\x04\xce\x06\x12\x13\n\r\n\x05\x04\x1b\x02\0\x08\x12\x04\
    \xce\x06\x14<\n\x10\n\x08\x04\x1b\x02\0\x08\x9c\x08\0\x12\x04\xce\x06\
    \x15;\n-\n\x04\x04\x1b\x02\x01\x12\x04\xd1\x06\x02=\x1a\x1f\x20Required.\
    \x20Name\x20of\x20the\x20object.\n\n\x0f\n\x05\x04\x1b\x02\x01\x04\x12\
    \x06\xd1\x06\x02\xce\x06=\n\r\n\x05\x04\x1b\x02\x01\x05\x12\x04\xd1\x06\
    \x02\x08\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\xd1\x06\t\x0f\n\r\n\x05\
    \x04\x1b\x02\x01\x03\x12\x04\xd1\x06\x12\x13\n\r\n\x05\x04\x1b\x02\x01\
    \x08\x12\x04\xd1\x06\x14<\n\x10\n\x08\x04\x1b\x02\x01\x08\x9c\x08\0\x12\
    \x04\xd1\x06\x15;\nx\n\x04\x04\x1b\x02\x02\x12\x04\xd5\x06\x02\x17\x1aj\
    \x20If\x20present,\x20selects\x20a\x20specific\x20revision\x20of\x20this\
    \x20object\x20(as\x20opposed\x20to\x20the\n\x20latest\x20version,\x20the\
    \x20default).\n\n\x0f\n\x05\x04\x1b\x02\x02\x04\x12\x06\xd5\x06\x02\xd1\
    \x06=\n\r\n\x05\x04\x1b\x02\x02\x05\x12\x04\xd5\x06\x02\x07\n\r\n\x05\
    \x04\x1b\x02\x02\x01\x12\x04\xd5\x06\x08\x12\n\r\n\x05\x04\x1b\x02\x02\
    \x03\x12\x04\xd5\x06\x15\x16\nG\n\x04\x04\x1b\x02\x03\x12\x04\xd8\x06\
    \x020\x1a9\x20Properties\x20of\x20the\x20object\x20access\x20control\x20\
    to\x20be\x20inserted.\n\n\x0f\n\x05\x04\x1b\x02\x03\x04\x12\x06\xd8\x06\
    \x02\xd5\x06\x17\n\r\n\x05\x04\x1b\x02\x03\x06\x12\x04\xd8\x06\x02\x15\n\
    \r\n\x05\x04\x1b\x02\x03\x01\x12\x04\xd8\x06\x16+\n\r\n\x05\x04\x1b\x02\
    \x03\x03\x12\x04\xd8\x06./\nG\n\x04\x04\x1b\x02\x04\x12\x04\xdb\x06\x020\
    \x1a9\x20A\x20set\x20of\x20parameters\x20common\x20to\x20all\x20Storage\
    \x20API\x20requests.\n\n\x0f\n\x05\x04\x1b\x02\x04\x04\x12\x06\xdb\x06\
    \x02\xd8\x060\n\r\n\x05\x04\x1b\x02\x04\x06\x12\x04\xdb\x06\x02\x15\n\r\
    \n\x05\x04\x1b\x02\x04\x01\x12\x04\xdb\x06\x16+\n\r\n\x05\x04\x1b\x02\
    \x04\x03\x12\x04\xdb\x06./\n=\n\x02\x04\x1c\x12\x06\xdf\x06\0\xec\x06\
    \x01\x1a/\x20Request\x20message\x20for\x20ListObjectAccessControls.\n\n\
    \x0b\n\x03\x04\x1c\x01\x12\x04\xdf\x06\x08'\n+\n\x04\x04\x1c\x02\0\x12\
    \x04\xe1\x06\x02=\x1a\x1d\x20Required.\x20Name\x20of\x20a\x20bucket.\n\n\
    \x0f\n\x05\x04\x1c\x02\0\x04\x12\x06\xe1\x06\x02\xdf\x06)\n\r\n\x05\x04\
    \x1c\x02\0\x05\x12\x04\xe1\x06\x02\x08\n\r\n\x05\x04\x1c\x02\0\x01\x12\
    \x04\xe1\x06\t\x0f\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xe1\x06\x12\x13\n\
    \r\n\x05\x04\x1c\x02\0\x08\x12\x04\xe1\x06\x14<\n\x10\n\x08\x04\x1c\x02\
    \0\x08\x9c\x08\0\x12\x04\xe1\x06\x15;\n-\n\x04\x04\x1c\x02\x01\x12\x04\
    \xe4\x06\x02=\x1a\x1f\x20Required.\x20Name\x20of\x20the\x20object.\n\n\
    \x0f\n\x05\x04\x1c\x02\x01\x04\x12\x06\xe4\x06\x02\xe1\x06=\n\r\n\x05\
    \x04\x1c\x02\x01\x05\x12\x04\xe4\x06\x02\x08\n\r\n\x05\x04\x1c\x02\x01\
    \x01\x12\x04\xe4\x06\t\x0f\n\r\n\x05\x04\x1c\x02\x01\x03\x12\x04\xe4\x06\
    \x12\x13\n\r\n\x05\x04\x1c\x02\x01\x08\x12\x04\xe4\x06\x14<\n\x10\n\x08\
    \x04\x1c\x02\x01\x08\x9c\x08\0\x12\x04\xe4\x06\x15;\nx\n\x04\x04\x1c\x02\
    \x02\x12\x04\xe8\x06\x02\x17\x1aj\x20If\x20present,\x20selects\x20a\x20s\
    pecific\x20revision\x20of\x20this\x20object\x20(as\x20opposed\x20to\x20t\
    he\n\x20latest\x20version,\x20the\x20default).\n\n\x0f\n\x05\x04\x1c\x02\
    \x02\x04\x12\x06\xe8\x06\x02\xe4\x06=\n\r\n\x05\x04\x1c\x02\x02\x05\x12\
    \x04\xe8\x06\x02\x07\n\r\n\x05\x04\x1c\x02\x02\x01\x12\x04\xe8\x06\x08\
    \x12\n\r\n\x05\x04\x1c\x02\x02\x03\x12\x04\xe8\x06\x15\x16\nG\n\x04\x04\
    \x1c\x02\x03\x12\x04\xeb\x06\x020\x1a9\x20A\x20set\x20of\x20parameters\
    \x20common\x20to\x20all\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04\
    \x1c\x02\x03\x04\x12\x06\xeb\x06\x02\xe8\x06\x17\n\r\n\x05\x04\x1c\x02\
    \x03\x06\x12\x04\xeb\x06\x02\x15\n\r\n\x05\x04\x1c\x02\x03\x01\x12\x04\
    \xeb\x06\x16+\n\r\n\x05\x04\x1c\x02\x03\x03\x12\x04\xeb\x06./\n=\n\x02\
    \x04\x1d\x12\x06\xef\x06\0\x95\x07\x01\x1a/\x20Request\x20message\x20for\
    \x20PatchObjectAccessControl.\n\n\x0b\n\x03\x04\x1d\x01\x12\x04\xef\x06\
    \x08'\n+\n\x04\x04\x1d\x02\0\x12\x04\xf1\x06\x02=\x1a\x1d\x20Required.\
    \x20Name\x20of\x20a\x20bucket.\n\n\x0f\n\x05\x04\x1d\x02\0\x04\x12\x06\
    \xf1\x06\x02\xef\x06)\n\r\n\x05\x04\x1d\x02\0\x05\x12\x04\xf1\x06\x02\
    \x08\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xf1\x06\t\x0f\n\r\n\x05\x04\x1d\
    \x02\0\x03\x12\x04\xf1\x06\x12\x13\n\r\n\x05\x04\x1d\x02\0\x08\x12\x04\
    \xf1\x06\x14<\n\x10\n\x08\x04\x1d\x02\0\x08\x9c\x08\0\x12\x04\xf1\x06\
    \x15;\n\xd0\x01\n\x04\x04\x1d\x02\x01\x12\x04\xfa\x06\x02=\x1a\xc1\x01\
    \x20Required.\x20The\x20entity\x20holding\x20the\x20permission.\x20Can\
    \x20be\x20one\x20of:\n\x20*\x20`user-`*userId*\n\x20*\x20`user-`*emailAd\
    dress*\n\x20*\x20`group-`*groupId*\n\x20*\x20`group-`*emailAddress*\n\
    \x20*\x20`allUsers`\n\x20*\x20`allAuthenticatedUsers`\n\n\x0f\n\x05\x04\
    \x1d\x02\x01\x04\x12\x06\xfa\x06\x02\xf1\x06=\n\r\n\x05\x04\x1d\x02\x01\
    \x05\x12\x04\xfa\x06\x02\x08\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\xfa\
    \x06\t\x0f\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xfa\x06\x12\x13\n\r\n\
    \x05\x04\x1d\x02\x01\x08\x12\x04\xfa\x06\x14<\n\x10\n\x08\x04\x1d\x02\
    \x01\x08\x9c\x08\0\x12\x04\xfa\x06\x15;\n8\n\x04\x04\x1d\x02\x02\x12\x04\
    \xfe\x06\x02=\x1a*\x20Required.\x20Name\x20of\x20the\x20object.\n\x20Req\
    uired.\n\n\x0f\n\x05\x04\x1d\x02\x02\x04\x12\x06\xfe\x06\x02\xfa\x06=\n\
    \r\n\x05\x04\x1d\x02\x02\x05\x12\x04\xfe\x06\x02\x08\n\r\n\x05\x04\x1d\
    \x02\x02\x01\x12\x04\xfe\x06\t\x0f\n\r\n\x05\x04\x1d\x02\x02\x03\x12\x04\
    \xfe\x06\x12\x13\n\r\n\x05\x04\x1d\x02\x02\x08\x12\x04\xfe\x06\x14<\n\
    \x10\n\x08\x04\x1d\x02\x02\x08\x9c\x08\0\x12\x04\xfe\x06\x15;\nx\n\x04\
    \x04\x1d\x02\x03\x12\x04\x82\x07\x02\x17\x1aj\x20If\x20present,\x20selec\
    ts\x20a\x20specific\x20revision\x20of\x20this\x20object\x20(as\x20oppose\
    d\x20to\x20the\n\x20latest\x20version,\x20the\x20default).\n\n\x0f\n\x05\
    \x04\x1d\x02\x03\x04\x12\x06\x82\x07\x02\xfe\x06=\n\r\n\x05\x04\x1d\x02\
    \x03\x05\x12\x04\x82\x07\x02\x07\n\r\n\x05\x04\x1d\x02\x03\x01\x12\x04\
    \x82\x07\x08\x12\n\r\n\x05\x04\x1d\x02\x03\x03\x12\x04\x82\x07\x15\x16\n\
    5\n\x04\x04\x1d\x02\x04\x12\x04\x85\x07\x020\x1a'\x20The\x20ObjectAccess\
    Control\x20for\x20updating.\n\n\x0f\n\x05\x04\x1d\x02\x04\x04\x12\x06\
    \x85\x07\x02\x82\x07\x17\n\r\n\x05\x04\x1d\x02\x04\x06\x12\x04\x85\x07\
    \x02\x15\n\r\n\x05\x04\x1d\x02\x04\x01\x12\x04\x85\x07\x16+\n\r\n\x05\
    \x04\x1d\x02\x04\x03\x12\x04\x85\x07./\nG\n\x04\x04\x1d\x02\x05\x12\x04\
    \x88\x07\x020\x1a9\x20A\x20set\x20of\x20parameters\x20common\x20to\x20al\
    l\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04\x1d\x02\x05\x04\x12\
    \x06\x88\x07\x02\x85\x070\n\r\n\x05\x04\x1d\x02\x05\x06\x12\x04\x88\x07\
    \x02\x15\n\r\n\x05\x04\x1d\x02\x05\x01\x12\x04\x88\x07\x16+\n\r\n\x05\
    \x04\x1d\x02\x05\x03\x12\x04\x88\x07./\n\xbd\x03\n\x04\x04\x1d\x02\x06\
    \x12\x04\x94\x07\x02,\x1a\xae\x03\x20List\x20of\x20fields\x20to\x20be\
    \x20updated.\n\n\x20To\x20specify\x20ALL\x20fields,\x20equivalent\x20to\
    \x20the\x20JSON\x20API's\x20\"update\"\x20function,\n\x20specify\x20a\
    \x20single\x20field\x20with\x20the\x20value\x20`*`.\x20Note:\x20not\x20r\
    ecommended.\x20If\x20a\x20new\n\x20field\x20is\x20introduced\x20at\x20a\
    \x20later\x20time,\x20an\x20older\x20client\x20updating\x20with\x20the\
    \x20`*`\n\x20may\x20accidentally\x20reset\x20the\x20new\x20field's\x20va\
    lue.\n\n\x20Not\x20specifying\x20any\x20fields\x20is\x20an\x20error.\n\
    \x20Not\x20specifying\x20a\x20field\x20while\x20setting\x20that\x20field\
    \x20to\x20a\x20non-default\x20value\x20is\n\x20an\x20error.\n\n\x0f\n\
    \x05\x04\x1d\x02\x06\x04\x12\x06\x94\x07\x02\x88\x070\n\r\n\x05\x04\x1d\
    \x02\x06\x06\x12\x04\x94\x07\x02\x1b\n\r\n\x05\x04\x1d\x02\x06\x01\x12\
    \x04\x94\x07\x1c'\n\r\n\x05\x04\x1d\x02\x06\x03\x12\x04\x94\x07*+\n>\n\
    \x02\x04\x1e\x12\x06\x98\x07\0\xbe\x07\x01\x1a0\x20Request\x20message\
    \x20for\x20UpdateObjectAccessControl.\n\n\x0b\n\x03\x04\x1e\x01\x12\x04\
    \x98\x07\x08(\n+\n\x04\x04\x1e\x02\0\x12\x04\x9a\x07\x02=\x1a\x1d\x20Req\
    uired.\x20Name\x20of\x20a\x20bucket.\n\n\x0f\n\x05\x04\x1e\x02\0\x04\x12\
    \x06\x9a\x07\x02\x98\x07*\n\r\n\x05\x04\x1e\x02\0\x05\x12\x04\x9a\x07\
    \x02\x08\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\x9a\x07\t\x0f\n\r\n\x05\x04\
    \x1e\x02\0\x03\x12\x04\x9a\x07\x12\x13\n\r\n\x05\x04\x1e\x02\0\x08\x12\
    \x04\x9a\x07\x14<\n\x10\n\x08\x04\x1e\x02\0\x08\x9c\x08\0\x12\x04\x9a\
    \x07\x15;\n\xd0\x01\n\x04\x04\x1e\x02\x01\x12\x04\xa3\x07\x02=\x1a\xc1\
    \x01\x20Required.\x20The\x20entity\x20holding\x20the\x20permission.\x20C\
    an\x20be\x20one\x20of:\n\x20*\x20`user-`*userId*\n\x20*\x20`user-`*email\
    Address*\n\x20*\x20`group-`*groupId*\n\x20*\x20`group-`*emailAddress*\n\
    \x20*\x20`allUsers`\n\x20*\x20`allAuthenticatedUsers`\n\n\x0f\n\x05\x04\
    \x1e\x02\x01\x04\x12\x06\xa3\x07\x02\x9a\x07=\n\r\n\x05\x04\x1e\x02\x01\
    \x05\x12\x04\xa3\x07\x02\x08\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xa3\
    \x07\t\x0f\n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\xa3\x07\x12\x13\n\r\n\
    \x05\x04\x1e\x02\x01\x08\x12\x04\xa3\x07\x14<\n\x10\n\x08\x04\x1e\x02\
    \x01\x08\x9c\x08\0\x12\x04\xa3\x07\x15;\n8\n\x04\x04\x1e\x02\x02\x12\x04\
    \xa7\x07\x02=\x1a*\x20Required.\x20Name\x20of\x20the\x20object.\n\x20Req\
    uired.\n\n\x0f\n\x05\x04\x1e\x02\x02\x04\x12\x06\xa7\x07\x02\xa3\x07=\n\
    \r\n\x05\x04\x1e\x02\x02\x05\x12\x04\xa7\x07\x02\x08\n\r\n\x05\x04\x1e\
    \x02\x02\x01\x12\x04\xa7\x07\t\x0f\n\r\n\x05\x04\x1e\x02\x02\x03\x12\x04\
    \xa7\x07\x12\x13\n\r\n\x05\x04\x1e\x02\x02\x08\x12\x04\xa7\x07\x14<\n\
    \x10\n\x08\x04\x1e\x02\x02\x08\x9c\x08\0\x12\x04\xa7\x07\x15;\nx\n\x04\
    \x04\x1e\x02\x03\x12\x04\xab\x07\x02\x17\x1aj\x20If\x20present,\x20selec\
    ts\x20a\x20specific\x20revision\x20of\x20this\x20object\x20(as\x20oppose\
    d\x20to\x20the\n\x20latest\x20version,\x20the\x20default).\n\n\x0f\n\x05\
    \x04\x1e\x02\x03\x04\x12\x06\xab\x07\x02\xa7\x07=\n\r\n\x05\x04\x1e\x02\
    \x03\x05\x12\x04\xab\x07\x02\x07\n\r\n\x05\x04\x1e\x02\x03\x01\x12\x04\
    \xab\x07\x08\x12\n\r\n\x05\x04\x1e\x02\x03\x03\x12\x04\xab\x07\x15\x16\n\
    5\n\x04\x04\x1e\x02\x04\x12\x04\xae\x07\x020\x1a'\x20The\x20ObjectAccess\
    Control\x20for\x20updating.\n\n\x0f\n\x05\x04\x1e\x02\x04\x04\x12\x06\
    \xae\x07\x02\xab\x07\x17\n\r\n\x05\x04\x1e\x02\x04\x06\x12\x04\xae\x07\
    \x02\x15\n\r\n\x05\x04\x1e\x02\x04\x01\x12\x04\xae\x07\x16+\n\r\n\x05\
    \x04\x1e\x02\x04\x03\x12\x04\xae\x07./\nG\n\x04\x04\x1e\x02\x05\x12\x04\
    \xb1\x07\x020\x1a9\x20A\x20set\x20of\x20parameters\x20common\x20to\x20al\
    l\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04\x1e\x02\x05\x04\x12\
    \x06\xb1\x07\x02\xae\x070\n\r\n\x05\x04\x1e\x02\x05\x06\x12\x04\xb1\x07\
    \x02\x15\n\r\n\x05\x04\x1e\x02\x05\x01\x12\x04\xb1\x07\x16+\n\r\n\x05\
    \x04\x1e\x02\x05\x03\x12\x04\xb1\x07./\n\xbd\x03\n\x04\x04\x1e\x02\x06\
    \x12\x04\xbd\x07\x02,\x1a\xae\x03\x20List\x20of\x20fields\x20to\x20be\
    \x20updated.\n\n\x20To\x20specify\x20ALL\x20fields,\x20equivalent\x20to\
    \x20the\x20JSON\x20API's\x20\"update\"\x20function,\n\x20specify\x20a\
    \x20single\x20field\x20with\x20the\x20value\x20`*`.\x20Note:\x20not\x20r\
    ecommended.\x20If\x20a\x20new\n\x20field\x20is\x20introduced\x20at\x20a\
    \x20later\x20time,\x20an\x20older\x20client\x20updating\x20with\x20the\
    \x20`*`\n\x20may\x20accidentally\x20reset\x20the\x20new\x20field's\x20va\
    lue.\n\n\x20Not\x20specifying\x20any\x20fields\x20is\x20an\x20error.\n\
    \x20Not\x20specifying\x20a\x20field\x20while\x20setting\x20that\x20field\
    \x20to\x20a\x20non-default\x20value\x20is\n\x20an\x20error.\n\n\x0f\n\
    \x05\x04\x1e\x02\x06\x04\x12\x06\xbd\x07\x02\xb1\x070\n\r\n\x05\x04\x1e\
    \x02\x06\x06\x12\x04\xbd\x07\x02\x1b\n\r\n\x05\x04\x1e\x02\x06\x01\x12\
    \x04\xbd\x07\x1c'\n\r\n\x05\x04\x1e\x02\x06\x03\x12\x04\xbd\x07*+\n2\n\
    \x02\x04\x1f\x12\x06\xc1\x07\0\xfb\x07\x01\x1a$\x20Request\x20message\
    \x20for\x20ComposeObject.\n\n\x0b\n\x03\x04\x1f\x01\x12\x04\xc1\x07\x08\
    \x1c\nK\n\x04\x04\x1f\x03\0\x12\x06\xc3\x07\x02\xd5\x07\x03\x1a;\x20Desc\
    ription\x20of\x20a\x20source\x20object\x20for\x20a\x20composition\x20req\
    uest.\n\n\r\n\x05\x04\x1f\x03\0\x01\x12\x04\xc3\x07\n\x17\nO\n\x06\x04\
    \x1f\x03\0\x03\0\x12\x06\xc5\x07\x04\xca\x07\x05\x1a=\x20Preconditions\
    \x20for\x20a\x20source\x20object\x20of\x20a\x20composition\x20request.\n\
    \n\x0f\n\x07\x04\x1f\x03\0\x03\0\x01\x12\x04\xc5\x07\x0c\x1f\n\xe8\x01\n\
    \x08\x04\x1f\x03\0\x03\0\x02\0\x12\x04\xc9\x07\x069\x1a\xd5\x01\x20Only\
    \x20perform\x20the\x20composition\x20if\x20the\x20generation\x20of\x20th\
    e\x20source\x20object\n\x20that\x20would\x20be\x20used\x20matches\x20thi\
    s\x20value.\x20\x20If\x20this\x20value\x20and\x20a\x20generation\n\x20ar\
    e\x20both\x20specified,\x20they\x20must\x20be\x20the\x20same\x20value\
    \x20or\x20the\x20call\x20will\x20fail.\n\n\x13\n\t\x04\x1f\x03\0\x03\0\
    \x02\0\x04\x12\x06\xc9\x07\x06\xc5\x07!\n\x11\n\t\x04\x1f\x03\0\x03\0\
    \x02\0\x06\x12\x04\xc9\x07\x06\x20\n\x11\n\t\x04\x1f\x03\0\x03\0\x02\0\
    \x01\x12\x04\xc9\x07!4\n\x11\n\t\x04\x1f\x03\0\x03\0\x02\0\x03\x12\x04\
    \xc9\x0778\n_\n\x06\x04\x1f\x03\0\x02\0\x12\x04\xce\x07\x04\x14\x1aO\x20\
    The\x20source\x20object's\x20name.\x20All\x20source\x20objects\x20must\
    \x20reside\x20in\x20the\x20same\n\x20bucket.\n\n\x11\n\x07\x04\x1f\x03\0\
    \x02\0\x04\x12\x06\xce\x07\x04\xca\x07\x05\n\x0f\n\x07\x04\x1f\x03\0\x02\
    \0\x05\x12\x04\xce\x07\x04\n\n\x0f\n\x07\x04\x1f\x03\0\x02\0\x01\x12\x04\
    \xce\x07\x0b\x0f\n\x0f\n\x07\x04\x1f\x03\0\x02\0\x03\x12\x04\xce\x07\x12\
    \x13\nE\n\x06\x04\x1f\x03\0\x02\x01\x12\x04\xd1\x07\x04\x19\x1a5\x20The\
    \x20generation\x20of\x20this\x20object\x20to\x20use\x20as\x20the\x20sour\
    ce.\n\n\x11\n\x07\x04\x1f\x03\0\x02\x01\x04\x12\x06\xd1\x07\x04\xce\x07\
    \x14\n\x0f\n\x07\x04\x1f\x03\0\x02\x01\x05\x12\x04\xd1\x07\x04\t\n\x0f\n\
    \x07\x04\x1f\x03\0\x02\x01\x01\x12\x04\xd1\x07\n\x14\n\x0f\n\x07\x04\x1f\
    \x03\0\x02\x01\x03\x12\x04\xd1\x07\x17\x18\nL\n\x06\x04\x1f\x03\0\x02\
    \x02\x12\x04\xd4\x07\x041\x1a<\x20Conditions\x20that\x20must\x20be\x20me\
    t\x20for\x20this\x20operation\x20to\x20execute.\n\n\x11\n\x07\x04\x1f\
    \x03\0\x02\x02\x04\x12\x06\xd4\x07\x04\xd1\x07\x19\n\x0f\n\x07\x04\x1f\
    \x03\0\x02\x02\x06\x12\x04\xd4\x07\x04\x17\n\x0f\n\x07\x04\x1f\x03\0\x02\
    \x02\x01\x12\x04\xd4\x07\x18,\n\x0f\n\x07\x04\x1f\x03\0\x02\x02\x03\x12\
    \x04\xd4\x07/0\n}\n\x04\x04\x1f\x02\0\x12\x04\xd9\x07\x02I\x1ao\x20Requi\
    red.\x20Name\x20of\x20the\x20bucket\x20containing\x20the\x20source\x20ob\
    jects.\x20The\x20destination\x20object\x20is\n\x20stored\x20in\x20this\
    \x20bucket.\n\n\x0f\n\x05\x04\x1f\x02\0\x04\x12\x06\xd9\x07\x02\xd5\x07\
    \x03\n\r\n\x05\x04\x1f\x02\0\x05\x12\x04\xd9\x07\x02\x08\n\r\n\x05\x04\
    \x1f\x02\0\x01\x12\x04\xd9\x07\t\x1b\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\
    \xd9\x07\x1e\x1f\n\r\n\x05\x04\x1f\x02\0\x08\x12\x04\xd9\x07\x20H\n\x10\
    \n\x08\x04\x1f\x02\0\x08\x9c\x08\0\x12\x04\xd9\x07!G\n1\n\x04\x04\x1f\
    \x02\x01\x12\x04\xdc\x07\x02I\x1a#\x20Required.\x20Name\x20of\x20the\x20\
    new\x20object.\n\n\x0f\n\x05\x04\x1f\x02\x01\x04\x12\x06\xdc\x07\x02\xd9\
    \x07I\n\r\n\x05\x04\x1f\x02\x01\x05\x12\x04\xdc\x07\x02\x08\n\r\n\x05\
    \x04\x1f\x02\x01\x01\x12\x04\xdc\x07\t\x1b\n\r\n\x05\x04\x1f\x02\x01\x03\
    \x12\x04\xdc\x07\x1e\x1f\n\r\n\x05\x04\x1f\x02\x01\x08\x12\x04\xdc\x07\
    \x20H\n\x10\n\x08\x04\x1f\x02\x01\x08\x9c\x08\0\x12\x04\xdc\x07!G\nT\n\
    \x04\x04\x1f\x02\x02\x12\x04\xdf\x07\x02A\x1aF\x20Apply\x20a\x20predefin\
    ed\x20set\x20of\x20access\x20controls\x20to\x20the\x20destination\x20obj\
    ect.\n\n\x0f\n\x05\x04\x1f\x02\x02\x04\x12\x06\xdf\x07\x02\xdc\x07I\n\r\
    \n\x05\x04\x1f\x02\x02\x06\x12\x04\xdf\x07\x02!\n\r\n\x05\x04\x1f\x02\
    \x02\x01\x12\x04\xdf\x07\"<\n\r\n\x05\x04\x1f\x02\x02\x03\x12\x04\xdf\
    \x07?@\n3\n\x04\x04\x1f\x02\x03\x12\x04\xe2\x07\x02\x1a\x1a%\x20Properti\
    es\x20of\x20the\x20resulting\x20object.\n\n\x0f\n\x05\x04\x1f\x02\x03\
    \x04\x12\x06\xe2\x07\x02\xdf\x07A\n\r\n\x05\x04\x1f\x02\x03\x06\x12\x04\
    \xe2\x07\x02\x08\n\r\n\x05\x04\x1f\x02\x03\x01\x12\x04\xe2\x07\t\x14\n\r\
    \n\x05\x04\x1f\x02\x03\x03\x12\x04\xe2\x07\x17\x19\nZ\n\x04\x04\x1f\x02\
    \x04\x12\x04\xe5\x07\x02-\x1aL\x20The\x20list\x20of\x20source\x20objects\
    \x20that\x20will\x20be\x20concatenated\x20into\x20a\x20single\x20object.\
    \n\n\r\n\x05\x04\x1f\x02\x04\x04\x12\x04\xe5\x07\x02\n\n\r\n\x05\x04\x1f\
    \x02\x04\x06\x12\x04\xe5\x07\x0b\x18\n\r\n\x05\x04\x1f\x02\x04\x01\x12\
    \x04\xe5\x07\x19'\n\r\n\x05\x04\x1f\x02\x04\x03\x12\x04\xe5\x07*,\n\xd1\
    \x01\n\x04\x04\x1f\x02\x05\x12\x04\xea\x07\x025\x1a\xc2\x01\x20Makes\x20\
    the\x20operation\x20conditional\x20on\x20whether\x20the\x20object's\x20c\
    urrent\x20generation\n\x20matches\x20the\x20given\x20value.\x20Setting\
    \x20to\x200\x20makes\x20the\x20operation\x20succeed\x20only\x20if\n\x20t\
    here\x20are\x20no\x20live\x20versions\x20of\x20the\x20object.\n\n\x0f\n\
    \x05\x04\x1f\x02\x05\x04\x12\x06\xea\x07\x02\xe5\x07-\n\r\n\x05\x04\x1f\
    \x02\x05\x06\x12\x04\xea\x07\x02\x1c\n\r\n\x05\x04\x1f\x02\x05\x01\x12\
    \x04\xea\x07\x1d0\n\r\n\x05\x04\x1f\x02\x05\x03\x12\x04\xea\x0734\nx\n\
    \x04\x04\x1f\x02\x06\x12\x04\xee\x07\x029\x1aj\x20Makes\x20the\x20operat\
    ion\x20conditional\x20on\x20whether\x20the\x20object's\x20current\n\x20m\
    etageneration\x20matches\x20the\x20given\x20value.\n\n\x0f\n\x05\x04\x1f\
    \x02\x06\x04\x12\x06\xee\x07\x02\xea\x075\n\r\n\x05\x04\x1f\x02\x06\x06\
    \x12\x04\xee\x07\x02\x1c\n\r\n\x05\x04\x1f\x02\x06\x01\x12\x04\xee\x07\
    \x1d4\n\r\n\x05\x04\x1f\x02\x06\x03\x12\x04\xee\x0778\n\xf8\x01\n\x04\
    \x04\x1f\x02\x07\x12\x04\xf4\x07\x02\x1a\x1a\xe9\x01\x20Resource\x20name\
    \x20of\x20the\x20Cloud\x20KMS\x20key,\x20of\x20the\x20form\n\x20`project\
    s/my-project/locations/my-location/keyRings/my-kr/cryptoKeys/my-key`,\n\
    \x20that\x20will\x20be\x20used\x20to\x20encrypt\x20the\x20object.\x20Ove\
    rrides\x20the\x20object\n\x20metadata's\x20`kms_key_name`\x20value,\x20i\
    f\x20any.\n\n\x0f\n\x05\x04\x1f\x02\x07\x04\x12\x06\xf4\x07\x02\xee\x079\
    \n\r\n\x05\x04\x1f\x02\x07\x05\x12\x04\xf4\x07\x02\x08\n\r\n\x05\x04\x1f\
    \x02\x07\x01\x12\x04\xf4\x07\t\x15\n\r\n\x05\x04\x1f\x02\x07\x03\x12\x04\
    \xf4\x07\x18\x19\nX\n\x04\x04\x1f\x02\x08\x12\x04\xf7\x07\x02=\x1aJ\x20A\
    \x20set\x20of\x20parameters\x20common\x20to\x20Storage\x20API\x20request\
    s\x20concerning\x20an\x20object.\n\n\x0f\n\x05\x04\x1f\x02\x08\x04\x12\
    \x06\xf7\x07\x02\xf4\x07\x1a\n\r\n\x05\x04\x1f\x02\x08\x06\x12\x04\xf7\
    \x07\x02\x1b\n\r\n\x05\x04\x1f\x02\x08\x01\x12\x04\xf7\x07\x1c8\n\r\n\
    \x05\x04\x1f\x02\x08\x03\x12\x04\xf7\x07;<\nG\n\x04\x04\x1f\x02\t\x12\
    \x04\xfa\x07\x021\x1a9\x20A\x20set\x20of\x20parameters\x20common\x20to\
    \x20all\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04\x1f\x02\t\x04\
    \x12\x06\xfa\x07\x02\xf7\x07=\n\r\n\x05\x04\x1f\x02\t\x06\x12\x04\xfa\
    \x07\x02\x15\n\r\n\x05\x04\x1f\x02\t\x01\x12\x04\xfa\x07\x16+\n\r\n\x05\
    \x04\x1f\x02\t\x03\x12\x04\xfa\x07.0\n/\n\x02\x04\x20\x12\x06\xfe\x07\0\
    \xcd\x08\x01\x1a!\x20Request\x20message\x20for\x20CopyObject.\n\n\x0b\n\
    \x03\x04\x20\x01\x12\x04\xfe\x07\x08\x19\n\x92\x01\n\x04\x04\x20\x02\0\
    \x12\x04\x82\x08\x02I\x1a\x83\x01\x20Required.\x20Name\x20of\x20the\x20b\
    ucket\x20in\x20which\x20to\x20store\x20the\x20new\x20object.\x20Override\
    s\x20the\x20provided\n\x20object\n\x20metadata's\x20`bucket`\x20value,\
    \x20if\x20any.\n\n\x0f\n\x05\x04\x20\x02\0\x04\x12\x06\x82\x08\x02\xfe\
    \x07\x1b\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\x82\x08\x02\x08\n\r\n\x05\
    \x04\x20\x02\0\x01\x12\x04\x82\x08\t\x1b\n\r\n\x05\x04\x20\x02\0\x03\x12\
    \x04\x82\x08\x1e\x1f\n\r\n\x05\x04\x20\x02\0\x08\x12\x04\x82\x08\x20H\n\
    \x10\n\x08\x04\x20\x02\0\x08\x9c\x08\0\x12\x04\x82\x08!G\n\xa7\x01\n\x04\
    \x04\x20\x02\x01\x12\x04\x87\x08\x02I\x1a\x98\x01\x20Required.\x20Name\
    \x20of\x20the\x20new\x20object.\n\x20Required\x20when\x20the\x20object\
    \x20metadata\x20is\x20not\x20otherwise\x20provided.\x20Overrides\x20the\
    \n\x20object\x20metadata's\x20`name`\x20value,\x20if\x20any.\n\n\x0f\n\
    \x05\x04\x20\x02\x01\x04\x12\x06\x87\x08\x02\x82\x08I\n\r\n\x05\x04\x20\
    \x02\x01\x05\x12\x04\x87\x08\x02\x08\n\r\n\x05\x04\x20\x02\x01\x01\x12\
    \x04\x87\x08\t\x1b\n\r\n\x05\x04\x20\x02\x01\x03\x12\x04\x87\x08\x1e\x1f\
    \n\r\n\x05\x04\x20\x02\x01\x08\x12\x04\x87\x08\x20H\n\x10\n\x08\x04\x20\
    \x02\x01\x08\x9c\x08\0\x12\x04\x87\x08!G\nT\n\x04\x04\x20\x02\x02\x12\
    \x04\x8a\x08\x02A\x1aF\x20Apply\x20a\x20predefined\x20set\x20of\x20acces\
    s\x20controls\x20to\x20the\x20destination\x20object.\n\n\x0f\n\x05\x04\
    \x20\x02\x02\x04\x12\x06\x8a\x08\x02\x87\x08I\n\r\n\x05\x04\x20\x02\x02\
    \x06\x12\x04\x8a\x08\x02!\n\r\n\x05\x04\x20\x02\x02\x01\x12\x04\x8a\x08\
    \"<\n\r\n\x05\x04\x20\x02\x02\x03\x12\x04\x8a\x08?@\n\xdd\x01\n\x04\x04\
    \x20\x02\x03\x12\x04\x8f\x08\x025\x1a\xce\x01\x20Makes\x20the\x20operati\
    on\x20conditional\x20on\x20whether\x20the\x20destination\x20object's\x20\
    current\n\x20generation\x20matches\x20the\x20given\x20value.\x20Setting\
    \x20to\x200\x20makes\x20the\x20operation\n\x20succeed\x20only\x20if\x20t\
    here\x20are\x20no\x20live\x20versions\x20of\x20the\x20object.\n\n\x0f\n\
    \x05\x04\x20\x02\x03\x04\x12\x06\x8f\x08\x02\x8a\x08A\n\r\n\x05\x04\x20\
    \x02\x03\x06\x12\x04\x8f\x08\x02\x1c\n\r\n\x05\x04\x20\x02\x03\x01\x12\
    \x04\x8f\x08\x1d0\n\r\n\x05\x04\x20\x02\x03\x03\x12\x04\x8f\x0834\n\x94\
    \x02\n\x04\x04\x20\x02\x04\x12\x04\x95\x08\x029\x1a\x85\x02\x20Makes\x20\
    the\x20operation\x20conditional\x20on\x20whether\x20the\x20destination\
    \x20object's\x20current\n\x20generation\x20does\x20not\x20match\x20the\
    \x20given\x20value.\x20If\x20no\x20live\x20object\x20exists,\x20the\n\
    \x20precondition\x20fails.\x20Setting\x20to\x200\x20makes\x20the\x20oper\
    ation\x20succeed\x20only\x20if\x20there\n\x20is\x20a\x20live\x20version\
    \x20of\x20the\x20object.\n\n\x0f\n\x05\x04\x20\x02\x04\x04\x12\x06\x95\
    \x08\x02\x8f\x085\n\r\n\x05\x04\x20\x02\x04\x06\x12\x04\x95\x08\x02\x1c\
    \n\r\n\x05\x04\x20\x02\x04\x01\x12\x04\x95\x08\x1d4\n\r\n\x05\x04\x20\
    \x02\x04\x03\x12\x04\x95\x0878\n\x84\x01\n\x04\x04\x20\x02\x05\x12\x04\
    \x99\x08\x029\x1av\x20Makes\x20the\x20operation\x20conditional\x20on\x20\
    whether\x20the\x20destination\x20object's\x20current\n\x20metageneration\
    \x20matches\x20the\x20given\x20value.\n\n\x0f\n\x05\x04\x20\x02\x05\x04\
    \x12\x06\x99\x08\x02\x95\x089\n\r\n\x05\x04\x20\x02\x05\x06\x12\x04\x99\
    \x08\x02\x1c\n\r\n\x05\x04\x20\x02\x05\x01\x12\x04\x99\x08\x1d4\n\r\n\
    \x05\x04\x20\x02\x05\x03\x12\x04\x99\x0878\n\x8b\x01\n\x04\x04\x20\x02\
    \x06\x12\x04\x9d\x08\x02=\x1a}\x20Makes\x20the\x20operation\x20condition\
    al\x20on\x20whether\x20the\x20destination\x20object's\x20current\n\x20me\
    tageneration\x20does\x20not\x20match\x20the\x20given\x20value.\n\n\x0f\n\
    \x05\x04\x20\x02\x06\x04\x12\x06\x9d\x08\x02\x99\x089\n\r\n\x05\x04\x20\
    \x02\x06\x06\x12\x04\x9d\x08\x02\x1c\n\r\n\x05\x04\x20\x02\x06\x01\x12\
    \x04\x9d\x08\x1d8\n\r\n\x05\x04\x20\x02\x06\x03\x12\x04\x9d\x08;<\n{\n\
    \x04\x04\x20\x02\x07\x12\x04\xa1\x08\x02<\x1am\x20Makes\x20the\x20operat\
    ion\x20conditional\x20on\x20whether\x20the\x20source\x20object's\x20curr\
    ent\n\x20generation\x20matches\x20the\x20given\x20value.\n\n\x0f\n\x05\
    \x04\x20\x02\x07\x04\x12\x06\xa1\x08\x02\x9d\x08=\n\r\n\x05\x04\x20\x02\
    \x07\x06\x12\x04\xa1\x08\x02\x1c\n\r\n\x05\x04\x20\x02\x07\x01\x12\x04\
    \xa1\x08\x1d7\n\r\n\x05\x04\x20\x02\x07\x03\x12\x04\xa1\x08:;\n\x82\x01\
    \n\x04\x04\x20\x02\x08\x12\x04\xa5\x08\x02@\x1at\x20Makes\x20the\x20oper\
    ation\x20conditional\x20on\x20whether\x20the\x20source\x20object's\x20cu\
    rrent\n\x20generation\x20does\x20not\x20match\x20the\x20given\x20value.\
    \n\n\x0f\n\x05\x04\x20\x02\x08\x04\x12\x06\xa5\x08\x02\xa1\x08<\n\r\n\
    \x05\x04\x20\x02\x08\x06\x12\x04\xa5\x08\x02\x1c\n\r\n\x05\x04\x20\x02\
    \x08\x01\x12\x04\xa5\x08\x1d;\n\r\n\x05\x04\x20\x02\x08\x03\x12\x04\xa5\
    \x08>?\n\x7f\n\x04\x04\x20\x02\t\x12\x04\xa9\x08\x02A\x1aq\x20Makes\x20t\
    he\x20operation\x20conditional\x20on\x20whether\x20the\x20source\x20obje\
    ct's\x20current\n\x20metageneration\x20matches\x20the\x20given\x20value.\
    \n\n\x0f\n\x05\x04\x20\x02\t\x04\x12\x06\xa9\x08\x02\xa5\x08@\n\r\n\x05\
    \x04\x20\x02\t\x06\x12\x04\xa9\x08\x02\x1c\n\r\n\x05\x04\x20\x02\t\x01\
    \x12\x04\xa9\x08\x1d;\n\r\n\x05\x04\x20\x02\t\x03\x12\x04\xa9\x08>@\n\
    \x86\x01\n\x04\x04\x20\x02\n\x12\x04\xad\x08\x02E\x1ax\x20Makes\x20the\
    \x20operation\x20conditional\x20on\x20whether\x20the\x20source\x20object\
    's\x20current\n\x20metageneration\x20does\x20not\x20match\x20the\x20give\
    n\x20value.\n\n\x0f\n\x05\x04\x20\x02\n\x04\x12\x06\xad\x08\x02\xa9\x08A\
    \n\r\n\x05\x04\x20\x02\n\x06\x12\x04\xad\x08\x02\x1c\n\r\n\x05\x04\x20\
    \x02\n\x01\x12\x04\xad\x08\x1d?\n\r\n\x05\x04\x20\x02\n\x03\x12\x04\xad\
    \x08BD\n\x9a\x01\n\x04\x04\x20\x02\x0b\x12\x04\xb2\x08\x02)\x1a\x8b\x01\
    \x20Set\x20of\x20properties\x20to\x20return.\x20Defaults\x20to\x20`NO_AC\
    L`,\x20unless\x20the\n\x20object\x20resource\x20specifies\x20the\x20`acl\
    `\x20property,\x20when\x20it\x20defaults\n\x20to\x20`full`.\n\n\x0f\n\
    \x05\x04\x20\x02\x0b\x04\x12\x06\xb2\x08\x02\xad\x08E\n\r\n\x05\x04\x20\
    \x02\x0b\x06\x12\x04\xb2\x08\x02\x18\n\r\n\x05\x04\x20\x02\x0b\x01\x12\
    \x04\xb2\x08\x19#\n\r\n\x05\x04\x20\x02\x0b\x03\x12\x04\xb2\x08&(\nP\n\
    \x04\x04\x20\x02\x0c\x12\x04\xb5\x08\x02E\x1aB\x20Required.\x20Name\x20o\
    f\x20the\x20bucket\x20in\x20which\x20to\x20find\x20the\x20source\x20obje\
    ct.\n\n\x0f\n\x05\x04\x20\x02\x0c\x04\x12\x06\xb5\x08\x02\xb2\x08)\n\r\n\
    \x05\x04\x20\x02\x0c\x05\x12\x04\xb5\x08\x02\x08\n\r\n\x05\x04\x20\x02\
    \x0c\x01\x12\x04\xb5\x08\t\x16\n\r\n\x05\x04\x20\x02\x0c\x03\x12\x04\xb5\
    \x08\x19\x1b\n\r\n\x05\x04\x20\x02\x0c\x08\x12\x04\xb5\x08\x1cD\n\x10\n\
    \x08\x04\x20\x02\x0c\x08\x9c\x08\0\x12\x04\xb5\x08\x1dC\n4\n\x04\x04\x20\
    \x02\r\x12\x04\xb8\x08\x02E\x1a&\x20Required.\x20Name\x20of\x20the\x20so\
    urce\x20object.\n\n\x0f\n\x05\x04\x20\x02\r\x04\x12\x06\xb8\x08\x02\xb5\
    \x08E\n\r\n\x05\x04\x20\x02\r\x05\x12\x04\xb8\x08\x02\x08\n\r\n\x05\x04\
    \x20\x02\r\x01\x12\x04\xb8\x08\t\x16\n\r\n\x05\x04\x20\x02\r\x03\x12\x04\
    \xb8\x08\x19\x1b\n\r\n\x05\x04\x20\x02\r\x08\x12\x04\xb8\x08\x1cD\n\x10\
    \n\x08\x04\x20\x02\r\x08\x9c\x08\0\x12\x04\xb8\x08\x1dC\n~\n\x04\x04\x20\
    \x02\x0e\x12\x04\xbc\x08\x02\x1f\x1ap\x20If\x20present,\x20selects\x20a\
    \x20specific\x20revision\x20of\x20the\x20source\x20object\x20(as\x20oppo\
    sed\x20to\n\x20the\x20latest\x20version,\x20the\x20default).\n\n\x0f\n\
    \x05\x04\x20\x02\x0e\x04\x12\x06\xbc\x08\x02\xb8\x08E\n\r\n\x05\x04\x20\
    \x02\x0e\x05\x12\x04\xbc\x08\x02\x07\n\r\n\x05\x04\x20\x02\x0e\x01\x12\
    \x04\xbc\x08\x08\x19\n\r\n\x05\x04\x20\x02\x0e\x03\x12\x04\xbc\x08\x1c\
    \x1e\ng\n\x04\x04\x20\x02\x0f\x12\x04\xc0\x08\x02\x1a\x1aY\x20Properties\
    \x20of\x20the\x20resulting\x20object.\x20If\x20not\x20set,\x20duplicate\
    \x20properties\x20of\n\x20source\x20object.\n\n\x0f\n\x05\x04\x20\x02\
    \x0f\x04\x12\x06\xc0\x08\x02\xbc\x08\x1f\n\r\n\x05\x04\x20\x02\x0f\x06\
    \x12\x04\xc0\x08\x02\x08\n\r\n\x05\x04\x20\x02\x0f\x01\x12\x04\xc0\x08\t\
    \x14\n\r\n\x05\x04\x20\x02\x0f\x03\x12\x04\xc0\x08\x17\x19\n\xf8\x01\n\
    \x04\x04\x20\x02\x10\x12\x04\xc6\x08\x02'\x1a\xe9\x01\x20Resource\x20nam\
    e\x20of\x20the\x20Cloud\x20KMS\x20key,\x20of\x20the\x20form\n\x20`projec\
    ts/my-project/locations/my-location/keyRings/my-kr/cryptoKeys/my-key`,\n\
    \x20that\x20will\x20be\x20used\x20to\x20encrypt\x20the\x20object.\x20Ove\
    rrides\x20the\x20object\n\x20metadata's\x20`kms_key_name`\x20value,\x20i\
    f\x20any.\n\n\x0f\n\x05\x04\x20\x02\x10\x04\x12\x06\xc6\x08\x02\xc0\x08\
    \x1a\n\r\n\x05\x04\x20\x02\x10\x05\x12\x04\xc6\x08\x02\x08\n\r\n\x05\x04\
    \x20\x02\x10\x01\x12\x04\xc6\x08\t!\n\r\n\x05\x04\x20\x02\x10\x03\x12\
    \x04\xc6\x08$&\nX\n\x04\x04\x20\x02\x11\x12\x04\xc9\x08\x02>\x1aJ\x20A\
    \x20set\x20of\x20parameters\x20common\x20to\x20Storage\x20API\x20request\
    s\x20concerning\x20an\x20object.\n\n\x0f\n\x05\x04\x20\x02\x11\x04\x12\
    \x06\xc9\x08\x02\xc6\x08'\n\r\n\x05\x04\x20\x02\x11\x06\x12\x04\xc9\x08\
    \x02\x1b\n\r\n\x05\x04\x20\x02\x11\x01\x12\x04\xc9\x08\x1c8\n\r\n\x05\
    \x04\x20\x02\x11\x03\x12\x04\xc9\x08;=\nG\n\x04\x04\x20\x02\x12\x12\x04\
    \xcc\x08\x021\x1a9\x20A\x20set\x20of\x20parameters\x20common\x20to\x20al\
    l\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04\x20\x02\x12\x04\x12\
    \x06\xcc\x08\x02\xc9\x08>\n\r\n\x05\x04\x20\x02\x12\x06\x12\x04\xcc\x08\
    \x02\x15\n\r\n\x05\x04\x20\x02\x12\x01\x12\x04\xcc\x08\x16+\n\r\n\x05\
    \x04\x20\x02\x12\x03\x12\x04\xcc\x08.0\n~\n\x02\x04!\x12\x06\xd1\x08\0\
    \xf9\x08\x01\x1ap\x20Message\x20for\x20deleting\x20an\x20object.\n\x20Ei\
    ther\x20`bucket`\x20and\x20`object`\x20*or*\x20`upload_id`\x20**must**\
    \x20be\x20set\x20(but\x20not\x20both).\n\n\x0b\n\x03\x04!\x01\x12\x04\
    \xd1\x08\x08\x1b\nI\n\x04\x04!\x02\0\x12\x04\xd3\x08\x02=\x1a;\x20Requir\
    ed.\x20Name\x20of\x20the\x20bucket\x20in\x20which\x20the\x20object\x20re\
    sides.\n\n\x0f\n\x05\x04!\x02\0\x04\x12\x06\xd3\x08\x02\xd1\x08\x1d\n\r\
    \n\x05\x04!\x02\0\x05\x12\x04\xd3\x08\x02\x08\n\r\n\x05\x04!\x02\0\x01\
    \x12\x04\xd3\x08\t\x0f\n\r\n\x05\x04!\x02\0\x03\x12\x04\xd3\x08\x12\x13\
    \n\r\n\x05\x04!\x02\0\x08\x12\x04\xd3\x08\x14<\n\x10\n\x08\x04!\x02\0\
    \x08\x9c\x08\0\x12\x04\xd3\x08\x15;\n^\n\x04\x04!\x02\x01\x12\x04\xd6\
    \x08\x02=\x1aP\x20Required.\x20The\x20name\x20of\x20the\x20object\x20to\
    \x20delete\x20(when\x20not\x20using\x20a\x20resumable\x20write).\n\n\x0f\
    \n\x05\x04!\x02\x01\x04\x12\x06\xd6\x08\x02\xd3\x08=\n\r\n\x05\x04!\x02\
    \x01\x05\x12\x04\xd6\x08\x02\x08\n\r\n\x05\x04!\x02\x01\x01\x12\x04\xd6\
    \x08\t\x0f\n\r\n\x05\x04!\x02\x01\x03\x12\x04\xd6\x08\x12\x13\n\r\n\x05\
    \x04!\x02\x01\x08\x12\x04\xd6\x08\x14<\n\x10\n\x08\x04!\x02\x01\x08\x9c\
    \x08\0\x12\x04\xd6\x08\x15;\n\xb5\x01\n\x04\x04!\x02\x02\x12\x04\xdb\x08\
    \x02\x17\x1a\xa6\x01\x20The\x20resumable\x20upload_id\x20of\x20the\x20ob\
    ject\x20to\x20delete\x20(when\x20using\x20a\n\x20resumable\x20write).\
    \x20This\x20should\x20be\x20copied\x20from\x20the\x20`upload_id`\x20fiel\
    d\x20of\n\x20`StartResumableWriteResponse`.\n\n\x0f\n\x05\x04!\x02\x02\
    \x04\x12\x06\xdb\x08\x02\xd6\x08=\n\r\n\x05\x04!\x02\x02\x05\x12\x04\xdb\
    \x08\x02\x08\n\r\n\x05\x04!\x02\x02\x01\x12\x04\xdb\x08\t\x12\n\r\n\x05\
    \x04!\x02\x02\x03\x12\x04\xdb\x08\x15\x16\n\x84\x01\n\x04\x04!\x02\x03\
    \x12\x04\xdf\x08\x02\x17\x1av\x20If\x20present,\x20permanently\x20delete\
    s\x20a\x20specific\x20revision\x20of\x20this\x20object\x20(as\n\x20oppos\
    ed\x20to\x20the\x20latest\x20version,\x20the\x20default).\n\n\x0f\n\x05\
    \x04!\x02\x03\x04\x12\x06\xdf\x08\x02\xdb\x08\x17\n\r\n\x05\x04!\x02\x03\
    \x05\x12\x04\xdf\x08\x02\x07\n\r\n\x05\x04!\x02\x03\x01\x12\x04\xdf\x08\
    \x08\x12\n\r\n\x05\x04!\x02\x03\x03\x12\x04\xdf\x08\x15\x16\n\xd1\x01\n\
    \x04\x04!\x02\x04\x12\x04\xe4\x08\x025\x1a\xc2\x01\x20Makes\x20the\x20op\
    eration\x20conditional\x20on\x20whether\x20the\x20object's\x20current\
    \x20generation\n\x20matches\x20the\x20given\x20value.\x20Setting\x20to\
    \x200\x20makes\x20the\x20operation\x20succeed\x20only\x20if\n\x20there\
    \x20are\x20no\x20live\x20versions\x20of\x20the\x20object.\n\n\x0f\n\x05\
    \x04!\x02\x04\x04\x12\x06\xe4\x08\x02\xdf\x08\x17\n\r\n\x05\x04!\x02\x04\
    \x06\x12\x04\xe4\x08\x02\x1c\n\r\n\x05\x04!\x02\x04\x01\x12\x04\xe4\x08\
    \x1d0\n\r\n\x05\x04!\x02\x04\x03\x12\x04\xe4\x0834\n\x88\x02\n\x04\x04!\
    \x02\x05\x12\x04\xea\x08\x029\x1a\xf9\x01\x20Makes\x20the\x20operation\
    \x20conditional\x20on\x20whether\x20the\x20object's\x20current\x20genera\
    tion\n\x20does\x20not\x20match\x20the\x20given\x20value.\x20If\x20no\x20\
    live\x20object\x20exists,\x20the\x20precondition\n\x20fails.\x20Setting\
    \x20to\x200\x20makes\x20the\x20operation\x20succeed\x20only\x20if\x20the\
    re\x20is\x20a\x20live\n\x20version\x20of\x20the\x20object.\n\n\x0f\n\x05\
    \x04!\x02\x05\x04\x12\x06\xea\x08\x02\xe4\x085\n\r\n\x05\x04!\x02\x05\
    \x06\x12\x04\xea\x08\x02\x1c\n\r\n\x05\x04!\x02\x05\x01\x12\x04\xea\x08\
    \x1d4\n\r\n\x05\x04!\x02\x05\x03\x12\x04\xea\x0878\nx\n\x04\x04!\x02\x06\
    \x12\x04\xee\x08\x029\x1aj\x20Makes\x20the\x20operation\x20conditional\
    \x20on\x20whether\x20the\x20object's\x20current\n\x20metageneration\x20m\
    atches\x20the\x20given\x20value.\n\n\x0f\n\x05\x04!\x02\x06\x04\x12\x06\
    \xee\x08\x02\xea\x089\n\r\n\x05\x04!\x02\x06\x06\x12\x04\xee\x08\x02\x1c\
    \n\r\n\x05\x04!\x02\x06\x01\x12\x04\xee\x08\x1d4\n\r\n\x05\x04!\x02\x06\
    \x03\x12\x04\xee\x0878\n\x7f\n\x04\x04!\x02\x07\x12\x04\xf2\x08\x02=\x1a\
    q\x20Makes\x20the\x20operation\x20conditional\x20on\x20whether\x20the\
    \x20object's\x20current\n\x20metageneration\x20does\x20not\x20match\x20t\
    he\x20given\x20value.\n\n\x0f\n\x05\x04!\x02\x07\x04\x12\x06\xf2\x08\x02\
    \xee\x089\n\r\n\x05\x04!\x02\x07\x06\x12\x04\xf2\x08\x02\x1c\n\r\n\x05\
    \x04!\x02\x07\x01\x12\x04\xf2\x08\x1d8\n\r\n\x05\x04!\x02\x07\x03\x12\
    \x04\xf2\x08;<\nX\n\x04\x04!\x02\x08\x12\x04\xf5\x08\x02>\x1aJ\x20A\x20s\
    et\x20of\x20parameters\x20common\x20to\x20Storage\x20API\x20requests\x20\
    concerning\x20an\x20object.\n\n\x0f\n\x05\x04!\x02\x08\x04\x12\x06\xf5\
    \x08\x02\xf2\x08=\n\r\n\x05\x04!\x02\x08\x06\x12\x04\xf5\x08\x02\x1b\n\r\
    \n\x05\x04!\x02\x08\x01\x12\x04\xf5\x08\x1c8\n\r\n\x05\x04!\x02\x08\x03\
    \x12\x04\xf5\x08;=\nG\n\x04\x04!\x02\t\x12\x04\xf8\x08\x021\x1a9\x20A\
    \x20set\x20of\x20parameters\x20common\x20to\x20all\x20Storage\x20API\x20\
    requests.\n\n\x0f\n\x05\x04!\x02\t\x04\x12\x06\xf8\x08\x02\xf5\x08>\n\r\
    \n\x05\x04!\x02\t\x06\x12\x04\xf8\x08\x02\x15\n\r\n\x05\x04!\x02\t\x01\
    \x12\x04\xf8\x08\x16+\n\r\n\x05\x04!\x02\t\x03\x12\x04\xf8\x08.0\n3\n\
    \x02\x04\"\x12\x06\xfc\x08\0\xb1\t\x01\x1a%\x20Request\x20message\x20for\
    \x20GetObjectMedia.\n\n\x0b\n\x03\x04\"\x01\x12\x04\xfc\x08\x08\x1d\nE\n\
    \x04\x04\"\x02\0\x12\x04\xfe\x08\x02\x14\x1a7\x20The\x20name\x20of\x20th\
    e\x20bucket\x20containing\x20the\x20object\x20to\x20read.\n\n\x0f\n\x05\
    \x04\"\x02\0\x04\x12\x06\xfe\x08\x02\xfc\x08\x1f\n\r\n\x05\x04\"\x02\0\
    \x05\x12\x04\xfe\x08\x02\x08\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xfe\x08\t\
    \x0f\n\r\n\x05\x04\"\x02\0\x03\x12\x04\xfe\x08\x12\x13\n/\n\x04\x04\"\
    \x02\x01\x12\x04\x81\t\x02\x14\x1a!\x20The\x20name\x20of\x20the\x20objec\
    t\x20to\x20read.\n\n\x0f\n\x05\x04\"\x02\x01\x04\x12\x06\x81\t\x02\xfe\
    \x08\x14\n\r\n\x05\x04\"\x02\x01\x05\x12\x04\x81\t\x02\x08\n\r\n\x05\x04\
    \"\x02\x01\x01\x12\x04\x81\t\t\x0f\n\r\n\x05\x04\"\x02\x01\x03\x12\x04\
    \x81\t\x12\x13\nx\n\x04\x04\"\x02\x02\x12\x04\x85\t\x02\x17\x1aj\x20If\
    \x20present,\x20selects\x20a\x20specific\x20revision\x20of\x20this\x20ob\
    ject\x20(as\x20opposed\n\x20to\x20the\x20latest\x20version,\x20the\x20de\
    fault).\n\n\x0f\n\x05\x04\"\x02\x02\x04\x12\x06\x85\t\x02\x81\t\x14\n\r\
    \n\x05\x04\"\x02\x02\x05\x12\x04\x85\t\x02\x07\n\r\n\x05\x04\"\x02\x02\
    \x01\x12\x04\x85\t\x08\x12\n\r\n\x05\x04\"\x02\x02\x03\x12\x04\x85\t\x15\
    \x16\n\x8f\x03\n\x04\x04\"\x02\x03\x12\x04\x8e\t\x02\x18\x1a\x80\x03\x20\
    The\x20offset\x20for\x20the\x20first\x20byte\x20to\x20return\x20in\x20th\
    e\x20read,\x20relative\x20to\x20the\x20start\n\x20of\x20the\x20object.\n\
    \n\x20A\x20negative\x20`read_offset`\x20value\x20will\x20be\x20interpret\
    ed\x20as\x20the\x20number\x20of\x20bytes\n\x20back\x20from\x20the\x20end\
    \x20of\x20the\x20object\x20to\x20be\x20returned.\x20For\x20example,\x20i\
    f\x20an\x20object's\n\x20length\x20is\x2015\x20bytes,\x20a\x20GetObjectM\
    ediaRequest\x20with\x20`read_offset`\x20=\x20-5\x20and\n\x20`read_limit`\
    \x20=\x203\x20would\x20return\x20bytes\x2010\x20through\x2012\x20of\x20t\
    he\x20object.\n\n\x0f\n\x05\x04\"\x02\x03\x04\x12\x06\x8e\t\x02\x85\t\
    \x17\n\r\n\x05\x04\"\x02\x03\x05\x12\x04\x8e\t\x02\x07\n\r\n\x05\x04\"\
    \x02\x03\x01\x12\x04\x8e\t\x08\x13\n\r\n\x05\x04\"\x02\x03\x03\x12\x04\
    \x8e\t\x16\x17\n\x92\x03\n\x04\x04\"\x02\x04\x12\x04\x97\t\x02\x17\x1a\
    \x83\x03\x20The\x20maximum\x20number\x20of\x20`data`\x20bytes\x20the\x20\
    server\x20is\x20allowed\x20to\x20return\x20in\x20the\n\x20sum\x20of\x20a\
    ll\x20`Object`\x20messages.\x20A\x20`read_limit`\x20of\x20zero\x20indica\
    tes\x20that\x20there\n\x20is\x20no\x20limit,\x20and\x20a\x20negative\x20\
    `read_limit`\x20will\x20cause\x20an\x20error.\n\n\x20If\x20the\x20stream\
    \x20returns\x20fewer\x20bytes\x20than\x20allowed\x20by\x20the\x20`read_l\
    imit`\x20and\x20no\n\x20error\x20occurred,\x20the\x20stream\x20includes\
    \x20all\x20data\x20from\x20the\x20`read_offset`\x20to\x20the\n\x20end\
    \x20of\x20the\x20resource.\n\n\x0f\n\x05\x04\"\x02\x04\x04\x12\x06\x97\t\
    \x02\x8e\t\x18\n\r\n\x05\x04\"\x02\x04\x05\x12\x04\x97\t\x02\x07\n\r\n\
    \x05\x04\"\x02\x04\x01\x12\x04\x97\t\x08\x12\n\r\n\x05\x04\"\x02\x04\x03\
    \x12\x04\x97\t\x15\x16\n\xd1\x01\n\x04\x04\"\x02\x05\x12\x04\x9c\t\x025\
    \x1a\xc2\x01\x20Makes\x20the\x20operation\x20conditional\x20on\x20whethe\
    r\x20the\x20object's\x20current\x20generation\n\x20matches\x20the\x20giv\
    en\x20value.\x20Setting\x20to\x200\x20makes\x20the\x20operation\x20succe\
    ed\x20only\x20if\n\x20there\x20are\x20no\x20live\x20versions\x20of\x20th\
    e\x20object.\n\n\x0f\n\x05\x04\"\x02\x05\x04\x12\x06\x9c\t\x02\x97\t\x17\
    \n\r\n\x05\x04\"\x02\x05\x06\x12\x04\x9c\t\x02\x1c\n\r\n\x05\x04\"\x02\
    \x05\x01\x12\x04\x9c\t\x1d0\n\r\n\x05\x04\"\x02\x05\x03\x12\x04\x9c\t34\
    \n\x88\x02\n\x04\x04\"\x02\x06\x12\x04\xa2\t\x029\x1a\xf9\x01\x20Makes\
    \x20the\x20operation\x20conditional\x20on\x20whether\x20the\x20object's\
    \x20current\x20generation\n\x20does\x20not\x20match\x20the\x20given\x20v\
    alue.\x20If\x20no\x20live\x20object\x20exists,\x20the\x20precondition\n\
    \x20fails.\x20Setting\x20to\x200\x20makes\x20the\x20operation\x20succeed\
    \x20only\x20if\x20there\x20is\x20a\x20live\n\x20version\x20of\x20the\x20\
    object.\n\n\x0f\n\x05\x04\"\x02\x06\x04\x12\x06\xa2\t\x02\x9c\t5\n\r\n\
    \x05\x04\"\x02\x06\x06\x12\x04\xa2\t\x02\x1c\n\r\n\x05\x04\"\x02\x06\x01\
    \x12\x04\xa2\t\x1d4\n\r\n\x05\x04\"\x02\x06\x03\x12\x04\xa2\t78\nx\n\x04\
    \x04\"\x02\x07\x12\x04\xa6\t\x029\x1aj\x20Makes\x20the\x20operation\x20c\
    onditional\x20on\x20whether\x20the\x20object's\x20current\n\x20metagener\
    ation\x20matches\x20the\x20given\x20value.\n\n\x0f\n\x05\x04\"\x02\x07\
    \x04\x12\x06\xa6\t\x02\xa2\t9\n\r\n\x05\x04\"\x02\x07\x06\x12\x04\xa6\t\
    \x02\x1c\n\r\n\x05\x04\"\x02\x07\x01\x12\x04\xa6\t\x1d4\n\r\n\x05\x04\"\
    \x02\x07\x03\x12\x04\xa6\t78\n\x7f\n\x04\x04\"\x02\x08\x12\x04\xaa\t\x02\
    =\x1aq\x20Makes\x20the\x20operation\x20conditional\x20on\x20whether\x20t\
    he\x20object's\x20current\n\x20metageneration\x20does\x20not\x20match\
    \x20the\x20given\x20value.\n\n\x0f\n\x05\x04\"\x02\x08\x04\x12\x06\xaa\t\
    \x02\xa6\t9\n\r\n\x05\x04\"\x02\x08\x06\x12\x04\xaa\t\x02\x1c\n\r\n\x05\
    \x04\"\x02\x08\x01\x12\x04\xaa\t\x1d8\n\r\n\x05\x04\"\x02\x08\x03\x12\
    \x04\xaa\t;<\nX\n\x04\x04\"\x02\t\x12\x04\xad\t\x02>\x1aJ\x20A\x20set\
    \x20of\x20parameters\x20common\x20to\x20Storage\x20API\x20requests\x20co\
    ncerning\x20an\x20object.\n\n\x0f\n\x05\x04\"\x02\t\x04\x12\x06\xad\t\
    \x02\xaa\t=\n\r\n\x05\x04\"\x02\t\x06\x12\x04\xad\t\x02\x1b\n\r\n\x05\
    \x04\"\x02\t\x01\x12\x04\xad\t\x1c8\n\r\n\x05\x04\"\x02\t\x03\x12\x04\
    \xad\t;=\nG\n\x04\x04\"\x02\n\x12\x04\xb0\t\x021\x1a9\x20A\x20set\x20of\
    \x20parameters\x20common\x20to\x20all\x20Storage\x20API\x20requests.\n\n\
    \x0f\n\x05\x04\"\x02\n\x04\x12\x06\xb0\t\x02\xad\t>\n\r\n\x05\x04\"\x02\
    \n\x06\x12\x04\xb0\t\x02\x15\n\r\n\x05\x04\"\x02\n\x01\x12\x04\xb0\t\x16\
    +\n\r\n\x05\x04\"\x02\n\x03\x12\x04\xb0\t.0\n.\n\x02\x04#\x12\x06\xb4\t\
    \0\xda\t\x01\x1a\x20\x20Request\x20message\x20for\x20GetObject.\n\n\x0b\
    \n\x03\x04#\x01\x12\x04\xb4\t\x08\x18\nI\n\x04\x04#\x02\0\x12\x04\xb6\t\
    \x02=\x1a;\x20Required.\x20Name\x20of\x20the\x20bucket\x20in\x20which\
    \x20the\x20object\x20resides.\n\n\x0f\n\x05\x04#\x02\0\x04\x12\x06\xb6\t\
    \x02\xb4\t\x1a\n\r\n\x05\x04#\x02\0\x05\x12\x04\xb6\t\x02\x08\n\r\n\x05\
    \x04#\x02\0\x01\x12\x04\xb6\t\t\x0f\n\r\n\x05\x04#\x02\0\x03\x12\x04\xb6\
    \t\x12\x13\n\r\n\x05\x04#\x02\0\x08\x12\x04\xb6\t\x14<\n\x10\n\x08\x04#\
    \x02\0\x08\x9c\x08\0\x12\x04\xb6\t\x15;\n-\n\x04\x04#\x02\x01\x12\x04\
    \xb9\t\x02=\x1a\x1f\x20Required.\x20Name\x20of\x20the\x20object.\n\n\x0f\
    \n\x05\x04#\x02\x01\x04\x12\x06\xb9\t\x02\xb6\t=\n\r\n\x05\x04#\x02\x01\
    \x05\x12\x04\xb9\t\x02\x08\n\r\n\x05\x04#\x02\x01\x01\x12\x04\xb9\t\t\
    \x0f\n\r\n\x05\x04#\x02\x01\x03\x12\x04\xb9\t\x12\x13\n\r\n\x05\x04#\x02\
    \x01\x08\x12\x04\xb9\t\x14<\n\x10\n\x08\x04#\x02\x01\x08\x9c\x08\0\x12\
    \x04\xb9\t\x15;\nx\n\x04\x04#\x02\x02\x12\x04\xbd\t\x02\x17\x1aj\x20If\
    \x20present,\x20selects\x20a\x20specific\x20revision\x20of\x20this\x20ob\
    ject\x20(as\x20opposed\x20to\x20the\n\x20latest\x20version,\x20the\x20de\
    fault).\n\n\x0f\n\x05\x04#\x02\x02\x04\x12\x06\xbd\t\x02\xb9\t=\n\r\n\
    \x05\x04#\x02\x02\x05\x12\x04\xbd\t\x02\x07\n\r\n\x05\x04#\x02\x02\x01\
    \x12\x04\xbd\t\x08\x12\n\r\n\x05\x04#\x02\x02\x03\x12\x04\xbd\t\x15\x16\
    \n\xd1\x01\n\x04\x04#\x02\x03\x12\x04\xc2\t\x025\x1a\xc2\x01\x20Makes\
    \x20the\x20operation\x20conditional\x20on\x20whether\x20the\x20object's\
    \x20current\x20generation\n\x20matches\x20the\x20given\x20value.\x20Sett\
    ing\x20to\x200\x20makes\x20the\x20operation\x20succeed\x20only\x20if\n\
    \x20there\x20are\x20no\x20live\x20versions\x20of\x20the\x20object.\n\n\
    \x0f\n\x05\x04#\x02\x03\x04\x12\x06\xc2\t\x02\xbd\t\x17\n\r\n\x05\x04#\
    \x02\x03\x06\x12\x04\xc2\t\x02\x1c\n\r\n\x05\x04#\x02\x03\x01\x12\x04\
    \xc2\t\x1d0\n\r\n\x05\x04#\x02\x03\x03\x12\x04\xc2\t34\n\x88\x02\n\x04\
    \x04#\x02\x04\x12\x04\xc8\t\x029\x1a\xf9\x01\x20Makes\x20the\x20operatio\
    n\x20conditional\x20on\x20whether\x20the\x20object's\x20current\x20gener\
    ation\n\x20does\x20not\x20match\x20the\x20given\x20value.\x20If\x20no\
    \x20live\x20object\x20exists,\x20the\x20precondition\n\x20fails.\x20Sett\
    ing\x20to\x200\x20makes\x20the\x20operation\x20succeed\x20only\x20if\x20\
    there\x20is\x20a\x20live\n\x20version\x20of\x20the\x20object.\n\n\x0f\n\
    \x05\x04#\x02\x04\x04\x12\x06\xc8\t\x02\xc2\t5\n\r\n\x05\x04#\x02\x04\
    \x06\x12\x04\xc8\t\x02\x1c\n\r\n\x05\x04#\x02\x04\x01\x12\x04\xc8\t\x1d4\
    \n\r\n\x05\x04#\x02\x04\x03\x12\x04\xc8\t78\nx\n\x04\x04#\x02\x05\x12\
    \x04\xcc\t\x029\x1aj\x20Makes\x20the\x20operation\x20conditional\x20on\
    \x20whether\x20the\x20object's\x20current\n\x20metageneration\x20matches\
    \x20the\x20given\x20value.\n\n\x0f\n\x05\x04#\x02\x05\x04\x12\x06\xcc\t\
    \x02\xc8\t9\n\r\n\x05\x04#\x02\x05\x06\x12\x04\xcc\t\x02\x1c\n\r\n\x05\
    \x04#\x02\x05\x01\x12\x04\xcc\t\x1d4\n\r\n\x05\x04#\x02\x05\x03\x12\x04\
    \xcc\t78\n\x7f\n\x04\x04#\x02\x06\x12\x04\xd0\t\x02=\x1aq\x20Makes\x20th\
    e\x20operation\x20conditional\x20on\x20whether\x20the\x20object's\x20cur\
    rent\n\x20metageneration\x20does\x20not\x20match\x20the\x20given\x20valu\
    e.\n\n\x0f\n\x05\x04#\x02\x06\x04\x12\x06\xd0\t\x02\xcc\t9\n\r\n\x05\x04\
    #\x02\x06\x06\x12\x04\xd0\t\x02\x1c\n\r\n\x05\x04#\x02\x06\x01\x12\x04\
    \xd0\t\x1d8\n\r\n\x05\x04#\x02\x06\x03\x12\x04\xd0\t;<\nB\n\x04\x04#\x02\
    \x07\x12\x04\xd3\t\x02(\x1a4\x20Set\x20of\x20properties\x20to\x20return.\
    \x20Defaults\x20to\x20`NO_ACL`.\n\n\x0f\n\x05\x04#\x02\x07\x04\x12\x06\
    \xd3\t\x02\xd0\t=\n\r\n\x05\x04#\x02\x07\x06\x12\x04\xd3\t\x02\x18\n\r\n\
    \x05\x04#\x02\x07\x01\x12\x04\xd3\t\x19#\n\r\n\x05\x04#\x02\x07\x03\x12\
    \x04\xd3\t&'\nX\n\x04\x04#\x02\x08\x12\x04\xd6\t\x02>\x1aJ\x20A\x20set\
    \x20of\x20parameters\x20common\x20to\x20Storage\x20API\x20requests\x20co\
    ncerning\x20an\x20object.\n\n\x0f\n\x05\x04#\x02\x08\x04\x12\x06\xd6\t\
    \x02\xd3\t(\n\r\n\x05\x04#\x02\x08\x06\x12\x04\xd6\t\x02\x1b\n\r\n\x05\
    \x04#\x02\x08\x01\x12\x04\xd6\t\x1c8\n\r\n\x05\x04#\x02\x08\x03\x12\x04\
    \xd6\t;=\nG\n\x04\x04#\x02\t\x12\x04\xd9\t\x021\x1a9\x20A\x20set\x20of\
    \x20parameters\x20common\x20to\x20all\x20Storage\x20API\x20requests.\n\n\
    \x0f\n\x05\x04#\x02\t\x04\x12\x06\xd9\t\x02\xd6\t>\n\r\n\x05\x04#\x02\t\
    \x06\x12\x04\xd9\t\x02\x15\n\r\n\x05\x04#\x02\t\x01\x12\x04\xd9\t\x16+\n\
    \r\n\x05\x04#\x02\t\x03\x12\x04\xd9\t.0\n/\n\x02\x04$\x12\x06\xdd\t\0\
    \xf1\t\x01\x1a!\x20Response\x20message\x20for\x20GetObject.\n\n\x0b\n\
    \x03\x04$\x01\x12\x04\xdd\t\x08\x1e\n\x83\x02\n\x04\x04$\x02\0\x12\x04\
    \xe2\t\x02'\x1a\xf4\x01\x20A\x20portion\x20of\x20the\x20data\x20for\x20t\
    he\x20object.\x20The\x20service\x20**may**\x20leave\x20`data`\n\x20empty\
    \x20for\x20any\x20given\x20`ReadResponse`.\x20This\x20enables\x20the\x20\
    service\x20to\x20inform\x20the\n\x20client\x20that\x20the\x20request\x20\
    is\x20still\x20live\x20while\x20it\x20is\x20running\x20an\x20operation\
    \x20to\n\x20generate\x20more\x20data.\n\n\x0f\n\x05\x04$\x02\0\x04\x12\
    \x06\xe2\t\x02\xdd\t\x20\n\r\n\x05\x04$\x02\0\x06\x12\x04\xe2\t\x02\x11\
    \n\r\n\x05\x04$\x02\0\x01\x12\x04\xe2\t\x12\"\n\r\n\x05\x04$\x02\0\x03\
    \x12\x04\xe2\t%&\n\xb4\x01\n\x04\x04$\x02\x01\x12\x04\xe7\t\x02'\x1a\xa5\
    \x01\x20The\x20checksums\x20of\x20the\x20complete\x20object.\x20The\x20c\
    lient\x20should\x20compute\x20one\x20of\n\x20these\x20checksums\x20over\
    \x20the\x20downloaded\x20object\x20and\x20compare\x20it\x20against\x20th\
    e\x20value\n\x20provided\x20here.\n\n\x0f\n\x05\x04$\x02\x01\x04\x12\x06\
    \xe7\t\x02\xe2\t'\n\r\n\x05\x04$\x02\x01\x06\x12\x04\xe7\t\x02\x11\n\r\n\
    \x05\x04$\x02\x01\x01\x12\x04\xe7\t\x12\"\n\r\n\x05\x04$\x02\x01\x03\x12\
    \x04\xe7\t%&\n\xbe\x01\n\x04\x04$\x02\x02\x12\x04\xec\t\x02!\x1a\xaf\x01\
    \x20If\x20read_offset\x20and\x20or\x20read_limit\x20was\x20specified\x20\
    on\x20the\n\x20GetObjectMediaRequest,\x20ContentRange\x20will\x20be\x20p\
    opulated\x20on\x20the\x20first\n\x20GetObjectMediaResponse\x20message\
    \x20of\x20the\x20read\x20stream.\n\n\x0f\n\x05\x04$\x02\x02\x04\x12\x06\
    \xec\t\x02\xe7\t'\n\r\n\x05\x04$\x02\x02\x06\x12\x04\xec\t\x02\x0e\n\r\n\
    \x05\x04$\x02\x02\x01\x12\x04\xec\t\x0f\x1c\n\r\n\x05\x04$\x02\x02\x03\
    \x12\x04\xec\t\x1f\x20\nz\n\x04\x04$\x02\x03\x12\x04\xf0\t\x02\x16\x1al\
    \x20Metadata\x20of\x20the\x20object\x20whose\x20media\x20is\x20being\x20\
    returned.\n\x20Only\x20populated\x20in\x20the\x20first\x20response\x20in\
    \x20the\x20stream.\n\n\x0f\n\x05\x04$\x02\x03\x04\x12\x06\xf0\t\x02\xec\
    \t!\n\r\n\x05\x04$\x02\x03\x06\x12\x04\xf0\t\x02\x08\n\r\n\x05\x04$\x02\
    \x03\x01\x12\x04\xf0\t\t\x11\n\r\n\x05\x04$\x02\x03\x03\x12\x04\xf0\t\
    \x14\x15\nZ\n\x02\x04%\x12\x06\xf4\t\0\x92\n\x01\x1aL\x20Describes\x20an\
    \x20attempt\x20to\x20insert\x20an\x20object,\x20possibly\x20over\x20mult\
    iple\x20requests.\n\n\x0b\n\x03\x04%\x01\x12\x04\xf4\t\x08\x18\nH\n\x04\
    \x04%\x02\0\x12\x04\xf6\t\x02\x16\x1a:\x20Destination\x20object,\x20incl\
    uding\x20its\x20name\x20and\x20its\x20metadata.\n\n\x0f\n\x05\x04%\x02\0\
    \x04\x12\x06\xf6\t\x02\xf4\t\x1a\n\r\n\x05\x04%\x02\0\x06\x12\x04\xf6\t\
    \x02\x08\n\r\n\x05\x04%\x02\0\x01\x12\x04\xf6\t\t\x11\n\r\n\x05\x04%\x02\
    \0\x03\x12\x04\xf6\t\x14\x15\nI\n\x04\x04%\x02\x01\x12\x04\xf9\t\x025\
    \x1a;\x20Apply\x20a\x20predefined\x20set\x20of\x20access\x20controls\x20\
    to\x20this\x20object.\n\n\x0f\n\x05\x04%\x02\x01\x04\x12\x06\xf9\t\x02\
    \xf6\t\x16\n\r\n\x05\x04%\x02\x01\x06\x12\x04\xf9\t\x02!\n\r\n\x05\x04%\
    \x02\x01\x01\x12\x04\xf9\t\"0\n\r\n\x05\x04%\x02\x01\x03\x12\x04\xf9\t34\
    \n\xd1\x01\n\x04\x04%\x02\x02\x12\x04\xfe\t\x025\x1a\xc2\x01\x20Makes\
    \x20the\x20operation\x20conditional\x20on\x20whether\x20the\x20object's\
    \x20current\n\x20generation\x20matches\x20the\x20given\x20value.\x20Sett\
    ing\x20to\x200\x20makes\x20the\x20operation\n\x20succeed\x20only\x20if\
    \x20there\x20are\x20no\x20live\x20versions\x20of\x20the\x20object.\n\n\
    \x0f\n\x05\x04%\x02\x02\x04\x12\x06\xfe\t\x02\xf9\t5\n\r\n\x05\x04%\x02\
    \x02\x06\x12\x04\xfe\t\x02\x1c\n\r\n\x05\x04%\x02\x02\x01\x12\x04\xfe\t\
    \x1d0\n\r\n\x05\x04%\x02\x02\x03\x12\x04\xfe\t34\n\x88\x02\n\x04\x04%\
    \x02\x03\x12\x04\x84\n\x029\x1a\xf9\x01\x20Makes\x20the\x20operation\x20\
    conditional\x20on\x20whether\x20the\x20object's\x20current\n\x20generati\
    on\x20does\x20not\x20match\x20the\x20given\x20value.\x20If\x20no\x20live\
    \x20object\x20exists,\x20the\n\x20precondition\x20fails.\x20Setting\x20t\
    o\x200\x20makes\x20the\x20operation\x20succeed\x20only\x20if\n\x20there\
    \x20is\x20a\x20live\x20version\x20of\x20the\x20object.\n\n\x0f\n\x05\x04\
    %\x02\x03\x04\x12\x06\x84\n\x02\xfe\t5\n\r\n\x05\x04%\x02\x03\x06\x12\
    \x04\x84\n\x02\x1c\n\r\n\x05\x04%\x02\x03\x01\x12\x04\x84\n\x1d4\n\r\n\
    \x05\x04%\x02\x03\x03\x12\x04\x84\n78\nx\n\x04\x04%\x02\x04\x12\x04\x88\
    \n\x029\x1aj\x20Makes\x20the\x20operation\x20conditional\x20on\x20whethe\
    r\x20the\x20object's\x20current\n\x20metageneration\x20matches\x20the\
    \x20given\x20value.\n\n\x0f\n\x05\x04%\x02\x04\x04\x12\x06\x88\n\x02\x84\
    \n9\n\r\n\x05\x04%\x02\x04\x06\x12\x04\x88\n\x02\x1c\n\r\n\x05\x04%\x02\
    \x04\x01\x12\x04\x88\n\x1d4\n\r\n\x05\x04%\x02\x04\x03\x12\x04\x88\n78\n\
    \x7f\n\x04\x04%\x02\x05\x12\x04\x8c\n\x02=\x1aq\x20Makes\x20the\x20opera\
    tion\x20conditional\x20on\x20whether\x20the\x20object's\x20current\n\x20\
    metageneration\x20does\x20not\x20match\x20the\x20given\x20value.\n\n\x0f\
    \n\x05\x04%\x02\x05\x04\x12\x06\x8c\n\x02\x88\n9\n\r\n\x05\x04%\x02\x05\
    \x06\x12\x04\x8c\n\x02\x1c\n\r\n\x05\x04%\x02\x05\x01\x12\x04\x8c\n\x1d8\
    \n\r\n\x05\x04%\x02\x05\x03\x12\x04\x8c\n;<\n\x9a\x01\n\x04\x04%\x02\x06\
    \x12\x04\x91\n\x02(\x1a\x8b\x01\x20Set\x20of\x20properties\x20to\x20retu\
    rn.\x20Defaults\x20to\x20`NO_ACL`,\x20unless\x20the\n\x20object\x20resou\
    rce\x20specifies\x20the\x20`acl`\x20property,\x20when\x20it\x20defaults\
    \n\x20to\x20`full`.\n\n\x0f\n\x05\x04%\x02\x06\x04\x12\x06\x91\n\x02\x8c\
    \n=\n\r\n\x05\x04%\x02\x06\x06\x12\x04\x91\n\x02\x18\n\r\n\x05\x04%\x02\
    \x06\x01\x12\x04\x91\n\x19#\n\r\n\x05\x04%\x02\x06\x03\x12\x04\x91\n&'\n\
    .\n\x02\x04&\x12\x06\x95\n\0\xd8\n\x01\x1a\x20\x20Message\x20for\x20writ\
    ing\x20an\x20object.\n\n\x0b\n\x03\x04&\x01\x12\x04\x95\n\x08\x1b\nS\n\
    \x04\x04&\x08\0\x12\x06\x97\n\x02\x9f\n\x03\x1aC\x20The\x20first\x20mess\
    age\x20of\x20each\x20stream\x20should\x20set\x20one\x20of\x20the\x20foll\
    owing.\n\n\r\n\x05\x04&\x08\0\x01\x12\x04\x97\n\x08\x15\n}\n\x04\x04&\
    \x02\0\x12\x04\x9a\n\x04\x19\x1ao\x20For\x20resumable\x20uploads.\x20Thi\
    s\x20should\x20be\x20the\x20`upload_id`\x20returned\x20from\x20a\n\x20ca\
    ll\x20to\x20`StartResumableWriteResponse`.\n\n\r\n\x05\x04&\x02\0\x05\
    \x12\x04\x9a\n\x04\n\n\r\n\x05\x04&\x02\0\x01\x12\x04\x9a\n\x0b\x14\n\r\
    \n\x05\x04&\x02\0\x03\x12\x04\x9a\n\x17\x18\n\x90\x01\n\x04\x04&\x02\x01\
    \x12\x04\x9e\n\x04,\x1a\x81\x01\x20For\x20non-resumable\x20uploads.\x20D\
    escribes\x20the\x20overall\x20upload,\x20including\x20the\n\x20destinati\
    on\x20bucket\x20and\x20object\x20name,\x20preconditions,\x20etc.\n\n\r\n\
    \x05\x04&\x02\x01\x06\x12\x04\x9e\n\x04\x14\n\r\n\x05\x04&\x02\x01\x01\
    \x12\x04\x9e\n\x15'\n\r\n\x05\x04&\x02\x01\x03\x12\x04\x9e\n*+\n\xce\x04\
    \n\x04\x04&\x02\x02\x12\x04\xae\n\x02B\x1a\xbf\x04\x20Required.\x20The\
    \x20offset\x20from\x20the\x20beginning\x20of\x20the\x20object\x20at\x20w\
    hich\x20the\x20data\x20should\x20be\n\x20written.\n\n\x20In\x20the\x20fi\
    rst\x20`InsertObjectRequest`\x20of\x20a\x20`InsertObject()`\x20action,\
    \x20it\n\x20indicates\x20the\x20initial\x20offset\x20for\x20the\x20`Inse\
    rt()`\x20call.\x20The\x20value\x20**must**\x20be\n\x20equal\x20to\x20the\
    \x20`committed_size`\x20that\x20a\x20call\x20to\x20`QueryWriteStatus()`\
    \x20would\n\x20return\x20(0\x20if\x20this\x20is\x20the\x20first\x20write\
    \x20to\x20the\x20object).\n\n\x20On\x20subsequent\x20calls,\x20this\x20v\
    alue\x20**must**\x20be\x20no\x20larger\x20than\x20the\x20sum\x20of\x20th\
    e\n\x20first\x20`write_offset`\x20and\x20the\x20sizes\x20of\x20all\x20`d\
    ata`\x20chunks\x20sent\x20previously\x20on\n\x20this\x20stream.\n\n\x20A\
    n\x20incorrect\x20value\x20will\x20cause\x20an\x20error.\n\n\x0f\n\x05\
    \x04&\x02\x02\x04\x12\x06\xae\n\x02\x9f\n\x03\n\r\n\x05\x04&\x02\x02\x05\
    \x12\x04\xae\n\x02\x07\n\r\n\x05\x04&\x02\x02\x01\x12\x04\xae\n\x08\x14\
    \n\r\n\x05\x04&\x02\x02\x03\x12\x04\xae\n\x17\x18\n\r\n\x05\x04&\x02\x02\
    \x08\x12\x04\xae\n\x19A\n\x10\n\x08\x04&\x02\x02\x08\x9c\x08\0\x12\x04\
    \xae\n\x1a@\n7\n\x04\x04&\x08\x01\x12\x06\xb1\n\x02\xc3\n\x03\x1a'\x20A\
    \x20portion\x20of\x20the\x20data\x20for\x20the\x20object.\n\n\r\n\x05\
    \x04&\x08\x01\x01\x12\x04\xb1\n\x08\x0c\n\x96\x01\n\x04\x04&\x02\x03\x12\
    \x04\xb4\n\x04)\x1a\x87\x01\x20The\x20data\x20to\x20insert.\x20If\x20a\
    \x20crc32c\x20checksum\x20is\x20provided\x20that\x20doesn't\x20match\n\
    \x20the\x20checksum\x20computed\x20by\x20the\x20service,\x20the\x20reque\
    st\x20will\x20fail.\n\n\r\n\x05\x04&\x02\x03\x06\x12\x04\xb4\n\x04\x13\n\
    \r\n\x05\x04&\x02\x03\x01\x12\x04\xb4\n\x14$\n\r\n\x05\x04&\x02\x03\x03\
    \x12\x04\xb4\n'(\n\xdc\x05\n\x04\x04&\x02\x04\x12\x04\xc2\n\x04(\x1a\xcd\
    \x05\x20A\x20reference\x20to\x20an\x20existing\x20object.\x20This\x20can\
    \x20be\x20used\x20to\x20support\n\x20several\x20use\x20cases:\n\x20\x20\
    \x20-\x20Writing\x20a\x20sequence\x20of\x20data\x20buffers\x20supports\
    \x20the\x20basic\x20use\x20case\x20of\n\x20\x20\x20\x20\x20uploading\x20\
    a\x20complete\x20object,\x20chunk\x20by\x20chunk.\n\x20\x20\x20-\x20Writ\
    ing\x20a\x20sequence\x20of\x20references\x20to\x20existing\x20objects\
    \x20allows\x20an\n\x20\x20\x20\x20\x20object\x20to\x20be\x20composed\x20\
    from\x20a\x20collection\x20of\x20objects,\x20which\x20can\x20be\n\x20\
    \x20\x20\x20\x20used\x20to\x20support\x20parallel\x20object\x20writes.\n\
    \x20\x20\x20-\x20Writing\x20a\x20single\x20reference\x20with\x20a\x20giv\
    en\x20offset\x20and\x20size\x20can\x20be\x20used\n\x20\x20\x20\x20\x20to\
    \x20create\x20an\x20object\x20from\x20a\x20slice\x20of\x20an\x20existing\
    \x20object.\n\x20\x20\x20-\x20Writing\x20an\x20object\x20referencing\x20\
    a\x20object\x20slice\x20(created\x20as\x20noted\n\x20\x20\x20\x20\x20abo\
    ve)\x20followed\x20by\x20a\x20data\x20buffer\x20followed\x20by\x20anothe\
    r\x20object\n\x20\x20\x20\x20\x20slice\x20can\x20be\x20used\x20to\x20sup\
    port\x20delta\x20upload\x20functionality.\n\n\r\n\x05\x04&\x02\x04\x06\
    \x12\x04\xc2\n\x04\x19\n\r\n\x05\x04&\x02\x04\x01\x12\x04\xc2\n\x1a#\n\r\
    \n\x05\x04&\x02\x04\x03\x12\x04\xc2\n&'\n\xfd\x01\n\x04\x04&\x02\x05\x12\
    \x04\xc9\n\x02'\x1a\xee\x01\x20Checksums\x20for\x20the\x20complete\x20ob\
    ject.\x20If\x20the\x20checksums\x20computed\x20by\x20the\x20service\n\
    \x20don't\x20match\x20the\x20specifified\x20checksums\x20the\x20call\x20\
    will\x20fail.\x20May\x20only\x20be\n\x20provided\x20in\x20the\x20first\
    \x20or\x20last\x20request\x20(either\x20with\x20first_message,\x20or\n\
    \x20finish_write\x20set).\n\n\x0f\n\x05\x04&\x02\x05\x04\x12\x06\xc9\n\
    \x02\xc3\n\x03\n\r\n\x05\x04&\x02\x05\x06\x12\x04\xc9\n\x02\x11\n\r\n\
    \x05\x04&\x02\x05\x01\x12\x04\xc9\n\x12\"\n\r\n\x05\x04&\x02\x05\x03\x12\
    \x04\xc9\n%&\n\xd2\x02\n\x04\x04&\x02\x06\x12\x04\xd1\n\x02\x18\x1a\xc3\
    \x02\x20If\x20`true`,\x20this\x20indicates\x20that\x20the\x20write\x20is\
    \x20complete.\x20Sending\x20any\n\x20`InsertObjectRequest`s\x20subsequen\
    t\x20to\x20one\x20in\x20which\x20`finish_write`\x20is\x20`true`\n\x20wil\
    l\x20cause\x20an\x20error.\n\x20For\x20a\x20non-resumable\x20write\x20(w\
    here\x20the\x20upload_id\x20was\x20not\x20set\x20in\x20the\x20first\n\
    \x20message),\x20it\x20is\x20an\x20error\x20not\x20to\x20set\x20this\x20\
    field\x20in\x20the\x20final\x20message\x20of\x20the\n\x20stream.\n\n\x0f\
    \n\x05\x04&\x02\x06\x04\x12\x06\xd1\n\x02\xc9\n'\n\r\n\x05\x04&\x02\x06\
    \x05\x12\x04\xd1\n\x02\x06\n\r\n\x05\x04&\x02\x06\x01\x12\x04\xd1\n\x07\
    \x13\n\r\n\x05\x04&\x02\x06\x03\x12\x04\xd1\n\x16\x17\nX\n\x04\x04&\x02\
    \x07\x12\x04\xd4\n\x02=\x1aJ\x20A\x20set\x20of\x20parameters\x20common\
    \x20to\x20Storage\x20API\x20requests\x20concerning\x20an\x20object.\n\n\
    \x0f\n\x05\x04&\x02\x07\x04\x12\x06\xd4\n\x02\xd1\n\x18\n\r\n\x05\x04&\
    \x02\x07\x06\x12\x04\xd4\n\x02\x1b\n\r\n\x05\x04&\x02\x07\x01\x12\x04\
    \xd4\n\x1c8\n\r\n\x05\x04&\x02\x07\x03\x12\x04\xd4\n;<\nG\n\x04\x04&\x02\
    \x08\x12\x04\xd7\n\x020\x1a9\x20A\x20set\x20of\x20parameters\x20common\
    \x20to\x20all\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04&\x02\x08\
    \x04\x12\x06\xd7\n\x02\xd4\n=\n\r\n\x05\x04&\x02\x08\x06\x12\x04\xd7\n\
    \x02\x15\n\r\n\x05\x04&\x02\x08\x01\x12\x04\xd7\n\x16+\n\r\n\x05\x04&\
    \x02\x08\x03\x12\x04\xd7\n./\n0\n\x02\x04'\x12\x06\xdb\n\0\x84\x0b\x01\
    \x1a\"\x20Request\x20message\x20for\x20ListObjects.\n\n\x0b\n\x03\x04'\
    \x01\x12\x04\xdb\n\x08\x1a\nJ\n\x04\x04'\x02\0\x12\x04\xdd\n\x02=\x1a<\
    \x20Required.\x20Name\x20of\x20the\x20bucket\x20in\x20which\x20to\x20loo\
    k\x20for\x20objects.\n\n\x0f\n\x05\x04'\x02\0\x04\x12\x06\xdd\n\x02\xdb\
    \n\x1c\n\r\n\x05\x04'\x02\0\x05\x12\x04\xdd\n\x02\x08\n\r\n\x05\x04'\x02\
    \0\x01\x12\x04\xdd\n\t\x0f\n\r\n\x05\x04'\x02\0\x03\x12\x04\xdd\n\x12\
    \x13\n\r\n\x05\x04'\x02\0\x08\x12\x04\xdd\n\x14<\n\x10\n\x08\x04'\x02\0\
    \x08\x9c\x08\0\x12\x04\xdd\n\x15;\n\xd6\x02\n\x04\x04'\x02\x01\x12\x04\
    \xe5\n\x02\x17\x1a\xc7\x02\x20Returns\x20results\x20in\x20a\x20directory\
    -like\x20mode.\x20`items`\x20will\x20contain\n\x20only\x20objects\x20who\
    se\x20names,\x20aside\x20from\x20the\x20`prefix`,\x20do\x20not\n\x20cont\
    ain\x20`delimiter`.\x20Objects\x20whose\x20names,\x20aside\x20from\x20th\
    e\n\x20`prefix`,\x20contain\x20`delimiter`\x20will\x20have\x20their\x20n\
    ame,\n\x20truncated\x20after\x20the\x20`delimiter`,\x20returned\x20in\n\
    \x20`prefixes`.\x20Duplicate\x20`prefixes`\x20are\x20omitted.\n\n\x0f\n\
    \x05\x04'\x02\x01\x04\x12\x06\xe5\n\x02\xdd\n=\n\r\n\x05\x04'\x02\x01\
    \x05\x12\x04\xe5\n\x02\x08\n\r\n\x05\x04'\x02\x01\x01\x12\x04\xe5\n\t\
    \x12\n\r\n\x05\x04'\x02\x01\x03\x12\x04\xe5\n\x15\x16\n\x9b\x01\n\x04\
    \x04'\x02\x02\x12\x04\xea\n\x02&\x1a\x8c\x01\x20If\x20true,\x20objects\
    \x20that\x20end\x20in\x20exactly\x20one\x20instance\x20of\x20`delimiter`\
    \n\x20will\x20have\x20their\x20metadata\x20included\x20in\x20`items`\x20\
    in\x20addition\x20to\n\x20`prefixes`.\n\n\x0f\n\x05\x04'\x02\x02\x04\x12\
    \x06\xea\n\x02\xe5\n\x17\n\r\n\x05\x04'\x02\x02\x05\x12\x04\xea\n\x02\
    \x06\n\r\n\x05\x04'\x02\x02\x01\x12\x04\xea\n\x07!\n\r\n\x05\x04'\x02\
    \x02\x03\x12\x04\xea\n$%\n\x89\x02\n\x04\x04'\x02\x03\x12\x04\xf0\n\x02\
    \x18\x1a\xfa\x01\x20Maximum\x20number\x20of\x20`items`\x20plus\x20`prefi\
    xes`\x20to\x20return\n\x20in\x20a\x20single\x20page\x20of\x20responses.\
    \x20As\x20duplicate\x20`prefixes`\x20are\n\x20omitted,\x20fewer\x20total\
    \x20results\x20may\x20be\x20returned\x20than\x20requested.\x20The\x20ser\
    vice\n\x20will\x20use\x20this\x20parameter\x20or\x201,000\x20items,\x20w\
    hichever\x20is\x20smaller.\n\n\x0f\n\x05\x04'\x02\x03\x04\x12\x06\xf0\n\
    \x02\xea\n&\n\r\n\x05\x04'\x02\x03\x05\x12\x04\xf0\n\x02\x07\n\r\n\x05\
    \x04'\x02\x03\x01\x12\x04\xf0\n\x08\x13\n\r\n\x05\x04'\x02\x03\x03\x12\
    \x04\xf0\n\x16\x17\ni\n\x04\x04'\x02\x04\x12\x04\xf4\n\x02\x18\x1a[\x20A\
    \x20previously-returned\x20page\x20token\x20representing\x20part\x20of\
    \x20the\x20larger\x20set\x20of\n\x20results\x20to\x20view.\n\n\x0f\n\x05\
    \x04'\x02\x04\x04\x12\x06\xf4\n\x02\xf0\n\x18\n\r\n\x05\x04'\x02\x04\x05\
    \x12\x04\xf4\n\x02\x08\n\r\n\x05\x04'\x02\x04\x01\x12\x04\xf4\n\t\x13\n\
    \r\n\x05\x04'\x02\x04\x03\x12\x04\xf4\n\x16\x17\nM\n\x04\x04'\x02\x05\
    \x12\x04\xf7\n\x02\x14\x1a?\x20Filter\x20results\x20to\x20objects\x20who\
    se\x20names\x20begin\x20with\x20this\x20prefix.\n\n\x0f\n\x05\x04'\x02\
    \x05\x04\x12\x06\xf7\n\x02\xf4\n\x18\n\r\n\x05\x04'\x02\x05\x05\x12\x04\
    \xf7\n\x02\x08\n\r\n\x05\x04'\x02\x05\x01\x12\x04\xf7\n\t\x0f\n\r\n\x05\
    \x04'\x02\x05\x03\x12\x04\xf7\n\x12\x13\nB\n\x04\x04'\x02\x06\x12\x04\
    \xfa\n\x02(\x1a4\x20Set\x20of\x20properties\x20to\x20return.\x20Defaults\
    \x20to\x20`NO_ACL`.\n\n\x0f\n\x05\x04'\x02\x06\x04\x12\x06\xfa\n\x02\xf7\
    \n\x14\n\r\n\x05\x04'\x02\x06\x06\x12\x04\xfa\n\x02\x18\n\r\n\x05\x04'\
    \x02\x06\x01\x12\x04\xfa\n\x19#\n\r\n\x05\x04'\x02\x06\x03\x12\x04\xfa\n\
    &'\n\xd3\x01\n\x04\x04'\x02\x07\x12\x04\x80\x0b\x02\x14\x1a\xc4\x01\x20I\
    f\x20`true`,\x20lists\x20all\x20versions\x20of\x20an\x20object\x20as\x20\
    distinct\x20results.\n\x20The\x20default\x20is\x20`false`.\x20For\x20mor\
    e\x20information,\x20see\n\x20[Object\n\x20Versioning](https://cloud.goo\
    gle.com/storage/docs/object-versioning).\n\n\x0f\n\x05\x04'\x02\x07\x04\
    \x12\x06\x80\x0b\x02\xfa\n(\n\r\n\x05\x04'\x02\x07\x05\x12\x04\x80\x0b\
    \x02\x06\n\r\n\x05\x04'\x02\x07\x01\x12\x04\x80\x0b\x07\x0f\n\r\n\x05\
    \x04'\x02\x07\x03\x12\x04\x80\x0b\x12\x13\nG\n\x04\x04'\x02\x08\x12\x04\
    \x83\x0b\x021\x1a9\x20A\x20set\x20of\x20parameters\x20common\x20to\x20al\
    l\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04'\x02\x08\x04\x12\x06\
    \x83\x0b\x02\x80\x0b\x14\n\r\n\x05\x04'\x02\x08\x06\x12\x04\x83\x0b\x02\
    \x15\n\r\n\x05\x04'\x02\x08\x01\x12\x04\x83\x0b\x16+\n\r\n\x05\x04'\x02\
    \x08\x03\x12\x04\x83\x0b.0\nA\n\x02\x04(\x12\x06\x87\x0b\0\x91\x0b\x01\
    \x1a3\x20Request\x20object\x20for\x20`ByteStream.QueryWriteStatus`.\n\n\
    \x0b\n\x03\x04(\x01\x12\x04\x87\x0b\x08\x1f\nm\n\x04\x04(\x02\0\x12\x04\
    \x8a\x0b\x02@\x1a_\x20Required.\x20The\x20name\x20of\x20the\x20resume\
    \x20token\x20for\x20the\x20object\x20whose\x20write\x20status\x20is\x20b\
    eing\n\x20requested.\n\n\x0f\n\x05\x04(\x02\0\x04\x12\x06\x8a\x0b\x02\
    \x87\x0b!\n\r\n\x05\x04(\x02\0\x05\x12\x04\x8a\x0b\x02\x08\n\r\n\x05\x04\
    (\x02\0\x01\x12\x04\x8a\x0b\t\x12\n\r\n\x05\x04(\x02\0\x03\x12\x04\x8a\
    \x0b\x15\x16\n\r\n\x05\x04(\x02\0\x08\x12\x04\x8a\x0b\x17?\n\x10\n\x08\
    \x04(\x02\0\x08\x9c\x08\0\x12\x04\x8a\x0b\x18>\nX\n\x04\x04(\x02\x01\x12\
    \x04\x8d\x0b\x02=\x1aJ\x20A\x20set\x20of\x20parameters\x20common\x20to\
    \x20Storage\x20API\x20requests\x20concerning\x20an\x20object.\n\n\x0f\n\
    \x05\x04(\x02\x01\x04\x12\x06\x8d\x0b\x02\x8a\x0b@\n\r\n\x05\x04(\x02\
    \x01\x06\x12\x04\x8d\x0b\x02\x1b\n\r\n\x05\x04(\x02\x01\x01\x12\x04\x8d\
    \x0b\x1c8\n\r\n\x05\x04(\x02\x01\x03\x12\x04\x8d\x0b;<\nG\n\x04\x04(\x02\
    \x02\x12\x04\x90\x0b\x020\x1a9\x20A\x20set\x20of\x20parameters\x20common\
    \x20to\x20all\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04(\x02\x02\
    \x04\x12\x06\x90\x0b\x02\x8d\x0b=\n\r\n\x05\x04(\x02\x02\x06\x12\x04\x90\
    \x0b\x02\x15\n\r\n\x05\x04(\x02\x02\x01\x12\x04\x90\x0b\x16+\n\r\n\x05\
    \x04(\x02\x02\x03\x12\x04\x90\x0b./\nB\n\x02\x04)\x12\x06\x94\x0b\0\x9b\
    \x0b\x01\x1a4\x20Response\x20object\x20for\x20`ByteStream.QueryWriteStat\
    us`.\n\n\x0b\n\x03\x04)\x01\x12\x04\x94\x0b\x08\x20\nR\n\x04\x04)\x02\0\
    \x12\x04\x96\x0b\x02\x1b\x1aD\x20The\x20number\x20of\x20bytes\x20that\
    \x20have\x20been\x20processed\x20for\x20the\x20given\x20object.\n\n\x0f\
    \n\x05\x04)\x02\0\x04\x12\x06\x96\x0b\x02\x94\x0b\"\n\r\n\x05\x04)\x02\0\
    \x05\x12\x04\x96\x0b\x02\x07\n\r\n\x05\x04)\x02\0\x01\x12\x04\x96\x0b\
    \x08\x16\n\r\n\x05\x04)\x02\0\x03\x12\x04\x96\x0b\x19\x1a\n\xa6\x01\n\
    \x04\x04)\x02\x01\x12\x04\x9a\x0b\x02\x14\x1a\x97\x01\x20`complete`\x20i\
    s\x20`true`\x20only\x20if\x20the\x20client\x20has\x20sent\x20a\x20`Inser\
    tObjectRequest`\n\x20with\x20`finish_write`\x20set\x20to\x20true,\x20and\
    \x20the\x20server\x20has\x20processed\x20that\x20request.\n\n\x0f\n\x05\
    \x04)\x02\x01\x04\x12\x06\x9a\x0b\x02\x96\x0b\x1b\n\r\n\x05\x04)\x02\x01\
    \x05\x12\x04\x9a\x0b\x02\x06\n\r\n\x05\x04)\x02\x01\x01\x12\x04\x9a\x0b\
    \x07\x0f\n\r\n\x05\x04)\x02\x01\x03\x12\x04\x9a\x0b\x12\x13\n2\n\x02\x04\
    *\x12\x06\x9e\x0b\0\x85\x0c\x01\x1a$\x20Request\x20message\x20for\x20Rew\
    riteObject.\n\n\x0b\n\x03\x04*\x01\x12\x04\x9e\x0b\x08\x1c\n\x91\x01\n\
    \x04\x04*\x02\0\x12\x04\xa1\x0b\x02I\x1a\x82\x01\x20Required.\x20Name\
    \x20of\x20the\x20bucket\x20in\x20which\x20to\x20store\x20the\x20new\x20o\
    bject.\x20Overrides\x20the\x20provided\n\x20object\x20metadata's\x20`buc\
    ket`\x20value,\x20if\x20any.\n\n\x0f\n\x05\x04*\x02\0\x04\x12\x06\xa1\
    \x0b\x02\x9e\x0b\x1e\n\r\n\x05\x04*\x02\0\x05\x12\x04\xa1\x0b\x02\x08\n\
    \r\n\x05\x04*\x02\0\x01\x12\x04\xa1\x0b\t\x1b\n\r\n\x05\x04*\x02\0\x03\
    \x12\x04\xa1\x0b\x1e\x1f\n\r\n\x05\x04*\x02\0\x08\x12\x04\xa1\x0b\x20H\n\
    \x10\n\x08\x04*\x02\0\x08\x9c\x08\0\x12\x04\xa1\x0b!G\n\xa7\x01\n\x04\
    \x04*\x02\x01\x12\x04\xa6\x0b\x02I\x1a\x98\x01\x20Required.\x20Name\x20o\
    f\x20the\x20new\x20object.\n\x20Required\x20when\x20the\x20object\x20met\
    adata\x20is\x20not\x20otherwise\x20provided.\x20Overrides\x20the\n\x20ob\
    ject\x20metadata's\x20`name`\x20value,\x20if\x20any.\n\n\x0f\n\x05\x04*\
    \x02\x01\x04\x12\x06\xa6\x0b\x02\xa1\x0bI\n\r\n\x05\x04*\x02\x01\x05\x12\
    \x04\xa6\x0b\x02\x08\n\r\n\x05\x04*\x02\x01\x01\x12\x04\xa6\x0b\t\x1b\n\
    \r\n\x05\x04*\x02\x01\x03\x12\x04\xa6\x0b\x1e\x1f\n\r\n\x05\x04*\x02\x01\
    \x08\x12\x04\xa6\x0b\x20H\n\x10\n\x08\x04*\x02\x01\x08\x9c\x08\0\x12\x04\
    \xa6\x0b!G\n\xf8\x01\n\x04\x04*\x02\x02\x12\x04\xac\x0b\x02&\x1a\xe9\x01\
    \x20Resource\x20name\x20of\x20the\x20Cloud\x20KMS\x20key,\x20of\x20the\
    \x20form\n\x20`projects/my-project/locations/my-location/keyRings/my-kr/\
    cryptoKeys/my-key`,\n\x20that\x20will\x20be\x20used\x20to\x20encrypt\x20\
    the\x20object.\x20Overrides\x20the\x20object\n\x20metadata's\x20`kms_key\
    _name`\x20value,\x20if\x20any.\n\n\x0f\n\x05\x04*\x02\x02\x04\x12\x06\
    \xac\x0b\x02\xa6\x0bI\n\r\n\x05\x04*\x02\x02\x05\x12\x04\xac\x0b\x02\x08\
    \n\r\n\x05\x04*\x02\x02\x01\x12\x04\xac\x0b\t!\n\r\n\x05\x04*\x02\x02\
    \x03\x12\x04\xac\x0b$%\nT\n\x04\x04*\x02\x03\x12\x04\xaf\x0b\x02A\x1aF\
    \x20Apply\x20a\x20predefined\x20set\x20of\x20access\x20controls\x20to\
    \x20the\x20destination\x20object.\n\n\x0f\n\x05\x04*\x02\x03\x04\x12\x06\
    \xaf\x0b\x02\xac\x0b&\n\r\n\x05\x04*\x02\x03\x06\x12\x04\xaf\x0b\x02!\n\
    \r\n\x05\x04*\x02\x03\x01\x12\x04\xaf\x0b\"<\n\r\n\x05\x04*\x02\x03\x03\
    \x12\x04\xaf\x0b?@\n\xd1\x01\n\x04\x04*\x02\x04\x12\x04\xb4\x0b\x025\x1a\
    \xc2\x01\x20Makes\x20the\x20operation\x20conditional\x20on\x20whether\
    \x20the\x20object's\x20current\x20generation\n\x20matches\x20the\x20give\
    n\x20value.\x20Setting\x20to\x200\x20makes\x20the\x20operation\x20succee\
    d\x20only\x20if\n\x20there\x20are\x20no\x20live\x20versions\x20of\x20the\
    \x20object.\n\n\x0f\n\x05\x04*\x02\x04\x04\x12\x06\xb4\x0b\x02\xaf\x0bA\
    \n\r\n\x05\x04*\x02\x04\x06\x12\x04\xb4\x0b\x02\x1c\n\r\n\x05\x04*\x02\
    \x04\x01\x12\x04\xb4\x0b\x1d0\n\r\n\x05\x04*\x02\x04\x03\x12\x04\xb4\x0b\
    34\n\x88\x02\n\x04\x04*\x02\x05\x12\x04\xba\x0b\x029\x1a\xf9\x01\x20Make\
    s\x20the\x20operation\x20conditional\x20on\x20whether\x20the\x20object's\
    \x20current\x20generation\n\x20does\x20not\x20match\x20the\x20given\x20v\
    alue.\x20If\x20no\x20live\x20object\x20exists,\x20the\x20precondition\n\
    \x20fails.\x20Setting\x20to\x200\x20makes\x20the\x20operation\x20succeed\
    \x20only\x20if\x20there\x20is\x20a\x20live\n\x20version\x20of\x20the\x20\
    object.\n\n\x0f\n\x05\x04*\x02\x05\x04\x12\x06\xba\x0b\x02\xb4\x0b5\n\r\
    \n\x05\x04*\x02\x05\x06\x12\x04\xba\x0b\x02\x1c\n\r\n\x05\x04*\x02\x05\
    \x01\x12\x04\xba\x0b\x1d4\n\r\n\x05\x04*\x02\x05\x03\x12\x04\xba\x0b78\n\
    \x84\x01\n\x04\x04*\x02\x06\x12\x04\xbe\x0b\x029\x1av\x20Makes\x20the\
    \x20operation\x20conditional\x20on\x20whether\x20the\x20destination\x20o\
    bject's\x20current\n\x20metageneration\x20matches\x20the\x20given\x20val\
    ue.\n\n\x0f\n\x05\x04*\x02\x06\x04\x12\x06\xbe\x0b\x02\xba\x0b9\n\r\n\
    \x05\x04*\x02\x06\x06\x12\x04\xbe\x0b\x02\x1c\n\r\n\x05\x04*\x02\x06\x01\
    \x12\x04\xbe\x0b\x1d4\n\r\n\x05\x04*\x02\x06\x03\x12\x04\xbe\x0b78\n\x8b\
    \x01\n\x04\x04*\x02\x07\x12\x04\xc2\x0b\x02=\x1a}\x20Makes\x20the\x20ope\
    ration\x20conditional\x20on\x20whether\x20the\x20destination\x20object's\
    \x20current\n\x20metageneration\x20does\x20not\x20match\x20the\x20given\
    \x20value.\n\n\x0f\n\x05\x04*\x02\x07\x04\x12\x06\xc2\x0b\x02\xbe\x0b9\n\
    \r\n\x05\x04*\x02\x07\x06\x12\x04\xc2\x0b\x02\x1c\n\r\n\x05\x04*\x02\x07\
    \x01\x12\x04\xc2\x0b\x1d8\n\r\n\x05\x04*\x02\x07\x03\x12\x04\xc2\x0b;<\n\
    {\n\x04\x04*\x02\x08\x12\x04\xc6\x0b\x02<\x1am\x20Makes\x20the\x20operat\
    ion\x20conditional\x20on\x20whether\x20the\x20source\x20object's\x20curr\
    ent\n\x20generation\x20matches\x20the\x20given\x20value.\n\n\x0f\n\x05\
    \x04*\x02\x08\x04\x12\x06\xc6\x0b\x02\xc2\x0b=\n\r\n\x05\x04*\x02\x08\
    \x06\x12\x04\xc6\x0b\x02\x1c\n\r\n\x05\x04*\x02\x08\x01\x12\x04\xc6\x0b\
    \x1d7\n\r\n\x05\x04*\x02\x08\x03\x12\x04\xc6\x0b:;\n\x82\x01\n\x04\x04*\
    \x02\t\x12\x04\xca\x0b\x02A\x1at\x20Makes\x20the\x20operation\x20conditi\
    onal\x20on\x20whether\x20the\x20source\x20object's\x20current\n\x20gener\
    ation\x20does\x20not\x20match\x20the\x20given\x20value.\n\n\x0f\n\x05\
    \x04*\x02\t\x04\x12\x06\xca\x0b\x02\xc6\x0b<\n\r\n\x05\x04*\x02\t\x06\
    \x12\x04\xca\x0b\x02\x1c\n\r\n\x05\x04*\x02\t\x01\x12\x04\xca\x0b\x1d;\n\
    \r\n\x05\x04*\x02\t\x03\x12\x04\xca\x0b>@\n\x7f\n\x04\x04*\x02\n\x12\x04\
    \xce\x0b\x02A\x1aq\x20Makes\x20the\x20operation\x20conditional\x20on\x20\
    whether\x20the\x20source\x20object's\x20current\n\x20metageneration\x20m\
    atches\x20the\x20given\x20value.\n\n\x0f\n\x05\x04*\x02\n\x04\x12\x06\
    \xce\x0b\x02\xca\x0bA\n\r\n\x05\x04*\x02\n\x06\x12\x04\xce\x0b\x02\x1c\n\
    \r\n\x05\x04*\x02\n\x01\x12\x04\xce\x0b\x1d;\n\r\n\x05\x04*\x02\n\x03\
    \x12\x04\xce\x0b>@\n\x86\x01\n\x04\x04*\x02\x0b\x12\x04\xd2\x0b\x02E\x1a\
    x\x20Makes\x20the\x20operation\x20conditional\x20on\x20whether\x20the\
    \x20source\x20object's\x20current\n\x20metageneration\x20does\x20not\x20\
    match\x20the\x20given\x20value.\n\n\x0f\n\x05\x04*\x02\x0b\x04\x12\x06\
    \xd2\x0b\x02\xce\x0bA\n\r\n\x05\x04*\x02\x0b\x06\x12\x04\xd2\x0b\x02\x1c\
    \n\r\n\x05\x04*\x02\x0b\x01\x12\x04\xd2\x0b\x1d?\n\r\n\x05\x04*\x02\x0b\
    \x03\x12\x04\xd2\x0bBD\n\xee\x03\n\x04\x04*\x02\x0c\x12\x04\xdc\x0b\x02*\
    \x1a\xdf\x03\x20The\x20maximum\x20number\x20of\x20bytes\x20that\x20will\
    \x20be\x20rewritten\x20per\x20rewrite\x20request.\n\x20Most\x20callers\n\
    \x20shouldn't\x20need\x20to\x20specify\x20this\x20parameter\x20-\x20it\
    \x20is\x20primarily\x20in\x20place\x20to\n\x20support\x20testing.\x20If\
    \x20specified\x20the\x20value\x20must\x20be\x20an\x20integral\x20multipl\
    e\x20of\n\x201\x20MiB\x20(1048576).\x20Also,\x20this\x20only\x20applies\
    \x20to\x20requests\x20where\x20the\x20source\x20and\n\x20destination\x20\
    span\x20locations\x20and/or\x20storage\x20classes.\x20Finally,\x20this\
    \x20value\x20must\n\x20not\x20change\x20across\x20rewrite\x20calls\x20el\
    se\x20you'll\x20get\x20an\x20error\x20that\x20the\n\x20`rewriteToken`\
    \x20is\x20invalid.\n\n\x0f\n\x05\x04*\x02\x0c\x04\x12\x06\xdc\x0b\x02\
    \xd2\x0bE\n\r\n\x05\x04*\x02\x0c\x05\x12\x04\xdc\x0b\x02\x07\n\r\n\x05\
    \x04*\x02\x0c\x01\x12\x04\xdc\x0b\x08$\n\r\n\x05\x04*\x02\x0c\x03\x12\
    \x04\xdc\x0b')\n\x9a\x01\n\x04\x04*\x02\r\x12\x04\xe1\x0b\x02)\x1a\x8b\
    \x01\x20Set\x20of\x20properties\x20to\x20return.\x20Defaults\x20to\x20`N\
    O_ACL`,\x20unless\x20the\n\x20object\x20resource\x20specifies\x20the\x20\
    `acl`\x20property,\x20when\x20it\x20defaults\n\x20to\x20`full`.\n\n\x0f\
    \n\x05\x04*\x02\r\x04\x12\x06\xe1\x0b\x02\xdc\x0b*\n\r\n\x05\x04*\x02\r\
    \x06\x12\x04\xe1\x0b\x02\x18\n\r\n\x05\x04*\x02\r\x01\x12\x04\xe1\x0b\
    \x19#\n\r\n\x05\x04*\x02\r\x03\x12\x04\xe1\x0b&(\n\xc8\x02\n\x04\x04*\
    \x02\x0e\x12\x04\xe8\x0b\x02\x1c\x1a\xb9\x02\x20Include\x20this\x20field\
    \x20(from\x20the\x20previous\x20rewrite\x20response)\x20on\x20each\x20re\
    write\n\x20request\x20after\x20the\x20first\x20one,\x20until\x20the\x20r\
    ewrite\x20response\x20'done'\x20flag\x20is\n\x20true.\x20Calls\x20that\
    \x20provide\x20a\x20rewriteToken\x20can\x20omit\x20all\x20other\x20reque\
    st\x20fields,\n\x20but\x20if\x20included\x20those\x20fields\x20must\x20m\
    atch\x20the\x20values\x20provided\x20in\x20the\x20first\n\x20rewrite\x20\
    request.\n\n\x0f\n\x05\x04*\x02\x0e\x04\x12\x06\xe8\x0b\x02\xe1\x0b)\n\r\
    \n\x05\x04*\x02\x0e\x05\x12\x04\xe8\x0b\x02\x08\n\r\n\x05\x04*\x02\x0e\
    \x01\x12\x04\xe8\x0b\t\x16\n\r\n\x05\x04*\x02\x0e\x03\x12\x04\xe8\x0b\
    \x19\x1b\nP\n\x04\x04*\x02\x0f\x12\x04\xeb\x0b\x02E\x1aB\x20Required.\
    \x20Name\x20of\x20the\x20bucket\x20in\x20which\x20to\x20find\x20the\x20s\
    ource\x20object.\n\n\x0f\n\x05\x04*\x02\x0f\x04\x12\x06\xeb\x0b\x02\xe8\
    \x0b\x1c\n\r\n\x05\x04*\x02\x0f\x05\x12\x04\xeb\x0b\x02\x08\n\r\n\x05\
    \x04*\x02\x0f\x01\x12\x04\xeb\x0b\t\x16\n\r\n\x05\x04*\x02\x0f\x03\x12\
    \x04\xeb\x0b\x19\x1b\n\r\n\x05\x04*\x02\x0f\x08\x12\x04\xeb\x0b\x1cD\n\
    \x10\n\x08\x04*\x02\x0f\x08\x9c\x08\0\x12\x04\xeb\x0b\x1dC\n4\n\x04\x04*\
    \x02\x10\x12\x04\xee\x0b\x02E\x1a&\x20Required.\x20Name\x20of\x20the\x20\
    source\x20object.\n\n\x0f\n\x05\x04*\x02\x10\x04\x12\x06\xee\x0b\x02\xeb\
    \x0bE\n\r\n\x05\x04*\x02\x10\x05\x12\x04\xee\x0b\x02\x08\n\r\n\x05\x04*\
    \x02\x10\x01\x12\x04\xee\x0b\t\x16\n\r\n\x05\x04*\x02\x10\x03\x12\x04\
    \xee\x0b\x19\x1b\n\r\n\x05\x04*\x02\x10\x08\x12\x04\xee\x0b\x1cD\n\x10\n\
    \x08\x04*\x02\x10\x08\x9c\x08\0\x12\x04\xee\x0b\x1dC\n~\n\x04\x04*\x02\
    \x11\x12\x04\xf2\x0b\x02\x1f\x1ap\x20If\x20present,\x20selects\x20a\x20s\
    pecific\x20revision\x20of\x20the\x20source\x20object\x20(as\x20opposed\
    \x20to\n\x20the\x20latest\x20version,\x20the\x20default).\n\n\x0f\n\x05\
    \x04*\x02\x11\x04\x12\x06\xf2\x0b\x02\xee\x0bE\n\r\n\x05\x04*\x02\x11\
    \x05\x12\x04\xf2\x0b\x02\x07\n\r\n\x05\x04*\x02\x11\x01\x12\x04\xf2\x0b\
    \x08\x19\n\r\n\x05\x04*\x02\x11\x03\x12\x04\xf2\x0b\x1c\x1e\nC\n\x04\x04\
    *\x02\x12\x12\x04\xf5\x0b\x02\x15\x1a5\x20Properties\x20of\x20the\x20des\
    tination,\x20post-rewrite\x20object.\n\n\x0f\n\x05\x04*\x02\x12\x04\x12\
    \x06\xf5\x0b\x02\xf2\x0b\x1f\n\r\n\x05\x04*\x02\x12\x06\x12\x04\xf5\x0b\
    \x02\x08\n\r\n\x05\x04*\x02\x12\x01\x12\x04\xf5\x0b\t\x0f\n\r\n\x05\x04*\
    \x02\x12\x03\x12\x04\xf5\x0b\x12\x14\nH\n\x04\x04*\x02\x13\x12\x04\xf8\
    \x0b\x02/\x1a:\x20The\x20algorithm\x20used\x20to\x20encrypt\x20the\x20so\
    urce\x20object,\x20if\x20any.\n\n\x0f\n\x05\x04*\x02\x13\x04\x12\x06\xf8\
    \x0b\x02\xf5\x0b\x15\n\r\n\x05\x04*\x02\x13\x05\x12\x04\xf8\x0b\x02\x08\
    \n\r\n\x05\x04*\x02\x13\x01\x12\x04\xf8\x0b\t)\n\r\n\x05\x04*\x02\x13\
    \x03\x12\x04\xf8\x0b,.\nM\n\x04\x04*\x02\x14\x12\x04\xfb\x0b\x02)\x1a?\
    \x20The\x20encryption\x20key\x20used\x20to\x20encrypt\x20the\x20source\
    \x20object,\x20if\x20any.\n\n\x0f\n\x05\x04*\x02\x14\x04\x12\x06\xfb\x0b\
    \x02\xf8\x0b/\n\r\n\x05\x04*\x02\x14\x05\x12\x04\xfb\x0b\x02\x08\n\r\n\
    \x05\x04*\x02\x14\x01\x12\x04\xfb\x0b\t#\n\r\n\x05\x04*\x02\x14\x03\x12\
    \x04\xfb\x0b&(\nV\n\x04\x04*\x02\x15\x12\x04\xfe\x0b\x020\x1aH\x20The\
    \x20SHA-256\x20hash\x20of\x20the\x20key\x20used\x20to\x20encrypt\x20the\
    \x20source\x20object,\x20if\x20any.\n\n\x0f\n\x05\x04*\x02\x15\x04\x12\
    \x06\xfe\x0b\x02\xfb\x0b)\n\r\n\x05\x04*\x02\x15\x05\x12\x04\xfe\x0b\x02\
    \x08\n\r\n\x05\x04*\x02\x15\x01\x12\x04\xfe\x0b\t*\n\r\n\x05\x04*\x02\
    \x15\x03\x12\x04\xfe\x0b-/\nX\n\x04\x04*\x02\x16\x12\x04\x81\x0c\x02>\
    \x1aJ\x20A\x20set\x20of\x20parameters\x20common\x20to\x20Storage\x20API\
    \x20requests\x20concerning\x20an\x20object.\n\n\x0f\n\x05\x04*\x02\x16\
    \x04\x12\x06\x81\x0c\x02\xfe\x0b0\n\r\n\x05\x04*\x02\x16\x06\x12\x04\x81\
    \x0c\x02\x1b\n\r\n\x05\x04*\x02\x16\x01\x12\x04\x81\x0c\x1c8\n\r\n\x05\
    \x04*\x02\x16\x03\x12\x04\x81\x0c;=\nG\n\x04\x04*\x02\x17\x12\x04\x84\
    \x0c\x021\x1a9\x20A\x20set\x20of\x20parameters\x20common\x20to\x20all\
    \x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04*\x02\x17\x04\x12\x06\
    \x84\x0c\x02\x81\x0c>\n\r\n\x05\x04*\x02\x17\x06\x12\x04\x84\x0c\x02\x15\
    \n\r\n\x05\x04*\x02\x17\x01\x12\x04\x84\x0c\x16+\n\r\n\x05\x04*\x02\x17\
    \x03\x12\x04\x84\x0c.0\n#\n\x02\x04+\x12\x06\x88\x0c\0\x9c\x0c\x01\x1a\
    \x15\x20A\x20rewrite\x20response.\n\n\x0b\n\x03\x04+\x01\x12\x04\x88\x0c\
    \x08\x17\n\xa9\x01\n\x04\x04+\x02\0\x12\x04\x8b\x0c\x02\"\x1a\x9a\x01\
    \x20The\x20total\x20bytes\x20written\x20so\x20far,\x20which\x20can\x20be\
    \x20used\x20to\x20provide\x20a\x20waiting\x20user\n\x20with\x20a\x20prog\
    ress\x20indicator.\x20This\x20property\x20is\x20always\x20present\x20in\
    \x20the\x20response.\n\n\x0f\n\x05\x04+\x02\0\x04\x12\x06\x8b\x0c\x02\
    \x88\x0c\x19\n\r\n\x05\x04+\x02\0\x05\x12\x04\x8b\x0c\x02\x07\n\r\n\x05\
    \x04+\x02\0\x01\x12\x04\x8b\x0c\x08\x1d\n\r\n\x05\x04+\x02\0\x03\x12\x04\
    \x8b\x0c\x20!\nu\n\x04\x04+\x02\x01\x12\x04\x8f\x0c\x02\x18\x1ag\x20The\
    \x20total\x20size\x20of\x20the\x20object\x20being\x20copied\x20in\x20byt\
    es.\x20This\x20property\x20is\x20always\n\x20present\x20in\x20the\x20res\
    ponse.\n\n\x0f\n\x05\x04+\x02\x01\x04\x12\x06\x8f\x0c\x02\x8b\x0c\"\n\r\
    \n\x05\x04+\x02\x01\x05\x12\x04\x8f\x0c\x02\x07\n\r\n\x05\x04+\x02\x01\
    \x01\x12\x04\x8f\x0c\x08\x13\n\r\n\x05\x04+\x02\x01\x03\x12\x04\x8f\x0c\
    \x16\x17\n\x91\x01\n\x04\x04+\x02\x02\x12\x04\x93\x0c\x02\x10\x1a\x82\
    \x01\x20`true`\x20if\x20the\x20copy\x20is\x20finished;\x20otherwise,\x20\
    `false`\x20if\n\x20the\x20copy\x20is\x20in\x20progress.\x20This\x20prope\
    rty\x20is\x20always\x20present\x20in\x20the\x20response.\n\n\x0f\n\x05\
    \x04+\x02\x02\x04\x12\x06\x93\x0c\x02\x8f\x0c\x18\n\r\n\x05\x04+\x02\x02\
    \x05\x12\x04\x93\x0c\x02\x06\n\r\n\x05\x04+\x02\x02\x01\x12\x04\x93\x0c\
    \x07\x0b\n\r\n\x05\x04+\x02\x02\x03\x12\x04\x93\x0c\x0e\x0f\n\x9d\x01\n\
    \x04\x04+\x02\x03\x12\x04\x97\x0c\x02\x1b\x1a\x8e\x01\x20A\x20token\x20t\
    o\x20use\x20in\x20subsequent\x20requests\x20to\x20continue\x20copying\
    \x20data.\x20This\x20token\n\x20is\x20present\x20in\x20the\x20response\
    \x20only\x20when\x20there\x20is\x20more\x20data\x20to\x20copy.\n\n\x0f\n\
    \x05\x04+\x02\x03\x04\x12\x06\x97\x0c\x02\x93\x0c\x10\n\r\n\x05\x04+\x02\
    \x03\x05\x12\x04\x97\x0c\x02\x08\n\r\n\x05\x04+\x02\x03\x01\x12\x04\x97\
    \x0c\t\x16\n\r\n\x05\x04+\x02\x03\x03\x12\x04\x97\x0c\x19\x1a\n\x94\x01\
    \n\x04\x04+\x02\x04\x12\x04\x9b\x0c\x02\x16\x1a\x85\x01\x20A\x20resource\
    \x20containing\x20the\x20metadata\x20for\x20the\x20copied-to\x20object.\
    \x20This\x20property\n\x20is\x20present\x20in\x20the\x20response\x20only\
    \x20when\x20copying\x20completes.\n\n\x0f\n\x05\x04+\x02\x04\x04\x12\x06\
    \x9b\x0c\x02\x97\x0c\x1b\n\r\n\x05\x04+\x02\x04\x06\x12\x04\x9b\x0c\x02\
    \x08\n\r\n\x05\x04+\x02\x04\x01\x12\x04\x9b\x0c\t\x11\n\r\n\x05\x04+\x02\
    \x04\x03\x12\x04\x9b\x0c\x14\x15\n4\n\x02\x04,\x12\x06\x9f\x0c\0\xa8\x0c\
    \x01\x1a&\x20Request\x20message\x20StartResumableWrite.\n\n\x0b\n\x03\
    \x04,\x01\x12\x04\x9f\x0c\x08\"\n[\n\x04\x04,\x02\0\x12\x04\xa1\x0c\x02*\
    \x1aM\x20The\x20destination\x20bucket,\x20object,\x20and\x20metadata,\
    \x20as\x20well\x20as\x20any\x20preconditions.\n\n\x0f\n\x05\x04,\x02\0\
    \x04\x12\x06\xa1\x0c\x02\x9f\x0c$\n\r\n\x05\x04,\x02\0\x06\x12\x04\xa1\
    \x0c\x02\x12\n\r\n\x05\x04,\x02\0\x01\x12\x04\xa1\x0c\x13%\n\r\n\x05\x04\
    ,\x02\0\x03\x12\x04\xa1\x0c()\nX\n\x04\x04,\x02\x01\x12\x04\xa4\x0c\x02=\
    \x1aJ\x20A\x20set\x20of\x20parameters\x20common\x20to\x20Storage\x20API\
    \x20requests\x20concerning\x20an\x20object.\n\n\x0f\n\x05\x04,\x02\x01\
    \x04\x12\x06\xa4\x0c\x02\xa1\x0c*\n\r\n\x05\x04,\x02\x01\x06\x12\x04\xa4\
    \x0c\x02\x1b\n\r\n\x05\x04,\x02\x01\x01\x12\x04\xa4\x0c\x1c8\n\r\n\x05\
    \x04,\x02\x01\x03\x12\x04\xa4\x0c;<\nG\n\x04\x04,\x02\x02\x12\x04\xa7\
    \x0c\x020\x1a9\x20A\x20set\x20of\x20parameters\x20common\x20to\x20all\
    \x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04,\x02\x02\x04\x12\x06\
    \xa7\x0c\x02\xa4\x0c=\n\r\n\x05\x04,\x02\x02\x06\x12\x04\xa7\x0c\x02\x15\
    \n\r\n\x05\x04,\x02\x02\x01\x12\x04\xa7\x0c\x16+\n\r\n\x05\x04,\x02\x02\
    \x03\x12\x04\xa7\x0c./\nC\n\x02\x04-\x12\x06\xab\x0c\0\xaf\x0c\x01\x1a5\
    \x20Response\x20object\x20for\x20ByteStream.StartResumableWrite.\n\n\x0b\
    \n\x03\x04-\x01\x12\x04\xab\x0c\x08#\n\x9b\x01\n\x04\x04-\x02\0\x12\x04\
    \xae\x0c\x02\x17\x1a\x8c\x01\x20The\x20upload_id\x20of\x20the\x20newly\
    \x20started\x20resumable\x20write\x20operation.\x20This\n\x20value\x20sh\
    ould\x20be\x20copied\x20into\x20the\x20`InsertObjectRequest.upload_id`\
    \x20field.\n\n\x0f\n\x05\x04-\x02\0\x04\x12\x06\xae\x0c\x02\xab\x0c%\n\r\
    \n\x05\x04-\x02\0\x05\x12\x04\xae\x0c\x02\x08\n\r\n\x05\x04-\x02\0\x01\
    \x12\x04\xae\x0c\t\x12\n\r\n\x05\x04-\x02\0\x03\x12\x04\xae\x0c\x15\x16\
    \n0\n\x02\x04.\x12\x06\xb2\x0c\0\xea\x0c\x01\x1a\"\x20Request\x20message\
    \x20for\x20PatchObject.\n\n\x0b\n\x03\x04.\x01\x12\x04\xb2\x0c\x08\x1a\n\
    I\n\x04\x04.\x02\0\x12\x04\xb4\x0c\x02=\x1a;\x20Required.\x20Name\x20of\
    \x20the\x20bucket\x20in\x20which\x20the\x20object\x20resides.\n\n\x0f\n\
    \x05\x04.\x02\0\x04\x12\x06\xb4\x0c\x02\xb2\x0c\x1c\n\r\n\x05\x04.\x02\0\
    \x05\x12\x04\xb4\x0c\x02\x08\n\r\n\x05\x04.\x02\0\x01\x12\x04\xb4\x0c\t\
    \x0f\n\r\n\x05\x04.\x02\0\x03\x12\x04\xb4\x0c\x12\x13\n\r\n\x05\x04.\x02\
    \0\x08\x12\x04\xb4\x0c\x14<\n\x10\n\x08\x04.\x02\0\x08\x9c\x08\0\x12\x04\
    \xb4\x0c\x15;\n-\n\x04\x04.\x02\x01\x12\x04\xb7\x0c\x02=\x1a\x1f\x20Requ\
    ired.\x20Name\x20of\x20the\x20object.\n\n\x0f\n\x05\x04.\x02\x01\x04\x12\
    \x06\xb7\x0c\x02\xb4\x0c=\n\r\n\x05\x04.\x02\x01\x05\x12\x04\xb7\x0c\x02\
    \x08\n\r\n\x05\x04.\x02\x01\x01\x12\x04\xb7\x0c\t\x0f\n\r\n\x05\x04.\x02\
    \x01\x03\x12\x04\xb7\x0c\x12\x13\n\r\n\x05\x04.\x02\x01\x08\x12\x04\xb7\
    \x0c\x14<\n\x10\n\x08\x04.\x02\x01\x08\x9c\x08\0\x12\x04\xb7\x0c\x15;\nx\
    \n\x04\x04.\x02\x02\x12\x04\xbb\x0c\x02\x17\x1aj\x20If\x20present,\x20se\
    lects\x20a\x20specific\x20revision\x20of\x20this\x20object\x20(as\x20opp\
    osed\x20to\x20the\n\x20latest\x20version,\x20the\x20default).\n\n\x0f\n\
    \x05\x04.\x02\x02\x04\x12\x06\xbb\x0c\x02\xb7\x0c=\n\r\n\x05\x04.\x02\
    \x02\x05\x12\x04\xbb\x0c\x02\x07\n\r\n\x05\x04.\x02\x02\x01\x12\x04\xbb\
    \x0c\x08\x12\n\r\n\x05\x04.\x02\x02\x03\x12\x04\xbb\x0c\x15\x16\n\xd1\
    \x01\n\x04\x04.\x02\x03\x12\x04\xc0\x0c\x025\x1a\xc2\x01\x20Makes\x20the\
    \x20operation\x20conditional\x20on\x20whether\x20the\x20object's\x20curr\
    ent\x20generation\n\x20matches\x20the\x20given\x20value.\x20Setting\x20t\
    o\x200\x20makes\x20the\x20operation\x20succeed\x20only\x20if\n\x20there\
    \x20are\x20no\x20live\x20versions\x20of\x20the\x20object.\n\n\x0f\n\x05\
    \x04.\x02\x03\x04\x12\x06\xc0\x0c\x02\xbb\x0c\x17\n\r\n\x05\x04.\x02\x03\
    \x06\x12\x04\xc0\x0c\x02\x1c\n\r\n\x05\x04.\x02\x03\x01\x12\x04\xc0\x0c\
    \x1d0\n\r\n\x05\x04.\x02\x03\x03\x12\x04\xc0\x0c34\n\x88\x02\n\x04\x04.\
    \x02\x04\x12\x04\xc6\x0c\x029\x1a\xf9\x01\x20Makes\x20the\x20operation\
    \x20conditional\x20on\x20whether\x20the\x20object's\x20current\x20genera\
    tion\n\x20does\x20not\x20match\x20the\x20given\x20value.\x20If\x20no\x20\
    live\x20object\x20exists,\x20the\x20precondition\n\x20fails.\x20Setting\
    \x20to\x200\x20makes\x20the\x20operation\x20succeed\x20only\x20if\x20the\
    re\x20is\x20a\x20live\n\x20version\x20of\x20the\x20object.\n\n\x0f\n\x05\
    \x04.\x02\x04\x04\x12\x06\xc6\x0c\x02\xc0\x0c5\n\r\n\x05\x04.\x02\x04\
    \x06\x12\x04\xc6\x0c\x02\x1c\n\r\n\x05\x04.\x02\x04\x01\x12\x04\xc6\x0c\
    \x1d4\n\r\n\x05\x04.\x02\x04\x03\x12\x04\xc6\x0c78\nx\n\x04\x04.\x02\x05\
    \x12\x04\xca\x0c\x029\x1aj\x20Makes\x20the\x20operation\x20conditional\
    \x20on\x20whether\x20the\x20object's\x20current\n\x20metageneration\x20m\
    atches\x20the\x20given\x20value.\n\n\x0f\n\x05\x04.\x02\x05\x04\x12\x06\
    \xca\x0c\x02\xc6\x0c9\n\r\n\x05\x04.\x02\x05\x06\x12\x04\xca\x0c\x02\x1c\
    \n\r\n\x05\x04.\x02\x05\x01\x12\x04\xca\x0c\x1d4\n\r\n\x05\x04.\x02\x05\
    \x03\x12\x04\xca\x0c78\n\x7f\n\x04\x04.\x02\x06\x12\x04\xce\x0c\x02=\x1a\
    q\x20Makes\x20the\x20operation\x20conditional\x20on\x20whether\x20the\
    \x20object's\x20current\n\x20metageneration\x20does\x20not\x20match\x20t\
    he\x20given\x20value.\n\n\x0f\n\x05\x04.\x02\x06\x04\x12\x06\xce\x0c\x02\
    \xca\x0c9\n\r\n\x05\x04.\x02\x06\x06\x12\x04\xce\x0c\x02\x1c\n\r\n\x05\
    \x04.\x02\x06\x01\x12\x04\xce\x0c\x1d8\n\r\n\x05\x04.\x02\x06\x03\x12\
    \x04\xce\x0c;<\nI\n\x04\x04.\x02\x07\x12\x04\xd1\x0c\x025\x1a;\x20Apply\
    \x20a\x20predefined\x20set\x20of\x20access\x20controls\x20to\x20this\x20\
    object.\n\n\x0f\n\x05\x04.\x02\x07\x04\x12\x06\xd1\x0c\x02\xce\x0c=\n\r\
    \n\x05\x04.\x02\x07\x06\x12\x04\xd1\x0c\x02!\n\r\n\x05\x04.\x02\x07\x01\
    \x12\x04\xd1\x0c\"0\n\r\n\x05\x04.\x02\x07\x03\x12\x04\xd1\x0c34\n@\n\
    \x04\x04.\x02\x08\x12\x04\xd4\x0c\x02(\x1a2\x20Set\x20of\x20properties\
    \x20to\x20return.\x20Defaults\x20to\x20`FULL`.\n\n\x0f\n\x05\x04.\x02\
    \x08\x04\x12\x06\xd4\x0c\x02\xd1\x0c5\n\r\n\x05\x04.\x02\x08\x06\x12\x04\
    \xd4\x0c\x02\x18\n\r\n\x05\x04.\x02\x08\x01\x12\x04\xd4\x0c\x19#\n\r\n\
    \x05\x04.\x02\x08\x03\x12\x04\xd4\x0c&'\n1\n\x04\x04.\x02\t\x12\x04\xd7\
    \x0c\x02\x17\x1a#\x20The\x20Object\x20metadata\x20for\x20updating.\n\n\
    \x0f\n\x05\x04.\x02\t\x04\x12\x06\xd7\x0c\x02\xd4\x0c(\n\r\n\x05\x04.\
    \x02\t\x06\x12\x04\xd7\x0c\x02\x08\n\r\n\x05\x04.\x02\t\x01\x12\x04\xd7\
    \x0c\t\x11\n\r\n\x05\x04.\x02\t\x03\x12\x04\xd7\x0c\x14\x16\n\xbd\x03\n\
    \x04\x04.\x02\n\x12\x04\xe3\x0c\x02-\x1a\xae\x03\x20List\x20of\x20fields\
    \x20to\x20be\x20updated.\n\n\x20To\x20specify\x20ALL\x20fields,\x20equiv\
    alent\x20to\x20the\x20JSON\x20API's\x20\"update\"\x20function,\n\x20spec\
    ify\x20a\x20single\x20field\x20with\x20the\x20value\x20`*`.\x20Note:\x20\
    not\x20recommended.\x20If\x20a\x20new\n\x20field\x20is\x20introduced\x20\
    at\x20a\x20later\x20time,\x20an\x20older\x20client\x20updating\x20with\
    \x20the\x20`*`\n\x20may\x20accidentally\x20reset\x20the\x20new\x20field'\
    s\x20value.\n\n\x20Not\x20specifying\x20any\x20fields\x20is\x20an\x20err\
    or.\n\x20Not\x20specifying\x20a\x20field\x20while\x20setting\x20that\x20\
    field\x20to\x20a\x20non-default\x20value\x20is\n\x20an\x20error.\n\n\x0f\
    \n\x05\x04.\x02\n\x04\x12\x06\xe3\x0c\x02\xd7\x0c\x17\n\r\n\x05\x04.\x02\
    \n\x06\x12\x04\xe3\x0c\x02\x1b\n\r\n\x05\x04.\x02\n\x01\x12\x04\xe3\x0c\
    \x1c'\n\r\n\x05\x04.\x02\n\x03\x12\x04\xe3\x0c*,\nX\n\x04\x04.\x02\x0b\
    \x12\x04\xe6\x0c\x02>\x1aJ\x20A\x20set\x20of\x20parameters\x20common\x20\
    to\x20Storage\x20API\x20requests\x20concerning\x20an\x20object.\n\n\x0f\
    \n\x05\x04.\x02\x0b\x04\x12\x06\xe6\x0c\x02\xe3\x0c-\n\r\n\x05\x04.\x02\
    \x0b\x06\x12\x04\xe6\x0c\x02\x1b\n\r\n\x05\x04.\x02\x0b\x01\x12\x04\xe6\
    \x0c\x1c8\n\r\n\x05\x04.\x02\x0b\x03\x12\x04\xe6\x0c;=\nG\n\x04\x04.\x02\
    \x0c\x12\x04\xe9\x0c\x021\x1a9\x20A\x20set\x20of\x20parameters\x20common\
    \x20to\x20all\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04.\x02\x0c\
    \x04\x12\x06\xe9\x0c\x02\xe6\x0c>\n\r\n\x05\x04.\x02\x0c\x06\x12\x04\xe9\
    \x0c\x02\x15\n\r\n\x05\x04.\x02\x0c\x01\x12\x04\xe9\x0c\x16+\n\r\n\x05\
    \x04.\x02\x0c\x03\x12\x04\xe9\x0c.0\n1\n\x02\x04/\x12\x06\xed\x0c\0\x99\
    \r\x01\x1a#\x20Request\x20message\x20for\x20UpdateObject.\n\n\x0b\n\x03\
    \x04/\x01\x12\x04\xed\x0c\x08\x1b\nI\n\x04\x04/\x02\0\x12\x04\xef\x0c\
    \x02=\x1a;\x20Required.\x20Name\x20of\x20the\x20bucket\x20in\x20which\
    \x20the\x20object\x20resides.\n\n\x0f\n\x05\x04/\x02\0\x04\x12\x06\xef\
    \x0c\x02\xed\x0c\x1d\n\r\n\x05\x04/\x02\0\x05\x12\x04\xef\x0c\x02\x08\n\
    \r\n\x05\x04/\x02\0\x01\x12\x04\xef\x0c\t\x0f\n\r\n\x05\x04/\x02\0\x03\
    \x12\x04\xef\x0c\x12\x13\n\r\n\x05\x04/\x02\0\x08\x12\x04\xef\x0c\x14<\n\
    \x10\n\x08\x04/\x02\0\x08\x9c\x08\0\x12\x04\xef\x0c\x15;\n-\n\x04\x04/\
    \x02\x01\x12\x04\xf2\x0c\x02=\x1a\x1f\x20Required.\x20Name\x20of\x20the\
    \x20object.\n\n\x0f\n\x05\x04/\x02\x01\x04\x12\x06\xf2\x0c\x02\xef\x0c=\
    \n\r\n\x05\x04/\x02\x01\x05\x12\x04\xf2\x0c\x02\x08\n\r\n\x05\x04/\x02\
    \x01\x01\x12\x04\xf2\x0c\t\x0f\n\r\n\x05\x04/\x02\x01\x03\x12\x04\xf2\
    \x0c\x12\x13\n\r\n\x05\x04/\x02\x01\x08\x12\x04\xf2\x0c\x14<\n\x10\n\x08\
    \x04/\x02\x01\x08\x9c\x08\0\x12\x04\xf2\x0c\x15;\nx\n\x04\x04/\x02\x02\
    \x12\x04\xf6\x0c\x02\x17\x1aj\x20If\x20present,\x20selects\x20a\x20speci\
    fic\x20revision\x20of\x20this\x20object\x20(as\x20opposed\x20to\x20the\n\
    \x20latest\x20version,\x20the\x20default).\n\n\x0f\n\x05\x04/\x02\x02\
    \x04\x12\x06\xf6\x0c\x02\xf2\x0c=\n\r\n\x05\x04/\x02\x02\x05\x12\x04\xf6\
    \x0c\x02\x07\n\r\n\x05\x04/\x02\x02\x01\x12\x04\xf6\x0c\x08\x12\n\r\n\
    \x05\x04/\x02\x02\x03\x12\x04\xf6\x0c\x15\x16\n\xd1\x01\n\x04\x04/\x02\
    \x03\x12\x04\xfb\x0c\x025\x1a\xc2\x01\x20Makes\x20the\x20operation\x20co\
    nditional\x20on\x20whether\x20the\x20object's\x20current\x20generation\n\
    \x20matches\x20the\x20given\x20value.\x20Setting\x20to\x200\x20makes\x20\
    the\x20operation\x20succeed\x20only\x20if\n\x20there\x20are\x20no\x20liv\
    e\x20versions\x20of\x20the\x20object.\n\n\x0f\n\x05\x04/\x02\x03\x04\x12\
    \x06\xfb\x0c\x02\xf6\x0c\x17\n\r\n\x05\x04/\x02\x03\x06\x12\x04\xfb\x0c\
    \x02\x1c\n\r\n\x05\x04/\x02\x03\x01\x12\x04\xfb\x0c\x1d0\n\r\n\x05\x04/\
    \x02\x03\x03\x12\x04\xfb\x0c34\n\x88\x02\n\x04\x04/\x02\x04\x12\x04\x81\
    \r\x029\x1a\xf9\x01\x20Makes\x20the\x20operation\x20conditional\x20on\
    \x20whether\x20the\x20object's\x20current\x20generation\n\x20does\x20not\
    \x20match\x20the\x20given\x20value.\x20If\x20no\x20live\x20object\x20exi\
    sts,\x20the\x20precondition\n\x20fails.\x20Setting\x20to\x200\x20makes\
    \x20the\x20operation\x20succeed\x20only\x20if\x20there\x20is\x20a\x20liv\
    e\n\x20version\x20of\x20the\x20object.\n\n\x0f\n\x05\x04/\x02\x04\x04\
    \x12\x06\x81\r\x02\xfb\x0c5\n\r\n\x05\x04/\x02\x04\x06\x12\x04\x81\r\x02\
    \x1c\n\r\n\x05\x04/\x02\x04\x01\x12\x04\x81\r\x1d4\n\r\n\x05\x04/\x02\
    \x04\x03\x12\x04\x81\r78\nx\n\x04\x04/\x02\x05\x12\x04\x85\r\x029\x1aj\
    \x20Makes\x20the\x20operation\x20conditional\x20on\x20whether\x20the\x20\
    object's\x20current\n\x20metageneration\x20matches\x20the\x20given\x20va\
    lue.\n\n\x0f\n\x05\x04/\x02\x05\x04\x12\x06\x85\r\x02\x81\r9\n\r\n\x05\
    \x04/\x02\x05\x06\x12\x04\x85\r\x02\x1c\n\r\n\x05\x04/\x02\x05\x01\x12\
    \x04\x85\r\x1d4\n\r\n\x05\x04/\x02\x05\x03\x12\x04\x85\r78\n\x7f\n\x04\
    \x04/\x02\x06\x12\x04\x89\r\x02=\x1aq\x20Makes\x20the\x20operation\x20co\
    nditional\x20on\x20whether\x20the\x20object's\x20current\n\x20metagenera\
    tion\x20does\x20not\x20match\x20the\x20given\x20value.\n\n\x0f\n\x05\x04\
    /\x02\x06\x04\x12\x06\x89\r\x02\x85\r9\n\r\n\x05\x04/\x02\x06\x06\x12\
    \x04\x89\r\x02\x1c\n\r\n\x05\x04/\x02\x06\x01\x12\x04\x89\r\x1d8\n\r\n\
    \x05\x04/\x02\x06\x03\x12\x04\x89\r;<\nI\n\x04\x04/\x02\x07\x12\x04\x8c\
    \r\x025\x1a;\x20Apply\x20a\x20predefined\x20set\x20of\x20access\x20contr\
    ols\x20to\x20this\x20object.\n\n\x0f\n\x05\x04/\x02\x07\x04\x12\x06\x8c\
    \r\x02\x89\r=\n\r\n\x05\x04/\x02\x07\x06\x12\x04\x8c\r\x02!\n\r\n\x05\
    \x04/\x02\x07\x01\x12\x04\x8c\r\"0\n\r\n\x05\x04/\x02\x07\x03\x12\x04\
    \x8c\r34\n@\n\x04\x04/\x02\x08\x12\x04\x8f\r\x02(\x1a2\x20Set\x20of\x20p\
    roperties\x20to\x20return.\x20Defaults\x20to\x20`FULL`.\n\n\x0f\n\x05\
    \x04/\x02\x08\x04\x12\x06\x8f\r\x02\x8c\r5\n\r\n\x05\x04/\x02\x08\x06\
    \x12\x04\x8f\r\x02\x18\n\r\n\x05\x04/\x02\x08\x01\x12\x04\x8f\r\x19#\n\r\
    \n\x05\x04/\x02\x08\x03\x12\x04\x8f\r&'\n1\n\x04\x04/\x02\t\x12\x04\x92\
    \r\x02\x17\x1a#\x20The\x20Object\x20metadata\x20for\x20updating.\n\n\x0f\
    \n\x05\x04/\x02\t\x04\x12\x06\x92\r\x02\x8f\r(\n\r\n\x05\x04/\x02\t\x06\
    \x12\x04\x92\r\x02\x08\n\r\n\x05\x04/\x02\t\x01\x12\x04\x92\r\t\x11\n\r\
    \n\x05\x04/\x02\t\x03\x12\x04\x92\r\x14\x16\nX\n\x04\x04/\x02\n\x12\x04\
    \x95\r\x02>\x1aJ\x20A\x20set\x20of\x20parameters\x20common\x20to\x20Stor\
    age\x20API\x20requests\x20concerning\x20an\x20object.\n\n\x0f\n\x05\x04/\
    \x02\n\x04\x12\x06\x95\r\x02\x92\r\x17\n\r\n\x05\x04/\x02\n\x06\x12\x04\
    \x95\r\x02\x1b\n\r\n\x05\x04/\x02\n\x01\x12\x04\x95\r\x1c8\n\r\n\x05\x04\
    /\x02\n\x03\x12\x04\x95\r;=\nG\n\x04\x04/\x02\x0b\x12\x04\x98\r\x021\x1a\
    9\x20A\x20set\x20of\x20parameters\x20common\x20to\x20all\x20Storage\x20A\
    PI\x20requests.\n\n\x0f\n\x05\x04/\x02\x0b\x04\x12\x06\x98\r\x02\x95\r>\
    \n\r\n\x05\x04/\x02\x0b\x06\x12\x04\x98\r\x02\x15\n\r\n\x05\x04/\x02\x0b\
    \x01\x12\x04\x98\r\x16+\n\r\n\x05\x04/\x02\x0b\x03\x12\x04\x98\r.0\n4\n\
    \x02\x040\x12\x06\x9c\r\0\xc8\r\x01\x1a&\x20Request\x20message\x20for\
    \x20WatchAllObjects.\n\n\x0b\n\x03\x040\x01\x12\x04\x9c\r\x08\x1e\n@\n\
    \x04\x040\x02\0\x12\x04\x9e\r\x02\x14\x1a2\x20Name\x20of\x20the\x20bucke\
    t\x20in\x20which\x20to\x20look\x20for\x20objects.\n\n\x0f\n\x05\x040\x02\
    \0\x04\x12\x06\x9e\r\x02\x9c\r\x20\n\r\n\x05\x040\x02\0\x05\x12\x04\x9e\
    \r\x02\x08\n\r\n\x05\x040\x02\0\x01\x12\x04\x9e\r\t\x0f\n\r\n\x05\x040\
    \x02\0\x03\x12\x04\x9e\r\x12\x13\n\xd3\x01\n\x04\x040\x02\x01\x12\x04\
    \xa4\r\x02\x14\x1a\xc4\x01\x20If\x20`true`,\x20lists\x20all\x20versions\
    \x20of\x20an\x20object\x20as\x20distinct\x20results.\n\x20The\x20default\
    \x20is\x20`false`.\x20For\x20more\x20information,\x20see\n\x20[Object\n\
    \x20Versioning](https://cloud.google.com/storage/docs/object-versioning)\
    .\n\n\x0f\n\x05\x040\x02\x01\x04\x12\x06\xa4\r\x02\x9e\r\x14\n\r\n\x05\
    \x040\x02\x01\x05\x12\x04\xa4\r\x02\x06\n\r\n\x05\x040\x02\x01\x01\x12\
    \x04\xa4\r\x07\x0f\n\r\n\x05\x040\x02\x01\x03\x12\x04\xa4\r\x12\x13\n\
    \xd6\x02\n\x04\x040\x02\x02\x12\x04\xac\r\x02\x17\x1a\xc7\x02\x20Returns\
    \x20results\x20in\x20a\x20directory-like\x20mode.\x20`items`\x20will\x20\
    contain\n\x20only\x20objects\x20whose\x20names,\x20aside\x20from\x20the\
    \x20`prefix`,\x20do\x20not\n\x20contain\x20`delimiter`.\x20Objects\x20wh\
    ose\x20names,\x20aside\x20from\x20the\n\x20`prefix`,\x20contain\x20`deli\
    miter`\x20will\x20have\x20their\x20name,\n\x20truncated\x20after\x20the\
    \x20`delimiter`,\x20returned\x20in\n\x20`prefixes`.\x20Duplicate\x20`pre\
    fixes`\x20are\x20omitted.\n\n\x0f\n\x05\x040\x02\x02\x04\x12\x06\xac\r\
    \x02\xa4\r\x14\n\r\n\x05\x040\x02\x02\x05\x12\x04\xac\r\x02\x08\n\r\n\
    \x05\x040\x02\x02\x01\x12\x04\xac\r\t\x12\n\r\n\x05\x040\x02\x02\x03\x12\
    \x04\xac\r\x15\x16\n\x89\x02\n\x04\x040\x02\x03\x12\x04\xb2\r\x02\x18\
    \x1a\xfa\x01\x20Maximum\x20number\x20of\x20`items`\x20plus\x20`prefixes`\
    \x20to\x20return\n\x20in\x20a\x20single\x20page\x20of\x20responses.\x20A\
    s\x20duplicate\x20`prefixes`\x20are\n\x20omitted,\x20fewer\x20total\x20r\
    esults\x20may\x20be\x20returned\x20than\x20requested.\x20The\x20service\
    \n\x20will\x20use\x20this\x20parameter\x20or\x201,000\x20items,\x20which\
    ever\x20is\x20smaller.\n\n\x0f\n\x05\x040\x02\x03\x04\x12\x06\xb2\r\x02\
    \xac\r\x17\n\r\n\x05\x040\x02\x03\x05\x12\x04\xb2\r\x02\x07\n\r\n\x05\
    \x040\x02\x03\x01\x12\x04\xb2\r\x08\x13\n\r\n\x05\x040\x02\x03\x03\x12\
    \x04\xb2\r\x16\x17\nM\n\x04\x040\x02\x04\x12\x04\xb5\r\x02\x14\x1a?\x20F\
    ilter\x20results\x20to\x20objects\x20whose\x20names\x20begin\x20with\x20\
    this\x20prefix.\n\n\x0f\n\x05\x040\x02\x04\x04\x12\x06\xb5\r\x02\xb2\r\
    \x18\n\r\n\x05\x040\x02\x04\x05\x12\x04\xb5\r\x02\x08\n\r\n\x05\x040\x02\
    \x04\x01\x12\x04\xb5\r\t\x0f\n\r\n\x05\x040\x02\x04\x03\x12\x04\xb5\r\
    \x12\x13\n\x9b\x01\n\x04\x040\x02\x05\x12\x04\xba\r\x02&\x1a\x8c\x01\x20\
    If\x20true,\x20objects\x20that\x20end\x20in\x20exactly\x20one\x20instanc\
    e\x20of\x20`delimiter`\n\x20will\x20have\x20their\x20metadata\x20include\
    d\x20in\x20`items`\x20in\x20addition\x20to\n\x20`prefixes`.\n\n\x0f\n\
    \x05\x040\x02\x05\x04\x12\x06\xba\r\x02\xb5\r\x14\n\r\n\x05\x040\x02\x05\
    \x05\x12\x04\xba\r\x02\x06\n\r\n\x05\x040\x02\x05\x01\x12\x04\xba\r\x07!\
    \n\r\n\x05\x040\x02\x05\x03\x12\x04\xba\r$%\ni\n\x04\x040\x02\x06\x12\
    \x04\xbe\r\x02\x18\x1a[\x20A\x20previously-returned\x20page\x20token\x20\
    representing\x20part\x20of\x20the\x20larger\x20set\x20of\n\x20results\
    \x20to\x20view.\n\n\x0f\n\x05\x040\x02\x06\x04\x12\x06\xbe\r\x02\xba\r&\
    \n\r\n\x05\x040\x02\x06\x05\x12\x04\xbe\r\x02\x08\n\r\n\x05\x040\x02\x06\
    \x01\x12\x04\xbe\r\t\x13\n\r\n\x05\x040\x02\x06\x03\x12\x04\xbe\r\x16\
    \x17\nB\n\x04\x040\x02\x07\x12\x04\xc1\r\x02(\x1a4\x20Set\x20of\x20prope\
    rties\x20to\x20return.\x20Defaults\x20to\x20`NO_ACL`.\n\n\x0f\n\x05\x040\
    \x02\x07\x04\x12\x06\xc1\r\x02\xbe\r\x18\n\r\n\x05\x040\x02\x07\x06\x12\
    \x04\xc1\r\x02\x18\n\r\n\x05\x040\x02\x07\x01\x12\x04\xc1\r\x19#\n\r\n\
    \x05\x040\x02\x07\x03\x12\x04\xc1\r&'\n9\n\x04\x040\x02\x08\x12\x04\xc4\
    \r\x02\x17\x1a+\x20Properties\x20of\x20the\x20channel\x20to\x20be\x20ins\
    erted.\n\n\x0f\n\x05\x040\x02\x08\x04\x12\x06\xc4\r\x02\xc1\r(\n\r\n\x05\
    \x040\x02\x08\x06\x12\x04\xc4\r\x02\t\n\r\n\x05\x040\x02\x08\x01\x12\x04\
    \xc4\r\n\x11\n\r\n\x05\x040\x02\x08\x03\x12\x04\xc4\r\x14\x16\nG\n\x04\
    \x040\x02\t\x12\x04\xc7\r\x021\x1a9\x20A\x20set\x20of\x20parameters\x20c\
    ommon\x20to\x20all\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x040\x02\
    \t\x04\x12\x06\xc7\r\x02\xc4\r\x17\n\r\n\x05\x040\x02\t\x06\x12\x04\xc7\
    \r\x02\x15\n\r\n\x05\x040\x02\t\x01\x12\x04\xc7\r\x16+\n\r\n\x05\x040\
    \x02\t\x03\x12\x04\xc7\r.0\n=\n\x02\x041\x12\x06\xcb\r\0\xd1\r\x01\x1a/\
    \x20Request\x20message\x20for\x20GetProjectServiceAccount.\n\n\x0b\n\x03\
    \x041\x01\x12\x04\xcb\r\x08'\n%\n\x04\x041\x02\0\x12\x04\xcd\r\x02A\x1a\
    \x17\x20Required.\x20Project\x20ID.\n\n\x0f\n\x05\x041\x02\0\x04\x12\x06\
    \xcd\r\x02\xcb\r)\n\r\n\x05\x041\x02\0\x05\x12\x04\xcd\r\x02\x08\n\r\n\
    \x05\x041\x02\0\x01\x12\x04\xcd\r\t\x13\n\r\n\x05\x041\x02\0\x03\x12\x04\
    \xcd\r\x16\x17\n\r\n\x05\x041\x02\0\x08\x12\x04\xcd\r\x18@\n\x10\n\x08\
    \x041\x02\0\x08\x9c\x08\0\x12\x04\xcd\r\x19?\nG\n\x04\x041\x02\x01\x12\
    \x04\xd0\r\x020\x1a9\x20A\x20set\x20of\x20parameters\x20common\x20to\x20\
    all\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x041\x02\x01\x04\x12\
    \x06\xd0\r\x02\xcd\rA\n\r\n\x05\x041\x02\x01\x06\x12\x04\xd0\r\x02\x15\n\
    \r\n\x05\x041\x02\x01\x01\x12\x04\xd0\r\x16+\n\r\n\x05\x041\x02\x01\x03\
    \x12\x04\xd0\r./\n\x0c\n\x02\x042\x12\x06\xd3\r\0\xdc\r\x01\n\x0b\n\x03\
    \x042\x01\x12\x04\xd3\r\x08\x1c\nT\n\x04\x042\x02\0\x12\x04\xd5\r\x02A\
    \x1aF\x20Required.\x20The\x20project\x20that\x20the\x20HMAC-owning\x20se\
    rvice\x20account\x20lives\x20in.\n\n\x0f\n\x05\x042\x02\0\x04\x12\x06\
    \xd5\r\x02\xd3\r\x1e\n\r\n\x05\x042\x02\0\x05\x12\x04\xd5\r\x02\x08\n\r\
    \n\x05\x042\x02\0\x01\x12\x04\xd5\r\t\x13\n\r\n\x05\x042\x02\0\x03\x12\
    \x04\xd5\r\x16\x17\n\r\n\x05\x042\x02\0\x08\x12\x04\xd5\r\x18@\n\x10\n\
    \x08\x042\x02\0\x08\x9c\x08\0\x12\x04\xd5\r\x19?\nE\n\x04\x042\x02\x01\
    \x12\x04\xd8\r\x02L\x1a7\x20Required.\x20The\x20service\x20account\x20to\
    \x20create\x20the\x20HMAC\x20for.\n\n\x0f\n\x05\x042\x02\x01\x04\x12\x06\
    \xd8\r\x02\xd5\rA\n\r\n\x05\x042\x02\x01\x05\x12\x04\xd8\r\x02\x08\n\r\n\
    \x05\x042\x02\x01\x01\x12\x04\xd8\r\t\x1e\n\r\n\x05\x042\x02\x01\x03\x12\
    \x04\xd8\r!\"\n\r\n\x05\x042\x02\x01\x08\x12\x04\xd8\r#K\n\x10\n\x08\x04\
    2\x02\x01\x08\x9c\x08\0\x12\x04\xd8\r$J\nG\n\x04\x042\x02\x02\x12\x04\
    \xdb\r\x020\x1a9\x20A\x20set\x20of\x20parameters\x20common\x20to\x20all\
    \x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x042\x02\x02\x04\x12\x06\
    \xdb\r\x02\xd8\rL\n\r\n\x05\x042\x02\x02\x06\x12\x04\xdb\r\x02\x15\n\r\n\
    \x05\x042\x02\x02\x01\x12\x04\xdb\r\x16+\n\r\n\x05\x042\x02\x02\x03\x12\
    \x04\xdb\r./\n]\n\x02\x043\x12\x06\xdf\r\0\xe5\r\x01\x1aO\x20Create\x20h\
    mac\x20response.\x20\x20The\x20only\x20time\x20the\x20secret\x20for\x20a\
    n\x20HMAC\x20will\x20be\x20returned.\n\n\x0b\n\x03\x043\x01\x12\x04\xdf\
    \r\x08\x1d\n\x1d\n\x04\x043\x02\0\x12\x04\xe1\r\x02\x1f\x1a\x0f\x20Key\
    \x20metadata.\n\n\x0f\n\x05\x043\x02\0\x04\x12\x06\xe1\r\x02\xdf\r\x1f\n\
    \r\n\x05\x043\x02\0\x06\x12\x04\xe1\r\x02\x11\n\r\n\x05\x043\x02\0\x01\
    \x12\x04\xe1\r\x12\x1a\n\r\n\x05\x043\x02\0\x03\x12\x04\xe1\r\x1d\x1e\n)\
    \n\x04\x043\x02\x01\x12\x04\xe4\r\x02\x14\x1a\x1b\x20HMAC\x20key\x20secr\
    et\x20material.\n\n\x0f\n\x05\x043\x02\x01\x04\x12\x06\xe4\r\x02\xe1\r\
    \x1f\n\r\n\x05\x043\x02\x01\x05\x12\x04\xe4\r\x02\x08\n\r\n\x05\x043\x02\
    \x01\x01\x12\x04\xe4\r\t\x0f\n\r\n\x05\x043\x02\x01\x03\x12\x04\xe4\r\
    \x12\x13\n:\n\x02\x044\x12\x06\xe8\r\0\xf1\r\x01\x1a,\x20Request\x20obje\
    ct\x20to\x20delete\x20a\x20given\x20HMAC\x20key.\n\n\x0b\n\x03\x044\x01\
    \x12\x04\xe8\r\x08\x1c\nE\n\x04\x044\x02\0\x12\x04\xea\r\x02@\x1a7\x20Re\
    quired.\x20The\x20identifying\x20key\x20for\x20the\x20HMAC\x20to\x20dele\
    te.\n\n\x0f\n\x05\x044\x02\0\x04\x12\x06\xea\r\x02\xe8\r\x1e\n\r\n\x05\
    \x044\x02\0\x05\x12\x04\xea\r\x02\x08\n\r\n\x05\x044\x02\0\x01\x12\x04\
    \xea\r\t\x12\n\r\n\x05\x044\x02\0\x03\x12\x04\xea\r\x15\x16\n\r\n\x05\
    \x044\x02\0\x08\x12\x04\xea\r\x17?\n\x10\n\x08\x044\x02\0\x08\x9c\x08\0\
    \x12\x04\xea\r\x18>\n>\n\x04\x044\x02\x01\x12\x04\xed\r\x02A\x1a0\x20Req\
    uired.\x20The\x20project\x20id\x20the\x20HMAC\x20key\x20lies\x20in.\n\n\
    \x0f\n\x05\x044\x02\x01\x04\x12\x06\xed\r\x02\xea\r@\n\r\n\x05\x044\x02\
    \x01\x05\x12\x04\xed\r\x02\x08\n\r\n\x05\x044\x02\x01\x01\x12\x04\xed\r\
    \t\x13\n\r\n\x05\x044\x02\x01\x03\x12\x04\xed\r\x16\x17\n\r\n\x05\x044\
    \x02\x01\x08\x12\x04\xed\r\x18@\n\x10\n\x08\x044\x02\x01\x08\x9c\x08\0\
    \x12\x04\xed\r\x19?\nG\n\x04\x044\x02\x02\x12\x04\xf0\r\x020\x1a9\x20A\
    \x20set\x20of\x20parameters\x20common\x20to\x20all\x20Storage\x20API\x20\
    requests.\n\n\x0f\n\x05\x044\x02\x02\x04\x12\x06\xf0\r\x02\xed\rA\n\r\n\
    \x05\x044\x02\x02\x06\x12\x04\xf0\r\x02\x15\n\r\n\x05\x044\x02\x02\x01\
    \x12\x04\xf0\r\x16+\n\r\n\x05\x044\x02\x02\x03\x12\x04\xf0\r./\nC\n\x02\
    \x045\x12\x06\xf4\r\0\xfd\r\x01\x1a5\x20Request\x20object\x20to\x20get\
    \x20metadata\x20on\x20a\x20given\x20HMAC\x20key.\n\n\x0b\n\x03\x045\x01\
    \x12\x04\xf4\r\x08\x19\nE\n\x04\x045\x02\0\x12\x04\xf6\r\x02@\x1a7\x20Re\
    quired.\x20The\x20identifying\x20key\x20for\x20the\x20HMAC\x20to\x20dele\
    te.\n\n\x0f\n\x05\x045\x02\0\x04\x12\x06\xf6\r\x02\xf4\r\x1b\n\r\n\x05\
    \x045\x02\0\x05\x12\x04\xf6\r\x02\x08\n\r\n\x05\x045\x02\0\x01\x12\x04\
    \xf6\r\t\x12\n\r\n\x05\x045\x02\0\x03\x12\x04\xf6\r\x15\x16\n\r\n\x05\
    \x045\x02\0\x08\x12\x04\xf6\r\x17?\n\x10\n\x08\x045\x02\0\x08\x9c\x08\0\
    \x12\x04\xf6\r\x18>\n>\n\x04\x045\x02\x01\x12\x04\xf9\r\x02A\x1a0\x20Req\
    uired.\x20The\x20project\x20id\x20the\x20HMAC\x20key\x20lies\x20in.\n\n\
    \x0f\n\x05\x045\x02\x01\x04\x12\x06\xf9\r\x02\xf6\r@\n\r\n\x05\x045\x02\
    \x01\x05\x12\x04\xf9\r\x02\x08\n\r\n\x05\x045\x02\x01\x01\x12\x04\xf9\r\
    \t\x13\n\r\n\x05\x045\x02\x01\x03\x12\x04\xf9\r\x16\x17\n\r\n\x05\x045\
    \x02\x01\x08\x12\x04\xf9\r\x18@\n\x10\n\x08\x045\x02\x01\x08\x9c\x08\0\
    \x12\x04\xf9\r\x19?\nG\n\x04\x045\x02\x02\x12\x04\xfc\r\x020\x1a9\x20A\
    \x20set\x20of\x20parameters\x20common\x20to\x20all\x20Storage\x20API\x20\
    requests.\n\n\x0f\n\x05\x045\x02\x02\x04\x12\x06\xfc\r\x02\xf9\rA\n\r\n\
    \x05\x045\x02\x02\x06\x12\x04\xfc\r\x02\x15\n\r\n\x05\x045\x02\x02\x01\
    \x12\x04\xfc\r\x16+\n\r\n\x05\x045\x02\x02\x03\x12\x04\xfc\r./\nK\n\x02\
    \x046\x12\x06\x80\x0e\0\x92\x0e\x01\x1a=\x20Request\x20to\x20fetch\x20a\
    \x20list\x20of\x20HMAC\x20keys\x20under\x20a\x20given\x20project.\n\n\
    \x0b\n\x03\x046\x01\x12\x04\x80\x0e\x08\x1b\n?\n\x04\x046\x02\0\x12\x04\
    \x82\x0e\x02A\x1a1\x20Required.\x20The\x20project\x20id\x20to\x20list\
    \x20HMAC\x20keys\x20for.\n\n\x0f\n\x05\x046\x02\0\x04\x12\x06\x82\x0e\
    \x02\x80\x0e\x1d\n\r\n\x05\x046\x02\0\x05\x12\x04\x82\x0e\x02\x08\n\r\n\
    \x05\x046\x02\0\x01\x12\x04\x82\x0e\t\x13\n\r\n\x05\x046\x02\0\x03\x12\
    \x04\x82\x0e\x16\x17\n\r\n\x05\x046\x02\0\x08\x12\x04\x82\x0e\x18@\n\x10\
    \n\x08\x046\x02\0\x08\x9c\x08\0\x12\x04\x82\x0e\x19?\nT\n\x04\x046\x02\
    \x01\x12\x04\x85\x0e\x02#\x1aF\x20An\x20optional\x20filter\x20to\x20only\
    \x20return\x20HMAC\x20keys\x20for\x20one\x20service\x20account.\n\n\x0f\
    \n\x05\x046\x02\x01\x04\x12\x06\x85\x0e\x02\x82\x0eA\n\r\n\x05\x046\x02\
    \x01\x05\x12\x04\x85\x0e\x02\x08\n\r\n\x05\x046\x02\x01\x01\x12\x04\x85\
    \x0e\t\x1e\n\r\n\x05\x046\x02\x01\x03\x12\x04\x85\x0e!\"\nY\n\x04\x046\
    \x02\x02\x12\x04\x88\x0e\x02\x1d\x1aK\x20An\x20optional\x20bool\x20to\
    \x20return\x20deleted\x20keys\x20that\x20have\x20not\x20been\x20wiped\
    \x20out\x20yet.\n\n\x0f\n\x05\x046\x02\x02\x04\x12\x06\x88\x0e\x02\x85\
    \x0e#\n\r\n\x05\x046\x02\x02\x05\x12\x04\x88\x0e\x02\x06\n\r\n\x05\x046\
    \x02\x02\x01\x12\x04\x88\x0e\x07\x18\n\r\n\x05\x046\x02\x02\x03\x12\x04\
    \x88\x0e\x1b\x1c\n5\n\x04\x046\x02\x03\x12\x04\x8b\x0e\x02\x18\x1a'\x20T\
    he\x20maximum\x20number\x20of\x20keys\x20to\x20return.\n\n\x0f\n\x05\x04\
    6\x02\x03\x04\x12\x06\x8b\x0e\x02\x88\x0e\x1d\n\r\n\x05\x046\x02\x03\x05\
    \x12\x04\x8b\x0e\x02\x07\n\r\n\x05\x046\x02\x03\x01\x12\x04\x8b\x0e\x08\
    \x13\n\r\n\x05\x046\x02\x03\x03\x12\x04\x8b\x0e\x16\x17\n[\n\x04\x046\
    \x02\x04\x12\x04\x8e\x0e\x02\x18\x1aM\x20A\x20previously\x20returned\x20\
    token\x20from\x20ListHmacKeysResponse\x20to\x20get\x20the\x20next\x20pag\
    e.\n\n\x0f\n\x05\x046\x02\x04\x04\x12\x06\x8e\x0e\x02\x8b\x0e\x18\n\r\n\
    \x05\x046\x02\x04\x05\x12\x04\x8e\x0e\x02\x08\n\r\n\x05\x046\x02\x04\x01\
    \x12\x04\x8e\x0e\t\x13\n\r\n\x05\x046\x02\x04\x03\x12\x04\x8e\x0e\x16\
    \x17\nG\n\x04\x046\x02\x05\x12\x04\x91\x0e\x020\x1a9\x20A\x20set\x20of\
    \x20parameters\x20common\x20to\x20all\x20Storage\x20API\x20requests.\n\n\
    \x0f\n\x05\x046\x02\x05\x04\x12\x06\x91\x0e\x02\x8e\x0e\x18\n\r\n\x05\
    \x046\x02\x05\x06\x12\x04\x91\x0e\x02\x15\n\r\n\x05\x046\x02\x05\x01\x12\
    \x04\x91\x0e\x16+\n\r\n\x05\x046\x02\x05\x03\x12\x04\x91\x0e./\nB\n\x02\
    \x047\x12\x06\x95\x0e\0\x9c\x0e\x01\x1a4\x20Hmac\x20key\x20list\x20respo\
    nse\x20with\x20next\x20page\x20information.\n\n\x0b\n\x03\x047\x01\x12\
    \x04\x95\x0e\x08\x1c\n\xa0\x01\n\x04\x047\x02\0\x12\x04\x98\x0e\x02\x1d\
    \x1a\x91\x01\x20The\x20continuation\x20token,\x20used\x20to\x20page\x20t\
    hrough\x20large\x20result\x20sets.\x20Provide\n\x20this\x20value\x20in\
    \x20a\x20subsequent\x20request\x20to\x20return\x20the\x20next\x20page\
    \x20of\x20results.\n\n\x0f\n\x05\x047\x02\0\x04\x12\x06\x98\x0e\x02\x95\
    \x0e\x1e\n\r\n\x05\x047\x02\0\x05\x12\x04\x98\x0e\x02\x08\n\r\n\x05\x047\
    \x02\0\x01\x12\x04\x98\x0e\t\x18\n\r\n\x05\x047\x02\0\x03\x12\x04\x98\
    \x0e\x1b\x1c\n\"\n\x04\x047\x02\x01\x12\x04\x9b\x0e\x02%\x1a\x14\x20The\
    \x20list\x20of\x20items.\n\n\r\n\x05\x047\x02\x01\x04\x12\x04\x9b\x0e\
    \x02\n\n\r\n\x05\x047\x02\x01\x06\x12\x04\x9b\x0e\x0b\x1a\n\r\n\x05\x047\
    \x02\x01\x01\x12\x04\x9b\x0e\x1b\x20\n\r\n\x05\x047\x02\x01\x03\x12\x04\
    \x9b\x0e#$\n;\n\x02\x048\x12\x06\x9f\x0e\0\xab\x0e\x01\x1a-\x20Request\
    \x20object\x20to\x20update\x20an\x20HMAC\x20key\x20state.\n\n\x0b\n\x03\
    \x048\x01\x12\x04\x9f\x0e\x08\x1c\n1\n\x04\x048\x02\0\x12\x04\xa1\x0e\
    \x02@\x1a#\x20Required.\x20The\x20id\x20of\x20the\x20HMAC\x20key.\n\n\
    \x0f\n\x05\x048\x02\0\x04\x12\x06\xa1\x0e\x02\x9f\x0e\x1e\n\r\n\x05\x048\
    \x02\0\x05\x12\x04\xa1\x0e\x02\x08\n\r\n\x05\x048\x02\0\x01\x12\x04\xa1\
    \x0e\t\x12\n\r\n\x05\x048\x02\0\x03\x12\x04\xa1\x0e\x15\x16\n\r\n\x05\
    \x048\x02\0\x08\x12\x04\xa1\x0e\x17?\n\x10\n\x08\x048\x02\0\x08\x9c\x08\
    \0\x12\x04\xa1\x0e\x18>\nL\n\x04\x048\x02\x01\x12\x04\xa4\x0e\x02A\x1a>\
    \x20Required.\x20The\x20project\x20id\x20the\x20HMAC's\x20service\x20acc\
    ount\x20lies\x20in.\n\n\x0f\n\x05\x048\x02\x01\x04\x12\x06\xa4\x0e\x02\
    \xa1\x0e@\n\r\n\x05\x048\x02\x01\x05\x12\x04\xa4\x0e\x02\x08\n\r\n\x05\
    \x048\x02\x01\x01\x12\x04\xa4\x0e\t\x13\n\r\n\x05\x048\x02\x01\x03\x12\
    \x04\xa4\x0e\x16\x17\n\r\n\x05\x048\x02\x01\x08\x12\x04\xa4\x0e\x18@\n\
    \x10\n\x08\x048\x02\x01\x08\x9c\x08\0\x12\x04\xa4\x0e\x19?\nD\n\x04\x048\
    \x02\x02\x12\x04\xa7\x0e\x02H\x1a6\x20Required.\x20The\x20service\x20acc\
    ount\x20owner\x20of\x20the\x20HMAC\x20key.\n\n\x0f\n\x05\x048\x02\x02\
    \x04\x12\x06\xa7\x0e\x02\xa4\x0eA\n\r\n\x05\x048\x02\x02\x06\x12\x04\xa7\
    \x0e\x02\x11\n\r\n\x05\x048\x02\x02\x01\x12\x04\xa7\x0e\x12\x1a\n\r\n\
    \x05\x048\x02\x02\x03\x12\x04\xa7\x0e\x1d\x1e\n\r\n\x05\x048\x02\x02\x08\
    \x12\x04\xa7\x0e\x1fG\n\x10\n\x08\x048\x02\x02\x08\x9c\x08\0\x12\x04\xa7\
    \x0e\x20F\nG\n\x04\x048\x02\x03\x12\x04\xaa\x0e\x020\x1a9\x20A\x20set\
    \x20of\x20parameters\x20common\x20to\x20all\x20Storage\x20API\x20request\
    s.\n\n\x0f\n\x05\x048\x02\x03\x04\x12\x06\xaa\x0e\x02\xa7\x0eH\n\r\n\x05\
    \x048\x02\x03\x06\x12\x04\xaa\x0e\x02\x15\n\r\n\x05\x048\x02\x03\x01\x12\
    \x04\xaa\x0e\x16+\n\r\n\x05\x048\x02\x03\x03\x12\x04\xaa\x0e./\nb\n\x02\
    \x049\x12\x06\xaf\x0e\0\xb5\x0e\x01\x1aT\x20A\x20wrapper\x20around\x20th\
    e\x20IAM\x20get\x20policy\x20request\x20to\x20support\x20our\n\x20common\
    _request_params.\n\n\x0b\n\x03\x049\x01\x12\x04\xaf\x0e\x08\x1b\n(\n\x04\
    \x049\x02\0\x12\x04\xb1\x0e\x024\x1a\x1a\x20The\x20request\x20sent\x20to\
    \x20IAM.\n\n\x0f\n\x05\x049\x02\0\x04\x12\x06\xb1\x0e\x02\xaf\x0e\x1d\n\
    \r\n\x05\x049\x02\0\x06\x12\x04\xb1\x0e\x02#\n\r\n\x05\x049\x02\0\x01\
    \x12\x04\xb1\x0e$/\n\r\n\x05\x049\x02\0\x03\x12\x04\xb1\x0e23\nG\n\x04\
    \x049\x02\x01\x12\x04\xb4\x0e\x020\x1a9\x20A\x20set\x20of\x20parameters\
    \x20common\x20to\x20all\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04\
    9\x02\x01\x04\x12\x06\xb4\x0e\x02\xb1\x0e4\n\r\n\x05\x049\x02\x01\x06\
    \x12\x04\xb4\x0e\x02\x15\n\r\n\x05\x049\x02\x01\x01\x12\x04\xb4\x0e\x16+\
    \n\r\n\x05\x049\x02\x01\x03\x12\x04\xb4\x0e./\nb\n\x02\x04:\x12\x06\xb9\
    \x0e\0\xbf\x0e\x01\x1aT\x20A\x20wrapper\x20around\x20the\x20IAM\x20set\
    \x20policy\x20request\x20to\x20support\x20our\n\x20common_request_params\
    .\n\n\x0b\n\x03\x04:\x01\x12\x04\xb9\x0e\x08\x1b\n(\n\x04\x04:\x02\0\x12\
    \x04\xbb\x0e\x024\x1a\x1a\x20The\x20request\x20sent\x20to\x20IAM.\n\n\
    \x0f\n\x05\x04:\x02\0\x04\x12\x06\xbb\x0e\x02\xb9\x0e\x1d\n\r\n\x05\x04:\
    \x02\0\x06\x12\x04\xbb\x0e\x02#\n\r\n\x05\x04:\x02\0\x01\x12\x04\xbb\x0e\
    $/\n\r\n\x05\x04:\x02\0\x03\x12\x04\xbb\x0e23\nG\n\x04\x04:\x02\x01\x12\
    \x04\xbe\x0e\x020\x1a9\x20A\x20set\x20of\x20parameters\x20common\x20to\
    \x20all\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04:\x02\x01\x04\
    \x12\x06\xbe\x0e\x02\xbb\x0e4\n\r\n\x05\x04:\x02\x01\x06\x12\x04\xbe\x0e\
    \x02\x15\n\r\n\x05\x04:\x02\x01\x01\x12\x04\xbe\x0e\x16+\n\r\n\x05\x04:\
    \x02\x01\x03\x12\x04\xbe\x0e./\nl\n\x02\x04;\x12\x06\xc3\x0e\0\xc9\x0e\
    \x01\x1a^\x20A\x20wrapper\x20around\x20the\x20IAM\x20test\x20iam\x20perm\
    issions\x20request\x20to\x20support\x20our\n\x20common_request_params.\n\
    \n\x0b\n\x03\x04;\x01\x12\x04\xc3\x0e\x08!\n(\n\x04\x04;\x02\0\x12\x04\
    \xc5\x0e\x02:\x1a\x1a\x20The\x20request\x20sent\x20to\x20IAM.\n\n\x0f\n\
    \x05\x04;\x02\0\x04\x12\x06\xc5\x0e\x02\xc3\x0e#\n\r\n\x05\x04;\x02\0\
    \x06\x12\x04\xc5\x0e\x02)\n\r\n\x05\x04;\x02\0\x01\x12\x04\xc5\x0e*5\n\r\
    \n\x05\x04;\x02\0\x03\x12\x04\xc5\x0e89\nG\n\x04\x04;\x02\x01\x12\x04\
    \xc8\x0e\x020\x1a9\x20A\x20set\x20of\x20parameters\x20common\x20to\x20al\
    l\x20Storage\x20API\x20requests.\n\n\x0f\n\x05\x04;\x02\x01\x04\x12\x06\
    \xc8\x0e\x02\xc5\x0e:\n\r\n\x05\x04;\x02\x01\x06\x12\x04\xc8\x0e\x02\x15\
    \n\r\n\x05\x04;\x02\x01\x01\x12\x04\xc8\x0e\x16+\n\r\n\x05\x04;\x02\x01\
    \x03\x12\x04\xc8\x0e./\nD\n\x02\x04<\x12\x06\xcc\x0e\0\xd6\x0e\x01\x1a6\
    \x20Parameters\x20that\x20can\x20be\x20passed\x20to\x20any\x20object\x20\
    request.\n\n\x0b\n\x03\x04<\x01\x12\x04\xcc\x0e\x08!\nY\n\x04\x04<\x02\0\
    \x12\x04\xce\x0e\x02\"\x1aK\x20Encryption\x20algorithm\x20used\x20with\
    \x20Customer-Supplied\x20Encryption\x20Keys\x20feature.\n\n\x0f\n\x05\
    \x04<\x02\0\x04\x12\x06\xce\x0e\x02\xcc\x0e#\n\r\n\x05\x04<\x02\0\x05\
    \x12\x04\xce\x0e\x02\x08\n\r\n\x05\x04<\x02\0\x01\x12\x04\xce\x0e\t\x1d\
    \n\r\n\x05\x04<\x02\0\x03\x12\x04\xce\x0e\x20!\nS\n\x04\x04<\x02\x01\x12\
    \x04\xd1\x0e\x02\x1c\x1aE\x20Encryption\x20key\x20used\x20with\x20Custom\
    er-Supplied\x20Encryption\x20Keys\x20feature.\n\n\x0f\n\x05\x04<\x02\x01\
    \x04\x12\x06\xd1\x0e\x02\xce\x0e\"\n\r\n\x05\x04<\x02\x01\x05\x12\x04\
    \xd1\x0e\x02\x08\n\r\n\x05\x04<\x02\x01\x01\x12\x04\xd1\x0e\t\x17\n\r\n\
    \x05\x04<\x02\x01\x03\x12\x04\xd1\x0e\x1a\x1b\nc\n\x04\x04<\x02\x02\x12\
    \x04\xd5\x0e\x02#\x1aU\x20SHA256\x20hash\x20of\x20encryption\x20key\x20u\
    sed\x20with\x20Customer-Supplied\x20Encryption\x20Keys\n\x20feature.\n\n\
    \x0f\n\x05\x04<\x02\x02\x04\x12\x06\xd5\x0e\x02\xd1\x0e\x1c\n\r\n\x05\
    \x04<\x02\x02\x05\x12\x04\xd5\x0e\x02\x08\n\r\n\x05\x04<\x02\x02\x01\x12\
    \x04\xd5\x0e\t\x1e\n\r\n\x05\x04<\x02\x02\x03\x12\x04\xd5\x0e!\"\n=\n\
    \x02\x04=\x12\x06\xd9\x0e\0\xe7\x0e\x01\x1a/\x20Parameters\x20that\x20ca\
    n\x20be\x20passed\x20to\x20any\x20request.\n\n\x0b\n\x03\x04=\x01\x12\
    \x04\xd9\x0e\x08\x1b\nZ\n\x04\x04=\x02\0\x12\x04\xdb\x0e\x02C\x1aL\x20Re\
    quired.\x20Required\x20when\x20using\x20buckets\x20with\x20Requestor\x20\
    Pays\x20feature\x20enabled.\n\n\x0f\n\x05\x04=\x02\0\x04\x12\x06\xdb\x0e\
    \x02\xd9\x0e\x1d\n\r\n\x05\x04=\x02\0\x05\x12\x04\xdb\x0e\x02\x08\n\r\n\
    \x05\x04=\x02\0\x01\x12\x04\xdb\x0e\t\x15\n\r\n\x05\x04=\x02\0\x03\x12\
    \x04\xdb\x0e\x18\x19\n\r\n\x05\x04=\x02\0\x08\x12\x04\xdb\x0e\x1aB\n\x10\
    \n\x08\x04=\x02\0\x08\x9c\x08\0\x12\x04\xdb\x0e\x1bA\n\xff\x02\n\x04\x04\
    =\x02\x01\x12\x04\xe3\x0e\x02\x18\x1a\xf0\x02\x20Lets\x20you\x20enforce\
    \x20per-user\x20quotas\x20from\x20a\x20server-side\x20application\x20eve\
    n\x20in\n\x20cases\x20when\x20the\x20user's\x20IP\x20address\x20is\x20un\
    known.\x20This\x20can\x20occur,\x20for\x20example,\n\x20with\x20applicat\
    ions\x20that\x20run\x20cron\x20jobs\x20on\x20App\x20Engine\x20on\x20a\
    \x20user's\x20behalf.\n\x20You\x20can\x20choose\x20any\x20arbitrary\x20s\
    tring\x20that\x20uniquely\x20identifies\x20a\x20user,\x20but\x20it\n\x20\
    is\x20limited\x20to\x2040\x20characters.\n\x20Overrides\x20user_ip\x20if\
    \x20both\x20are\x20provided.\n\n\x0f\n\x05\x04=\x02\x01\x04\x12\x06\xe3\
    \x0e\x02\xdb\x0eC\n\r\n\x05\x04=\x02\x01\x05\x12\x04\xe3\x0e\x02\x08\n\r\
    \n\x05\x04=\x02\x01\x01\x12\x04\xe3\x0e\t\x13\n\r\n\x05\x04=\x02\x01\x03\
    \x12\x04\xe3\x0e\x16\x17\n<\n\x04\x04=\x02\x02\x12\x04\xe6\x0e\x02'\x1a.\
    \x20Subset\x20of\x20fields\x20to\x20include\x20in\x20the\x20response.\n\
    \n\x0f\n\x05\x04=\x02\x02\x04\x12\x06\xe6\x0e\x02\xe3\x0e\x18\n\r\n\x05\
    \x04=\x02\x02\x06\x12\x04\xe6\x0e\x02\x1b\n\r\n\x05\x04=\x02\x02\x01\x12\
    \x04\xe6\x0e\x1c\"\n\r\n\x05\x04=\x02\x02\x03\x12\x04\xe6\x0e%&\n!\n\x02\
    \x04>\x12\x06\xea\x0e\0\xbc\x0f\x01\x1a\x13\x20Shared\x20constants.\n\n\
    \x0b\n\x03\x04>\x01\x12\x04\xea\x0e\x08\x18\nP\n\x04\x04>\x04\0\x12\x06\
    \xec\x0e\x02\xb9\x0f\x03\x1a@\x20A\x20collection\x20of\x20constant\x20va\
    lues\x20meaningful\x20to\x20the\x20Storage\x20API.\n\n\r\n\x05\x04>\x04\
    \0\x01\x12\x04\xec\x0e\x07\r\n\r\n\x05\x04>\x04\0\x03\x12\x04\xed\x0e\
    \x04\x1e\n\x0e\n\x06\x04>\x04\0\x03\x02\x12\x04\xed\x0e\x04\x1e\n=\n\x06\
    \x04>\x04\0\x02\0\x12\x04\xf0\x0e\x04\x1b\x1a-\x20Unused.\x20Proto3\x20r\
    equires\x20first\x20enum\x20to\x20be\x200.\n\n\x0f\n\x07\x04>\x04\0\x02\
    \0\x01\x12\x04\xf0\x0e\x04\x16\n\x0f\n\x07\x04>\x04\0\x02\0\x02\x12\x04\
    \xf0\x0e\x19\x1a\nd\n\x06\x04>\x04\0\x02\x01\x12\x04\xf5\x0e\x04#\x1aT\
    \x20The\x20maximum\x20size\x20chunk\x20that\x20can\x20will\x20be\x20retu\
    rned\x20in\x20a\x20single\n\x20ReadRequest.\n\x202\x20MiB.\n\n\x0f\n\x07\
    \x04>\x04\0\x02\x01\x01\x12\x04\xf5\x0e\x04\x18\n\x0f\n\x07\x04>\x04\0\
    \x02\x01\x02\x12\x04\xf5\x0e\x1b\"\nb\n\x06\x04>\x04\0\x02\x02\x12\x04\
    \xf9\x0e\x04$\x1aR\x20The\x20maximum\x20size\x20chunk\x20that\x20can\x20\
    be\x20sent\x20in\x20a\x20single\x20InsertObjectRequest.\n\x202\x20MiB.\n\
    \n\x0f\n\x07\x04>\x04\0\x02\x02\x01\x12\x04\xf9\x0e\x04\x19\n\x0f\n\x07\
    \x04>\x04\0\x02\x02\x02\x12\x04\xf9\x0e\x1c#\n\x8c\x01\n\x06\x04>\x04\0\
    \x02\x03\x12\x04\xfe\x0e\x04!\x1a|\x20The\x20maximum\x20size\x20of\x20an\
    \x20object\x20in\x20MB\x20-\x20whether\x20written\x20in\x20a\x20single\
    \x20stream\n\x20or\x20composed\x20from\x20multiple\x20other\x20objects.\
    \n\x205\x20TiB.\n\n\x0f\n\x07\x04>\x04\0\x02\x03\x01\x12\x04\xfe\x0e\x04\
    \x16\n\x0f\n\x07\x04>\x04\0\x02\x03\x02\x12\x04\xfe\x0e\x19\x20\nl\n\x06\
    \x04>\x04\0\x02\x04\x12\x04\x83\x0f\x040\x1a\\\x20The\x20maximum\x20leng\
    th\x20field\x20name\x20that\x20can\x20be\x20sent\x20in\x20a\x20single\n\
    \x20custom\x20metadata\x20field.\n\x201\x20KiB.\n\n\x0f\n\x07\x04>\x04\0\
    \x02\x04\x01\x12\x04\x83\x0f\x04(\n\x0f\n\x07\x04>\x04\0\x02\x04\x02\x12\
    \x04\x83\x0f+/\nm\n\x06\x04>\x04\0\x02\x05\x12\x04\x88\x0f\x041\x1a]\x20\
    The\x20maximum\x20length\x20field\x20value\x20that\x20can\x20be\x20sent\
    \x20in\x20a\x20single\n\x20custom_metadata\x20field.\n\x204\x20KiB.\n\n\
    \x0f\n\x07\x04>\x04\0\x02\x05\x01\x12\x04\x88\x0f\x04)\n\x0f\n\x07\x04>\
    \x04\0\x02\x05\x02\x12\x04\x88\x0f,0\n\x8f\x01\n\x06\x04>\x04\0\x02\x06\
    \x12\x04\x8d\x0f\x040\x1a\x7f\x20The\x20maximum\x20total\x20bytes\x20tha\
    t\x20can\x20be\x20populated\x20into\x20all\x20field\x20names\x20and\n\
    \x20values\x20of\x20the\x20custom_metadata\x20for\x20one\x20object.\n\
    \x208\x20KiB.\n\n\x0f\n\x07\x04>\x04\0\x02\x06\x01\x12\x04\x8d\x0f\x04(\
    \n\x0f\n\x07\x04>\x04\0\x02\x06\x02\x12\x04\x8d\x0f+/\nj\n\x06\x04>\x04\
    \0\x02\x07\x12\x04\x92\x0f\x041\x1aZ\x20The\x20maximum\x20total\x20bytes\
    \x20that\x20can\x20be\x20populated\x20into\x20all\x20bucket\x20metadata\
    \n\x20fields.\n\x2020\x20KiB.\n\n\x0f\n\x07\x04>\x04\0\x02\x07\x01\x12\
    \x04\x92\x0f\x04(\n\x0f\n\x07\x04>\x04\0\x02\x07\x02\x12\x04\x92\x0f+0\n\
    n\n\x06\x04>\x04\0\x02\x08\x12\x04\x96\x0f\x04.\x1a^\x20The\x20maximum\
    \x20number\x20of\x20NotificationConfigurations\x20that\x20can\x20be\x20r\
    egistered\n\x20for\x20a\x20given\x20bucket.\n\n\x0f\n\x07\x04>\x04\0\x02\
    \x08\x01\x12\x04\x96\x0f\x04'\n\x0f\n\x07\x04>\x04\0\x02\x08\x02\x12\x04\
    \x96\x0f*-\nb\n\x06\x04>\x04\0\x02\t\x12\x04\x9a\x0f\x04)\x1aR\x20The\
    \x20maximum\x20number\x20of\x20LifecycleRules\x20that\x20can\x20be\x20re\
    gistered\x20for\x20a\x20given\n\x20bucket.\n\n\x0f\n\x07\x04>\x04\0\x02\
    \t\x01\x12\x04\x9a\x0f\x04\"\n\x0f\n\x07\x04>\x04\0\x02\t\x02\x12\x04\
    \x9a\x0f%(\nQ\n\x06\x04>\x04\0\x02\n\x12\x04\x9d\x0f\x04+\x1aA\x20The\
    \x20maximum\x20number\x20of\x20custom\x20attributes\x20per\x20Notificati\
    onConfig.\n\n\x0f\n\x07\x04>\x04\0\x02\n\x01\x12\x04\x9d\x0f\x04&\n\x0f\
    \n\x07\x04>\x04\0\x02\n\x02\x12\x04\x9d\x0f)*\n_\n\x06\x04>\x04\0\x02\
    \x0b\x12\x04\xa1\x0f\x047\x1aO\x20The\x20maximum\x20length\x20of\x20a\
    \x20custom\x20attribute\x20key\x20included\x20in\n\x20NotificationConfig\
    .\n\n\x0f\n\x07\x04>\x04\0\x02\x0b\x01\x12\x04\xa1\x0f\x040\n\x0f\n\x07\
    \x04>\x04\0\x02\x0b\x02\x12\x04\xa1\x0f36\nc\n\x06\x04>\x04\0\x02\x0c\
    \x12\x04\xa5\x0f\x04:\x1aS\x20The\x20maximum\x20length\x20of\x20a\x20cus\
    tom\x20attribute\x20value\x20included\x20in\x20a\n\x20NotificationConfig\
    .\n\n\x0f\n\x07\x04>\x04\0\x02\x0c\x01\x12\x04\xa5\x0f\x042\n\x0f\n\x07\
    \x04>\x04\0\x02\x0c\x02\x12\x04\xa5\x0f59\nK\n\x06\x04>\x04\0\x02\r\x12\
    \x04\xa8\x0f\x04\"\x1a;\x20The\x20maximum\x20number\x20of\x20key/value\
    \x20entries\x20per\x20bucket\x20label.\n\n\x0f\n\x07\x04>\x04\0\x02\r\
    \x01\x12\x04\xa8\x0f\x04\x1c\n\x0f\n\x07\x04>\x04\0\x02\r\x02\x12\x04\
    \xa8\x0f\x1f!\nZ\n\x06\x04>\x04\0\x02\x0e\x12\x04\xac\x0f\x04%\x1aJ\x20T\
    he\x20maximum\x20character\x20length\x20of\x20the\x20key\x20or\x20value\
    \x20in\x20a\x20bucket\n\x20label\x20map.\n\n\x0f\n\x07\x04>\x04\0\x02\
    \x0e\x01\x12\x04\xac\x0f\x04\x1f\n\x0f\n\x07\x04>\x04\0\x02\x0e\x02\x12\
    \x04\xac\x0f\"$\nS\n\x06\x04>\x04\0\x02\x0f\x12\x04\xb0\x0f\x04%\x1aC\
    \x20The\x20maximum\x20byte\x20size\x20of\x20the\x20key\x20or\x20value\
    \x20in\x20a\x20bucket\x20label\n\x20map.\n\n\x0f\n\x07\x04>\x04\0\x02\
    \x0f\x01\x12\x04\xb0\x0f\x04\x1e\n\x0f\n\x07\x04>\x04\0\x02\x0f\x02\x12\
    \x04\xb0\x0f!$\nc\n\x06\x04>\x04\0\x02\x10\x12\x04\xb4\x0f\x045\x1aS\x20\
    The\x20maximum\x20number\x20of\x20object\x20IDs\x20that\x20can\x20be\x20\
    included\x20in\x20a\n\x20DeleteObjectsRequest.\n\n\x0f\n\x07\x04>\x04\0\
    \x02\x10\x01\x12\x04\xb4\x0f\x04-\n\x0f\n\x07\x04>\x04\0\x02\x10\x02\x12\
    \x04\xb4\x0f04\nw\n\x06\x04>\x04\0\x02\x11\x12\x04\xb8\x0f\x04$\x1ag\x20\
    The\x20maximum\x20number\x20of\x20days\x20for\x20which\x20a\x20token\x20\
    returned\x20by\x20the\n\x20GetListObjectsSplitPoints\x20RPC\x20is\x20val\
    id.\n\n\x0f\n\x07\x04>\x04\0\x02\x11\x01\x12\x04\xb8\x0f\x04\x1e\n\x0f\n\
    \x07\x04>\x04\0\x02\x11\x02\x12\x04\xb8\x0f!#b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
