// This file is generated by rust-protobuf 2.7.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/pubsub/v1/pubsub.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_7_0;

#[derive(PartialEq,Clone,Default)]
pub struct MessageStoragePolicy {
    // message fields
    pub allowed_persistence_regions: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessageStoragePolicy {
    fn default() -> &'a MessageStoragePolicy {
        <MessageStoragePolicy as ::protobuf::Message>::default_instance()
    }
}

impl MessageStoragePolicy {
    pub fn new() -> MessageStoragePolicy {
        ::std::default::Default::default()
    }

    // repeated string allowed_persistence_regions = 1;


    pub fn get_allowed_persistence_regions(&self) -> &[::std::string::String] {
        &self.allowed_persistence_regions
    }
    pub fn clear_allowed_persistence_regions(&mut self) {
        self.allowed_persistence_regions.clear();
    }

    // Param is passed by value, moved
    pub fn set_allowed_persistence_regions(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.allowed_persistence_regions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allowed_persistence_regions(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.allowed_persistence_regions
    }

    // Take field
    pub fn take_allowed_persistence_regions(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.allowed_persistence_regions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MessageStoragePolicy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.allowed_persistence_regions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.allowed_persistence_regions {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.allowed_persistence_regions {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageStoragePolicy {
        MessageStoragePolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "allowed_persistence_regions",
                    |m: &MessageStoragePolicy| { &m.allowed_persistence_regions },
                    |m: &mut MessageStoragePolicy| { &mut m.allowed_persistence_regions },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MessageStoragePolicy>(
                    "MessageStoragePolicy",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessageStoragePolicy {
        static mut instance: ::protobuf::lazy::Lazy<MessageStoragePolicy> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MessageStoragePolicy,
        };
        unsafe {
            instance.get(MessageStoragePolicy::new)
        }
    }
}

impl ::protobuf::Clear for MessageStoragePolicy {
    fn clear(&mut self) {
        self.allowed_persistence_regions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageStoragePolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageStoragePolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Topic {
    // message fields
    pub name: ::std::string::String,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub message_storage_policy: ::protobuf::SingularPtrField<MessageStoragePolicy>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Topic {
    fn default() -> &'a Topic {
        <Topic as ::protobuf::Message>::default_instance()
    }
}

impl Topic {
    pub fn new() -> Topic {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .google.pubsub.v1.Topic.LabelsEntry labels = 2;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }

    // .google.pubsub.v1.MessageStoragePolicy message_storage_policy = 3;


    pub fn get_message_storage_policy(&self) -> &MessageStoragePolicy {
        self.message_storage_policy.as_ref().unwrap_or_else(|| MessageStoragePolicy::default_instance())
    }
    pub fn clear_message_storage_policy(&mut self) {
        self.message_storage_policy.clear();
    }

    pub fn has_message_storage_policy(&self) -> bool {
        self.message_storage_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_storage_policy(&mut self, v: MessageStoragePolicy) {
        self.message_storage_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_storage_policy(&mut self) -> &mut MessageStoragePolicy {
        if self.message_storage_policy.is_none() {
            self.message_storage_policy.set_default();
        }
        self.message_storage_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_storage_policy(&mut self) -> MessageStoragePolicy {
        self.message_storage_policy.take().unwrap_or_else(|| MessageStoragePolicy::new())
    }
}

impl ::protobuf::Message for Topic {
    fn is_initialized(&self) -> bool {
        for v in &self.message_storage_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message_storage_policy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.labels);
        if let Some(ref v) = self.message_storage_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.labels, os)?;
        if let Some(ref v) = self.message_storage_policy.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Topic {
        Topic::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Topic| { &m.name },
                    |m: &mut Topic| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "labels",
                    |m: &Topic| { &m.labels },
                    |m: &mut Topic| { &mut m.labels },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageStoragePolicy>>(
                    "message_storage_policy",
                    |m: &Topic| { &m.message_storage_policy },
                    |m: &mut Topic| { &mut m.message_storage_policy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Topic>(
                    "Topic",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Topic {
        static mut instance: ::protobuf::lazy::Lazy<Topic> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Topic,
        };
        unsafe {
            instance.get(Topic::new)
        }
    }
}

impl ::protobuf::Clear for Topic {
    fn clear(&mut self) {
        self.name.clear();
        self.labels.clear();
        self.message_storage_policy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Topic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Topic {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PubsubMessage {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub attributes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub message_id: ::std::string::String,
    pub publish_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PubsubMessage {
    fn default() -> &'a PubsubMessage {
        <PubsubMessage as ::protobuf::Message>::default_instance()
    }
}

impl PubsubMessage {
    pub fn new() -> PubsubMessage {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // repeated .google.pubsub.v1.PubsubMessage.AttributesEntry attributes = 2;


    pub fn get_attributes(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.attributes
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attributes(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.attributes
    }

    // Take field
    pub fn take_attributes(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.attributes, ::std::collections::HashMap::new())
    }

    // string message_id = 3;


    pub fn get_message_id(&self) -> &str {
        &self.message_id
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::std::string::String) {
        self.message_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut ::std::string::String {
        &mut self.message_id
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message_id, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp publish_time = 4;


    pub fn get_publish_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.publish_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_publish_time(&mut self) {
        self.publish_time.clear();
    }

    pub fn has_publish_time(&self) -> bool {
        self.publish_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publish_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.publish_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_publish_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.publish_time.is_none() {
            self.publish_time.set_default();
        }
        self.publish_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_publish_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.publish_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for PubsubMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.publish_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.attributes)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.publish_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.attributes);
        if !self.message_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message_id);
        }
        if let Some(ref v) = self.publish_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.attributes, os)?;
        if !self.message_id.is_empty() {
            os.write_string(3, &self.message_id)?;
        }
        if let Some(ref v) = self.publish_time.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PubsubMessage {
        PubsubMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &PubsubMessage| { &m.data },
                    |m: &mut PubsubMessage| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "attributes",
                    |m: &PubsubMessage| { &m.attributes },
                    |m: &mut PubsubMessage| { &mut m.attributes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message_id",
                    |m: &PubsubMessage| { &m.message_id },
                    |m: &mut PubsubMessage| { &mut m.message_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "publish_time",
                    |m: &PubsubMessage| { &m.publish_time },
                    |m: &mut PubsubMessage| { &mut m.publish_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PubsubMessage>(
                    "PubsubMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PubsubMessage {
        static mut instance: ::protobuf::lazy::Lazy<PubsubMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PubsubMessage,
        };
        unsafe {
            instance.get(PubsubMessage::new)
        }
    }
}

impl ::protobuf::Clear for PubsubMessage {
    fn clear(&mut self) {
        self.data.clear();
        self.attributes.clear();
        self.message_id.clear();
        self.publish_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PubsubMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PubsubMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTopicRequest {
    // message fields
    pub topic: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTopicRequest {
    fn default() -> &'a GetTopicRequest {
        <GetTopicRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTopicRequest {
    pub fn new() -> GetTopicRequest {
        ::std::default::Default::default()
    }

    // string topic = 1;


    pub fn get_topic(&self) -> &str {
        &self.topic
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        &mut self.topic
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.topic, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetTopicRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.topic)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.topic);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.topic.is_empty() {
            os.write_string(1, &self.topic)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTopicRequest {
        GetTopicRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "topic",
                    |m: &GetTopicRequest| { &m.topic },
                    |m: &mut GetTopicRequest| { &mut m.topic },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetTopicRequest>(
                    "GetTopicRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetTopicRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetTopicRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetTopicRequest,
        };
        unsafe {
            instance.get(GetTopicRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetTopicRequest {
    fn clear(&mut self) {
        self.topic.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTopicRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTopicRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateTopicRequest {
    // message fields
    pub topic: ::protobuf::SingularPtrField<Topic>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateTopicRequest {
    fn default() -> &'a UpdateTopicRequest {
        <UpdateTopicRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateTopicRequest {
    pub fn new() -> UpdateTopicRequest {
        ::std::default::Default::default()
    }

    // .google.pubsub.v1.Topic topic = 1;


    pub fn get_topic(&self) -> &Topic {
        self.topic.as_ref().unwrap_or_else(|| Topic::default_instance())
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    pub fn has_topic(&self) -> bool {
        self.topic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: Topic) {
        self.topic = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut Topic {
        if self.topic.is_none() {
            self.topic.set_default();
        }
        self.topic.as_mut().unwrap()
    }

    // Take field
    pub fn take_topic(&mut self) -> Topic {
        self.topic.take().unwrap_or_else(|| Topic::new())
    }

    // .google.protobuf.FieldMask update_mask = 2;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for UpdateTopicRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.topic {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.topic)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.topic.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.topic.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateTopicRequest {
        UpdateTopicRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Topic>>(
                    "topic",
                    |m: &UpdateTopicRequest| { &m.topic },
                    |m: &mut UpdateTopicRequest| { &mut m.topic },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                    "update_mask",
                    |m: &UpdateTopicRequest| { &m.update_mask },
                    |m: &mut UpdateTopicRequest| { &mut m.update_mask },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateTopicRequest>(
                    "UpdateTopicRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateTopicRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdateTopicRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateTopicRequest,
        };
        unsafe {
            instance.get(UpdateTopicRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdateTopicRequest {
    fn clear(&mut self) {
        self.topic.clear();
        self.update_mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateTopicRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateTopicRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PublishRequest {
    // message fields
    pub topic: ::std::string::String,
    pub messages: ::protobuf::RepeatedField<PubsubMessage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PublishRequest {
    fn default() -> &'a PublishRequest {
        <PublishRequest as ::protobuf::Message>::default_instance()
    }
}

impl PublishRequest {
    pub fn new() -> PublishRequest {
        ::std::default::Default::default()
    }

    // string topic = 1;


    pub fn get_topic(&self) -> &str {
        &self.topic
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        &mut self.topic
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.topic, ::std::string::String::new())
    }

    // repeated .google.pubsub.v1.PubsubMessage messages = 2;


    pub fn get_messages(&self) -> &[PubsubMessage] {
        &self.messages
    }
    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::protobuf::RepeatedField<PubsubMessage>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::protobuf::RepeatedField<PubsubMessage> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::protobuf::RepeatedField<PubsubMessage> {
        ::std::mem::replace(&mut self.messages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PublishRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.messages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.topic)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.messages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.topic);
        }
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.topic.is_empty() {
            os.write_string(1, &self.topic)?;
        }
        for v in &self.messages {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PublishRequest {
        PublishRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "topic",
                    |m: &PublishRequest| { &m.topic },
                    |m: &mut PublishRequest| { &mut m.topic },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PubsubMessage>>(
                    "messages",
                    |m: &PublishRequest| { &m.messages },
                    |m: &mut PublishRequest| { &mut m.messages },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PublishRequest>(
                    "PublishRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PublishRequest {
        static mut instance: ::protobuf::lazy::Lazy<PublishRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PublishRequest,
        };
        unsafe {
            instance.get(PublishRequest::new)
        }
    }
}

impl ::protobuf::Clear for PublishRequest {
    fn clear(&mut self) {
        self.topic.clear();
        self.messages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PublishRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PublishRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PublishResponse {
    // message fields
    pub message_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PublishResponse {
    fn default() -> &'a PublishResponse {
        <PublishResponse as ::protobuf::Message>::default_instance()
    }
}

impl PublishResponse {
    pub fn new() -> PublishResponse {
        ::std::default::Default::default()
    }

    // repeated string message_ids = 1;


    pub fn get_message_ids(&self) -> &[::std::string::String] {
        &self.message_ids
    }
    pub fn clear_message_ids(&mut self) {
        self.message_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.message_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_message_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.message_ids
    }

    // Take field
    pub fn take_message_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.message_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PublishResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.message_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.message_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.message_ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PublishResponse {
        PublishResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message_ids",
                    |m: &PublishResponse| { &m.message_ids },
                    |m: &mut PublishResponse| { &mut m.message_ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PublishResponse>(
                    "PublishResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PublishResponse {
        static mut instance: ::protobuf::lazy::Lazy<PublishResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PublishResponse,
        };
        unsafe {
            instance.get(PublishResponse::new)
        }
    }
}

impl ::protobuf::Clear for PublishResponse {
    fn clear(&mut self) {
        self.message_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PublishResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PublishResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListTopicsRequest {
    // message fields
    pub project: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListTopicsRequest {
    fn default() -> &'a ListTopicsRequest {
        <ListTopicsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListTopicsRequest {
    pub fn new() -> ListTopicsRequest {
        ::std::default::Default::default()
    }

    // string project = 1;


    pub fn get_project(&self) -> &str {
        &self.project
    }
    pub fn clear_project(&mut self) {
        self.project.clear();
    }

    // Param is passed by value, moved
    pub fn set_project(&mut self, v: ::std::string::String) {
        self.project = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project(&mut self) -> &mut ::std::string::String {
        &mut self.project
    }

    // Take field
    pub fn take_project(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListTopicsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.project.is_empty() {
            os.write_string(1, &self.project)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListTopicsRequest {
        ListTopicsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "project",
                    |m: &ListTopicsRequest| { &m.project },
                    |m: &mut ListTopicsRequest| { &mut m.project },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "page_size",
                    |m: &ListTopicsRequest| { &m.page_size },
                    |m: &mut ListTopicsRequest| { &mut m.page_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "page_token",
                    |m: &ListTopicsRequest| { &m.page_token },
                    |m: &mut ListTopicsRequest| { &mut m.page_token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListTopicsRequest>(
                    "ListTopicsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListTopicsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListTopicsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListTopicsRequest,
        };
        unsafe {
            instance.get(ListTopicsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListTopicsRequest {
    fn clear(&mut self) {
        self.project.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListTopicsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTopicsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListTopicsResponse {
    // message fields
    pub topics: ::protobuf::RepeatedField<Topic>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListTopicsResponse {
    fn default() -> &'a ListTopicsResponse {
        <ListTopicsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListTopicsResponse {
    pub fn new() -> ListTopicsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.pubsub.v1.Topic topics = 1;


    pub fn get_topics(&self) -> &[Topic] {
        &self.topics
    }
    pub fn clear_topics(&mut self) {
        self.topics.clear();
    }

    // Param is passed by value, moved
    pub fn set_topics(&mut self, v: ::protobuf::RepeatedField<Topic>) {
        self.topics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_topics(&mut self) -> &mut ::protobuf::RepeatedField<Topic> {
        &mut self.topics
    }

    // Take field
    pub fn take_topics(&mut self) -> ::protobuf::RepeatedField<Topic> {
        ::std::mem::replace(&mut self.topics, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListTopicsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.topics {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.topics)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.topics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.topics {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListTopicsResponse {
        ListTopicsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Topic>>(
                    "topics",
                    |m: &ListTopicsResponse| { &m.topics },
                    |m: &mut ListTopicsResponse| { &mut m.topics },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "next_page_token",
                    |m: &ListTopicsResponse| { &m.next_page_token },
                    |m: &mut ListTopicsResponse| { &mut m.next_page_token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListTopicsResponse>(
                    "ListTopicsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListTopicsResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListTopicsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListTopicsResponse,
        };
        unsafe {
            instance.get(ListTopicsResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListTopicsResponse {
    fn clear(&mut self) {
        self.topics.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListTopicsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTopicsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListTopicSubscriptionsRequest {
    // message fields
    pub topic: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListTopicSubscriptionsRequest {
    fn default() -> &'a ListTopicSubscriptionsRequest {
        <ListTopicSubscriptionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListTopicSubscriptionsRequest {
    pub fn new() -> ListTopicSubscriptionsRequest {
        ::std::default::Default::default()
    }

    // string topic = 1;


    pub fn get_topic(&self) -> &str {
        &self.topic
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        &mut self.topic
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.topic, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListTopicSubscriptionsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.topic)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.topic);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.topic.is_empty() {
            os.write_string(1, &self.topic)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListTopicSubscriptionsRequest {
        ListTopicSubscriptionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "topic",
                    |m: &ListTopicSubscriptionsRequest| { &m.topic },
                    |m: &mut ListTopicSubscriptionsRequest| { &mut m.topic },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "page_size",
                    |m: &ListTopicSubscriptionsRequest| { &m.page_size },
                    |m: &mut ListTopicSubscriptionsRequest| { &mut m.page_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "page_token",
                    |m: &ListTopicSubscriptionsRequest| { &m.page_token },
                    |m: &mut ListTopicSubscriptionsRequest| { &mut m.page_token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListTopicSubscriptionsRequest>(
                    "ListTopicSubscriptionsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListTopicSubscriptionsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListTopicSubscriptionsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListTopicSubscriptionsRequest,
        };
        unsafe {
            instance.get(ListTopicSubscriptionsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListTopicSubscriptionsRequest {
    fn clear(&mut self) {
        self.topic.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListTopicSubscriptionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTopicSubscriptionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListTopicSubscriptionsResponse {
    // message fields
    pub subscriptions: ::protobuf::RepeatedField<::std::string::String>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListTopicSubscriptionsResponse {
    fn default() -> &'a ListTopicSubscriptionsResponse {
        <ListTopicSubscriptionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListTopicSubscriptionsResponse {
    pub fn new() -> ListTopicSubscriptionsResponse {
        ::std::default::Default::default()
    }

    // repeated string subscriptions = 1;


    pub fn get_subscriptions(&self) -> &[::std::string::String] {
        &self.subscriptions
    }
    pub fn clear_subscriptions(&mut self) {
        self.subscriptions.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscriptions(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.subscriptions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subscriptions(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.subscriptions
    }

    // Take field
    pub fn take_subscriptions(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.subscriptions, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListTopicSubscriptionsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.subscriptions)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.subscriptions {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.subscriptions {
            os.write_string(1, &v)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListTopicSubscriptionsResponse {
        ListTopicSubscriptionsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "subscriptions",
                    |m: &ListTopicSubscriptionsResponse| { &m.subscriptions },
                    |m: &mut ListTopicSubscriptionsResponse| { &mut m.subscriptions },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "next_page_token",
                    |m: &ListTopicSubscriptionsResponse| { &m.next_page_token },
                    |m: &mut ListTopicSubscriptionsResponse| { &mut m.next_page_token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListTopicSubscriptionsResponse>(
                    "ListTopicSubscriptionsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListTopicSubscriptionsResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListTopicSubscriptionsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListTopicSubscriptionsResponse,
        };
        unsafe {
            instance.get(ListTopicSubscriptionsResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListTopicSubscriptionsResponse {
    fn clear(&mut self) {
        self.subscriptions.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListTopicSubscriptionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTopicSubscriptionsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListTopicSnapshotsRequest {
    // message fields
    pub topic: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListTopicSnapshotsRequest {
    fn default() -> &'a ListTopicSnapshotsRequest {
        <ListTopicSnapshotsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListTopicSnapshotsRequest {
    pub fn new() -> ListTopicSnapshotsRequest {
        ::std::default::Default::default()
    }

    // string topic = 1;


    pub fn get_topic(&self) -> &str {
        &self.topic
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        &mut self.topic
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.topic, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListTopicSnapshotsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.topic)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.topic);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.topic.is_empty() {
            os.write_string(1, &self.topic)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListTopicSnapshotsRequest {
        ListTopicSnapshotsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "topic",
                    |m: &ListTopicSnapshotsRequest| { &m.topic },
                    |m: &mut ListTopicSnapshotsRequest| { &mut m.topic },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "page_size",
                    |m: &ListTopicSnapshotsRequest| { &m.page_size },
                    |m: &mut ListTopicSnapshotsRequest| { &mut m.page_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "page_token",
                    |m: &ListTopicSnapshotsRequest| { &m.page_token },
                    |m: &mut ListTopicSnapshotsRequest| { &mut m.page_token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListTopicSnapshotsRequest>(
                    "ListTopicSnapshotsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListTopicSnapshotsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListTopicSnapshotsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListTopicSnapshotsRequest,
        };
        unsafe {
            instance.get(ListTopicSnapshotsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListTopicSnapshotsRequest {
    fn clear(&mut self) {
        self.topic.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListTopicSnapshotsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTopicSnapshotsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListTopicSnapshotsResponse {
    // message fields
    pub snapshots: ::protobuf::RepeatedField<::std::string::String>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListTopicSnapshotsResponse {
    fn default() -> &'a ListTopicSnapshotsResponse {
        <ListTopicSnapshotsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListTopicSnapshotsResponse {
    pub fn new() -> ListTopicSnapshotsResponse {
        ::std::default::Default::default()
    }

    // repeated string snapshots = 1;


    pub fn get_snapshots(&self) -> &[::std::string::String] {
        &self.snapshots
    }
    pub fn clear_snapshots(&mut self) {
        self.snapshots.clear();
    }

    // Param is passed by value, moved
    pub fn set_snapshots(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.snapshots = v;
    }

    // Mutable pointer to the field.
    pub fn mut_snapshots(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.snapshots
    }

    // Take field
    pub fn take_snapshots(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.snapshots, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListTopicSnapshotsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.snapshots)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.snapshots {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.snapshots {
            os.write_string(1, &v)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListTopicSnapshotsResponse {
        ListTopicSnapshotsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshots",
                    |m: &ListTopicSnapshotsResponse| { &m.snapshots },
                    |m: &mut ListTopicSnapshotsResponse| { &mut m.snapshots },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "next_page_token",
                    |m: &ListTopicSnapshotsResponse| { &m.next_page_token },
                    |m: &mut ListTopicSnapshotsResponse| { &mut m.next_page_token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListTopicSnapshotsResponse>(
                    "ListTopicSnapshotsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListTopicSnapshotsResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListTopicSnapshotsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListTopicSnapshotsResponse,
        };
        unsafe {
            instance.get(ListTopicSnapshotsResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListTopicSnapshotsResponse {
    fn clear(&mut self) {
        self.snapshots.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListTopicSnapshotsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTopicSnapshotsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteTopicRequest {
    // message fields
    pub topic: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteTopicRequest {
    fn default() -> &'a DeleteTopicRequest {
        <DeleteTopicRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteTopicRequest {
    pub fn new() -> DeleteTopicRequest {
        ::std::default::Default::default()
    }

    // string topic = 1;


    pub fn get_topic(&self) -> &str {
        &self.topic
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        &mut self.topic
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.topic, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteTopicRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.topic)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.topic);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.topic.is_empty() {
            os.write_string(1, &self.topic)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteTopicRequest {
        DeleteTopicRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "topic",
                    |m: &DeleteTopicRequest| { &m.topic },
                    |m: &mut DeleteTopicRequest| { &mut m.topic },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteTopicRequest>(
                    "DeleteTopicRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteTopicRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteTopicRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteTopicRequest,
        };
        unsafe {
            instance.get(DeleteTopicRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteTopicRequest {
    fn clear(&mut self) {
        self.topic.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteTopicRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteTopicRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Subscription {
    // message fields
    pub name: ::std::string::String,
    pub topic: ::std::string::String,
    pub push_config: ::protobuf::SingularPtrField<PushConfig>,
    pub ack_deadline_seconds: i32,
    pub retain_acked_messages: bool,
    pub message_retention_duration: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub expiration_policy: ::protobuf::SingularPtrField<ExpirationPolicy>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Subscription {
    fn default() -> &'a Subscription {
        <Subscription as ::protobuf::Message>::default_instance()
    }
}

impl Subscription {
    pub fn new() -> Subscription {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string topic = 2;


    pub fn get_topic(&self) -> &str {
        &self.topic
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        &mut self.topic
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.topic, ::std::string::String::new())
    }

    // .google.pubsub.v1.PushConfig push_config = 4;


    pub fn get_push_config(&self) -> &PushConfig {
        self.push_config.as_ref().unwrap_or_else(|| PushConfig::default_instance())
    }
    pub fn clear_push_config(&mut self) {
        self.push_config.clear();
    }

    pub fn has_push_config(&self) -> bool {
        self.push_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_push_config(&mut self, v: PushConfig) {
        self.push_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_push_config(&mut self) -> &mut PushConfig {
        if self.push_config.is_none() {
            self.push_config.set_default();
        }
        self.push_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_push_config(&mut self) -> PushConfig {
        self.push_config.take().unwrap_or_else(|| PushConfig::new())
    }

    // int32 ack_deadline_seconds = 5;


    pub fn get_ack_deadline_seconds(&self) -> i32 {
        self.ack_deadline_seconds
    }
    pub fn clear_ack_deadline_seconds(&mut self) {
        self.ack_deadline_seconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_ack_deadline_seconds(&mut self, v: i32) {
        self.ack_deadline_seconds = v;
    }

    // bool retain_acked_messages = 7;


    pub fn get_retain_acked_messages(&self) -> bool {
        self.retain_acked_messages
    }
    pub fn clear_retain_acked_messages(&mut self) {
        self.retain_acked_messages = false;
    }

    // Param is passed by value, moved
    pub fn set_retain_acked_messages(&mut self, v: bool) {
        self.retain_acked_messages = v;
    }

    // .google.protobuf.Duration message_retention_duration = 8;


    pub fn get_message_retention_duration(&self) -> &::protobuf::well_known_types::Duration {
        self.message_retention_duration.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Duration::default_instance())
    }
    pub fn clear_message_retention_duration(&mut self) {
        self.message_retention_duration.clear();
    }

    pub fn has_message_retention_duration(&self) -> bool {
        self.message_retention_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_retention_duration(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.message_retention_duration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_retention_duration(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.message_retention_duration.is_none() {
            self.message_retention_duration.set_default();
        }
        self.message_retention_duration.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_retention_duration(&mut self) -> ::protobuf::well_known_types::Duration {
        self.message_retention_duration.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // repeated .google.pubsub.v1.Subscription.LabelsEntry labels = 9;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }

    // .google.pubsub.v1.ExpirationPolicy expiration_policy = 11;


    pub fn get_expiration_policy(&self) -> &ExpirationPolicy {
        self.expiration_policy.as_ref().unwrap_or_else(|| ExpirationPolicy::default_instance())
    }
    pub fn clear_expiration_policy(&mut self) {
        self.expiration_policy.clear();
    }

    pub fn has_expiration_policy(&self) -> bool {
        self.expiration_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_policy(&mut self, v: ExpirationPolicy) {
        self.expiration_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expiration_policy(&mut self) -> &mut ExpirationPolicy {
        if self.expiration_policy.is_none() {
            self.expiration_policy.set_default();
        }
        self.expiration_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_expiration_policy(&mut self) -> ExpirationPolicy {
        self.expiration_policy.take().unwrap_or_else(|| ExpirationPolicy::new())
    }
}

impl ::protobuf::Message for Subscription {
    fn is_initialized(&self) -> bool {
        for v in &self.push_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.message_retention_duration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.expiration_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.topic)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.push_config)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ack_deadline_seconds = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.retain_acked_messages = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message_retention_duration)?;
                },
                9 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expiration_policy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.topic);
        }
        if let Some(ref v) = self.push_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ack_deadline_seconds != 0 {
            my_size += ::protobuf::rt::value_size(5, self.ack_deadline_seconds, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.retain_acked_messages != false {
            my_size += 2;
        }
        if let Some(ref v) = self.message_retention_duration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(9, &self.labels);
        if let Some(ref v) = self.expiration_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.topic.is_empty() {
            os.write_string(2, &self.topic)?;
        }
        if let Some(ref v) = self.push_config.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ack_deadline_seconds != 0 {
            os.write_int32(5, self.ack_deadline_seconds)?;
        }
        if self.retain_acked_messages != false {
            os.write_bool(7, self.retain_acked_messages)?;
        }
        if let Some(ref v) = self.message_retention_duration.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(9, &self.labels, os)?;
        if let Some(ref v) = self.expiration_policy.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Subscription {
        Subscription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Subscription| { &m.name },
                    |m: &mut Subscription| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "topic",
                    |m: &Subscription| { &m.topic },
                    |m: &mut Subscription| { &mut m.topic },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PushConfig>>(
                    "push_config",
                    |m: &Subscription| { &m.push_config },
                    |m: &mut Subscription| { &mut m.push_config },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ack_deadline_seconds",
                    |m: &Subscription| { &m.ack_deadline_seconds },
                    |m: &mut Subscription| { &mut m.ack_deadline_seconds },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "retain_acked_messages",
                    |m: &Subscription| { &m.retain_acked_messages },
                    |m: &mut Subscription| { &mut m.retain_acked_messages },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                    "message_retention_duration",
                    |m: &Subscription| { &m.message_retention_duration },
                    |m: &mut Subscription| { &mut m.message_retention_duration },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "labels",
                    |m: &Subscription| { &m.labels },
                    |m: &mut Subscription| { &mut m.labels },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExpirationPolicy>>(
                    "expiration_policy",
                    |m: &Subscription| { &m.expiration_policy },
                    |m: &mut Subscription| { &mut m.expiration_policy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Subscription>(
                    "Subscription",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Subscription {
        static mut instance: ::protobuf::lazy::Lazy<Subscription> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Subscription,
        };
        unsafe {
            instance.get(Subscription::new)
        }
    }
}

impl ::protobuf::Clear for Subscription {
    fn clear(&mut self) {
        self.name.clear();
        self.topic.clear();
        self.push_config.clear();
        self.ack_deadline_seconds = 0;
        self.retain_acked_messages = false;
        self.message_retention_duration.clear();
        self.labels.clear();
        self.expiration_policy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Subscription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Subscription {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExpirationPolicy {
    // message fields
    pub ttl: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExpirationPolicy {
    fn default() -> &'a ExpirationPolicy {
        <ExpirationPolicy as ::protobuf::Message>::default_instance()
    }
}

impl ExpirationPolicy {
    pub fn new() -> ExpirationPolicy {
        ::std::default::Default::default()
    }

    // .google.protobuf.Duration ttl = 1;


    pub fn get_ttl(&self) -> &::protobuf::well_known_types::Duration {
        self.ttl.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Duration::default_instance())
    }
    pub fn clear_ttl(&mut self) {
        self.ttl.clear();
    }

    pub fn has_ttl(&self) -> bool {
        self.ttl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ttl(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.ttl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ttl(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.ttl.is_none() {
            self.ttl.set_default();
        }
        self.ttl.as_mut().unwrap()
    }

    // Take field
    pub fn take_ttl(&mut self) -> ::protobuf::well_known_types::Duration {
        self.ttl.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for ExpirationPolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.ttl {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ttl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ttl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ttl.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExpirationPolicy {
        ExpirationPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                    "ttl",
                    |m: &ExpirationPolicy| { &m.ttl },
                    |m: &mut ExpirationPolicy| { &mut m.ttl },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExpirationPolicy>(
                    "ExpirationPolicy",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExpirationPolicy {
        static mut instance: ::protobuf::lazy::Lazy<ExpirationPolicy> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExpirationPolicy,
        };
        unsafe {
            instance.get(ExpirationPolicy::new)
        }
    }
}

impl ::protobuf::Clear for ExpirationPolicy {
    fn clear(&mut self) {
        self.ttl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExpirationPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExpirationPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PushConfig {
    // message fields
    pub push_endpoint: ::std::string::String,
    pub attributes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PushConfig {
    fn default() -> &'a PushConfig {
        <PushConfig as ::protobuf::Message>::default_instance()
    }
}

impl PushConfig {
    pub fn new() -> PushConfig {
        ::std::default::Default::default()
    }

    // string push_endpoint = 1;


    pub fn get_push_endpoint(&self) -> &str {
        &self.push_endpoint
    }
    pub fn clear_push_endpoint(&mut self) {
        self.push_endpoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_push_endpoint(&mut self, v: ::std::string::String) {
        self.push_endpoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_push_endpoint(&mut self) -> &mut ::std::string::String {
        &mut self.push_endpoint
    }

    // Take field
    pub fn take_push_endpoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.push_endpoint, ::std::string::String::new())
    }

    // repeated .google.pubsub.v1.PushConfig.AttributesEntry attributes = 2;


    pub fn get_attributes(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.attributes
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attributes(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.attributes
    }

    // Take field
    pub fn take_attributes(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.attributes, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for PushConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.push_endpoint)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.attributes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.push_endpoint.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.push_endpoint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.attributes);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.push_endpoint.is_empty() {
            os.write_string(1, &self.push_endpoint)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.attributes, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PushConfig {
        PushConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "push_endpoint",
                    |m: &PushConfig| { &m.push_endpoint },
                    |m: &mut PushConfig| { &mut m.push_endpoint },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "attributes",
                    |m: &PushConfig| { &m.attributes },
                    |m: &mut PushConfig| { &mut m.attributes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PushConfig>(
                    "PushConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PushConfig {
        static mut instance: ::protobuf::lazy::Lazy<PushConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PushConfig,
        };
        unsafe {
            instance.get(PushConfig::new)
        }
    }
}

impl ::protobuf::Clear for PushConfig {
    fn clear(&mut self) {
        self.push_endpoint.clear();
        self.attributes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PushConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PushConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReceivedMessage {
    // message fields
    pub ack_id: ::std::string::String,
    pub message: ::protobuf::SingularPtrField<PubsubMessage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReceivedMessage {
    fn default() -> &'a ReceivedMessage {
        <ReceivedMessage as ::protobuf::Message>::default_instance()
    }
}

impl ReceivedMessage {
    pub fn new() -> ReceivedMessage {
        ::std::default::Default::default()
    }

    // string ack_id = 1;


    pub fn get_ack_id(&self) -> &str {
        &self.ack_id
    }
    pub fn clear_ack_id(&mut self) {
        self.ack_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_id(&mut self, v: ::std::string::String) {
        self.ack_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ack_id(&mut self) -> &mut ::std::string::String {
        &mut self.ack_id
    }

    // Take field
    pub fn take_ack_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ack_id, ::std::string::String::new())
    }

    // .google.pubsub.v1.PubsubMessage message = 2;


    pub fn get_message(&self) -> &PubsubMessage {
        self.message.as_ref().unwrap_or_else(|| PubsubMessage::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: PubsubMessage) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut PubsubMessage {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> PubsubMessage {
        self.message.take().unwrap_or_else(|| PubsubMessage::new())
    }
}

impl ::protobuf::Message for ReceivedMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ack_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ack_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ack_id);
        }
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.ack_id.is_empty() {
            os.write_string(1, &self.ack_id)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReceivedMessage {
        ReceivedMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ack_id",
                    |m: &ReceivedMessage| { &m.ack_id },
                    |m: &mut ReceivedMessage| { &mut m.ack_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PubsubMessage>>(
                    "message",
                    |m: &ReceivedMessage| { &m.message },
                    |m: &mut ReceivedMessage| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReceivedMessage>(
                    "ReceivedMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReceivedMessage {
        static mut instance: ::protobuf::lazy::Lazy<ReceivedMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReceivedMessage,
        };
        unsafe {
            instance.get(ReceivedMessage::new)
        }
    }
}

impl ::protobuf::Clear for ReceivedMessage {
    fn clear(&mut self) {
        self.ack_id.clear();
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReceivedMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReceivedMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSubscriptionRequest {
    // message fields
    pub subscription: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSubscriptionRequest {
    fn default() -> &'a GetSubscriptionRequest {
        <GetSubscriptionRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSubscriptionRequest {
    pub fn new() -> GetSubscriptionRequest {
        ::std::default::Default::default()
    }

    // string subscription = 1;


    pub fn get_subscription(&self) -> &str {
        &self.subscription
    }
    pub fn clear_subscription(&mut self) {
        self.subscription.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscription(&mut self, v: ::std::string::String) {
        self.subscription = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription(&mut self) -> &mut ::std::string::String {
        &mut self.subscription
    }

    // Take field
    pub fn take_subscription(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subscription, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetSubscriptionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subscription)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSubscriptionRequest {
        GetSubscriptionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "subscription",
                    |m: &GetSubscriptionRequest| { &m.subscription },
                    |m: &mut GetSubscriptionRequest| { &mut m.subscription },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetSubscriptionRequest>(
                    "GetSubscriptionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetSubscriptionRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetSubscriptionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetSubscriptionRequest,
        };
        unsafe {
            instance.get(GetSubscriptionRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetSubscriptionRequest {
    fn clear(&mut self) {
        self.subscription.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSubscriptionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSubscriptionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateSubscriptionRequest {
    // message fields
    pub subscription: ::protobuf::SingularPtrField<Subscription>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateSubscriptionRequest {
    fn default() -> &'a UpdateSubscriptionRequest {
        <UpdateSubscriptionRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateSubscriptionRequest {
    pub fn new() -> UpdateSubscriptionRequest {
        ::std::default::Default::default()
    }

    // .google.pubsub.v1.Subscription subscription = 1;


    pub fn get_subscription(&self) -> &Subscription {
        self.subscription.as_ref().unwrap_or_else(|| Subscription::default_instance())
    }
    pub fn clear_subscription(&mut self) {
        self.subscription.clear();
    }

    pub fn has_subscription(&self) -> bool {
        self.subscription.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscription(&mut self, v: Subscription) {
        self.subscription = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription(&mut self) -> &mut Subscription {
        if self.subscription.is_none() {
            self.subscription.set_default();
        }
        self.subscription.as_mut().unwrap()
    }

    // Take field
    pub fn take_subscription(&mut self) -> Subscription {
        self.subscription.take().unwrap_or_else(|| Subscription::new())
    }

    // .google.protobuf.FieldMask update_mask = 2;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for UpdateSubscriptionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.subscription {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.subscription)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.subscription.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.subscription.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateSubscriptionRequest {
        UpdateSubscriptionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Subscription>>(
                    "subscription",
                    |m: &UpdateSubscriptionRequest| { &m.subscription },
                    |m: &mut UpdateSubscriptionRequest| { &mut m.subscription },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                    "update_mask",
                    |m: &UpdateSubscriptionRequest| { &m.update_mask },
                    |m: &mut UpdateSubscriptionRequest| { &mut m.update_mask },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateSubscriptionRequest>(
                    "UpdateSubscriptionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateSubscriptionRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdateSubscriptionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateSubscriptionRequest,
        };
        unsafe {
            instance.get(UpdateSubscriptionRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdateSubscriptionRequest {
    fn clear(&mut self) {
        self.subscription.clear();
        self.update_mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateSubscriptionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateSubscriptionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListSubscriptionsRequest {
    // message fields
    pub project: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListSubscriptionsRequest {
    fn default() -> &'a ListSubscriptionsRequest {
        <ListSubscriptionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListSubscriptionsRequest {
    pub fn new() -> ListSubscriptionsRequest {
        ::std::default::Default::default()
    }

    // string project = 1;


    pub fn get_project(&self) -> &str {
        &self.project
    }
    pub fn clear_project(&mut self) {
        self.project.clear();
    }

    // Param is passed by value, moved
    pub fn set_project(&mut self, v: ::std::string::String) {
        self.project = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project(&mut self) -> &mut ::std::string::String {
        &mut self.project
    }

    // Take field
    pub fn take_project(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListSubscriptionsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.project.is_empty() {
            os.write_string(1, &self.project)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListSubscriptionsRequest {
        ListSubscriptionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "project",
                    |m: &ListSubscriptionsRequest| { &m.project },
                    |m: &mut ListSubscriptionsRequest| { &mut m.project },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "page_size",
                    |m: &ListSubscriptionsRequest| { &m.page_size },
                    |m: &mut ListSubscriptionsRequest| { &mut m.page_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "page_token",
                    |m: &ListSubscriptionsRequest| { &m.page_token },
                    |m: &mut ListSubscriptionsRequest| { &mut m.page_token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListSubscriptionsRequest>(
                    "ListSubscriptionsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListSubscriptionsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListSubscriptionsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListSubscriptionsRequest,
        };
        unsafe {
            instance.get(ListSubscriptionsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListSubscriptionsRequest {
    fn clear(&mut self) {
        self.project.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListSubscriptionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSubscriptionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListSubscriptionsResponse {
    // message fields
    pub subscriptions: ::protobuf::RepeatedField<Subscription>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListSubscriptionsResponse {
    fn default() -> &'a ListSubscriptionsResponse {
        <ListSubscriptionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListSubscriptionsResponse {
    pub fn new() -> ListSubscriptionsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.pubsub.v1.Subscription subscriptions = 1;


    pub fn get_subscriptions(&self) -> &[Subscription] {
        &self.subscriptions
    }
    pub fn clear_subscriptions(&mut self) {
        self.subscriptions.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscriptions(&mut self, v: ::protobuf::RepeatedField<Subscription>) {
        self.subscriptions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subscriptions(&mut self) -> &mut ::protobuf::RepeatedField<Subscription> {
        &mut self.subscriptions
    }

    // Take field
    pub fn take_subscriptions(&mut self) -> ::protobuf::RepeatedField<Subscription> {
        ::std::mem::replace(&mut self.subscriptions, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListSubscriptionsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.subscriptions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subscriptions)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.subscriptions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.subscriptions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListSubscriptionsResponse {
        ListSubscriptionsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Subscription>>(
                    "subscriptions",
                    |m: &ListSubscriptionsResponse| { &m.subscriptions },
                    |m: &mut ListSubscriptionsResponse| { &mut m.subscriptions },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "next_page_token",
                    |m: &ListSubscriptionsResponse| { &m.next_page_token },
                    |m: &mut ListSubscriptionsResponse| { &mut m.next_page_token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListSubscriptionsResponse>(
                    "ListSubscriptionsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListSubscriptionsResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListSubscriptionsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListSubscriptionsResponse,
        };
        unsafe {
            instance.get(ListSubscriptionsResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListSubscriptionsResponse {
    fn clear(&mut self) {
        self.subscriptions.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListSubscriptionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSubscriptionsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteSubscriptionRequest {
    // message fields
    pub subscription: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteSubscriptionRequest {
    fn default() -> &'a DeleteSubscriptionRequest {
        <DeleteSubscriptionRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteSubscriptionRequest {
    pub fn new() -> DeleteSubscriptionRequest {
        ::std::default::Default::default()
    }

    // string subscription = 1;


    pub fn get_subscription(&self) -> &str {
        &self.subscription
    }
    pub fn clear_subscription(&mut self) {
        self.subscription.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscription(&mut self, v: ::std::string::String) {
        self.subscription = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription(&mut self) -> &mut ::std::string::String {
        &mut self.subscription
    }

    // Take field
    pub fn take_subscription(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subscription, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteSubscriptionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subscription)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteSubscriptionRequest {
        DeleteSubscriptionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "subscription",
                    |m: &DeleteSubscriptionRequest| { &m.subscription },
                    |m: &mut DeleteSubscriptionRequest| { &mut m.subscription },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteSubscriptionRequest>(
                    "DeleteSubscriptionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteSubscriptionRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteSubscriptionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteSubscriptionRequest,
        };
        unsafe {
            instance.get(DeleteSubscriptionRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteSubscriptionRequest {
    fn clear(&mut self) {
        self.subscription.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteSubscriptionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSubscriptionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModifyPushConfigRequest {
    // message fields
    pub subscription: ::std::string::String,
    pub push_config: ::protobuf::SingularPtrField<PushConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModifyPushConfigRequest {
    fn default() -> &'a ModifyPushConfigRequest {
        <ModifyPushConfigRequest as ::protobuf::Message>::default_instance()
    }
}

impl ModifyPushConfigRequest {
    pub fn new() -> ModifyPushConfigRequest {
        ::std::default::Default::default()
    }

    // string subscription = 1;


    pub fn get_subscription(&self) -> &str {
        &self.subscription
    }
    pub fn clear_subscription(&mut self) {
        self.subscription.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscription(&mut self, v: ::std::string::String) {
        self.subscription = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription(&mut self) -> &mut ::std::string::String {
        &mut self.subscription
    }

    // Take field
    pub fn take_subscription(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subscription, ::std::string::String::new())
    }

    // .google.pubsub.v1.PushConfig push_config = 2;


    pub fn get_push_config(&self) -> &PushConfig {
        self.push_config.as_ref().unwrap_or_else(|| PushConfig::default_instance())
    }
    pub fn clear_push_config(&mut self) {
        self.push_config.clear();
    }

    pub fn has_push_config(&self) -> bool {
        self.push_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_push_config(&mut self, v: PushConfig) {
        self.push_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_push_config(&mut self) -> &mut PushConfig {
        if self.push_config.is_none() {
            self.push_config.set_default();
        }
        self.push_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_push_config(&mut self) -> PushConfig {
        self.push_config.take().unwrap_or_else(|| PushConfig::new())
    }
}

impl ::protobuf::Message for ModifyPushConfigRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.push_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subscription)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.push_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        if let Some(ref v) = self.push_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        if let Some(ref v) = self.push_config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModifyPushConfigRequest {
        ModifyPushConfigRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "subscription",
                    |m: &ModifyPushConfigRequest| { &m.subscription },
                    |m: &mut ModifyPushConfigRequest| { &mut m.subscription },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PushConfig>>(
                    "push_config",
                    |m: &ModifyPushConfigRequest| { &m.push_config },
                    |m: &mut ModifyPushConfigRequest| { &mut m.push_config },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ModifyPushConfigRequest>(
                    "ModifyPushConfigRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ModifyPushConfigRequest {
        static mut instance: ::protobuf::lazy::Lazy<ModifyPushConfigRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ModifyPushConfigRequest,
        };
        unsafe {
            instance.get(ModifyPushConfigRequest::new)
        }
    }
}

impl ::protobuf::Clear for ModifyPushConfigRequest {
    fn clear(&mut self) {
        self.subscription.clear();
        self.push_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyPushConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyPushConfigRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PullRequest {
    // message fields
    pub subscription: ::std::string::String,
    pub return_immediately: bool,
    pub max_messages: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PullRequest {
    fn default() -> &'a PullRequest {
        <PullRequest as ::protobuf::Message>::default_instance()
    }
}

impl PullRequest {
    pub fn new() -> PullRequest {
        ::std::default::Default::default()
    }

    // string subscription = 1;


    pub fn get_subscription(&self) -> &str {
        &self.subscription
    }
    pub fn clear_subscription(&mut self) {
        self.subscription.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscription(&mut self, v: ::std::string::String) {
        self.subscription = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription(&mut self) -> &mut ::std::string::String {
        &mut self.subscription
    }

    // Take field
    pub fn take_subscription(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subscription, ::std::string::String::new())
    }

    // bool return_immediately = 2;


    pub fn get_return_immediately(&self) -> bool {
        self.return_immediately
    }
    pub fn clear_return_immediately(&mut self) {
        self.return_immediately = false;
    }

    // Param is passed by value, moved
    pub fn set_return_immediately(&mut self, v: bool) {
        self.return_immediately = v;
    }

    // int32 max_messages = 3;


    pub fn get_max_messages(&self) -> i32 {
        self.max_messages
    }
    pub fn clear_max_messages(&mut self) {
        self.max_messages = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_messages(&mut self, v: i32) {
        self.max_messages = v;
    }
}

impl ::protobuf::Message for PullRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subscription)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.return_immediately = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_messages = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        if self.return_immediately != false {
            my_size += 2;
        }
        if self.max_messages != 0 {
            my_size += ::protobuf::rt::value_size(3, self.max_messages, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        if self.return_immediately != false {
            os.write_bool(2, self.return_immediately)?;
        }
        if self.max_messages != 0 {
            os.write_int32(3, self.max_messages)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PullRequest {
        PullRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "subscription",
                    |m: &PullRequest| { &m.subscription },
                    |m: &mut PullRequest| { &mut m.subscription },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "return_immediately",
                    |m: &PullRequest| { &m.return_immediately },
                    |m: &mut PullRequest| { &mut m.return_immediately },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "max_messages",
                    |m: &PullRequest| { &m.max_messages },
                    |m: &mut PullRequest| { &mut m.max_messages },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PullRequest>(
                    "PullRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PullRequest {
        static mut instance: ::protobuf::lazy::Lazy<PullRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PullRequest,
        };
        unsafe {
            instance.get(PullRequest::new)
        }
    }
}

impl ::protobuf::Clear for PullRequest {
    fn clear(&mut self) {
        self.subscription.clear();
        self.return_immediately = false;
        self.max_messages = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PullRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PullRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PullResponse {
    // message fields
    pub received_messages: ::protobuf::RepeatedField<ReceivedMessage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PullResponse {
    fn default() -> &'a PullResponse {
        <PullResponse as ::protobuf::Message>::default_instance()
    }
}

impl PullResponse {
    pub fn new() -> PullResponse {
        ::std::default::Default::default()
    }

    // repeated .google.pubsub.v1.ReceivedMessage received_messages = 1;


    pub fn get_received_messages(&self) -> &[ReceivedMessage] {
        &self.received_messages
    }
    pub fn clear_received_messages(&mut self) {
        self.received_messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_received_messages(&mut self, v: ::protobuf::RepeatedField<ReceivedMessage>) {
        self.received_messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_received_messages(&mut self) -> &mut ::protobuf::RepeatedField<ReceivedMessage> {
        &mut self.received_messages
    }

    // Take field
    pub fn take_received_messages(&mut self) -> ::protobuf::RepeatedField<ReceivedMessage> {
        ::std::mem::replace(&mut self.received_messages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PullResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.received_messages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.received_messages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.received_messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.received_messages {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PullResponse {
        PullResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReceivedMessage>>(
                    "received_messages",
                    |m: &PullResponse| { &m.received_messages },
                    |m: &mut PullResponse| { &mut m.received_messages },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PullResponse>(
                    "PullResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PullResponse {
        static mut instance: ::protobuf::lazy::Lazy<PullResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PullResponse,
        };
        unsafe {
            instance.get(PullResponse::new)
        }
    }
}

impl ::protobuf::Clear for PullResponse {
    fn clear(&mut self) {
        self.received_messages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PullResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PullResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModifyAckDeadlineRequest {
    // message fields
    pub subscription: ::std::string::String,
    pub ack_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub ack_deadline_seconds: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModifyAckDeadlineRequest {
    fn default() -> &'a ModifyAckDeadlineRequest {
        <ModifyAckDeadlineRequest as ::protobuf::Message>::default_instance()
    }
}

impl ModifyAckDeadlineRequest {
    pub fn new() -> ModifyAckDeadlineRequest {
        ::std::default::Default::default()
    }

    // string subscription = 1;


    pub fn get_subscription(&self) -> &str {
        &self.subscription
    }
    pub fn clear_subscription(&mut self) {
        self.subscription.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscription(&mut self, v: ::std::string::String) {
        self.subscription = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription(&mut self) -> &mut ::std::string::String {
        &mut self.subscription
    }

    // Take field
    pub fn take_subscription(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subscription, ::std::string::String::new())
    }

    // repeated string ack_ids = 4;


    pub fn get_ack_ids(&self) -> &[::std::string::String] {
        &self.ack_ids
    }
    pub fn clear_ack_ids(&mut self) {
        self.ack_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ack_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ack_ids
    }

    // Take field
    pub fn take_ack_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ack_ids, ::protobuf::RepeatedField::new())
    }

    // int32 ack_deadline_seconds = 3;


    pub fn get_ack_deadline_seconds(&self) -> i32 {
        self.ack_deadline_seconds
    }
    pub fn clear_ack_deadline_seconds(&mut self) {
        self.ack_deadline_seconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_ack_deadline_seconds(&mut self, v: i32) {
        self.ack_deadline_seconds = v;
    }
}

impl ::protobuf::Message for ModifyAckDeadlineRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subscription)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ack_ids)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ack_deadline_seconds = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        for value in &self.ack_ids {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if self.ack_deadline_seconds != 0 {
            my_size += ::protobuf::rt::value_size(3, self.ack_deadline_seconds, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        for v in &self.ack_ids {
            os.write_string(4, &v)?;
        };
        if self.ack_deadline_seconds != 0 {
            os.write_int32(3, self.ack_deadline_seconds)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModifyAckDeadlineRequest {
        ModifyAckDeadlineRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "subscription",
                    |m: &ModifyAckDeadlineRequest| { &m.subscription },
                    |m: &mut ModifyAckDeadlineRequest| { &mut m.subscription },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ack_ids",
                    |m: &ModifyAckDeadlineRequest| { &m.ack_ids },
                    |m: &mut ModifyAckDeadlineRequest| { &mut m.ack_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ack_deadline_seconds",
                    |m: &ModifyAckDeadlineRequest| { &m.ack_deadline_seconds },
                    |m: &mut ModifyAckDeadlineRequest| { &mut m.ack_deadline_seconds },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ModifyAckDeadlineRequest>(
                    "ModifyAckDeadlineRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ModifyAckDeadlineRequest {
        static mut instance: ::protobuf::lazy::Lazy<ModifyAckDeadlineRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ModifyAckDeadlineRequest,
        };
        unsafe {
            instance.get(ModifyAckDeadlineRequest::new)
        }
    }
}

impl ::protobuf::Clear for ModifyAckDeadlineRequest {
    fn clear(&mut self) {
        self.subscription.clear();
        self.ack_ids.clear();
        self.ack_deadline_seconds = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyAckDeadlineRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyAckDeadlineRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AcknowledgeRequest {
    // message fields
    pub subscription: ::std::string::String,
    pub ack_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AcknowledgeRequest {
    fn default() -> &'a AcknowledgeRequest {
        <AcknowledgeRequest as ::protobuf::Message>::default_instance()
    }
}

impl AcknowledgeRequest {
    pub fn new() -> AcknowledgeRequest {
        ::std::default::Default::default()
    }

    // string subscription = 1;


    pub fn get_subscription(&self) -> &str {
        &self.subscription
    }
    pub fn clear_subscription(&mut self) {
        self.subscription.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscription(&mut self, v: ::std::string::String) {
        self.subscription = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription(&mut self) -> &mut ::std::string::String {
        &mut self.subscription
    }

    // Take field
    pub fn take_subscription(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subscription, ::std::string::String::new())
    }

    // repeated string ack_ids = 2;


    pub fn get_ack_ids(&self) -> &[::std::string::String] {
        &self.ack_ids
    }
    pub fn clear_ack_ids(&mut self) {
        self.ack_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ack_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ack_ids
    }

    // Take field
    pub fn take_ack_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ack_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AcknowledgeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subscription)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ack_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        for value in &self.ack_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        for v in &self.ack_ids {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AcknowledgeRequest {
        AcknowledgeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "subscription",
                    |m: &AcknowledgeRequest| { &m.subscription },
                    |m: &mut AcknowledgeRequest| { &mut m.subscription },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ack_ids",
                    |m: &AcknowledgeRequest| { &m.ack_ids },
                    |m: &mut AcknowledgeRequest| { &mut m.ack_ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AcknowledgeRequest>(
                    "AcknowledgeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AcknowledgeRequest {
        static mut instance: ::protobuf::lazy::Lazy<AcknowledgeRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AcknowledgeRequest,
        };
        unsafe {
            instance.get(AcknowledgeRequest::new)
        }
    }
}

impl ::protobuf::Clear for AcknowledgeRequest {
    fn clear(&mut self) {
        self.subscription.clear();
        self.ack_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AcknowledgeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AcknowledgeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamingPullRequest {
    // message fields
    pub subscription: ::std::string::String,
    pub ack_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub modify_deadline_seconds: ::std::vec::Vec<i32>,
    pub modify_deadline_ack_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub stream_ack_deadline_seconds: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamingPullRequest {
    fn default() -> &'a StreamingPullRequest {
        <StreamingPullRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamingPullRequest {
    pub fn new() -> StreamingPullRequest {
        ::std::default::Default::default()
    }

    // string subscription = 1;


    pub fn get_subscription(&self) -> &str {
        &self.subscription
    }
    pub fn clear_subscription(&mut self) {
        self.subscription.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscription(&mut self, v: ::std::string::String) {
        self.subscription = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription(&mut self) -> &mut ::std::string::String {
        &mut self.subscription
    }

    // Take field
    pub fn take_subscription(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subscription, ::std::string::String::new())
    }

    // repeated string ack_ids = 2;


    pub fn get_ack_ids(&self) -> &[::std::string::String] {
        &self.ack_ids
    }
    pub fn clear_ack_ids(&mut self) {
        self.ack_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ack_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ack_ids
    }

    // Take field
    pub fn take_ack_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ack_ids, ::protobuf::RepeatedField::new())
    }

    // repeated int32 modify_deadline_seconds = 3;


    pub fn get_modify_deadline_seconds(&self) -> &[i32] {
        &self.modify_deadline_seconds
    }
    pub fn clear_modify_deadline_seconds(&mut self) {
        self.modify_deadline_seconds.clear();
    }

    // Param is passed by value, moved
    pub fn set_modify_deadline_seconds(&mut self, v: ::std::vec::Vec<i32>) {
        self.modify_deadline_seconds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_modify_deadline_seconds(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.modify_deadline_seconds
    }

    // Take field
    pub fn take_modify_deadline_seconds(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.modify_deadline_seconds, ::std::vec::Vec::new())
    }

    // repeated string modify_deadline_ack_ids = 4;


    pub fn get_modify_deadline_ack_ids(&self) -> &[::std::string::String] {
        &self.modify_deadline_ack_ids
    }
    pub fn clear_modify_deadline_ack_ids(&mut self) {
        self.modify_deadline_ack_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_modify_deadline_ack_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.modify_deadline_ack_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_modify_deadline_ack_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.modify_deadline_ack_ids
    }

    // Take field
    pub fn take_modify_deadline_ack_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.modify_deadline_ack_ids, ::protobuf::RepeatedField::new())
    }

    // int32 stream_ack_deadline_seconds = 5;


    pub fn get_stream_ack_deadline_seconds(&self) -> i32 {
        self.stream_ack_deadline_seconds
    }
    pub fn clear_stream_ack_deadline_seconds(&mut self) {
        self.stream_ack_deadline_seconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_stream_ack_deadline_seconds(&mut self, v: i32) {
        self.stream_ack_deadline_seconds = v;
    }
}

impl ::protobuf::Message for StreamingPullRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subscription)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ack_ids)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.modify_deadline_seconds)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.modify_deadline_ack_ids)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.stream_ack_deadline_seconds = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        for value in &self.ack_ids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.modify_deadline_seconds {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.modify_deadline_ack_ids {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if self.stream_ack_deadline_seconds != 0 {
            my_size += ::protobuf::rt::value_size(5, self.stream_ack_deadline_seconds, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        for v in &self.ack_ids {
            os.write_string(2, &v)?;
        };
        for v in &self.modify_deadline_seconds {
            os.write_int32(3, *v)?;
        };
        for v in &self.modify_deadline_ack_ids {
            os.write_string(4, &v)?;
        };
        if self.stream_ack_deadline_seconds != 0 {
            os.write_int32(5, self.stream_ack_deadline_seconds)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamingPullRequest {
        StreamingPullRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "subscription",
                    |m: &StreamingPullRequest| { &m.subscription },
                    |m: &mut StreamingPullRequest| { &mut m.subscription },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ack_ids",
                    |m: &StreamingPullRequest| { &m.ack_ids },
                    |m: &mut StreamingPullRequest| { &mut m.ack_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "modify_deadline_seconds",
                    |m: &StreamingPullRequest| { &m.modify_deadline_seconds },
                    |m: &mut StreamingPullRequest| { &mut m.modify_deadline_seconds },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "modify_deadline_ack_ids",
                    |m: &StreamingPullRequest| { &m.modify_deadline_ack_ids },
                    |m: &mut StreamingPullRequest| { &mut m.modify_deadline_ack_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "stream_ack_deadline_seconds",
                    |m: &StreamingPullRequest| { &m.stream_ack_deadline_seconds },
                    |m: &mut StreamingPullRequest| { &mut m.stream_ack_deadline_seconds },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StreamingPullRequest>(
                    "StreamingPullRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StreamingPullRequest {
        static mut instance: ::protobuf::lazy::Lazy<StreamingPullRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StreamingPullRequest,
        };
        unsafe {
            instance.get(StreamingPullRequest::new)
        }
    }
}

impl ::protobuf::Clear for StreamingPullRequest {
    fn clear(&mut self) {
        self.subscription.clear();
        self.ack_ids.clear();
        self.modify_deadline_seconds.clear();
        self.modify_deadline_ack_ids.clear();
        self.stream_ack_deadline_seconds = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamingPullRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamingPullRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamingPullResponse {
    // message fields
    pub received_messages: ::protobuf::RepeatedField<ReceivedMessage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamingPullResponse {
    fn default() -> &'a StreamingPullResponse {
        <StreamingPullResponse as ::protobuf::Message>::default_instance()
    }
}

impl StreamingPullResponse {
    pub fn new() -> StreamingPullResponse {
        ::std::default::Default::default()
    }

    // repeated .google.pubsub.v1.ReceivedMessage received_messages = 1;


    pub fn get_received_messages(&self) -> &[ReceivedMessage] {
        &self.received_messages
    }
    pub fn clear_received_messages(&mut self) {
        self.received_messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_received_messages(&mut self, v: ::protobuf::RepeatedField<ReceivedMessage>) {
        self.received_messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_received_messages(&mut self) -> &mut ::protobuf::RepeatedField<ReceivedMessage> {
        &mut self.received_messages
    }

    // Take field
    pub fn take_received_messages(&mut self) -> ::protobuf::RepeatedField<ReceivedMessage> {
        ::std::mem::replace(&mut self.received_messages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StreamingPullResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.received_messages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.received_messages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.received_messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.received_messages {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamingPullResponse {
        StreamingPullResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReceivedMessage>>(
                    "received_messages",
                    |m: &StreamingPullResponse| { &m.received_messages },
                    |m: &mut StreamingPullResponse| { &mut m.received_messages },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StreamingPullResponse>(
                    "StreamingPullResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StreamingPullResponse {
        static mut instance: ::protobuf::lazy::Lazy<StreamingPullResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StreamingPullResponse,
        };
        unsafe {
            instance.get(StreamingPullResponse::new)
        }
    }
}

impl ::protobuf::Clear for StreamingPullResponse {
    fn clear(&mut self) {
        self.received_messages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamingPullResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamingPullResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateSnapshotRequest {
    // message fields
    pub name: ::std::string::String,
    pub subscription: ::std::string::String,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateSnapshotRequest {
    fn default() -> &'a CreateSnapshotRequest {
        <CreateSnapshotRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateSnapshotRequest {
    pub fn new() -> CreateSnapshotRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string subscription = 2;


    pub fn get_subscription(&self) -> &str {
        &self.subscription
    }
    pub fn clear_subscription(&mut self) {
        self.subscription.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscription(&mut self, v: ::std::string::String) {
        self.subscription = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription(&mut self) -> &mut ::std::string::String {
        &mut self.subscription
    }

    // Take field
    pub fn take_subscription(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subscription, ::std::string::String::new())
    }

    // repeated .google.pubsub.v1.CreateSnapshotRequest.LabelsEntry labels = 3;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for CreateSnapshotRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subscription)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subscription);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.labels);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.subscription.is_empty() {
            os.write_string(2, &self.subscription)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.labels, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateSnapshotRequest {
        CreateSnapshotRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CreateSnapshotRequest| { &m.name },
                    |m: &mut CreateSnapshotRequest| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "subscription",
                    |m: &CreateSnapshotRequest| { &m.subscription },
                    |m: &mut CreateSnapshotRequest| { &mut m.subscription },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "labels",
                    |m: &CreateSnapshotRequest| { &m.labels },
                    |m: &mut CreateSnapshotRequest| { &mut m.labels },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateSnapshotRequest>(
                    "CreateSnapshotRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateSnapshotRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateSnapshotRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateSnapshotRequest,
        };
        unsafe {
            instance.get(CreateSnapshotRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateSnapshotRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.subscription.clear();
        self.labels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateSnapshotRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSnapshotRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateSnapshotRequest {
    // message fields
    pub snapshot: ::protobuf::SingularPtrField<Snapshot>,
    pub update_mask: ::protobuf::SingularPtrField<::protobuf::well_known_types::FieldMask>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateSnapshotRequest {
    fn default() -> &'a UpdateSnapshotRequest {
        <UpdateSnapshotRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateSnapshotRequest {
    pub fn new() -> UpdateSnapshotRequest {
        ::std::default::Default::default()
    }

    // .google.pubsub.v1.Snapshot snapshot = 1;


    pub fn get_snapshot(&self) -> &Snapshot {
        self.snapshot.as_ref().unwrap_or_else(|| Snapshot::default_instance())
    }
    pub fn clear_snapshot(&mut self) {
        self.snapshot.clear();
    }

    pub fn has_snapshot(&self) -> bool {
        self.snapshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshot(&mut self, v: Snapshot) {
        self.snapshot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshot(&mut self) -> &mut Snapshot {
        if self.snapshot.is_none() {
            self.snapshot.set_default();
        }
        self.snapshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshot(&mut self) -> Snapshot {
        self.snapshot.take().unwrap_or_else(|| Snapshot::new())
    }

    // .google.protobuf.FieldMask update_mask = 2;


    pub fn get_update_mask(&self) -> &::protobuf::well_known_types::FieldMask {
        self.update_mask.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::default_instance())
    }
    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: ::protobuf::well_known_types::FieldMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut ::protobuf::well_known_types::FieldMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> ::protobuf::well_known_types::FieldMask {
        self.update_mask.take().unwrap_or_else(|| ::protobuf::well_known_types::FieldMask::new())
    }
}

impl ::protobuf::Message for UpdateSnapshotRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.snapshot {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.snapshot)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshot.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateSnapshotRequest {
        UpdateSnapshotRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Snapshot>>(
                    "snapshot",
                    |m: &UpdateSnapshotRequest| { &m.snapshot },
                    |m: &mut UpdateSnapshotRequest| { &mut m.snapshot },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FieldMask>>(
                    "update_mask",
                    |m: &UpdateSnapshotRequest| { &m.update_mask },
                    |m: &mut UpdateSnapshotRequest| { &mut m.update_mask },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateSnapshotRequest>(
                    "UpdateSnapshotRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateSnapshotRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdateSnapshotRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateSnapshotRequest,
        };
        unsafe {
            instance.get(UpdateSnapshotRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdateSnapshotRequest {
    fn clear(&mut self) {
        self.snapshot.clear();
        self.update_mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateSnapshotRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateSnapshotRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Snapshot {
    // message fields
    pub name: ::std::string::String,
    pub topic: ::std::string::String,
    pub expire_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Snapshot {
    fn default() -> &'a Snapshot {
        <Snapshot as ::protobuf::Message>::default_instance()
    }
}

impl Snapshot {
    pub fn new() -> Snapshot {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string topic = 2;


    pub fn get_topic(&self) -> &str {
        &self.topic
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        &mut self.topic
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.topic, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp expire_time = 3;


    pub fn get_expire_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.expire_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_expire_time(&mut self) {
        self.expire_time.clear();
    }

    pub fn has_expire_time(&self) -> bool {
        self.expire_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expire_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.expire_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expire_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.expire_time.is_none() {
            self.expire_time.set_default();
        }
        self.expire_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_expire_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.expire_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // repeated .google.pubsub.v1.Snapshot.LabelsEntry labels = 4;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for Snapshot {
    fn is_initialized(&self) -> bool {
        for v in &self.expire_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.topic)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expire_time)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.topic);
        }
        if let Some(ref v) = self.expire_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.labels);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.topic.is_empty() {
            os.write_string(2, &self.topic)?;
        }
        if let Some(ref v) = self.expire_time.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.labels, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Snapshot {
        Snapshot::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Snapshot| { &m.name },
                    |m: &mut Snapshot| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "topic",
                    |m: &Snapshot| { &m.topic },
                    |m: &mut Snapshot| { &mut m.topic },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "expire_time",
                    |m: &Snapshot| { &m.expire_time },
                    |m: &mut Snapshot| { &mut m.expire_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "labels",
                    |m: &Snapshot| { &m.labels },
                    |m: &mut Snapshot| { &mut m.labels },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Snapshot>(
                    "Snapshot",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Snapshot {
        static mut instance: ::protobuf::lazy::Lazy<Snapshot> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Snapshot,
        };
        unsafe {
            instance.get(Snapshot::new)
        }
    }
}

impl ::protobuf::Clear for Snapshot {
    fn clear(&mut self) {
        self.name.clear();
        self.topic.clear();
        self.expire_time.clear();
        self.labels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Snapshot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Snapshot {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSnapshotRequest {
    // message fields
    pub snapshot: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSnapshotRequest {
    fn default() -> &'a GetSnapshotRequest {
        <GetSnapshotRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSnapshotRequest {
    pub fn new() -> GetSnapshotRequest {
        ::std::default::Default::default()
    }

    // string snapshot = 1;


    pub fn get_snapshot(&self) -> &str {
        &self.snapshot
    }
    pub fn clear_snapshot(&mut self) {
        self.snapshot.clear();
    }

    // Param is passed by value, moved
    pub fn set_snapshot(&mut self, v: ::std::string::String) {
        self.snapshot = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshot(&mut self) -> &mut ::std::string::String {
        &mut self.snapshot
    }

    // Take field
    pub fn take_snapshot(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.snapshot, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetSnapshotRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.snapshot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.snapshot.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.snapshot);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.snapshot.is_empty() {
            os.write_string(1, &self.snapshot)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSnapshotRequest {
        GetSnapshotRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshot",
                    |m: &GetSnapshotRequest| { &m.snapshot },
                    |m: &mut GetSnapshotRequest| { &mut m.snapshot },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetSnapshotRequest>(
                    "GetSnapshotRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetSnapshotRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetSnapshotRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetSnapshotRequest,
        };
        unsafe {
            instance.get(GetSnapshotRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetSnapshotRequest {
    fn clear(&mut self) {
        self.snapshot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSnapshotRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSnapshotRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListSnapshotsRequest {
    // message fields
    pub project: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListSnapshotsRequest {
    fn default() -> &'a ListSnapshotsRequest {
        <ListSnapshotsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListSnapshotsRequest {
    pub fn new() -> ListSnapshotsRequest {
        ::std::default::Default::default()
    }

    // string project = 1;


    pub fn get_project(&self) -> &str {
        &self.project
    }
    pub fn clear_project(&mut self) {
        self.project.clear();
    }

    // Param is passed by value, moved
    pub fn set_project(&mut self, v: ::std::string::String) {
        self.project = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project(&mut self) -> &mut ::std::string::String {
        &mut self.project
    }

    // Take field
    pub fn take_project(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project, ::std::string::String::new())
    }

    // int32 page_size = 2;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 3;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListSnapshotsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.project.is_empty() {
            os.write_string(1, &self.project)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListSnapshotsRequest {
        ListSnapshotsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "project",
                    |m: &ListSnapshotsRequest| { &m.project },
                    |m: &mut ListSnapshotsRequest| { &mut m.project },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "page_size",
                    |m: &ListSnapshotsRequest| { &m.page_size },
                    |m: &mut ListSnapshotsRequest| { &mut m.page_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "page_token",
                    |m: &ListSnapshotsRequest| { &m.page_token },
                    |m: &mut ListSnapshotsRequest| { &mut m.page_token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListSnapshotsRequest>(
                    "ListSnapshotsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListSnapshotsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListSnapshotsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListSnapshotsRequest,
        };
        unsafe {
            instance.get(ListSnapshotsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListSnapshotsRequest {
    fn clear(&mut self) {
        self.project.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListSnapshotsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSnapshotsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListSnapshotsResponse {
    // message fields
    pub snapshots: ::protobuf::RepeatedField<Snapshot>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListSnapshotsResponse {
    fn default() -> &'a ListSnapshotsResponse {
        <ListSnapshotsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListSnapshotsResponse {
    pub fn new() -> ListSnapshotsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.pubsub.v1.Snapshot snapshots = 1;


    pub fn get_snapshots(&self) -> &[Snapshot] {
        &self.snapshots
    }
    pub fn clear_snapshots(&mut self) {
        self.snapshots.clear();
    }

    // Param is passed by value, moved
    pub fn set_snapshots(&mut self, v: ::protobuf::RepeatedField<Snapshot>) {
        self.snapshots = v;
    }

    // Mutable pointer to the field.
    pub fn mut_snapshots(&mut self) -> &mut ::protobuf::RepeatedField<Snapshot> {
        &mut self.snapshots
    }

    // Take field
    pub fn take_snapshots(&mut self) -> ::protobuf::RepeatedField<Snapshot> {
        ::std::mem::replace(&mut self.snapshots, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListSnapshotsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.snapshots {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.snapshots)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.snapshots {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.snapshots {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListSnapshotsResponse {
        ListSnapshotsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Snapshot>>(
                    "snapshots",
                    |m: &ListSnapshotsResponse| { &m.snapshots },
                    |m: &mut ListSnapshotsResponse| { &mut m.snapshots },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "next_page_token",
                    |m: &ListSnapshotsResponse| { &m.next_page_token },
                    |m: &mut ListSnapshotsResponse| { &mut m.next_page_token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListSnapshotsResponse>(
                    "ListSnapshotsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListSnapshotsResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListSnapshotsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListSnapshotsResponse,
        };
        unsafe {
            instance.get(ListSnapshotsResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListSnapshotsResponse {
    fn clear(&mut self) {
        self.snapshots.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListSnapshotsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListSnapshotsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteSnapshotRequest {
    // message fields
    pub snapshot: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteSnapshotRequest {
    fn default() -> &'a DeleteSnapshotRequest {
        <DeleteSnapshotRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteSnapshotRequest {
    pub fn new() -> DeleteSnapshotRequest {
        ::std::default::Default::default()
    }

    // string snapshot = 1;


    pub fn get_snapshot(&self) -> &str {
        &self.snapshot
    }
    pub fn clear_snapshot(&mut self) {
        self.snapshot.clear();
    }

    // Param is passed by value, moved
    pub fn set_snapshot(&mut self, v: ::std::string::String) {
        self.snapshot = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshot(&mut self) -> &mut ::std::string::String {
        &mut self.snapshot
    }

    // Take field
    pub fn take_snapshot(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.snapshot, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteSnapshotRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.snapshot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.snapshot.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.snapshot);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.snapshot.is_empty() {
            os.write_string(1, &self.snapshot)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteSnapshotRequest {
        DeleteSnapshotRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshot",
                    |m: &DeleteSnapshotRequest| { &m.snapshot },
                    |m: &mut DeleteSnapshotRequest| { &mut m.snapshot },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteSnapshotRequest>(
                    "DeleteSnapshotRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteSnapshotRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteSnapshotRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteSnapshotRequest,
        };
        unsafe {
            instance.get(DeleteSnapshotRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteSnapshotRequest {
    fn clear(&mut self) {
        self.snapshot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteSnapshotRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSnapshotRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SeekRequest {
    // message fields
    pub subscription: ::std::string::String,
    // message oneof groups
    pub target: ::std::option::Option<SeekRequest_oneof_target>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SeekRequest {
    fn default() -> &'a SeekRequest {
        <SeekRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum SeekRequest_oneof_target {
    time(::protobuf::well_known_types::Timestamp),
    snapshot(::std::string::String),
}

impl SeekRequest {
    pub fn new() -> SeekRequest {
        ::std::default::Default::default()
    }

    // string subscription = 1;


    pub fn get_subscription(&self) -> &str {
        &self.subscription
    }
    pub fn clear_subscription(&mut self) {
        self.subscription.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscription(&mut self, v: ::std::string::String) {
        self.subscription = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription(&mut self) -> &mut ::std::string::String {
        &mut self.subscription
    }

    // Take field
    pub fn take_subscription(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subscription, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp time = 2;


    pub fn get_time(&self) -> &::protobuf::well_known_types::Timestamp {
        match self.target {
            ::std::option::Option::Some(SeekRequest_oneof_target::time(ref v)) => v,
            _ => ::protobuf::well_known_types::Timestamp::default_instance(),
        }
    }
    pub fn clear_time(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(SeekRequest_oneof_target::time(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.target = ::std::option::Option::Some(SeekRequest_oneof_target::time(v))
    }

    // Mutable pointer to the field.
    pub fn mut_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if let ::std::option::Option::Some(SeekRequest_oneof_target::time(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(SeekRequest_oneof_target::time(::protobuf::well_known_types::Timestamp::new()));
        }
        match self.target {
            ::std::option::Option::Some(SeekRequest_oneof_target::time(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        if self.has_time() {
            match self.target.take() {
                ::std::option::Option::Some(SeekRequest_oneof_target::time(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Timestamp::new()
        }
    }

    // string snapshot = 3;


    pub fn get_snapshot(&self) -> &str {
        match self.target {
            ::std::option::Option::Some(SeekRequest_oneof_target::snapshot(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_snapshot(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_snapshot(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(SeekRequest_oneof_target::snapshot(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_snapshot(&mut self, v: ::std::string::String) {
        self.target = ::std::option::Option::Some(SeekRequest_oneof_target::snapshot(v))
    }

    // Mutable pointer to the field.
    pub fn mut_snapshot(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(SeekRequest_oneof_target::snapshot(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(SeekRequest_oneof_target::snapshot(::std::string::String::new()));
        }
        match self.target {
            ::std::option::Option::Some(SeekRequest_oneof_target::snapshot(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_snapshot(&mut self) -> ::std::string::String {
        if self.has_snapshot() {
            match self.target.take() {
                ::std::option::Option::Some(SeekRequest_oneof_target::snapshot(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for SeekRequest {
    fn is_initialized(&self) -> bool {
        if let Some(SeekRequest_oneof_target::time(ref v)) = self.target {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subscription)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target = ::std::option::Option::Some(SeekRequest_oneof_target::time(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target = ::std::option::Option::Some(SeekRequest_oneof_target::snapshot(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subscription.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subscription);
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &SeekRequest_oneof_target::time(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SeekRequest_oneof_target::snapshot(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.subscription.is_empty() {
            os.write_string(1, &self.subscription)?;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &SeekRequest_oneof_target::time(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SeekRequest_oneof_target::snapshot(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SeekRequest {
        SeekRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "subscription",
                    |m: &SeekRequest| { &m.subscription },
                    |m: &mut SeekRequest| { &mut m.subscription },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Timestamp>(
                    "time",
                    SeekRequest::has_time,
                    SeekRequest::get_time,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "snapshot",
                    SeekRequest::has_snapshot,
                    SeekRequest::get_snapshot,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SeekRequest>(
                    "SeekRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SeekRequest {
        static mut instance: ::protobuf::lazy::Lazy<SeekRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SeekRequest,
        };
        unsafe {
            instance.get(SeekRequest::new)
        }
    }
}

impl ::protobuf::Clear for SeekRequest {
    fn clear(&mut self) {
        self.subscription.clear();
        self.target = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SeekRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SeekRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SeekResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SeekResponse {
    fn default() -> &'a SeekResponse {
        <SeekResponse as ::protobuf::Message>::default_instance()
    }
}

impl SeekResponse {
    pub fn new() -> SeekResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SeekResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SeekResponse {
        SeekResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SeekResponse>(
                    "SeekResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SeekResponse {
        static mut instance: ::protobuf::lazy::Lazy<SeekResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SeekResponse,
        };
        unsafe {
            instance.get(SeekResponse::new)
        }
    }
}

impl ::protobuf::Clear for SeekResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SeekResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SeekResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1dgoogle/pubsub/v1/pubsub.proto\x12\x10google.pubsub.v1\x1a\x1cgoogl\
    e/api/annotations.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1bgoo\
    gle/protobuf/empty.proto\x1a\x20google/protobuf/field_mask.proto\x1a\x1f\
    google/protobuf/timestamp.proto\"V\n\x14MessageStoragePolicy\x12>\n\x1ba\
    llowed_persistence_regions\x18\x01\x20\x03(\tR\x19allowedPersistenceRegi\
    ons\"\xf1\x01\n\x05Topic\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12;\n\x06labels\x18\x02\x20\x03(\x0b2#.google.pubsub.v1.Topic.LabelsEn\
    tryR\x06labels\x12\\\n\x16message_storage_policy\x18\x03\x20\x01(\x0b2&.\
    google.pubsub.v1.MessageStoragePolicyR\x14messageStoragePolicy\x1a9\n\
    \x0bLabelsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\x91\x02\n\rPubsubMess\
    age\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\x12O\n\nattributes\
    \x18\x02\x20\x03(\x0b2/.google.pubsub.v1.PubsubMessage.AttributesEntryR\
    \nattributes\x12\x1d\n\nmessage_id\x18\x03\x20\x01(\tR\tmessageId\x12=\n\
    \x0cpublish_time\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \x0bpublishTime\x1a=\n\x0fAttributesEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\
    \x01\"'\n\x0fGetTopicRequest\x12\x14\n\x05topic\x18\x01\x20\x01(\tR\x05t\
    opic\"\x80\x01\n\x12UpdateTopicRequest\x12-\n\x05topic\x18\x01\x20\x01(\
    \x0b2\x17.google.pubsub.v1.TopicR\x05topic\x12;\n\x0bupdate_mask\x18\x02\
    \x20\x01(\x0b2\x1a.google.protobuf.FieldMaskR\nupdateMask\"c\n\x0ePublis\
    hRequest\x12\x14\n\x05topic\x18\x01\x20\x01(\tR\x05topic\x12;\n\x08messa\
    ges\x18\x02\x20\x03(\x0b2\x1f.google.pubsub.v1.PubsubMessageR\x08message\
    s\"2\n\x0fPublishResponse\x12\x1f\n\x0bmessage_ids\x18\x01\x20\x03(\tR\n\
    messageIds\"i\n\x11ListTopicsRequest\x12\x18\n\x07project\x18\x01\x20\
    \x01(\tR\x07project\x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05R\x08pageSi\
    ze\x12\x1d\n\npage_token\x18\x03\x20\x01(\tR\tpageToken\"m\n\x12ListTopi\
    csResponse\x12/\n\x06topics\x18\x01\x20\x03(\x0b2\x17.google.pubsub.v1.T\
    opicR\x06topics\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageT\
    oken\"q\n\x1dListTopicSubscriptionsRequest\x12\x14\n\x05topic\x18\x01\
    \x20\x01(\tR\x05topic\x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05R\x08page\
    Size\x12\x1d\n\npage_token\x18\x03\x20\x01(\tR\tpageToken\"n\n\x1eListTo\
    picSubscriptionsResponse\x12$\n\rsubscriptions\x18\x01\x20\x03(\tR\rsubs\
    criptions\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageToken\"\
    m\n\x19ListTopicSnapshotsRequest\x12\x14\n\x05topic\x18\x01\x20\x01(\tR\
    \x05topic\x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05R\x08pageSize\x12\x1d\
    \n\npage_token\x18\x03\x20\x01(\tR\tpageToken\"b\n\x1aListTopicSnapshots\
    Response\x12\x1c\n\tsnapshots\x18\x01\x20\x03(\tR\tsnapshots\x12&\n\x0fn\
    ext_page_token\x18\x02\x20\x01(\tR\rnextPageToken\"*\n\x12DeleteTopicReq\
    uest\x12\x14\n\x05topic\x18\x01\x20\x01(\tR\x05topic\"\x86\x04\n\x0cSubs\
    cription\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05topi\
    c\x18\x02\x20\x01(\tR\x05topic\x12=\n\x0bpush_config\x18\x04\x20\x01(\
    \x0b2\x1c.google.pubsub.v1.PushConfigR\npushConfig\x120\n\x14ack_deadlin\
    e_seconds\x18\x05\x20\x01(\x05R\x12ackDeadlineSeconds\x122\n\x15retain_a\
    cked_messages\x18\x07\x20\x01(\x08R\x13retainAckedMessages\x12W\n\x1ames\
    sage_retention_duration\x18\x08\x20\x01(\x0b2\x19.google.protobuf.Durati\
    onR\x18messageRetentionDuration\x12B\n\x06labels\x18\t\x20\x03(\x0b2*.go\
    ogle.pubsub.v1.Subscription.LabelsEntryR\x06labels\x12O\n\x11expiration_\
    policy\x18\x0b\x20\x01(\x0b2\".google.pubsub.v1.ExpirationPolicyR\x10exp\
    irationPolicy\x1a9\n\x0bLabelsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"?\n\
    \x10ExpirationPolicy\x12+\n\x03ttl\x18\x01\x20\x01(\x0b2\x19.google.prot\
    obuf.DurationR\x03ttl\"\xbe\x01\n\nPushConfig\x12#\n\rpush_endpoint\x18\
    \x01\x20\x01(\tR\x0cpushEndpoint\x12L\n\nattributes\x18\x02\x20\x03(\x0b\
    2,.google.pubsub.v1.PushConfig.AttributesEntryR\nattributes\x1a=\n\x0fAt\
    tributesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05v\
    alue\x18\x02\x20\x01(\tR\x05value:\x028\x01\"c\n\x0fReceivedMessage\x12\
    \x15\n\x06ack_id\x18\x01\x20\x01(\tR\x05ackId\x129\n\x07message\x18\x02\
    \x20\x01(\x0b2\x1f.google.pubsub.v1.PubsubMessageR\x07message\"<\n\x16Ge\
    tSubscriptionRequest\x12\"\n\x0csubscription\x18\x01\x20\x01(\tR\x0csubs\
    cription\"\x9c\x01\n\x19UpdateSubscriptionRequest\x12B\n\x0csubscription\
    \x18\x01\x20\x01(\x0b2\x1e.google.pubsub.v1.SubscriptionR\x0csubscriptio\
    n\x12;\n\x0bupdate_mask\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.FieldM\
    askR\nupdateMask\"p\n\x18ListSubscriptionsRequest\x12\x18\n\x07project\
    \x18\x01\x20\x01(\tR\x07project\x12\x1b\n\tpage_size\x18\x02\x20\x01(\
    \x05R\x08pageSize\x12\x1d\n\npage_token\x18\x03\x20\x01(\tR\tpageToken\"\
    \x89\x01\n\x19ListSubscriptionsResponse\x12D\n\rsubscriptions\x18\x01\
    \x20\x03(\x0b2\x1e.google.pubsub.v1.SubscriptionR\rsubscriptions\x12&\n\
    \x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageToken\"?\n\x19DeleteSub\
    scriptionRequest\x12\"\n\x0csubscription\x18\x01\x20\x01(\tR\x0csubscrip\
    tion\"|\n\x17ModifyPushConfigRequest\x12\"\n\x0csubscription\x18\x01\x20\
    \x01(\tR\x0csubscription\x12=\n\x0bpush_config\x18\x02\x20\x01(\x0b2\x1c\
    .google.pubsub.v1.PushConfigR\npushConfig\"\x83\x01\n\x0bPullRequest\x12\
    \"\n\x0csubscription\x18\x01\x20\x01(\tR\x0csubscription\x12-\n\x12retur\
    n_immediately\x18\x02\x20\x01(\x08R\x11returnImmediately\x12!\n\x0cmax_m\
    essages\x18\x03\x20\x01(\x05R\x0bmaxMessages\"^\n\x0cPullResponse\x12N\n\
    \x11received_messages\x18\x01\x20\x03(\x0b2!.google.pubsub.v1.ReceivedMe\
    ssageR\x10receivedMessages\"\x89\x01\n\x18ModifyAckDeadlineRequest\x12\"\
    \n\x0csubscription\x18\x01\x20\x01(\tR\x0csubscription\x12\x17\n\x07ack_\
    ids\x18\x04\x20\x03(\tR\x06ackIds\x120\n\x14ack_deadline_seconds\x18\x03\
    \x20\x01(\x05R\x12ackDeadlineSeconds\"Q\n\x12AcknowledgeRequest\x12\"\n\
    \x0csubscription\x18\x01\x20\x01(\tR\x0csubscription\x12\x17\n\x07ack_id\
    s\x18\x02\x20\x03(\tR\x06ackIds\"\x81\x02\n\x14StreamingPullRequest\x12\
    \"\n\x0csubscription\x18\x01\x20\x01(\tR\x0csubscription\x12\x17\n\x07ac\
    k_ids\x18\x02\x20\x03(\tR\x06ackIds\x126\n\x17modify_deadline_seconds\
    \x18\x03\x20\x03(\x05R\x15modifyDeadlineSeconds\x125\n\x17modify_deadlin\
    e_ack_ids\x18\x04\x20\x03(\tR\x14modifyDeadlineAckIds\x12=\n\x1bstream_a\
    ck_deadline_seconds\x18\x05\x20\x01(\x05R\x18streamAckDeadlineSeconds\"g\
    \n\x15StreamingPullResponse\x12N\n\x11received_messages\x18\x01\x20\x03(\
    \x0b2!.google.pubsub.v1.ReceivedMessageR\x10receivedMessages\"\xd7\x01\n\
    \x15CreateSnapshotRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12\"\n\x0csubscription\x18\x02\x20\x01(\tR\x0csubscription\x12K\n\x06l\
    abels\x18\x03\x20\x03(\x0b23.google.pubsub.v1.CreateSnapshotRequest.Labe\
    lsEntryR\x06labels\x1a9\n\x0bLabelsEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\
    \x01\"\x8c\x01\n\x15UpdateSnapshotRequest\x126\n\x08snapshot\x18\x01\x20\
    \x01(\x0b2\x1a.google.pubsub.v1.SnapshotR\x08snapshot\x12;\n\x0bupdate_m\
    ask\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.FieldMaskR\nupdateMask\"\
    \xec\x01\n\x08Snapshot\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\
    \x14\n\x05topic\x18\x02\x20\x01(\tR\x05topic\x12;\n\x0bexpire_time\x18\
    \x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\nexpireTime\x12>\n\x06\
    labels\x18\x04\x20\x03(\x0b2&.google.pubsub.v1.Snapshot.LabelsEntryR\x06\
    labels\x1a9\n\x0bLabelsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"0\n\x12GetSn\
    apshotRequest\x12\x1a\n\x08snapshot\x18\x01\x20\x01(\tR\x08snapshot\"l\n\
    \x14ListSnapshotsRequest\x12\x18\n\x07project\x18\x01\x20\x01(\tR\x07pro\
    ject\x12\x1b\n\tpage_size\x18\x02\x20\x01(\x05R\x08pageSize\x12\x1d\n\np\
    age_token\x18\x03\x20\x01(\tR\tpageToken\"y\n\x15ListSnapshotsResponse\
    \x128\n\tsnapshots\x18\x01\x20\x03(\x0b2\x1a.google.pubsub.v1.SnapshotR\
    \tsnapshots\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageToken\
    \"3\n\x15DeleteSnapshotRequest\x12\x1a\n\x08snapshot\x18\x01\x20\x01(\tR\
    \x08snapshot\"\x8b\x01\n\x0bSeekRequest\x12\"\n\x0csubscription\x18\x01\
    \x20\x01(\tR\x0csubscription\x120\n\x04time\x18\x02\x20\x01(\x0b2\x1a.go\
    ogle.protobuf.TimestampH\0R\x04time\x12\x1c\n\x08snapshot\x18\x03\x20\
    \x01(\tH\0R\x08snapshotB\x08\n\x06target\"\x0e\n\x0cSeekResponse2\xbf\
    \x08\n\tPublisher\x12j\n\x0bCreateTopic\x12\x17.google.pubsub.v1.Topic\
    \x1a\x17.google.pubsub.v1.Topic\")\x82\xd3\xe4\x93\x02#\x1a\x1e/v1/{name\
    =projects/*/topics/*}:\x01*\x12}\n\x0bUpdateTopic\x12$.google.pubsub.v1.\
    UpdateTopicRequest\x1a\x17.google.pubsub.v1.Topic\"/\x82\xd3\xe4\x93\x02\
    )2$/v1/{topic.name=projects/*/topics/*}:\x01*\x12\x82\x01\n\x07Publish\
    \x12\x20.google.pubsub.v1.PublishRequest\x1a!.google.pubsub.v1.PublishRe\
    sponse\"2\x82\xd3\xe4\x93\x02,\"'/v1/{topic=projects/*/topics/*}:publish\
    :\x01*\x12o\n\x08GetTopic\x12!.google.pubsub.v1.GetTopicRequest\x1a\x17.\
    google.pubsub.v1.Topic\"'\x82\xd3\xe4\x93\x02!\x12\x1f/v1/{topic=project\
    s/*/topics/*}\x12\x80\x01\n\nListTopics\x12#.google.pubsub.v1.ListTopics\
    Request\x1a$.google.pubsub.v1.ListTopicsResponse\"'\x82\xd3\xe4\x93\x02!\
    \x12\x1f/v1/{project=projects/*}/topics\x12\xb2\x01\n\x16ListTopicSubscr\
    iptions\x12/.google.pubsub.v1.ListTopicSubscriptionsRequest\x1a0.google.\
    pubsub.v1.ListTopicSubscriptionsResponse\"5\x82\xd3\xe4\x93\x02/\x12-/v1\
    /{topic=projects/*/topics/*}/subscriptions\x12\xa2\x01\n\x12ListTopicSna\
    pshots\x12+.google.pubsub.v1.ListTopicSnapshotsRequest\x1a,.google.pubsu\
    b.v1.ListTopicSnapshotsResponse\"1\x82\xd3\xe4\x93\x02+\x12)/v1/{topic=p\
    rojects/*/topics/*}/snapshots\x12t\n\x0bDeleteTopic\x12$.google.pubsub.v\
    1.DeleteTopicRequest\x1a\x16.google.protobuf.Empty\"'\x82\xd3\xe4\x93\
    \x02!*\x1f/v1/{topic=projects/*/topics/*}2\xf9\x11\n\nSubscriber\x12\x86\
    \x01\n\x12CreateSubscription\x12\x1e.google.pubsub.v1.Subscription\x1a\
    \x1e.google.pubsub.v1.Subscription\"0\x82\xd3\xe4\x93\x02*\x1a%/v1/{name\
    =projects/*/subscriptions/*}:\x01*\x12\x92\x01\n\x0fGetSubscription\x12(\
    .google.pubsub.v1.GetSubscriptionRequest\x1a\x1e.google.pubsub.v1.Subscr\
    iption\"5\x82\xd3\xe4\x93\x02/\x12-/v1/{subscription=projects/*/subscrip\
    tions/*}\x12\xa0\x01\n\x12UpdateSubscription\x12+.google.pubsub.v1.Updat\
    eSubscriptionRequest\x1a\x1e.google.pubsub.v1.Subscription\"=\x82\xd3\
    \xe4\x93\x02722/v1/{subscription.name=projects/*/subscriptions/*}:\x01*\
    \x12\x9c\x01\n\x11ListSubscriptions\x12*.google.pubsub.v1.ListSubscripti\
    onsRequest\x1a+.google.pubsub.v1.ListSubscriptionsResponse\".\x82\xd3\
    \xe4\x93\x02(\x12&/v1/{project=projects/*}/subscriptions\x12\x90\x01\n\
    \x12DeleteSubscription\x12+.google.pubsub.v1.DeleteSubscriptionRequest\
    \x1a\x16.google.protobuf.Empty\"5\x82\xd3\xe4\x93\x02/*-/v1/{subscriptio\
    n=projects/*/subscriptions/*}\x12\xa3\x01\n\x11ModifyAckDeadline\x12*.go\
    ogle.pubsub.v1.ModifyAckDeadlineRequest\x1a\x16.google.protobuf.Empty\"J\
    \x82\xd3\xe4\x93\x02D\"?/v1/{subscription=projects/*/subscriptions/*}:mo\
    difyAckDeadline:\x01*\x12\x91\x01\n\x0bAcknowledge\x12$.google.pubsub.v1\
    .AcknowledgeRequest\x1a\x16.google.protobuf.Empty\"D\x82\xd3\xe4\x93\x02\
    >\"9/v1/{subscription=projects/*/subscriptions/*}:acknowledge:\x01*\x12\
    \x84\x01\n\x04Pull\x12\x1d.google.pubsub.v1.PullRequest\x1a\x1e.google.p\
    ubsub.v1.PullResponse\"=\x82\xd3\xe4\x93\x027\"2/v1/{subscription=projec\
    ts/*/subscriptions/*}:pull:\x01*\x12f\n\rStreamingPull\x12&.google.pubsu\
    b.v1.StreamingPullRequest\x1a'.google.pubsub.v1.StreamingPullResponse\"\
    \0(\x010\x01\x12\xa0\x01\n\x10ModifyPushConfig\x12).google.pubsub.v1.Mod\
    ifyPushConfigRequest\x1a\x16.google.protobuf.Empty\"I\x82\xd3\xe4\x93\
    \x02C\">/v1/{subscription=projects/*/subscriptions/*}:modifyPushConfig:\
    \x01*\x12~\n\x0bGetSnapshot\x12$.google.pubsub.v1.GetSnapshotRequest\x1a\
    \x1a.google.pubsub.v1.Snapshot\"-\x82\xd3\xe4\x93\x02'\x12%/v1/{snapshot\
    =projects/*/snapshots/*}\x12\x8c\x01\n\rListSnapshots\x12&.google.pubsub\
    .v1.ListSnapshotsRequest\x1a'.google.pubsub.v1.ListSnapshotsResponse\"*\
    \x82\xd3\xe4\x93\x02$\x12\"/v1/{project=projects/*}/snapshots\x12\x83\
    \x01\n\x0eCreateSnapshot\x12'.google.pubsub.v1.CreateSnapshotRequest\x1a\
    \x1a.google.pubsub.v1.Snapshot\",\x82\xd3\xe4\x93\x02&\x1a!/v1/{name=pro\
    jects/*/snapshots/*}:\x01*\x12\x8c\x01\n\x0eUpdateSnapshot\x12'.google.p\
    ubsub.v1.UpdateSnapshotRequest\x1a\x1a.google.pubsub.v1.Snapshot\"5\x82\
    \xd3\xe4\x93\x02/2*/v1/{snapshot.name=projects/*/snapshots/*}:\x01*\x12\
    \x80\x01\n\x0eDeleteSnapshot\x12'.google.pubsub.v1.DeleteSnapshotRequest\
    \x1a\x16.google.protobuf.Empty\"-\x82\xd3\xe4\x93\x02'*%/v1/{snapshot=pr\
    ojects/*/snapshots/*}\x12\x84\x01\n\x04Seek\x12\x1d.google.pubsub.v1.See\
    kRequest\x1a\x1e.google.pubsub.v1.SeekResponse\"=\x82\xd3\xe4\x93\x027\"\
    2/v1/{subscription=projects/*/subscriptions/*}:seek:\x01*B\x92\x01\n\x14\
    com.google.pubsub.v1B\x0bPubsubProtoP\x01Z6google.golang.org/genproto/go\
    ogleapis/pubsub/v1;pubsub\xf8\x01\x01\xaa\x02\x16Google.Cloud.PubSub.V1\
    \xca\x02\x16Google\\Cloud\\PubSub\\V1J\x9a\xba\x02\n\x07\x12\x05\x0f\0\
    \xab\x07\x01\n\xbe\x04\n\x01\x0c\x12\x03\x0f\0\x122\xb3\x04\x20Copyright\
    \x202018\x20Google\x20LLC.\n\n\x20Licensed\x20under\x20the\x20Apache\x20\
    License,\x20Version\x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20n\
    ot\x20use\x20this\x20file\x20except\x20in\x20compliance\x20with\x20the\
    \x20License.\n\x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20Lice\
    nse\x20at\n\n\x20\x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-\
    2.0\n\n\x20Unless\x20required\x20by\x20applicable\x20law\x20or\x20agreed\
    \x20to\x20in\x20writing,\x20software\n\x20distributed\x20under\x20the\
    \x20License\x20is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\
    \x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20e\
    ither\x20express\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20\
    the\x20specific\x20language\x20governing\x20permissions\x20and\n\x20limi\
    tations\x20under\x20the\x20License.\n\n\n\x08\n\x01\x02\x12\x03\x11\0\
    \x19\n\t\n\x02\x03\0\x12\x03\x13\0&\n\t\n\x02\x03\x01\x12\x03\x14\0(\n\t\
    \n\x02\x03\x02\x12\x03\x15\0%\n\t\n\x02\x03\x03\x12\x03\x16\0*\n\t\n\x02\
    \x03\x04\x12\x03\x17\0)\n\x08\n\x01\x08\x12\x03\x19\0\x1f\n\t\n\x02\x08\
    \x1f\x12\x03\x19\0\x1f\n\x08\n\x01\x08\x12\x03\x1a\03\n\t\n\x02\x08%\x12\
    \x03\x1a\03\n\x08\n\x01\x08\x12\x03\x1b\0M\n\t\n\x02\x08\x0b\x12\x03\x1b\
    \0M\n\x08\n\x01\x08\x12\x03\x1c\0\"\n\t\n\x02\x08\n\x12\x03\x1c\0\"\n\
    \x08\n\x01\x08\x12\x03\x1d\0,\n\t\n\x02\x08\x08\x12\x03\x1d\0,\n\x08\n\
    \x01\x08\x12\x03\x1e\0-\n\t\n\x02\x08\x01\x12\x03\x1e\0-\n\x08\n\x01\x08\
    \x12\x03\x1f\03\n\t\n\x02\x08)\x12\x03\x1f\03\nj\n\x02\x06\0\x12\x04$\0i\
    \x01\x1a^\x20The\x20service\x20that\x20an\x20application\x20uses\x20to\
    \x20manipulate\x20topics,\x20and\x20to\x20send\n\x20messages\x20to\x20a\
    \x20topic.\n\n\n\n\x03\x06\0\x01\x12\x03$\x08\x11\n\x8b\x01\n\x04\x06\0\
    \x02\0\x12\x04'\x02,\x03\x1a}\x20Creates\x20the\x20given\x20topic\x20wit\
    h\x20the\x20given\x20name.\x20See\x20the\n\x20<a\x20href=\"/pubsub/docs/\
    admin#resource_names\">\x20resource\x20name\x20rules</a>.\n\n\x0c\n\x05\
    \x06\0\x02\0\x01\x12\x03'\x06\x11\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03'\
    \x12\x17\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03'\"'\n\r\n\x05\x06\0\x02\0\
    \x04\x12\x04(\x04+\x06\n\x11\n\t\x06\0\x02\0\x04\xb0\xca\xbc\"\x12\x04(\
    \x04+\x06\ng\n\x04\x06\0\x02\x01\x12\x040\x025\x03\x1aY\x20Updates\x20an\
    \x20existing\x20topic.\x20Note\x20that\x20certain\x20properties\x20of\
    \x20a\n\x20topic\x20are\x20not\x20modifiable.\n\n\x0c\n\x05\x06\0\x02\
    \x01\x01\x12\x030\x06\x11\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x030\x12$\n\
    \x0c\n\x05\x06\0\x02\x01\x03\x12\x030/4\n\r\n\x05\x06\0\x02\x01\x04\x12\
    \x041\x044\x06\n\x11\n\t\x06\0\x02\x01\x04\xb0\xca\xbc\"\x12\x041\x044\
    \x06\ni\n\x04\x06\0\x02\x02\x12\x049\x02>\x03\x1a[\x20Adds\x20one\x20or\
    \x20more\x20messages\x20to\x20the\x20topic.\x20Returns\x20`NOT_FOUND`\
    \x20if\x20the\x20topic\n\x20does\x20not\x20exist.\n\n\x0c\n\x05\x06\0\
    \x02\x02\x01\x12\x039\x06\r\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x039\x0e\
    \x1c\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x039'6\n\r\n\x05\x06\0\x02\x02\
    \x04\x12\x04:\x04=\x06\n\x11\n\t\x06\0\x02\x02\x04\xb0\xca\xbc\"\x12\x04\
    :\x04=\x06\n2\n\x04\x06\0\x02\x03\x12\x04A\x02E\x03\x1a$\x20Gets\x20the\
    \x20configuration\x20of\x20a\x20topic.\n\n\x0c\n\x05\x06\0\x02\x03\x01\
    \x12\x03A\x06\x0e\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03A\x0f\x1e\n\x0c\n\
    \x05\x06\0\x02\x03\x03\x12\x03A).\n\r\n\x05\x06\0\x02\x03\x04\x12\x04B\
    \x04D\x06\n\x11\n\t\x06\0\x02\x03\x04\xb0\xca\xbc\"\x12\x04B\x04D\x06\n&\
    \n\x04\x06\0\x02\x04\x12\x04H\x02L\x03\x1a\x18\x20Lists\x20matching\x20t\
    opics.\n\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03H\x06\x10\n\x0c\n\x05\x06\
    \0\x02\x04\x02\x12\x03H\x11\"\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03H-?\n\
    \r\n\x05\x06\0\x02\x04\x04\x12\x04I\x04K\x06\n\x11\n\t\x06\0\x02\x04\x04\
    \xb0\xca\xbc\"\x12\x04I\x04K\x06\nC\n\x04\x06\0\x02\x05\x12\x04O\x02S\
    \x03\x1a5\x20Lists\x20the\x20names\x20of\x20the\x20subscriptions\x20on\
    \x20this\x20topic.\n\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03O\x06\x1c\n\
    \x0c\n\x05\x06\0\x02\x05\x02\x12\x03O\x1d:\n\x0c\n\x05\x06\0\x02\x05\x03\
    \x12\x03OEc\n\r\n\x05\x06\0\x02\x05\x04\x12\x04P\x04R\x06\n\x11\n\t\x06\
    \0\x02\x05\x04\xb0\xca\xbc\"\x12\x04P\x04R\x06\n\x9a\x02\n\x04\x06\0\x02\
    \x06\x12\x04Y\x02]\x03\x1a\x8b\x02\x20Lists\x20the\x20names\x20of\x20the\
    \x20snapshots\x20on\x20this\x20topic.<br><br>\n\x20<b>ALPHA:</b>\x20This\
    \x20feature\x20is\x20part\x20of\x20an\x20alpha\x20release.\x20This\x20AP\
    I\x20might\x20be\n\x20changed\x20in\x20backward-incompatible\x20ways\x20\
    and\x20is\x20not\x20recommended\x20for\x20production\n\x20use.\x20It\x20\
    is\x20not\x20subject\x20to\x20any\x20SLA\x20or\x20deprecation\x20policy.\
    \n\n\x0c\n\x05\x06\0\x02\x06\x01\x12\x03Y\x06\x18\n\x0c\n\x05\x06\0\x02\
    \x06\x02\x12\x03Y\x192\n\x0c\n\x05\x06\0\x02\x06\x03\x12\x03Y=W\n\r\n\
    \x05\x06\0\x02\x06\x04\x12\x04Z\x04\\\x06\n\x11\n\t\x06\0\x02\x06\x04\
    \xb0\xca\xbc\"\x12\x04Z\x04\\\x06\n\xf3\x02\n\x04\x06\0\x02\x07\x12\x04d\
    \x02h\x03\x1a\xe4\x02\x20Deletes\x20the\x20topic\x20with\x20the\x20given\
    \x20name.\x20Returns\x20`NOT_FOUND`\x20if\x20the\x20topic\n\x20does\x20n\
    ot\x20exist.\x20After\x20a\x20topic\x20is\x20deleted,\x20a\x20new\x20top\
    ic\x20may\x20be\x20created\x20with\n\x20the\x20same\x20name;\x20this\x20\
    is\x20an\x20entirely\x20new\x20topic\x20with\x20none\x20of\x20the\x20old\
    \n\x20configuration\x20or\x20subscriptions.\x20Existing\x20subscriptions\
    \x20to\x20this\x20topic\x20are\n\x20not\x20deleted,\x20but\x20their\x20`\
    topic`\x20field\x20is\x20set\x20to\x20`_deleted-topic_`.\n\n\x0c\n\x05\
    \x06\0\x02\x07\x01\x12\x03d\x06\x11\n\x0c\n\x05\x06\0\x02\x07\x02\x12\
    \x03d\x12$\n\x0c\n\x05\x06\0\x02\x07\x03\x12\x03d/D\n\r\n\x05\x06\0\x02\
    \x07\x04\x12\x04e\x04g\x06\n\x11\n\t\x06\0\x02\x07\x04\xb0\xca\xbc\"\x12\
    \x04e\x04g\x06\n\xe1\x01\n\x02\x06\x01\x12\x05n\0\xad\x02\x01\x1a\xd3\
    \x01\x20The\x20service\x20that\x20an\x20application\x20uses\x20to\x20man\
    ipulate\x20subscriptions\x20and\x20to\n\x20consume\x20messages\x20from\
    \x20a\x20subscription\x20via\x20the\x20`Pull`\x20method\x20or\x20by\n\
    \x20establishing\x20a\x20bi-directional\x20stream\x20using\x20the\x20`St\
    reamingPull`\x20method.\n\n\n\n\x03\x06\x01\x01\x12\x03n\x08\x12\n\x84\
    \x05\n\x04\x06\x01\x02\0\x12\x04z\x02\x7f\x03\x1a\xf5\x04\x20Creates\x20\
    a\x20subscription\x20to\x20a\x20given\x20topic.\x20See\x20the\n\x20<a\
    \x20href=\"/pubsub/docs/admin#resource_names\">\x20resource\x20name\x20r\
    ules</a>.\n\x20If\x20the\x20subscription\x20already\x20exists,\x20return\
    s\x20`ALREADY_EXISTS`.\n\x20If\x20the\x20corresponding\x20topic\x20doesn\
    't\x20exist,\x20returns\x20`NOT_FOUND`.\n\n\x20If\x20the\x20name\x20is\
    \x20not\x20provided\x20in\x20the\x20request,\x20the\x20server\x20will\
    \x20assign\x20a\x20random\n\x20name\x20for\x20this\x20subscription\x20on\
    \x20the\x20same\x20project\x20as\x20the\x20topic,\x20conforming\n\x20to\
    \x20the\n\x20[resource\x20name\x20format](https://cloud.google.com/pubsu\
    b/docs/overview#names).\n\x20The\x20generated\x20name\x20is\x20populated\
    \x20in\x20the\x20returned\x20Subscription\x20object.\n\x20Note\x20that\
    \x20for\x20REST\x20API\x20requests,\x20you\x20must\x20specify\x20a\x20na\
    me\x20in\x20the\x20request.\n\n\x0c\n\x05\x06\x01\x02\0\x01\x12\x03z\x06\
    \x18\n\x0c\n\x05\x06\x01\x02\0\x02\x12\x03z\x19%\n\x0c\n\x05\x06\x01\x02\
    \0\x03\x12\x03z0<\n\r\n\x05\x06\x01\x02\0\x04\x12\x04{\x04~\x06\n\x11\n\
    \t\x06\x01\x02\0\x04\xb0\xca\xbc\"\x12\x04{\x04~\x06\nC\n\x04\x06\x01\
    \x02\x01\x12\x06\x82\x01\x02\x86\x01\x03\x1a3\x20Gets\x20the\x20configur\
    ation\x20details\x20of\x20a\x20subscription.\n\n\r\n\x05\x06\x01\x02\x01\
    \x01\x12\x04\x82\x01\x06\x15\n\r\n\x05\x06\x01\x02\x01\x02\x12\x04\x82\
    \x01\x16,\n\r\n\x05\x06\x01\x02\x01\x03\x12\x04\x82\x017C\n\x0f\n\x05\
    \x06\x01\x02\x01\x04\x12\x06\x83\x01\x04\x85\x01\x06\n\x13\n\t\x06\x01\
    \x02\x01\x04\xb0\xca\xbc\"\x12\x06\x83\x01\x04\x85\x01\x06\n\x8b\x01\n\
    \x04\x06\x01\x02\x02\x12\x06\x8a\x01\x02\x8f\x01\x03\x1a{\x20Updates\x20\
    an\x20existing\x20subscription.\x20Note\x20that\x20certain\x20properties\
    \x20of\x20a\n\x20subscription,\x20such\x20as\x20its\x20topic,\x20are\x20\
    not\x20modifiable.\n\n\r\n\x05\x06\x01\x02\x02\x01\x12\x04\x8a\x01\x06\
    \x18\n\r\n\x05\x06\x01\x02\x02\x02\x12\x04\x8a\x01\x192\n\r\n\x05\x06\
    \x01\x02\x02\x03\x12\x04\x8a\x01=I\n\x0f\n\x05\x06\x01\x02\x02\x04\x12\
    \x06\x8b\x01\x04\x8e\x01\x06\n\x13\n\t\x06\x01\x02\x02\x04\xb0\xca\xbc\"\
    \x12\x06\x8b\x01\x04\x8e\x01\x06\n/\n\x04\x06\x01\x02\x03\x12\x06\x92\
    \x01\x02\x96\x01\x03\x1a\x1f\x20Lists\x20matching\x20subscriptions.\n\n\
    \r\n\x05\x06\x01\x02\x03\x01\x12\x04\x92\x01\x06\x17\n\r\n\x05\x06\x01\
    \x02\x03\x02\x12\x04\x92\x01\x180\n\r\n\x05\x06\x01\x02\x03\x03\x12\x04\
    \x92\x01;T\n\x0f\n\x05\x06\x01\x02\x03\x04\x12\x06\x93\x01\x04\x95\x01\
    \x06\n\x13\n\t\x06\x01\x02\x03\x04\xb0\xca\xbc\"\x12\x06\x93\x01\x04\x95\
    \x01\x06\n\xef\x02\n\x04\x06\x01\x02\x04\x12\x06\x9d\x01\x02\xa1\x01\x03\
    \x1a\xde\x02\x20Deletes\x20an\x20existing\x20subscription.\x20All\x20mes\
    sages\x20retained\x20in\x20the\x20subscription\n\x20are\x20immediately\
    \x20dropped.\x20Calls\x20to\x20`Pull`\x20after\x20deletion\x20will\x20re\
    turn\n\x20`NOT_FOUND`.\x20After\x20a\x20subscription\x20is\x20deleted,\
    \x20a\x20new\x20one\x20may\x20be\x20created\x20with\n\x20the\x20same\x20\
    name,\x20but\x20the\x20new\x20one\x20has\x20no\x20association\x20with\
    \x20the\x20old\n\x20subscription\x20or\x20its\x20topic\x20unless\x20the\
    \x20same\x20topic\x20is\x20specified.\n\n\r\n\x05\x06\x01\x02\x04\x01\
    \x12\x04\x9d\x01\x06\x18\n\r\n\x05\x06\x01\x02\x04\x02\x12\x04\x9d\x01\
    \x192\n\r\n\x05\x06\x01\x02\x04\x03\x12\x04\x9d\x01=R\n\x0f\n\x05\x06\
    \x01\x02\x04\x04\x12\x06\x9e\x01\x04\xa0\x01\x06\n\x13\n\t\x06\x01\x02\
    \x04\x04\xb0\xca\xbc\"\x12\x06\x9e\x01\x04\xa0\x01\x06\n\xe7\x02\n\x04\
    \x06\x01\x02\x05\x12\x06\xa8\x01\x02\xad\x01\x03\x1a\xd6\x02\x20Modifies\
    \x20the\x20ack\x20deadline\x20for\x20a\x20specific\x20message.\x20This\
    \x20method\x20is\x20useful\n\x20to\x20indicate\x20that\x20more\x20time\
    \x20is\x20needed\x20to\x20process\x20a\x20message\x20by\x20the\n\x20subs\
    criber,\x20or\x20to\x20make\x20the\x20message\x20available\x20for\x20red\
    elivery\x20if\x20the\n\x20processing\x20was\x20interrupted.\x20Note\x20t\
    hat\x20this\x20does\x20not\x20modify\x20the\n\x20subscription-level\x20`\
    ackDeadlineSeconds`\x20used\x20for\x20subsequent\x20messages.\n\n\r\n\
    \x05\x06\x01\x02\x05\x01\x12\x04\xa8\x01\x06\x17\n\r\n\x05\x06\x01\x02\
    \x05\x02\x12\x04\xa8\x01\x180\n\r\n\x05\x06\x01\x02\x05\x03\x12\x04\xa8\
    \x01;P\n\x0f\n\x05\x06\x01\x02\x05\x04\x12\x06\xa9\x01\x04\xac\x01\x06\n\
    \x13\n\t\x06\x01\x02\x05\x04\xb0\xca\xbc\"\x12\x06\xa9\x01\x04\xac\x01\
    \x06\n\xed\x02\n\x04\x06\x01\x02\x06\x12\x06\xb6\x01\x02\xbb\x01\x03\x1a\
    \xdc\x02\x20Acknowledges\x20the\x20messages\x20associated\x20with\x20the\
    \x20`ack_ids`\x20in\x20the\n\x20`AcknowledgeRequest`.\x20The\x20Pub/Sub\
    \x20system\x20can\x20remove\x20the\x20relevant\x20messages\n\x20from\x20\
    the\x20subscription.\n\n\x20Acknowledging\x20a\x20message\x20whose\x20ac\
    k\x20deadline\x20has\x20expired\x20may\x20succeed,\n\x20but\x20such\x20a\
    \x20message\x20may\x20be\x20redelivered\x20later.\x20Acknowledging\x20a\
    \x20message\x20more\n\x20than\x20once\x20will\x20not\x20result\x20in\x20\
    an\x20error.\n\n\r\n\x05\x06\x01\x02\x06\x01\x12\x04\xb6\x01\x06\x11\n\r\
    \n\x05\x06\x01\x02\x06\x02\x12\x04\xb6\x01\x12$\n\r\n\x05\x06\x01\x02\
    \x06\x03\x12\x04\xb6\x01/D\n\x0f\n\x05\x06\x01\x02\x06\x04\x12\x06\xb7\
    \x01\x04\xba\x01\x06\n\x13\n\t\x06\x01\x02\x06\x04\xb0\xca\xbc\"\x12\x06\
    \xb7\x01\x04\xba\x01\x06\n\xab\x01\n\x04\x06\x01\x02\x07\x12\x06\xc0\x01\
    \x02\xc5\x01\x03\x1a\x9a\x01\x20Pulls\x20messages\x20from\x20the\x20serv\
    er.\x20The\x20server\x20may\x20return\x20`UNAVAILABLE`\x20if\n\x20there\
    \x20are\x20too\x20many\x20concurrent\x20pull\x20requests\x20pending\x20f\
    or\x20the\x20given\n\x20subscription.\n\n\r\n\x05\x06\x01\x02\x07\x01\
    \x12\x04\xc0\x01\x06\n\n\r\n\x05\x06\x01\x02\x07\x02\x12\x04\xc0\x01\x0b\
    \x16\n\r\n\x05\x06\x01\x02\x07\x03\x12\x04\xc0\x01!-\n\x0f\n\x05\x06\x01\
    \x02\x07\x04\x12\x06\xc1\x01\x04\xc4\x01\x06\n\x13\n\t\x06\x01\x02\x07\
    \x04\xb0\xca\xbc\"\x12\x06\xc1\x01\x04\xc4\x01\x06\n\xe2\x03\n\x04\x06\
    \x01\x02\x08\x12\x06\xce\x01\x02\xcf\x01\x03\x1a\xd1\x03\x20Establishes\
    \x20a\x20stream\x20with\x20the\x20server,\x20which\x20sends\x20messages\
    \x20down\x20to\x20the\n\x20client.\x20The\x20client\x20streams\x20acknow\
    ledgements\x20and\x20ack\x20deadline\x20modifications\n\x20back\x20to\
    \x20the\x20server.\x20The\x20server\x20will\x20close\x20the\x20stream\
    \x20and\x20return\x20the\x20status\n\x20on\x20any\x20error.\x20The\x20se\
    rver\x20may\x20close\x20the\x20stream\x20with\x20status\x20`UNAVAILABLE`\
    \x20to\n\x20reassign\x20server-side\x20resources,\x20in\x20which\x20case\
    ,\x20the\x20client\x20should\n\x20re-establish\x20the\x20stream.\x20Flow\
    \x20control\x20can\x20be\x20achieved\x20by\x20configuring\x20the\n\x20un\
    derlying\x20RPC\x20channel.\n\n\r\n\x05\x06\x01\x02\x08\x01\x12\x04\xce\
    \x01\x06\x13\n\r\n\x05\x06\x01\x02\x08\x05\x12\x04\xce\x01\x14\x1a\n\r\n\
    \x05\x06\x01\x02\x08\x02\x12\x04\xce\x01\x1b/\n\r\n\x05\x06\x01\x02\x08\
    \x06\x12\x04\xce\x01:@\n\r\n\x05\x06\x01\x02\x08\x03\x12\x04\xce\x01AV\n\
    \xf7\x02\n\x04\x06\x01\x02\t\x12\x06\xd7\x01\x02\xdc\x01\x03\x1a\xe6\x02\
    \x20Modifies\x20the\x20`PushConfig`\x20for\x20a\x20specified\x20subscrip\
    tion.\n\n\x20This\x20may\x20be\x20used\x20to\x20change\x20a\x20push\x20s\
    ubscription\x20to\x20a\x20pull\x20one\x20(signified\x20by\n\x20an\x20emp\
    ty\x20`PushConfig`)\x20or\x20vice\x20versa,\x20or\x20change\x20the\x20en\
    dpoint\x20URL\x20and\x20other\n\x20attributes\x20of\x20a\x20push\x20subs\
    cription.\x20Messages\x20will\x20accumulate\x20for\x20delivery\n\x20cont\
    inuously\x20through\x20the\x20call\x20regardless\x20of\x20changes\x20to\
    \x20the\x20`PushConfig`.\n\n\r\n\x05\x06\x01\x02\t\x01\x12\x04\xd7\x01\
    \x06\x16\n\r\n\x05\x06\x01\x02\t\x02\x12\x04\xd7\x01\x17.\n\r\n\x05\x06\
    \x01\x02\t\x03\x12\x04\xd7\x019N\n\x0f\n\x05\x06\x01\x02\t\x04\x12\x06\
    \xd8\x01\x04\xdb\x01\x06\n\x13\n\t\x06\x01\x02\t\x04\xb0\xca\xbc\"\x12\
    \x06\xd8\x01\x04\xdb\x01\x06\n\x9a\x02\n\x04\x06\x01\x02\n\x12\x06\xe2\
    \x01\x02\xe6\x01\x03\x1a\x89\x02\x20Gets\x20the\x20configuration\x20deta\
    ils\x20of\x20a\x20snapshot.<br><br>\n\x20<b>ALPHA:</b>\x20This\x20featur\
    e\x20is\x20part\x20of\x20an\x20alpha\x20release.\x20This\x20API\x20might\
    \x20be\n\x20changed\x20in\x20backward-incompatible\x20ways\x20and\x20is\
    \x20not\x20recommended\x20for\x20production\n\x20use.\x20It\x20is\x20not\
    \x20subject\x20to\x20any\x20SLA\x20or\x20deprecation\x20policy.\n\n\r\n\
    \x05\x06\x01\x02\n\x01\x12\x04\xe2\x01\x06\x11\n\r\n\x05\x06\x01\x02\n\
    \x02\x12\x04\xe2\x01\x12$\n\r\n\x05\x06\x01\x02\n\x03\x12\x04\xe2\x01/7\
    \n\x0f\n\x05\x06\x01\x02\n\x04\x12\x06\xe3\x01\x04\xe5\x01\x06\n\x13\n\t\
    \x06\x01\x02\n\x04\xb0\xca\xbc\"\x12\x06\xe3\x01\x04\xe5\x01\x06\n\x8a\
    \x02\n\x04\x06\x01\x02\x0b\x12\x06\xec\x01\x02\xf0\x01\x03\x1a\xf9\x01\
    \x20Lists\x20the\x20existing\x20snapshots.<br><br>\n\x20<b>ALPHA:</b>\
    \x20This\x20feature\x20is\x20part\x20of\x20an\x20alpha\x20release.\x20Th\
    is\x20API\x20might\x20be\n\x20changed\x20in\x20backward-incompatible\x20\
    ways\x20and\x20is\x20not\x20recommended\x20for\x20production\n\x20use.\
    \x20It\x20is\x20not\x20subject\x20to\x20any\x20SLA\x20or\x20deprecation\
    \x20policy.\n\n\r\n\x05\x06\x01\x02\x0b\x01\x12\x04\xec\x01\x06\x13\n\r\
    \n\x05\x06\x01\x02\x0b\x02\x12\x04\xec\x01\x14(\n\r\n\x05\x06\x01\x02\
    \x0b\x03\x12\x04\xec\x013H\n\x0f\n\x05\x06\x01\x02\x0b\x04\x12\x06\xed\
    \x01\x04\xef\x01\x06\n\x13\n\t\x06\x01\x02\x0b\x04\xb0\xca\xbc\"\x12\x06\
    \xed\x01\x04\xef\x01\x06\n\xe7\x07\n\x04\x06\x01\x02\x0c\x12\x06\x81\x02\
    \x02\x86\x02\x03\x1a\xd6\x07\x20Creates\x20a\x20snapshot\x20from\x20the\
    \x20requested\x20subscription.<br><br>\n\x20<b>ALPHA:</b>\x20This\x20fea\
    ture\x20is\x20part\x20of\x20an\x20alpha\x20release.\x20This\x20API\x20mi\
    ght\x20be\n\x20changed\x20in\x20backward-incompatible\x20ways\x20and\x20\
    is\x20not\x20recommended\x20for\x20production\n\x20use.\x20It\x20is\x20n\
    ot\x20subject\x20to\x20any\x20SLA\x20or\x20deprecation\x20policy.<br><br\
    >\n\x20If\x20the\x20snapshot\x20already\x20exists,\x20returns\x20`ALREAD\
    Y_EXISTS`.\n\x20If\x20the\x20requested\x20subscription\x20doesn't\x20exi\
    st,\x20returns\x20`NOT_FOUND`.\n\x20If\x20the\x20backlog\x20in\x20the\
    \x20subscription\x20is\x20too\x20old\x20--\x20and\x20the\x20resulting\
    \x20snapshot\n\x20would\x20expire\x20in\x20less\x20than\x201\x20hour\x20\
    --\x20then\x20`FAILED_PRECONDITION`\x20is\x20returned.\n\x20See\x20also\
    \x20the\x20`Snapshot.expire_time`\x20field.\x20If\x20the\x20name\x20is\
    \x20not\x20provided\x20in\n\x20the\x20request,\x20the\x20server\x20will\
    \x20assign\x20a\x20random\n\x20name\x20for\x20this\x20snapshot\x20on\x20\
    the\x20same\x20project\x20as\x20the\x20subscription,\x20conforming\n\x20\
    to\x20the\x20[resource\x20name\x20format](https://cloud.google.com/pubsu\
    b/docs/overview#names).\n\x20The\x20generated\n\x20name\x20is\x20populat\
    ed\x20in\x20the\x20returned\x20Snapshot\x20object.\x20Note\x20that\x20fo\
    r\x20REST\x20API\n\x20requests,\x20you\x20must\x20specify\x20a\x20name\
    \x20in\x20the\x20request.\n\n\r\n\x05\x06\x01\x02\x0c\x01\x12\x04\x81\
    \x02\x06\x14\n\r\n\x05\x06\x01\x02\x0c\x02\x12\x04\x81\x02\x15*\n\r\n\
    \x05\x06\x01\x02\x0c\x03\x12\x04\x81\x025=\n\x0f\n\x05\x06\x01\x02\x0c\
    \x04\x12\x06\x82\x02\x04\x85\x02\x06\n\x13\n\t\x06\x01\x02\x0c\x04\xb0\
    \xca\xbc\"\x12\x06\x82\x02\x04\x85\x02\x06\n\xca\x02\n\x04\x06\x01\x02\r\
    \x12\x06\x8d\x02\x02\x92\x02\x03\x1a\xb9\x02\x20Updates\x20an\x20existin\
    g\x20snapshot.<br><br>\n\x20<b>ALPHA:</b>\x20This\x20feature\x20is\x20pa\
    rt\x20of\x20an\x20alpha\x20release.\x20This\x20API\x20might\x20be\n\x20c\
    hanged\x20in\x20backward-incompatible\x20ways\x20and\x20is\x20not\x20rec\
    ommended\x20for\x20production\n\x20use.\x20It\x20is\x20not\x20subject\
    \x20to\x20any\x20SLA\x20or\x20deprecation\x20policy.\n\x20Note\x20that\
    \x20certain\x20properties\x20of\x20a\x20snapshot\x20are\x20not\x20modifi\
    able.\n\n\r\n\x05\x06\x01\x02\r\x01\x12\x04\x8d\x02\x06\x14\n\r\n\x05\
    \x06\x01\x02\r\x02\x12\x04\x8d\x02\x15*\n\r\n\x05\x06\x01\x02\r\x03\x12\
    \x04\x8d\x025=\n\x0f\n\x05\x06\x01\x02\r\x04\x12\x06\x8e\x02\x04\x91\x02\
    \x06\n\x13\n\t\x06\x01\x02\r\x04\xb0\xca\xbc\"\x12\x06\x8e\x02\x04\x91\
    \x02\x06\n\xaf\x04\n\x04\x06\x01\x02\x0e\x12\x06\x9c\x02\x02\xa0\x02\x03\
    \x1a\x9e\x04\x20Removes\x20an\x20existing\x20snapshot.\x20<br><br>\n\x20\
    <b>ALPHA:</b>\x20This\x20feature\x20is\x20part\x20of\x20an\x20alpha\x20r\
    elease.\x20This\x20API\x20might\x20be\n\x20changed\x20in\x20backward-inc\
    ompatible\x20ways\x20and\x20is\x20not\x20recommended\x20for\x20productio\
    n\n\x20use.\x20It\x20is\x20not\x20subject\x20to\x20any\x20SLA\x20or\x20d\
    eprecation\x20policy.\n\x20When\x20the\x20snapshot\x20is\x20deleted,\x20\
    all\x20messages\x20retained\x20in\x20the\x20snapshot\n\x20are\x20immedia\
    tely\x20dropped.\x20After\x20a\x20snapshot\x20is\x20deleted,\x20a\x20new\
    \x20one\x20may\x20be\n\x20created\x20with\x20the\x20same\x20name,\x20but\
    \x20the\x20new\x20one\x20has\x20no\x20association\x20with\x20the\x20old\
    \n\x20snapshot\x20or\x20its\x20subscription,\x20unless\x20the\x20same\
    \x20subscription\x20is\x20specified.\n\n\r\n\x05\x06\x01\x02\x0e\x01\x12\
    \x04\x9c\x02\x06\x14\n\r\n\x05\x06\x01\x02\x0e\x02\x12\x04\x9c\x02\x15*\
    \n\r\n\x05\x06\x01\x02\x0e\x03\x12\x04\x9c\x025J\n\x0f\n\x05\x06\x01\x02\
    \x0e\x04\x12\x06\x9d\x02\x04\x9f\x02\x06\n\x13\n\t\x06\x01\x02\x0e\x04\
    \xb0\xca\xbc\"\x12\x06\x9d\x02\x04\x9f\x02\x06\n\xdd\x02\n\x04\x06\x01\
    \x02\x0f\x12\x06\xa7\x02\x02\xac\x02\x03\x1a\xcc\x02\x20Seeks\x20an\x20e\
    xisting\x20subscription\x20to\x20a\x20point\x20in\x20time\x20or\x20to\
    \x20a\x20given\x20snapshot,\n\x20whichever\x20is\x20provided\x20in\x20th\
    e\x20request.<br><br>\n\x20<b>ALPHA:</b>\x20This\x20feature\x20is\x20par\
    t\x20of\x20an\x20alpha\x20release.\x20This\x20API\x20might\x20be\n\x20ch\
    anged\x20in\x20backward-incompatible\x20ways\x20and\x20is\x20not\x20reco\
    mmended\x20for\x20production\n\x20use.\x20It\x20is\x20not\x20subject\x20\
    to\x20any\x20SLA\x20or\x20deprecation\x20policy.\n\n\r\n\x05\x06\x01\x02\
    \x0f\x01\x12\x04\xa7\x02\x06\n\n\r\n\x05\x06\x01\x02\x0f\x02\x12\x04\xa7\
    \x02\x0b\x16\n\r\n\x05\x06\x01\x02\x0f\x03\x12\x04\xa7\x02!-\n\x0f\n\x05\
    \x06\x01\x02\x0f\x04\x12\x06\xa8\x02\x04\xab\x02\x06\n\x13\n\t\x06\x01\
    \x02\x0f\x04\xb0\xca\xbc\"\x12\x06\xa8\x02\x04\xab\x02\x06\n\x0c\n\x02\
    \x04\0\x12\x06\xaf\x02\0\xb7\x02\x01\n\x0b\n\x03\x04\0\x01\x12\x04\xaf\
    \x02\x08\x1c\n\xa4\x03\n\x04\x04\0\x02\0\x12\x04\xb6\x02\x022\x1a\x95\
    \x03\x20The\x20list\x20of\x20GCP\x20regions\x20where\x20messages\x20that\
    \x20are\x20published\x20to\x20the\x20topic\x20may\n\x20be\x20persisted\
    \x20in\x20storage.\x20Messages\x20published\x20by\x20publishers\x20runni\
    ng\x20in\n\x20non-allowed\x20GCP\x20regions\x20(or\x20running\x20outside\
    \x20of\x20GCP\x20altogether)\x20will\x20be\n\x20routed\x20for\x20storage\
    \x20in\x20one\x20of\x20the\x20allowed\x20regions.\x20An\x20empty\x20list\
    \x20indicates\x20a\n\x20misconfiguration\x20at\x20the\x20project\x20or\
    \x20organization\x20level,\x20which\x20will\x20result\x20in\n\x20all\x20\
    Publish\x20operations\x20failing.\n\n\r\n\x05\x04\0\x02\0\x04\x12\x04\
    \xb6\x02\x02\n\n\r\n\x05\x04\0\x02\0\x05\x12\x04\xb6\x02\x0b\x11\n\r\n\
    \x05\x04\0\x02\0\x01\x12\x04\xb6\x02\x12-\n\r\n\x05\x04\0\x02\0\x03\x12\
    \x04\xb6\x0201\n!\n\x02\x04\x01\x12\x06\xba\x02\0\xcd\x02\x01\x1a\x13\
    \x20A\x20topic\x20resource.\n\n\x0b\n\x03\x04\x01\x01\x12\x04\xba\x02\
    \x08\r\n\x82\x03\n\x04\x04\x01\x02\0\x12\x04\xc1\x02\x02\x12\x1a\xf3\x02\
    \x20The\x20name\x20of\x20the\x20topic.\x20It\x20must\x20have\x20the\x20f\
    ormat\n\x20`\"projects/{project}/topics/{topic}\"`.\x20`{topic}`\x20must\
    \x20start\x20with\x20a\x20letter,\n\x20and\x20contain\x20only\x20letters\
    \x20(`[A-Za-z]`),\x20numbers\x20(`[0-9]`),\x20dashes\x20(`-`),\n\x20unde\
    rscores\x20(`_`),\x20periods\x20(`.`),\x20tildes\x20(`~`),\x20plus\x20(`\
    +`)\x20or\x20percent\n\x20signs\x20(`%`).\x20It\x20must\x20be\x20between\
    \x203\x20and\x20255\x20characters\x20in\x20length,\x20and\x20it\n\x20mus\
    t\x20not\x20start\x20with\x20`\"goog\"`.\n\n\x0f\n\x05\x04\x01\x02\0\x04\
    \x12\x06\xc1\x02\x02\xba\x02\x0f\n\r\n\x05\x04\x01\x02\0\x05\x12\x04\xc1\
    \x02\x02\x08\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\xc1\x02\t\r\n\r\n\x05\
    \x04\x01\x02\0\x03\x12\x04\xc1\x02\x10\x11\nT\n\x04\x04\x01\x02\x01\x12\
    \x04\xc4\x02\x02!\x1aF\x20See\x20<a\x20href=\"/pubsub/docs/labels\">\x20\
    Creating\x20and\x20managing\x20labels</a>.\n\n\x0f\n\x05\x04\x01\x02\x01\
    \x04\x12\x06\xc4\x02\x02\xc1\x02\x12\n\r\n\x05\x04\x01\x02\x01\x06\x12\
    \x04\xc4\x02\x02\x15\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\xc4\x02\x16\
    \x1c\n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\xc4\x02\x1f\x20\n\xab\x03\n\
    \x04\x04\x01\x02\x02\x12\x04\xcc\x02\x022\x1a\x9c\x03\x20Policy\x20const\
    raining\x20how\x20messages\x20published\x20to\x20the\x20topic\x20may\x20\
    be\x20stored.\x20It\n\x20is\x20determined\x20when\x20the\x20topic\x20is\
    \x20created\x20based\x20on\x20the\x20policy\x20configured\x20at\n\x20the\
    \x20project\x20level.\x20It\x20must\x20not\x20be\x20set\x20by\x20the\x20\
    caller\x20in\x20the\x20request\x20to\n\x20CreateTopic\x20or\x20to\x20Upd\
    ateTopic.\x20This\x20field\x20will\x20be\x20populated\x20in\x20the\n\x20\
    responses\x20for\x20GetTopic,\x20CreateTopic,\x20and\x20UpdateTopic:\x20\
    if\x20not\x20present\x20in\x20the\n\x20response,\x20then\x20no\x20constr\
    aints\x20are\x20in\x20effect.\n\n\x0f\n\x05\x04\x01\x02\x02\x04\x12\x06\
    \xcc\x02\x02\xc4\x02!\n\r\n\x05\x04\x01\x02\x02\x06\x12\x04\xcc\x02\x02\
    \x16\n\r\n\x05\x04\x01\x02\x02\x01\x12\x04\xcc\x02\x17-\n\r\n\x05\x04\
    \x01\x02\x02\x03\x12\x04\xcc\x0201\n\x8a\x02\n\x02\x04\x02\x12\x06\xd3\
    \x02\0\xe5\x02\x01\x1a\xfb\x01\x20A\x20message\x20that\x20is\x20publishe\
    d\x20by\x20publishers\x20and\x20consumed\x20by\x20subscribers.\x20The\n\
    \x20message\x20must\x20contain\x20either\x20a\x20non-empty\x20data\x20fi\
    eld\x20or\x20at\x20least\x20one\x20attribute.\n\x20See\x20<a\x20href=\"/\
    pubsub/quotas\">Quotas\x20and\x20limits</a>\x20for\x20more\x20informatio\
    n\x20about\n\x20message\x20limits.\n\n\x0b\n\x03\x04\x02\x01\x12\x04\xd3\
    \x02\x08\x15\nq\n\x04\x04\x02\x02\0\x12\x04\xd6\x02\x02\x11\x1ac\x20The\
    \x20message\x20data\x20field.\x20If\x20this\x20field\x20is\x20empty,\x20\
    the\x20message\x20must\x20contain\n\x20at\x20least\x20one\x20attribute.\
    \n\n\x0f\n\x05\x04\x02\x02\0\x04\x12\x06\xd6\x02\x02\xd3\x02\x17\n\r\n\
    \x05\x04\x02\x02\0\x05\x12\x04\xd6\x02\x02\x07\n\r\n\x05\x04\x02\x02\0\
    \x01\x12\x04\xd6\x02\x08\x0c\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\xd6\x02\
    \x0f\x10\n5\n\x04\x04\x02\x02\x01\x12\x04\xd9\x02\x02%\x1a'\x20Optional\
    \x20attributes\x20for\x20this\x20message.\n\n\x0f\n\x05\x04\x02\x02\x01\
    \x04\x12\x06\xd9\x02\x02\xd6\x02\x11\n\r\n\x05\x04\x02\x02\x01\x06\x12\
    \x04\xd9\x02\x02\x15\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\xd9\x02\x16\
    \x20\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\xd9\x02#$\n\xb3\x02\n\x04\x04\
    \x02\x02\x02\x12\x04\xdf\x02\x02\x18\x1a\xa4\x02\x20ID\x20of\x20this\x20\
    message,\x20assigned\x20by\x20the\x20server\x20when\x20the\x20message\
    \x20is\x20published.\n\x20Guaranteed\x20to\x20be\x20unique\x20within\x20\
    the\x20topic.\x20This\x20value\x20may\x20be\x20read\x20by\x20a\n\x20subs\
    criber\x20that\x20receives\x20a\x20`PubsubMessage`\x20via\x20a\x20`Pull`\
    \x20call\x20or\x20a\x20push\n\x20delivery.\x20It\x20must\x20not\x20be\
    \x20populated\x20by\x20the\x20publisher\x20in\x20a\x20`Publish`\x20call.\
    \n\n\x0f\n\x05\x04\x02\x02\x02\x04\x12\x06\xdf\x02\x02\xd9\x02%\n\r\n\
    \x05\x04\x02\x02\x02\x05\x12\x04\xdf\x02\x02\x08\n\r\n\x05\x04\x02\x02\
    \x02\x01\x12\x04\xdf\x02\t\x13\n\r\n\x05\x04\x02\x02\x02\x03\x12\x04\xdf\
    \x02\x16\x17\n\xbb\x01\n\x04\x04\x02\x02\x03\x12\x04\xe4\x02\x02-\x1a\
    \xac\x01\x20The\x20time\x20at\x20which\x20the\x20message\x20was\x20publi\
    shed,\x20populated\x20by\x20the\x20server\x20when\n\x20it\x20receives\
    \x20the\x20`Publish`\x20call.\x20It\x20must\x20not\x20be\x20populated\
    \x20by\x20the\n\x20publisher\x20in\x20a\x20`Publish`\x20call.\n\n\x0f\n\
    \x05\x04\x02\x02\x03\x04\x12\x06\xe4\x02\x02\xdf\x02\x18\n\r\n\x05\x04\
    \x02\x02\x03\x06\x12\x04\xe4\x02\x02\x1b\n\r\n\x05\x04\x02\x02\x03\x01\
    \x12\x04\xe4\x02\x1c(\n\r\n\x05\x04\x02\x02\x03\x03\x12\x04\xe4\x02+,\n0\
    \n\x02\x04\x03\x12\x06\xe8\x02\0\xec\x02\x01\x1a\"\x20Request\x20for\x20\
    the\x20GetTopic\x20method.\n\n\x0b\n\x03\x04\x03\x01\x12\x04\xe8\x02\x08\
    \x17\n]\n\x04\x04\x03\x02\0\x12\x04\xeb\x02\x02\x13\x1aO\x20The\x20name\
    \x20of\x20the\x20topic\x20to\x20get.\n\x20Format\x20is\x20`projects/{pro\
    ject}/topics/{topic}`.\n\n\x0f\n\x05\x04\x03\x02\0\x04\x12\x06\xeb\x02\
    \x02\xe8\x02\x19\n\r\n\x05\x04\x03\x02\0\x05\x12\x04\xeb\x02\x02\x08\n\r\
    \n\x05\x04\x03\x02\0\x01\x12\x04\xeb\x02\t\x0e\n\r\n\x05\x04\x03\x02\0\
    \x03\x12\x04\xeb\x02\x11\x12\n3\n\x02\x04\x04\x12\x06\xef\x02\0\xf9\x02\
    \x01\x1a%\x20Request\x20for\x20the\x20UpdateTopic\x20method.\n\n\x0b\n\
    \x03\x04\x04\x01\x12\x04\xef\x02\x08\x1a\n)\n\x04\x04\x04\x02\0\x12\x04\
    \xf1\x02\x02\x12\x1a\x1b\x20The\x20updated\x20topic\x20object.\n\n\x0f\n\
    \x05\x04\x04\x02\0\x04\x12\x06\xf1\x02\x02\xef\x02\x1c\n\r\n\x05\x04\x04\
    \x02\0\x06\x12\x04\xf1\x02\x02\x07\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\
    \xf1\x02\x08\r\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\xf1\x02\x10\x11\n\xe1\
    \x02\n\x04\x04\x04\x02\x01\x12\x04\xf8\x02\x02,\x1a\xd2\x02\x20Indicates\
    \x20which\x20fields\x20in\x20the\x20provided\x20topic\x20to\x20update.\
    \x20Must\x20be\x20specified\n\x20and\x20non-empty.\x20Note\x20that\x20if\
    \x20`update_mask`\x20contains\n\x20\"message_storage_policy\"\x20then\
    \x20the\x20new\x20value\x20will\x20be\x20determined\x20based\x20on\x20th\
    e\n\x20policy\x20configured\x20at\x20the\x20project\x20or\x20organizatio\
    n\x20level.\x20The\n\x20`message_storage_policy`\x20must\x20not\x20be\
    \x20set\x20in\x20the\x20`topic`\x20provided\x20above.\n\n\x0f\n\x05\x04\
    \x04\x02\x01\x04\x12\x06\xf8\x02\x02\xf1\x02\x12\n\r\n\x05\x04\x04\x02\
    \x01\x06\x12\x04\xf8\x02\x02\x1b\n\r\n\x05\x04\x04\x02\x01\x01\x12\x04\
    \xf8\x02\x1c'\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\xf8\x02*+\n/\n\x02\
    \x04\x05\x12\x06\xfc\x02\0\x83\x03\x01\x1a!\x20Request\x20for\x20the\x20\
    Publish\x20method.\n\n\x0b\n\x03\x04\x05\x01\x12\x04\xfc\x02\x08\x16\n|\
    \n\x04\x04\x05\x02\0\x12\x04\xff\x02\x02\x13\x1an\x20The\x20messages\x20\
    in\x20the\x20request\x20will\x20be\x20published\x20on\x20this\x20topic.\
    \n\x20Format\x20is\x20`projects/{project}/topics/{topic}`.\n\n\x0f\n\x05\
    \x04\x05\x02\0\x04\x12\x06\xff\x02\x02\xfc\x02\x18\n\r\n\x05\x04\x05\x02\
    \0\x05\x12\x04\xff\x02\x02\x08\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xff\
    \x02\t\x0e\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xff\x02\x11\x12\n(\n\x04\
    \x04\x05\x02\x01\x12\x04\x82\x03\x02&\x1a\x1a\x20The\x20messages\x20to\
    \x20publish.\n\n\r\n\x05\x04\x05\x02\x01\x04\x12\x04\x82\x03\x02\n\n\r\n\
    \x05\x04\x05\x02\x01\x06\x12\x04\x82\x03\x0b\x18\n\r\n\x05\x04\x05\x02\
    \x01\x01\x12\x04\x82\x03\x19!\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\x82\
    \x03$%\n2\n\x02\x04\x06\x12\x06\x86\x03\0\x8b\x03\x01\x1a$\x20Response\
    \x20for\x20the\x20`Publish`\x20method.\n\n\x0b\n\x03\x04\x06\x01\x12\x04\
    \x86\x03\x08\x17\n\xa8\x01\n\x04\x04\x06\x02\0\x12\x04\x8a\x03\x02\"\x1a\
    \x99\x01\x20The\x20server-assigned\x20ID\x20of\x20each\x20published\x20m\
    essage,\x20in\x20the\x20same\x20order\x20as\n\x20the\x20messages\x20in\
    \x20the\x20request.\x20IDs\x20are\x20guaranteed\x20to\x20be\x20unique\
    \x20within\n\x20the\x20topic.\n\n\r\n\x05\x04\x06\x02\0\x04\x12\x04\x8a\
    \x03\x02\n\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\x8a\x03\x0b\x11\n\r\n\x05\
    \x04\x06\x02\0\x01\x12\x04\x8a\x03\x12\x1d\n\r\n\x05\x04\x06\x02\0\x03\
    \x12\x04\x8a\x03\x20!\n4\n\x02\x04\x07\x12\x06\x8e\x03\0\x9a\x03\x01\x1a\
    &\x20Request\x20for\x20the\x20`ListTopics`\x20method.\n\n\x0b\n\x03\x04\
    \x07\x01\x12\x04\x8e\x03\x08\x19\nd\n\x04\x04\x07\x02\0\x12\x04\x91\x03\
    \x02\x15\x1aV\x20The\x20name\x20of\x20the\x20project\x20in\x20which\x20t\
    o\x20list\x20topics.\n\x20Format\x20is\x20`projects/{project-id}`.\n\n\
    \x0f\n\x05\x04\x07\x02\0\x04\x12\x06\x91\x03\x02\x8e\x03\x1b\n\r\n\x05\
    \x04\x07\x02\0\x05\x12\x04\x91\x03\x02\x08\n\r\n\x05\x04\x07\x02\0\x01\
    \x12\x04\x91\x03\t\x10\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\x91\x03\x13\
    \x14\n3\n\x04\x04\x07\x02\x01\x12\x04\x94\x03\x02\x16\x1a%\x20Maximum\
    \x20number\x20of\x20topics\x20to\x20return.\n\n\x0f\n\x05\x04\x07\x02\
    \x01\x04\x12\x06\x94\x03\x02\x91\x03\x15\n\r\n\x05\x04\x07\x02\x01\x05\
    \x12\x04\x94\x03\x02\x07\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\x94\x03\
    \x08\x11\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\x94\x03\x14\x15\n\xc4\x01\
    \n\x04\x04\x07\x02\x02\x12\x04\x99\x03\x02\x18\x1a\xb5\x01\x20The\x20val\
    ue\x20returned\x20by\x20the\x20last\x20`ListTopicsResponse`;\x20indicate\
    s\x20that\x20this\x20is\n\x20a\x20continuation\x20of\x20a\x20prior\x20`L\
    istTopics`\x20call,\x20and\x20that\x20the\x20system\x20should\n\x20retur\
    n\x20the\x20next\x20page\x20of\x20data.\n\n\x0f\n\x05\x04\x07\x02\x02\
    \x04\x12\x06\x99\x03\x02\x94\x03\x16\n\r\n\x05\x04\x07\x02\x02\x05\x12\
    \x04\x99\x03\x02\x08\n\r\n\x05\x04\x07\x02\x02\x01\x12\x04\x99\x03\t\x13\
    \n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\x99\x03\x16\x17\n5\n\x02\x04\x08\
    \x12\x06\x9d\x03\0\xa4\x03\x01\x1a'\x20Response\x20for\x20the\x20`ListTo\
    pics`\x20method.\n\n\x0b\n\x03\x04\x08\x01\x12\x04\x9d\x03\x08\x1a\n%\n\
    \x04\x04\x08\x02\0\x12\x04\x9f\x03\x02\x1c\x1a\x17\x20The\x20resulting\
    \x20topics.\n\n\r\n\x05\x04\x08\x02\0\x04\x12\x04\x9f\x03\x02\n\n\r\n\
    \x05\x04\x08\x02\0\x06\x12\x04\x9f\x03\x0b\x10\n\r\n\x05\x04\x08\x02\0\
    \x01\x12\x04\x9f\x03\x11\x17\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\x9f\x03\
    \x1a\x1b\n\x99\x01\n\x04\x04\x08\x02\x01\x12\x04\xa3\x03\x02\x1d\x1a\x8a\
    \x01\x20If\x20not\x20empty,\x20indicates\x20that\x20there\x20may\x20be\
    \x20more\x20topics\x20that\x20match\x20the\n\x20request;\x20this\x20valu\
    e\x20should\x20be\x20passed\x20in\x20a\x20new\x20`ListTopicsRequest`.\n\
    \n\x0f\n\x05\x04\x08\x02\x01\x04\x12\x06\xa3\x03\x02\x9f\x03\x1c\n\r\n\
    \x05\x04\x08\x02\x01\x05\x12\x04\xa3\x03\x02\x08\n\r\n\x05\x04\x08\x02\
    \x01\x01\x12\x04\xa3\x03\t\x18\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\xa3\
    \x03\x1b\x1c\n@\n\x02\x04\t\x12\x06\xa7\x03\0\xb3\x03\x01\x1a2\x20Reques\
    t\x20for\x20the\x20`ListTopicSubscriptions`\x20method.\n\n\x0b\n\x03\x04\
    \t\x01\x12\x04\xa7\x03\x08%\ny\n\x04\x04\t\x02\0\x12\x04\xaa\x03\x02\x13\
    \x1ak\x20The\x20name\x20of\x20the\x20topic\x20that\x20subscriptions\x20a\
    re\x20attached\x20to.\n\x20Format\x20is\x20`projects/{project}/topics/{t\
    opic}`.\n\n\x0f\n\x05\x04\t\x02\0\x04\x12\x06\xaa\x03\x02\xa7\x03'\n\r\n\
    \x05\x04\t\x02\0\x05\x12\x04\xaa\x03\x02\x08\n\r\n\x05\x04\t\x02\0\x01\
    \x12\x04\xaa\x03\t\x0e\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xaa\x03\x11\x12\
    \n?\n\x04\x04\t\x02\x01\x12\x04\xad\x03\x02\x16\x1a1\x20Maximum\x20numbe\
    r\x20of\x20subscription\x20names\x20to\x20return.\n\n\x0f\n\x05\x04\t\
    \x02\x01\x04\x12\x06\xad\x03\x02\xaa\x03\x13\n\r\n\x05\x04\t\x02\x01\x05\
    \x12\x04\xad\x03\x02\x07\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xad\x03\x08\
    \x11\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xad\x03\x14\x15\n\xdc\x01\n\x04\
    \x04\t\x02\x02\x12\x04\xb2\x03\x02\x18\x1a\xcd\x01\x20The\x20value\x20re\
    turned\x20by\x20the\x20last\x20`ListTopicSubscriptionsResponse`;\x20indi\
    cates\n\x20that\x20this\x20is\x20a\x20continuation\x20of\x20a\x20prior\
    \x20`ListTopicSubscriptions`\x20call,\x20and\n\x20that\x20the\x20system\
    \x20should\x20return\x20the\x20next\x20page\x20of\x20data.\n\n\x0f\n\x05\
    \x04\t\x02\x02\x04\x12\x06\xb2\x03\x02\xad\x03\x16\n\r\n\x05\x04\t\x02\
    \x02\x05\x12\x04\xb2\x03\x02\x08\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\xb2\
    \x03\t\x13\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\xb2\x03\x16\x17\nA\n\x02\
    \x04\n\x12\x06\xb6\x03\0\xbe\x03\x01\x1a3\x20Response\x20for\x20the\x20`\
    ListTopicSubscriptions`\x20method.\n\n\x0b\n\x03\x04\n\x01\x12\x04\xb6\
    \x03\x08&\nF\n\x04\x04\n\x02\0\x12\x04\xb8\x03\x02$\x1a8\x20The\x20names\
    \x20of\x20the\x20subscriptions\x20that\x20match\x20the\x20request.\n\n\r\
    \n\x05\x04\n\x02\0\x04\x12\x04\xb8\x03\x02\n\n\r\n\x05\x04\n\x02\0\x05\
    \x12\x04\xb8\x03\x0b\x11\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xb8\x03\x12\
    \x1f\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xb8\x03\"#\n\xc7\x01\n\x04\x04\n\
    \x02\x01\x12\x04\xbd\x03\x02\x1d\x1a\xb8\x01\x20If\x20not\x20empty,\x20i\
    ndicates\x20that\x20there\x20may\x20be\x20more\x20subscriptions\x20that\
    \x20match\n\x20the\x20request;\x20this\x20value\x20should\x20be\x20passe\
    d\x20in\x20a\x20new\n\x20`ListTopicSubscriptionsRequest`\x20to\x20get\
    \x20more\x20subscriptions.\n\n\x0f\n\x05\x04\n\x02\x01\x04\x12\x06\xbd\
    \x03\x02\xb8\x03$\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\xbd\x03\x02\x08\n\
    \r\n\x05\x04\n\x02\x01\x01\x12\x04\xbd\x03\t\x18\n\r\n\x05\x04\n\x02\x01\
    \x03\x12\x04\xbd\x03\x1b\x1c\n\x97\x02\n\x02\x04\x0b\x12\x06\xc4\x03\0\
    \xd0\x03\x01\x1a\x88\x02\x20Request\x20for\x20the\x20`ListTopicSnapshots\
    `\x20method.<br><br>\n\x20<b>ALPHA:</b>\x20This\x20feature\x20is\x20part\
    \x20of\x20an\x20alpha\x20release.\x20This\x20API\x20might\x20be\n\x20cha\
    nged\x20in\x20backward-incompatible\x20ways\x20and\x20is\x20not\x20recom\
    mended\x20for\x20production\n\x20use.\x20It\x20is\x20not\x20subject\x20t\
    o\x20any\x20SLA\x20or\x20deprecation\x20policy.\n\n\x0b\n\x03\x04\x0b\
    \x01\x12\x04\xc4\x03\x08!\nu\n\x04\x04\x0b\x02\0\x12\x04\xc7\x03\x02\x13\
    \x1ag\x20The\x20name\x20of\x20the\x20topic\x20that\x20snapshots\x20are\
    \x20attached\x20to.\n\x20Format\x20is\x20`projects/{project}/topics/{top\
    ic}`.\n\n\x0f\n\x05\x04\x0b\x02\0\x04\x12\x06\xc7\x03\x02\xc4\x03#\n\r\n\
    \x05\x04\x0b\x02\0\x05\x12\x04\xc7\x03\x02\x08\n\r\n\x05\x04\x0b\x02\0\
    \x01\x12\x04\xc7\x03\t\x0e\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xc7\x03\
    \x11\x12\n;\n\x04\x04\x0b\x02\x01\x12\x04\xca\x03\x02\x16\x1a-\x20Maximu\
    m\x20number\x20of\x20snapshot\x20names\x20to\x20return.\n\n\x0f\n\x05\
    \x04\x0b\x02\x01\x04\x12\x06\xca\x03\x02\xc7\x03\x13\n\r\n\x05\x04\x0b\
    \x02\x01\x05\x12\x04\xca\x03\x02\x07\n\r\n\x05\x04\x0b\x02\x01\x01\x12\
    \x04\xca\x03\x08\x11\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\xca\x03\x14\
    \x15\n\xd4\x01\n\x04\x04\x0b\x02\x02\x12\x04\xcf\x03\x02\x18\x1a\xc5\x01\
    \x20The\x20value\x20returned\x20by\x20the\x20last\x20`ListTopicSnapshots\
    Response`;\x20indicates\n\x20that\x20this\x20is\x20a\x20continuation\x20\
    of\x20a\x20prior\x20`ListTopicSnapshots`\x20call,\x20and\n\x20that\x20th\
    e\x20system\x20should\x20return\x20the\x20next\x20page\x20of\x20data.\n\
    \n\x0f\n\x05\x04\x0b\x02\x02\x04\x12\x06\xcf\x03\x02\xca\x03\x16\n\r\n\
    \x05\x04\x0b\x02\x02\x05\x12\x04\xcf\x03\x02\x08\n\r\n\x05\x04\x0b\x02\
    \x02\x01\x12\x04\xcf\x03\t\x13\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\xcf\
    \x03\x16\x17\n\x98\x02\n\x02\x04\x0c\x12\x06\xd6\x03\0\xde\x03\x01\x1a\
    \x89\x02\x20Response\x20for\x20the\x20`ListTopicSnapshots`\x20method.<br\
    ><br>\n\x20<b>ALPHA:</b>\x20This\x20feature\x20is\x20part\x20of\x20an\
    \x20alpha\x20release.\x20This\x20API\x20might\x20be\n\x20changed\x20in\
    \x20backward-incompatible\x20ways\x20and\x20is\x20not\x20recommended\x20\
    for\x20production\n\x20use.\x20It\x20is\x20not\x20subject\x20to\x20any\
    \x20SLA\x20or\x20deprecation\x20policy.\n\n\x0b\n\x03\x04\x0c\x01\x12\
    \x04\xd6\x03\x08\"\nB\n\x04\x04\x0c\x02\0\x12\x04\xd8\x03\x02\x20\x1a4\
    \x20The\x20names\x20of\x20the\x20snapshots\x20that\x20match\x20the\x20re\
    quest.\n\n\r\n\x05\x04\x0c\x02\0\x04\x12\x04\xd8\x03\x02\n\n\r\n\x05\x04\
    \x0c\x02\0\x05\x12\x04\xd8\x03\x0b\x11\n\r\n\x05\x04\x0c\x02\0\x01\x12\
    \x04\xd8\x03\x12\x1b\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xd8\x03\x1e\x1f\
    \n\xbb\x01\n\x04\x04\x0c\x02\x01\x12\x04\xdd\x03\x02\x1d\x1a\xac\x01\x20\
    If\x20not\x20empty,\x20indicates\x20that\x20there\x20may\x20be\x20more\
    \x20snapshots\x20that\x20match\n\x20the\x20request;\x20this\x20value\x20\
    should\x20be\x20passed\x20in\x20a\x20new\n\x20`ListTopicSnapshotsRequest\
    `\x20to\x20get\x20more\x20snapshots.\n\n\x0f\n\x05\x04\x0c\x02\x01\x04\
    \x12\x06\xdd\x03\x02\xd8\x03\x20\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\
    \xdd\x03\x02\x08\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\xdd\x03\t\x18\n\r\
    \n\x05\x04\x0c\x02\x01\x03\x12\x04\xdd\x03\x1b\x1c\n5\n\x02\x04\r\x12\
    \x06\xe1\x03\0\xe5\x03\x01\x1a'\x20Request\x20for\x20the\x20`DeleteTopic\
    `\x20method.\n\n\x0b\n\x03\x04\r\x01\x12\x04\xe1\x03\x08\x1a\n\\\n\x04\
    \x04\r\x02\0\x12\x04\xe4\x03\x02\x13\x1aN\x20Name\x20of\x20the\x20topic\
    \x20to\x20delete.\n\x20Format\x20is\x20`projects/{project}/topics/{topic\
    }`.\n\n\x0f\n\x05\x04\r\x02\0\x04\x12\x06\xe4\x03\x02\xe1\x03\x1c\n\r\n\
    \x05\x04\r\x02\0\x05\x12\x04\xe4\x03\x02\x08\n\r\n\x05\x04\r\x02\0\x01\
    \x12\x04\xe4\x03\t\x0e\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xe4\x03\x11\x12\
    \n(\n\x02\x04\x0e\x12\x06\xe8\x03\0\xb3\x04\x01\x1a\x1a\x20A\x20subscrip\
    tion\x20resource.\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\xe8\x03\x08\x14\n\
    \x9e\x03\n\x04\x04\x0e\x02\0\x12\x04\xef\x03\x02\x12\x1a\x8f\x03\x20The\
    \x20name\x20of\x20the\x20subscription.\x20It\x20must\x20have\x20the\x20f\
    ormat\n\x20`\"projects/{project}/subscriptions/{subscription}\"`.\x20`{s\
    ubscription}`\x20must\n\x20start\x20with\x20a\x20letter,\x20and\x20conta\
    in\x20only\x20letters\x20(`[A-Za-z]`),\x20numbers\n\x20(`[0-9]`),\x20das\
    hes\x20(`-`),\x20underscores\x20(`_`),\x20periods\x20(`.`),\x20tildes\
    \x20(`~`),\n\x20plus\x20(`+`)\x20or\x20percent\x20signs\x20(`%`).\x20It\
    \x20must\x20be\x20between\x203\x20and\x20255\x20characters\n\x20in\x20le\
    ngth,\x20and\x20it\x20must\x20not\x20start\x20with\x20`\"goog\"`.\n\n\
    \x0f\n\x05\x04\x0e\x02\0\x04\x12\x06\xef\x03\x02\xe8\x03\x16\n\r\n\x05\
    \x04\x0e\x02\0\x05\x12\x04\xef\x03\x02\x08\n\r\n\x05\x04\x0e\x02\0\x01\
    \x12\x04\xef\x03\t\r\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xef\x03\x10\x11\
    \n\xdd\x01\n\x04\x04\x0e\x02\x01\x12\x04\xf5\x03\x02\x13\x1a\xce\x01\x20\
    The\x20name\x20of\x20the\x20topic\x20from\x20which\x20this\x20subscripti\
    on\x20is\x20receiving\x20messages.\n\x20Format\x20is\x20`projects/{proje\
    ct}/topics/{topic}`.\n\x20The\x20value\x20of\x20this\x20field\x20will\
    \x20be\x20`_deleted-topic_`\x20if\x20the\x20topic\x20has\x20been\n\x20de\
    leted.\n\n\x0f\n\x05\x04\x0e\x02\x01\x04\x12\x06\xf5\x03\x02\xef\x03\x12\
    \n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\xf5\x03\x02\x08\n\r\n\x05\x04\x0e\
    \x02\x01\x01\x12\x04\xf5\x03\t\x0e\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\
    \xf5\x03\x11\x12\n\xc9\x01\n\x04\x04\x0e\x02\x02\x12\x04\xfa\x03\x02\x1d\
    \x1a\xba\x01\x20If\x20push\x20delivery\x20is\x20used\x20with\x20this\x20\
    subscription,\x20this\x20field\x20is\n\x20used\x20to\x20configure\x20it.\
    \x20An\x20empty\x20`pushConfig`\x20signifies\x20that\x20the\x20subscribe\
    r\n\x20will\x20pull\x20and\x20ack\x20messages\x20using\x20API\x20methods\
    .\n\n\x0f\n\x05\x04\x0e\x02\x02\x04\x12\x06\xfa\x03\x02\xf5\x03\x13\n\r\
    \n\x05\x04\x0e\x02\x02\x06\x12\x04\xfa\x03\x02\x0c\n\r\n\x05\x04\x0e\x02\
    \x02\x01\x12\x04\xfa\x03\r\x18\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\xfa\
    \x03\x1b\x1c\n\xaf\x08\n\x04\x04\x0e\x02\x03\x12\x04\x90\x04\x02!\x1a\
    \xa0\x08\x20This\x20value\x20is\x20the\x20maximum\x20time\x20after\x20a\
    \x20subscriber\x20receives\x20a\x20message\n\x20before\x20the\x20subscri\
    ber\x20should\x20acknowledge\x20the\x20message.\x20After\x20message\n\
    \x20delivery\x20but\x20before\x20the\x20ack\x20deadline\x20expires\x20an\
    d\x20before\x20the\x20message\x20is\n\x20acknowledged,\x20it\x20is\x20an\
    \x20outstanding\x20message\x20and\x20will\x20not\x20be\x20delivered\n\
    \x20again\x20during\x20that\x20time\x20(on\x20a\x20best-effort\x20basis)\
    .\n\n\x20For\x20pull\x20subscriptions,\x20this\x20value\x20is\x20used\
    \x20as\x20the\x20initial\x20value\x20for\x20the\x20ack\n\x20deadline.\
    \x20To\x20override\x20this\x20value\x20for\x20a\x20given\x20message,\x20\
    call\n\x20`ModifyAckDeadline`\x20with\x20the\x20corresponding\x20`ack_id\
    `\x20if\x20using\n\x20non-streaming\x20pull\x20or\x20send\x20the\x20`ack\
    _id`\x20in\x20a\n\x20`StreamingModifyAckDeadlineRequest`\x20if\x20using\
    \x20streaming\x20pull.\n\x20The\x20minimum\x20custom\x20deadline\x20you\
    \x20can\x20specify\x20is\x2010\x20seconds.\n\x20The\x20maximum\x20custom\
    \x20deadline\x20you\x20can\x20specify\x20is\x20600\x20seconds\x20(10\x20\
    minutes).\n\x20If\x20this\x20parameter\x20is\x200,\x20a\x20default\x20va\
    lue\x20of\x2010\x20seconds\x20is\x20used.\n\n\x20For\x20push\x20delivery\
    ,\x20this\x20value\x20is\x20also\x20used\x20to\x20set\x20the\x20request\
    \x20timeout\x20for\n\x20the\x20call\x20to\x20the\x20push\x20endpoint.\n\
    \n\x20If\x20the\x20subscriber\x20never\x20acknowledges\x20the\x20message\
    ,\x20the\x20Pub/Sub\n\x20system\x20will\x20eventually\x20redeliver\x20th\
    e\x20message.\n\n\x0f\n\x05\x04\x0e\x02\x03\x04\x12\x06\x90\x04\x02\xfa\
    \x03\x1d\n\r\n\x05\x04\x0e\x02\x03\x05\x12\x04\x90\x04\x02\x07\n\r\n\x05\
    \x04\x0e\x02\x03\x01\x12\x04\x90\x04\x08\x1c\n\r\n\x05\x04\x0e\x02\x03\
    \x03\x12\x04\x90\x04\x1f\x20\n\xc8\x03\n\x04\x04\x0e\x02\x04\x12\x04\x99\
    \x04\x02!\x1a\xb9\x03\x20Indicates\x20whether\x20to\x20retain\x20acknowl\
    edged\x20messages.\x20If\x20true,\x20then\n\x20messages\x20are\x20not\
    \x20expunged\x20from\x20the\x20subscription's\x20backlog,\x20even\x20if\
    \x20they\x20are\n\x20acknowledged,\x20until\x20they\x20fall\x20out\x20of\
    \x20the\x20`message_retention_duration`\n\x20window.<br><br>\n\x20<b>ALP\
    HA:</b>\x20This\x20feature\x20is\x20part\x20of\x20an\x20alpha\x20release\
    .\x20This\x20API\x20might\x20be\n\x20changed\x20in\x20backward-incompati\
    ble\x20ways\x20and\x20is\x20not\x20recommended\x20for\x20production\n\
    \x20use.\x20It\x20is\x20not\x20subject\x20to\x20any\x20SLA\x20or\x20depr\
    ecation\x20policy.\n\n\x0f\n\x05\x04\x0e\x02\x04\x04\x12\x06\x99\x04\x02\
    \x90\x04!\n\r\n\x05\x04\x0e\x02\x04\x05\x12\x04\x99\x04\x02\x06\n\r\n\
    \x05\x04\x0e\x02\x04\x01\x12\x04\x99\x04\x07\x1c\n\r\n\x05\x04\x0e\x02\
    \x04\x03\x12\x04\x99\x04\x1f\x20\n\xce\x04\n\x04\x04\x0e\x02\x05\x12\x04\
    \xa4\x04\x02:\x1a\xbf\x04\x20How\x20long\x20to\x20retain\x20unacknowledg\
    ed\x20messages\x20in\x20the\x20subscription's\x20backlog,\n\x20from\x20t\
    he\x20moment\x20a\x20message\x20is\x20published.\n\x20If\x20`retain_acke\
    d_messages`\x20is\x20true,\x20then\x20this\x20also\x20configures\x20the\
    \x20retention\n\x20of\x20acknowledged\x20messages,\x20and\x20thus\x20con\
    figures\x20how\x20far\x20back\x20in\x20time\x20a\x20`Seek`\n\x20can\x20b\
    e\x20done.\x20Defaults\x20to\x207\x20days.\x20Cannot\x20be\x20more\x20th\
    an\x207\x20days\x20or\x20less\x20than\x2010\n\x20minutes.<br><br>\n\x20<\
    b>ALPHA:</b>\x20This\x20feature\x20is\x20part\x20of\x20an\x20alpha\x20re\
    lease.\x20This\x20API\x20might\x20be\n\x20changed\x20in\x20backward-inco\
    mpatible\x20ways\x20and\x20is\x20not\x20recommended\x20for\x20production\
    \n\x20use.\x20It\x20is\x20not\x20subject\x20to\x20any\x20SLA\x20or\x20de\
    precation\x20policy.\n\n\x0f\n\x05\x04\x0e\x02\x05\x04\x12\x06\xa4\x04\
    \x02\x99\x04!\n\r\n\x05\x04\x0e\x02\x05\x06\x12\x04\xa4\x04\x02\x1a\n\r\
    \n\x05\x04\x0e\x02\x05\x01\x12\x04\xa4\x04\x1b5\n\r\n\x05\x04\x0e\x02\
    \x05\x03\x12\x04\xa4\x0489\nT\n\x04\x04\x0e\x02\x06\x12\x04\xa7\x04\x02!\
    \x1aF\x20See\x20<a\x20href=\"/pubsub/docs/labels\">\x20Creating\x20and\
    \x20managing\x20labels</a>.\n\n\x0f\n\x05\x04\x0e\x02\x06\x04\x12\x06\
    \xa7\x04\x02\xa4\x04:\n\r\n\x05\x04\x0e\x02\x06\x06\x12\x04\xa7\x04\x02\
    \x15\n\r\n\x05\x04\x0e\x02\x06\x01\x12\x04\xa7\x04\x16\x1c\n\r\n\x05\x04\
    \x0e\x02\x06\x03\x12\x04\xa7\x04\x1f\x20\n\xf8\x04\n\x04\x04\x0e\x02\x07\
    \x12\x04\xb2\x04\x02*\x1a\xe9\x04\x20A\x20policy\x20that\x20specifies\
    \x20the\x20conditions\x20for\x20this\x20subscription's\x20expiration.\n\
    \x20A\x20subscription\x20is\x20considered\x20active\x20as\x20long\x20as\
    \x20any\x20connected\x20subscriber\x20is\n\x20successfully\x20consuming\
    \x20messages\x20from\x20the\x20subscription\x20or\x20is\x20issuing\n\x20\
    operations\x20on\x20the\x20subscription.\x20If\x20`expiration_policy`\
    \x20is\x20not\x20set,\x20a\n\x20*default\x20policy*\x20with\x20`ttl`\x20\
    of\x2031\x20days\x20will\x20be\x20used.\x20The\x20minimum\x20allowed\n\
    \x20value\x20for\x20`expiration_policy.ttl`\x20is\x201\x20day.\n\x20<b>B\
    ETA:</b>\x20This\x20feature\x20is\x20part\x20of\x20a\x20beta\x20release.\
    \x20This\x20API\x20might\x20be\n\x20changed\x20in\x20backward-incompatib\
    le\x20ways\x20and\x20is\x20not\x20recommended\x20for\x20production\n\x20\
    use.\x20It\x20is\x20not\x20subject\x20to\x20any\x20SLA\x20or\x20deprecat\
    ion\x20policy.\n\n\x0f\n\x05\x04\x0e\x02\x07\x04\x12\x06\xb2\x04\x02\xa7\
    \x04!\n\r\n\x05\x04\x0e\x02\x07\x06\x12\x04\xb2\x04\x02\x12\n\r\n\x05\
    \x04\x0e\x02\x07\x01\x12\x04\xb2\x04\x13$\n\r\n\x05\x04\x0e\x02\x07\x03\
    \x12\x04\xb2\x04')\nt\n\x02\x04\x0f\x12\x06\xb7\x04\0\xbf\x04\x01\x1af\
    \x20A\x20policy\x20that\x20specifies\x20the\x20conditions\x20for\x20reso\
    urce\x20expiration\x20(i.e.,\n\x20automatic\x20resource\x20deletion).\n\
    \n\x0b\n\x03\x04\x0f\x01\x12\x04\xb7\x04\x08\x18\n\x89\x03\n\x04\x04\x0f\
    \x02\0\x12\x04\xbe\x04\x02#\x1a\xfa\x02\x20Specifies\x20the\x20\"time-to\
    -live\"\x20duration\x20for\x20an\x20associated\x20resource.\x20The\n\x20\
    resource\x20expires\x20if\x20it\x20is\x20not\x20active\x20for\x20a\x20pe\
    riod\x20of\x20`ttl`.\x20The\x20definition\n\x20of\x20\"activity\"\x20dep\
    ends\x20on\x20the\x20type\x20of\x20the\x20associated\x20resource.\x20The\
    \x20minimum\n\x20and\x20maximum\x20allowed\x20values\x20for\x20`ttl`\x20\
    depend\x20on\x20the\x20type\x20of\x20the\x20associated\n\x20resource,\
    \x20as\x20well.\x20If\x20`ttl`\x20is\x20not\x20set,\x20the\x20associated\
    \x20resource\x20never\n\x20expires.\n\n\x0f\n\x05\x04\x0f\x02\0\x04\x12\
    \x06\xbe\x04\x02\xb7\x04\x1a\n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\xbe\x04\
    \x02\x1a\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xbe\x04\x1b\x1e\n\r\n\x05\
    \x04\x0f\x02\0\x03\x12\x04\xbe\x04!\"\n;\n\x02\x04\x10\x12\x06\xc2\x04\0\
    \xdd\x04\x01\x1a-\x20Configuration\x20for\x20a\x20push\x20delivery\x20en\
    dpoint.\n\n\x0b\n\x03\x04\x10\x01\x12\x04\xc2\x04\x08\x12\n\x97\x01\n\
    \x04\x04\x10\x02\0\x12\x04\xc5\x04\x02\x1b\x1a\x88\x01\x20A\x20URL\x20lo\
    cating\x20the\x20endpoint\x20to\x20which\x20messages\x20should\x20be\x20\
    pushed.\n\x20For\x20example,\x20a\x20Webhook\x20endpoint\x20might\x20use\
    \x20\"https://example.com/push\".\n\n\x0f\n\x05\x04\x10\x02\0\x04\x12\
    \x06\xc5\x04\x02\xc2\x04\x14\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xc5\x04\
    \x02\x08\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xc5\x04\t\x16\n\r\n\x05\x04\
    \x10\x02\0\x03\x12\x04\xc5\x04\x19\x1a\n\x8e\x08\n\x04\x04\x10\x02\x01\
    \x12\x04\xdc\x04\x02%\x1a\xff\x07\x20Endpoint\x20configuration\x20attrib\
    utes.\n\n\x20Every\x20endpoint\x20has\x20a\x20set\x20of\x20API\x20suppor\
    ted\x20attributes\x20that\x20can\x20be\x20used\x20to\n\x20control\x20dif\
    ferent\x20aspects\x20of\x20the\x20message\x20delivery.\n\n\x20The\x20cur\
    rently\x20supported\x20attribute\x20is\x20`x-goog-version`,\x20which\x20\
    you\x20can\n\x20use\x20to\x20change\x20the\x20format\x20of\x20the\x20pus\
    hed\x20message.\x20This\x20attribute\n\x20indicates\x20the\x20version\
    \x20of\x20the\x20data\x20expected\x20by\x20the\x20endpoint.\x20This\n\
    \x20controls\x20the\x20shape\x20of\x20the\x20pushed\x20message\x20(i.e.,\
    \x20its\x20fields\x20and\x20metadata).\n\x20The\x20endpoint\x20version\
    \x20is\x20based\x20on\x20the\x20version\x20of\x20the\x20Pub/Sub\x20API.\
    \n\n\x20If\x20not\x20present\x20during\x20the\x20`CreateSubscription`\
    \x20call,\x20it\x20will\x20default\x20to\n\x20the\x20version\x20of\x20th\
    e\x20API\x20used\x20to\x20make\x20such\x20call.\x20If\x20not\x20present\
    \x20during\x20a\n\x20`ModifyPushConfig`\x20call,\x20its\x20value\x20will\
    \x20not\x20be\x20changed.\x20`GetSubscription`\n\x20calls\x20will\x20alw\
    ays\x20return\x20a\x20valid\x20version,\x20even\x20if\x20the\x20subscrip\
    tion\x20was\n\x20created\x20without\x20this\x20attribute.\n\n\x20The\x20\
    possible\x20values\x20for\x20this\x20attribute\x20are:\n\n\x20*\x20`v1be\
    ta1`:\x20uses\x20the\x20push\x20format\x20defined\x20in\x20the\x20v1beta\
    1\x20Pub/Sub\x20API.\n\x20*\x20`v1`\x20or\x20`v1beta2`:\x20uses\x20the\
    \x20push\x20format\x20defined\x20in\x20the\x20v1\x20Pub/Sub\x20API.\n\n\
    \x0f\n\x05\x04\x10\x02\x01\x04\x12\x06\xdc\x04\x02\xc5\x04\x1b\n\r\n\x05\
    \x04\x10\x02\x01\x06\x12\x04\xdc\x04\x02\x15\n\r\n\x05\x04\x10\x02\x01\
    \x01\x12\x04\xdc\x04\x16\x20\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xdc\
    \x04#$\nB\n\x02\x04\x11\x12\x06\xe0\x04\0\xe6\x04\x01\x1a4\x20A\x20messa\
    ge\x20and\x20its\x20corresponding\x20acknowledgment\x20ID.\n\n\x0b\n\x03\
    \x04\x11\x01\x12\x04\xe0\x04\x08\x17\nH\n\x04\x04\x11\x02\0\x12\x04\xe2\
    \x04\x02\x14\x1a:\x20This\x20ID\x20can\x20be\x20used\x20to\x20acknowledg\
    e\x20the\x20received\x20message.\n\n\x0f\n\x05\x04\x11\x02\0\x04\x12\x06\
    \xe2\x04\x02\xe0\x04\x19\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xe2\x04\x02\
    \x08\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xe2\x04\t\x0f\n\r\n\x05\x04\x11\
    \x02\0\x03\x12\x04\xe2\x04\x12\x13\n\x1c\n\x04\x04\x11\x02\x01\x12\x04\
    \xe5\x04\x02\x1c\x1a\x0e\x20The\x20message.\n\n\x0f\n\x05\x04\x11\x02\
    \x01\x04\x12\x06\xe5\x04\x02\xe2\x04\x14\n\r\n\x05\x04\x11\x02\x01\x06\
    \x12\x04\xe5\x04\x02\x0f\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xe5\x04\
    \x10\x17\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xe5\x04\x1a\x1b\n7\n\x02\
    \x04\x12\x12\x06\xe9\x04\0\xed\x04\x01\x1a)\x20Request\x20for\x20the\x20\
    GetSubscription\x20method.\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xe9\x04\x08\
    \x1e\ni\n\x04\x04\x12\x02\0\x12\x04\xec\x04\x02\x1a\x1a[\x20The\x20name\
    \x20of\x20the\x20subscription\x20to\x20get.\n\x20Format\x20is\x20`projec\
    ts/{project}/subscriptions/{sub}`.\n\n\x0f\n\x05\x04\x12\x02\0\x04\x12\
    \x06\xec\x04\x02\xe9\x04\x20\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\xec\x04\
    \x02\x08\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xec\x04\t\x15\n\r\n\x05\x04\
    \x12\x02\0\x03\x12\x04\xec\x04\x18\x19\n:\n\x02\x04\x13\x12\x06\xf0\x04\
    \0\xf7\x04\x01\x1a,\x20Request\x20for\x20the\x20UpdateSubscription\x20me\
    thod.\n\n\x0b\n\x03\x04\x13\x01\x12\x04\xf0\x04\x08!\n0\n\x04\x04\x13\
    \x02\0\x12\x04\xf2\x04\x02\x20\x1a\"\x20The\x20updated\x20subscription\
    \x20object.\n\n\x0f\n\x05\x04\x13\x02\0\x04\x12\x06\xf2\x04\x02\xf0\x04#\
    \n\r\n\x05\x04\x13\x02\0\x06\x12\x04\xf2\x04\x02\x0e\n\r\n\x05\x04\x13\
    \x02\0\x01\x12\x04\xf2\x04\x0f\x1b\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\
    \xf2\x04\x1e\x1f\np\n\x04\x04\x13\x02\x01\x12\x04\xf6\x04\x02,\x1ab\x20I\
    ndicates\x20which\x20fields\x20in\x20the\x20provided\x20subscription\x20\
    to\x20update.\n\x20Must\x20be\x20specified\x20and\x20non-empty.\n\n\x0f\
    \n\x05\x04\x13\x02\x01\x04\x12\x06\xf6\x04\x02\xf2\x04\x20\n\r\n\x05\x04\
    \x13\x02\x01\x06\x12\x04\xf6\x04\x02\x1b\n\r\n\x05\x04\x13\x02\x01\x01\
    \x12\x04\xf6\x04\x1c'\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\xf6\x04*+\n;\
    \n\x02\x04\x14\x12\x06\xfa\x04\0\x86\x05\x01\x1a-\x20Request\x20for\x20t\
    he\x20`ListSubscriptions`\x20method.\n\n\x0b\n\x03\x04\x14\x01\x12\x04\
    \xfa\x04\x08\x20\nk\n\x04\x04\x14\x02\0\x12\x04\xfd\x04\x02\x15\x1a]\x20\
    The\x20name\x20of\x20the\x20project\x20in\x20which\x20to\x20list\x20subs\
    criptions.\n\x20Format\x20is\x20`projects/{project-id}`.\n\n\x0f\n\x05\
    \x04\x14\x02\0\x04\x12\x06\xfd\x04\x02\xfa\x04\"\n\r\n\x05\x04\x14\x02\0\
    \x05\x12\x04\xfd\x04\x02\x08\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xfd\x04\
    \t\x10\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xfd\x04\x13\x14\n:\n\x04\x04\
    \x14\x02\x01\x12\x04\x80\x05\x02\x16\x1a,\x20Maximum\x20number\x20of\x20\
    subscriptions\x20to\x20return.\n\n\x0f\n\x05\x04\x14\x02\x01\x04\x12\x06\
    \x80\x05\x02\xfd\x04\x15\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\x80\x05\
    \x02\x07\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\x80\x05\x08\x11\n\r\n\x05\
    \x04\x14\x02\x01\x03\x12\x04\x80\x05\x14\x15\n\xd2\x01\n\x04\x04\x14\x02\
    \x02\x12\x04\x85\x05\x02\x18\x1a\xc3\x01\x20The\x20value\x20returned\x20\
    by\x20the\x20last\x20`ListSubscriptionsResponse`;\x20indicates\x20that\n\
    \x20this\x20is\x20a\x20continuation\x20of\x20a\x20prior\x20`ListSubscrip\
    tions`\x20call,\x20and\x20that\x20the\n\x20system\x20should\x20return\
    \x20the\x20next\x20page\x20of\x20data.\n\n\x0f\n\x05\x04\x14\x02\x02\x04\
    \x12\x06\x85\x05\x02\x80\x05\x16\n\r\n\x05\x04\x14\x02\x02\x05\x12\x04\
    \x85\x05\x02\x08\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\x85\x05\t\x13\n\r\
    \n\x05\x04\x14\x02\x02\x03\x12\x04\x85\x05\x16\x17\n<\n\x02\x04\x15\x12\
    \x06\x89\x05\0\x91\x05\x01\x1a.\x20Response\x20for\x20the\x20`ListSubscr\
    iptions`\x20method.\n\n\x0b\n\x03\x04\x15\x01\x12\x04\x89\x05\x08!\n9\n\
    \x04\x04\x15\x02\0\x12\x04\x8b\x05\x02*\x1a+\x20The\x20subscriptions\x20\
    that\x20match\x20the\x20request.\n\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\
    \x8b\x05\x02\n\n\r\n\x05\x04\x15\x02\0\x06\x12\x04\x8b\x05\x0b\x17\n\r\n\
    \x05\x04\x15\x02\0\x01\x12\x04\x8b\x05\x18%\n\r\n\x05\x04\x15\x02\0\x03\
    \x12\x04\x8b\x05()\n\xc2\x01\n\x04\x04\x15\x02\x01\x12\x04\x90\x05\x02\
    \x1d\x1a\xb3\x01\x20If\x20not\x20empty,\x20indicates\x20that\x20there\
    \x20may\x20be\x20more\x20subscriptions\x20that\x20match\n\x20the\x20requ\
    est;\x20this\x20value\x20should\x20be\x20passed\x20in\x20a\x20new\n\x20`\
    ListSubscriptionsRequest`\x20to\x20get\x20more\x20subscriptions.\n\n\x0f\
    \n\x05\x04\x15\x02\x01\x04\x12\x06\x90\x05\x02\x8b\x05*\n\r\n\x05\x04\
    \x15\x02\x01\x05\x12\x04\x90\x05\x02\x08\n\r\n\x05\x04\x15\x02\x01\x01\
    \x12\x04\x90\x05\t\x18\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\x90\x05\x1b\
    \x1c\n:\n\x02\x04\x16\x12\x06\x94\x05\0\x98\x05\x01\x1a,\x20Request\x20f\
    or\x20the\x20DeleteSubscription\x20method.\n\n\x0b\n\x03\x04\x16\x01\x12\
    \x04\x94\x05\x08!\n`\n\x04\x04\x16\x02\0\x12\x04\x97\x05\x02\x1a\x1aR\
    \x20The\x20subscription\x20to\x20delete.\n\x20Format\x20is\x20`projects/\
    {project}/subscriptions/{sub}`.\n\n\x0f\n\x05\x04\x16\x02\0\x04\x12\x06\
    \x97\x05\x02\x94\x05#\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\x97\x05\x02\
    \x08\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\x97\x05\t\x15\n\r\n\x05\x04\x16\
    \x02\0\x03\x12\x04\x97\x05\x18\x19\n8\n\x02\x04\x17\x12\x06\x9b\x05\0\
    \xa7\x05\x01\x1a*\x20Request\x20for\x20the\x20ModifyPushConfig\x20method\
    .\n\n\x0b\n\x03\x04\x17\x01\x12\x04\x9b\x05\x08\x1f\nb\n\x04\x04\x17\x02\
    \0\x12\x04\x9e\x05\x02\x1a\x1aT\x20The\x20name\x20of\x20the\x20subscript\
    ion.\n\x20Format\x20is\x20`projects/{project}/subscriptions/{sub}`.\n\n\
    \x0f\n\x05\x04\x17\x02\0\x04\x12\x06\x9e\x05\x02\x9b\x05!\n\r\n\x05\x04\
    \x17\x02\0\x05\x12\x04\x9e\x05\x02\x08\n\r\n\x05\x04\x17\x02\0\x01\x12\
    \x04\x9e\x05\t\x15\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\x9e\x05\x18\x19\n\
    \xb8\x02\n\x04\x04\x17\x02\x01\x12\x04\xa6\x05\x02\x1d\x1a\xa9\x02\x20Th\
    e\x20push\x20configuration\x20for\x20future\x20deliveries.\n\n\x20An\x20\
    empty\x20`pushConfig`\x20indicates\x20that\x20the\x20Pub/Sub\x20system\
    \x20should\n\x20stop\x20pushing\x20messages\x20from\x20the\x20given\x20s\
    ubscription\x20and\x20allow\n\x20messages\x20to\x20be\x20pulled\x20and\
    \x20acknowledged\x20-\x20effectively\x20pausing\n\x20the\x20subscription\
    \x20if\x20`Pull`\x20or\x20`StreamingPull`\x20is\x20not\x20called.\n\n\
    \x0f\n\x05\x04\x17\x02\x01\x04\x12\x06\xa6\x05\x02\x9e\x05\x1a\n\r\n\x05\
    \x04\x17\x02\x01\x06\x12\x04\xa6\x05\x02\x0c\n\r\n\x05\x04\x17\x02\x01\
    \x01\x12\x04\xa6\x05\r\x18\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\xa6\x05\
    \x1b\x1c\n.\n\x02\x04\x18\x12\x06\xaa\x05\0\xb8\x05\x01\x1a\x20\x20Reque\
    st\x20for\x20the\x20`Pull`\x20method.\n\n\x0b\n\x03\x04\x18\x01\x12\x04\
    \xaa\x05\x08\x13\n{\n\x04\x04\x18\x02\0\x12\x04\xad\x05\x02\x1a\x1am\x20\
    The\x20subscription\x20from\x20which\x20messages\x20should\x20be\x20pull\
    ed.\n\x20Format\x20is\x20`projects/{project}/subscriptions/{sub}`.\n\n\
    \x0f\n\x05\x04\x18\x02\0\x04\x12\x06\xad\x05\x02\xaa\x05\x15\n\r\n\x05\
    \x04\x18\x02\0\x05\x12\x04\xad\x05\x02\x08\n\r\n\x05\x04\x18\x02\0\x01\
    \x12\x04\xad\x05\t\x15\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xad\x05\x18\
    \x19\n\xa9\x02\n\x04\x04\x18\x02\x01\x12\x04\xb3\x05\x02\x1e\x1a\x9a\x02\
    \x20If\x20this\x20field\x20set\x20to\x20true,\x20the\x20system\x20will\
    \x20respond\x20immediately\x20even\x20if\n\x20it\x20there\x20are\x20no\
    \x20messages\x20available\x20to\x20return\x20in\x20the\x20`Pull`\x20resp\
    onse.\n\x20Otherwise,\x20the\x20system\x20may\x20wait\x20(for\x20a\x20bo\
    unded\x20amount\x20of\x20time)\x20until\x20at\n\x20least\x20one\x20messa\
    ge\x20is\x20available,\x20rather\x20than\x20returning\x20no\x20messages.\
    \n\n\x0f\n\x05\x04\x18\x02\x01\x04\x12\x06\xb3\x05\x02\xad\x05\x1a\n\r\n\
    \x05\x04\x18\x02\x01\x05\x12\x04\xb3\x05\x02\x06\n\r\n\x05\x04\x18\x02\
    \x01\x01\x12\x04\xb3\x05\x07\x19\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\
    \xb3\x05\x1c\x1d\n\x89\x01\n\x04\x04\x18\x02\x02\x12\x04\xb7\x05\x02\x19\
    \x1a{\x20The\x20maximum\x20number\x20of\x20messages\x20returned\x20for\
    \x20this\x20request.\x20The\x20Pub/Sub\n\x20system\x20may\x20return\x20f\
    ewer\x20than\x20the\x20number\x20specified.\n\n\x0f\n\x05\x04\x18\x02\
    \x02\x04\x12\x06\xb7\x05\x02\xb3\x05\x1e\n\r\n\x05\x04\x18\x02\x02\x05\
    \x12\x04\xb7\x05\x02\x07\n\r\n\x05\x04\x18\x02\x02\x01\x12\x04\xb7\x05\
    \x08\x14\n\r\n\x05\x04\x18\x02\x02\x03\x12\x04\xb7\x05\x17\x18\n/\n\x02\
    \x04\x19\x12\x06\xbb\x05\0\xc1\x05\x01\x1a!\x20Response\x20for\x20the\
    \x20`Pull`\x20method.\n\n\x0b\n\x03\x04\x19\x01\x12\x04\xbb\x05\x08\x14\
    \n\xaa\x02\n\x04\x04\x19\x02\0\x12\x04\xc0\x05\x021\x1a\x9b\x02\x20Recei\
    ved\x20Pub/Sub\x20messages.\x20The\x20list\x20will\x20be\x20empty\x20if\
    \x20there\x20are\x20no\x20more\n\x20messages\x20available\x20in\x20the\
    \x20backlog.\x20For\x20JSON,\x20the\x20response\x20can\x20be\x20entirely\
    \n\x20empty.\x20The\x20Pub/Sub\x20system\x20may\x20return\x20fewer\x20th\
    an\x20the\x20`maxMessages`\x20requested\n\x20even\x20if\x20there\x20are\
    \x20more\x20messages\x20available\x20in\x20the\x20backlog.\n\n\r\n\x05\
    \x04\x19\x02\0\x04\x12\x04\xc0\x05\x02\n\n\r\n\x05\x04\x19\x02\0\x06\x12\
    \x04\xc0\x05\x0b\x1a\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xc0\x05\x1b,\n\
    \r\n\x05\x04\x19\x02\0\x03\x12\x04\xc0\x05/0\n9\n\x02\x04\x1a\x12\x06\
    \xc4\x05\0\xd4\x05\x01\x1a+\x20Request\x20for\x20the\x20ModifyAckDeadlin\
    e\x20method.\n\n\x0b\n\x03\x04\x1a\x01\x12\x04\xc4\x05\x08\x20\nb\n\x04\
    \x04\x1a\x02\0\x12\x04\xc7\x05\x02\x1a\x1aT\x20The\x20name\x20of\x20the\
    \x20subscription.\n\x20Format\x20is\x20`projects/{project}/subscriptions\
    /{sub}`.\n\n\x0f\n\x05\x04\x1a\x02\0\x04\x12\x06\xc7\x05\x02\xc4\x05\"\n\
    \r\n\x05\x04\x1a\x02\0\x05\x12\x04\xc7\x05\x02\x08\n\r\n\x05\x04\x1a\x02\
    \0\x01\x12\x04\xc7\x05\t\x15\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xc7\x05\
    \x18\x19\n+\n\x04\x04\x1a\x02\x01\x12\x04\xca\x05\x02\x1e\x1a\x1d\x20Lis\
    t\x20of\x20acknowledgment\x20IDs.\n\n\r\n\x05\x04\x1a\x02\x01\x04\x12\
    \x04\xca\x05\x02\n\n\r\n\x05\x04\x1a\x02\x01\x05\x12\x04\xca\x05\x0b\x11\
    \n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\xca\x05\x12\x19\n\r\n\x05\x04\x1a\
    \x02\x01\x03\x12\x04\xca\x05\x1c\x1d\n\xb5\x03\n\x04\x04\x1a\x02\x02\x12\
    \x04\xd3\x05\x02!\x1a\xa6\x03\x20The\x20new\x20ack\x20deadline\x20with\
    \x20respect\x20to\x20the\x20time\x20this\x20request\x20was\x20sent\x20to\
    \n\x20the\x20Pub/Sub\x20system.\x20For\x20example,\x20if\x20the\x20value\
    \x20is\x2010,\x20the\x20new\n\x20ack\x20deadline\x20will\x20expire\x2010\
    \x20seconds\x20after\x20the\x20`ModifyAckDeadline`\x20call\n\x20was\x20m\
    ade.\x20Specifying\x20zero\x20may\x20immediately\x20make\x20the\x20messa\
    ge\x20available\x20for\n\x20another\x20pull\x20request.\n\x20The\x20mini\
    mum\x20deadline\x20you\x20can\x20specify\x20is\x200\x20seconds.\n\x20The\
    \x20maximum\x20deadline\x20you\x20can\x20specify\x20is\x20600\x20seconds\
    \x20(10\x20minutes).\n\n\x0f\n\x05\x04\x1a\x02\x02\x04\x12\x06\xd3\x05\
    \x02\xca\x05\x1e\n\r\n\x05\x04\x1a\x02\x02\x05\x12\x04\xd3\x05\x02\x07\n\
    \r\n\x05\x04\x1a\x02\x02\x01\x12\x04\xd3\x05\x08\x1c\n\r\n\x05\x04\x1a\
    \x02\x02\x03\x12\x04\xd3\x05\x1f\x20\n3\n\x02\x04\x1b\x12\x06\xd7\x05\0\
    \xdf\x05\x01\x1a%\x20Request\x20for\x20the\x20Acknowledge\x20method.\n\n\
    \x0b\n\x03\x04\x1b\x01\x12\x04\xd7\x05\x08\x1a\nz\n\x04\x04\x1b\x02\0\
    \x12\x04\xda\x05\x02\x1a\x1al\x20The\x20subscription\x20whose\x20message\
    \x20is\x20being\x20acknowledged.\n\x20Format\x20is\x20`projects/{project\
    }/subscriptions/{sub}`.\n\n\x0f\n\x05\x04\x1b\x02\0\x04\x12\x06\xda\x05\
    \x02\xd7\x05\x1c\n\r\n\x05\x04\x1b\x02\0\x05\x12\x04\xda\x05\x02\x08\n\r\
    \n\x05\x04\x1b\x02\0\x01\x12\x04\xda\x05\t\x15\n\r\n\x05\x04\x1b\x02\0\
    \x03\x12\x04\xda\x05\x18\x19\n\x9e\x01\n\x04\x04\x1b\x02\x01\x12\x04\xde\
    \x05\x02\x1e\x1a\x8f\x01\x20The\x20acknowledgment\x20ID\x20for\x20the\
    \x20messages\x20being\x20acknowledged\x20that\x20was\x20returned\n\x20by\
    \x20the\x20Pub/Sub\x20system\x20in\x20the\x20`Pull`\x20response.\x20Must\
    \x20not\x20be\x20empty.\n\n\r\n\x05\x04\x1b\x02\x01\x04\x12\x04\xde\x05\
    \x02\n\n\r\n\x05\x04\x1b\x02\x01\x05\x12\x04\xde\x05\x0b\x11\n\r\n\x05\
    \x04\x1b\x02\x01\x01\x12\x04\xde\x05\x12\x19\n\r\n\x05\x04\x1b\x02\x01\
    \x03\x12\x04\xde\x05\x1c\x1d\n\xe1\x01\n\x02\x04\x1c\x12\x06\xe4\x05\0\
    \x8b\x06\x01\x1a\xd2\x01\x20Request\x20for\x20the\x20`StreamingPull`\x20\
    streaming\x20RPC\x20method.\x20This\x20request\x20is\x20used\x20to\n\x20\
    establish\x20the\x20initial\x20stream\x20as\x20well\x20as\x20to\x20strea\
    m\x20acknowledgements\x20and\x20ack\n\x20deadline\x20modifications\x20fr\
    om\x20the\x20client\x20to\x20the\x20server.\n\n\x0b\n\x03\x04\x1c\x01\
    \x12\x04\xe4\x05\x08\x1c\n\xfc\x01\n\x04\x04\x1c\x02\0\x12\x04\xe9\x05\
    \x02\x1a\x1a\xed\x01\x20The\x20subscription\x20for\x20which\x20to\x20ini\
    tialize\x20the\x20new\x20stream.\x20This\x20must\x20be\n\x20provided\x20\
    in\x20the\x20first\x20request\x20on\x20the\x20stream,\x20and\x20must\x20\
    not\x20be\x20set\x20in\n\x20subsequent\x20requests\x20from\x20client\x20\
    to\x20server.\n\x20Format\x20is\x20`projects/{project}/subscriptions/{su\
    b}`.\n\n\x0f\n\x05\x04\x1c\x02\0\x04\x12\x06\xe9\x05\x02\xe4\x05\x1e\n\r\
    \n\x05\x04\x1c\x02\0\x05\x12\x04\xe9\x05\x02\x08\n\r\n\x05\x04\x1c\x02\0\
    \x01\x12\x04\xe9\x05\t\x15\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xe9\x05\
    \x18\x19\n\x85\x03\n\x04\x04\x1c\x02\x01\x12\x04\xf0\x05\x02\x1e\x1a\xf6\
    \x02\x20List\x20of\x20acknowledgement\x20IDs\x20for\x20acknowledging\x20\
    previously\x20received\x20messages\n\x20(received\x20on\x20this\x20strea\
    m\x20or\x20a\x20different\x20stream).\x20If\x20an\x20ack\x20ID\x20has\
    \x20expired,\n\x20the\x20corresponding\x20message\x20may\x20be\x20redeli\
    vered\x20later.\x20Acknowledging\x20a\x20message\n\x20more\x20than\x20on\
    ce\x20will\x20not\x20result\x20in\x20an\x20error.\x20If\x20the\x20acknow\
    ledgement\x20ID\x20is\n\x20malformed,\x20the\x20stream\x20will\x20be\x20\
    aborted\x20with\x20status\x20`INVALID_ARGUMENT`.\n\n\r\n\x05\x04\x1c\x02\
    \x01\x04\x12\x04\xf0\x05\x02\n\n\r\n\x05\x04\x1c\x02\x01\x05\x12\x04\xf0\
    \x05\x0b\x11\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xf0\x05\x12\x19\n\r\n\
    \x05\x04\x1c\x02\x01\x03\x12\x04\xf0\x05\x1c\x1d\n\x89\x06\n\x04\x04\x1c\
    \x02\x02\x12\x04\xfd\x05\x02-\x1a\xfa\x05\x20The\x20list\x20of\x20new\
    \x20ack\x20deadlines\x20for\x20the\x20IDs\x20listed\x20in\n\x20`modify_d\
    eadline_ack_ids`.\x20The\x20size\x20of\x20this\x20list\x20must\x20be\x20\
    the\x20same\x20as\x20the\n\x20size\x20of\x20`modify_deadline_ack_ids`.\
    \x20If\x20it\x20differs\x20the\x20stream\x20will\x20be\x20aborted\n\x20w\
    ith\x20`INVALID_ARGUMENT`.\x20Each\x20element\x20in\x20this\x20list\x20i\
    s\x20applied\x20to\x20the\n\x20element\x20in\x20the\x20same\x20position\
    \x20in\x20`modify_deadline_ack_ids`.\x20The\x20new\x20ack\n\x20deadline\
    \x20is\x20with\x20respect\x20to\x20the\x20time\x20this\x20request\x20was\
    \x20sent\x20to\x20the\x20Pub/Sub\n\x20system.\x20Must\x20be\x20>=\x200.\
    \x20For\x20example,\x20if\x20the\x20value\x20is\x2010,\x20the\x20new\x20\
    ack\x20deadline\n\x20will\x20expire\x2010\x20seconds\x20after\x20this\
    \x20request\x20is\x20received.\x20If\x20the\x20value\x20is\x200,\n\x20th\
    e\x20message\x20is\x20immediately\x20made\x20available\x20for\x20another\
    \x20streaming\x20or\n\x20non-streaming\x20pull\x20request.\x20If\x20the\
    \x20value\x20is\x20<\x200\x20(an\x20error),\x20the\x20stream\x20will\n\
    \x20be\x20aborted\x20with\x20status\x20`INVALID_ARGUMENT`.\n\n\r\n\x05\
    \x04\x1c\x02\x02\x04\x12\x04\xfd\x05\x02\n\n\r\n\x05\x04\x1c\x02\x02\x05\
    \x12\x04\xfd\x05\x0b\x10\n\r\n\x05\x04\x1c\x02\x02\x01\x12\x04\xfd\x05\
    \x11(\n\r\n\x05\x04\x1c\x02\x02\x03\x12\x04\xfd\x05+,\n\xc8\x02\n\x04\
    \x04\x1c\x02\x03\x12\x04\x84\x06\x02.\x1a\xb9\x02\x20List\x20of\x20ackno\
    wledgement\x20IDs\x20whose\x20deadline\x20will\x20be\x20modified\x20base\
    d\x20on\x20the\n\x20corresponding\x20element\x20in\x20`modify_deadline_s\
    econds`.\x20This\x20field\x20can\x20be\x20used\n\x20to\x20indicate\x20th\
    at\x20more\x20time\x20is\x20needed\x20to\x20process\x20a\x20message\x20b\
    y\x20the\n\x20subscriber,\x20or\x20to\x20make\x20the\x20message\x20avail\
    able\x20for\x20redelivery\x20if\x20the\n\x20processing\x20was\x20interru\
    pted.\n\n\r\n\x05\x04\x1c\x02\x03\x04\x12\x04\x84\x06\x02\n\n\r\n\x05\
    \x04\x1c\x02\x03\x05\x12\x04\x84\x06\x0b\x11\n\r\n\x05\x04\x1c\x02\x03\
    \x01\x12\x04\x84\x06\x12)\n\r\n\x05\x04\x1c\x02\x03\x03\x12\x04\x84\x06,\
    -\n\xb4\x02\n\x04\x04\x1c\x02\x04\x12\x04\x8a\x06\x02(\x1a\xa5\x02\x20Th\
    e\x20ack\x20deadline\x20to\x20use\x20for\x20the\x20stream.\x20This\x20mu\
    st\x20be\x20provided\x20in\x20the\n\x20first\x20request\x20on\x20the\x20\
    stream,\x20but\x20it\x20can\x20also\x20be\x20updated\x20on\x20subsequent\
    \n\x20requests\x20from\x20client\x20to\x20server.\x20The\x20minimum\x20d\
    eadline\x20you\x20can\x20specify\x20is\x2010\n\x20seconds.\x20The\x20max\
    imum\x20deadline\x20you\x20can\x20specify\x20is\x20600\x20seconds\x20(10\
    \x20minutes).\n\n\x0f\n\x05\x04\x1c\x02\x04\x04\x12\x06\x8a\x06\x02\x84\
    \x06.\n\r\n\x05\x04\x1c\x02\x04\x05\x12\x04\x8a\x06\x02\x07\n\r\n\x05\
    \x04\x1c\x02\x04\x01\x12\x04\x8a\x06\x08#\n\r\n\x05\x04\x1c\x02\x04\x03\
    \x12\x04\x8a\x06&'\n\x81\x01\n\x02\x04\x1d\x12\x06\x8f\x06\0\x92\x06\x01\
    \x1as\x20Response\x20for\x20the\x20`StreamingPull`\x20method.\x20This\
    \x20response\x20is\x20used\x20to\x20stream\n\x20messages\x20from\x20the\
    \x20server\x20to\x20the\x20client.\n\n\x0b\n\x03\x04\x1d\x01\x12\x04\x8f\
    \x06\x08\x1d\nB\n\x04\x04\x1d\x02\0\x12\x04\x91\x06\x021\x1a4\x20Receive\
    d\x20Pub/Sub\x20messages.\x20This\x20will\x20not\x20be\x20empty.\n\n\r\n\
    \x05\x04\x1d\x02\0\x04\x12\x04\x91\x06\x02\n\n\r\n\x05\x04\x1d\x02\0\x06\
    \x12\x04\x91\x06\x0b\x1a\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\x91\x06\x1b\
    ,\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\x91\x06/0\n\x93\x02\n\x02\x04\x1e\
    \x12\x06\x98\x06\0\xae\x06\x01\x1a\x84\x02\x20Request\x20for\x20the\x20`\
    CreateSnapshot`\x20method.<br><br>\n\x20<b>ALPHA:</b>\x20This\x20feature\
    \x20is\x20part\x20of\x20an\x20alpha\x20release.\x20This\x20API\x20might\
    \x20be\x20changed\x20in\n\x20backward-incompatible\x20ways\x20and\x20is\
    \x20not\x20recommended\x20for\x20production\x20use.\n\x20It\x20is\x20not\
    \x20subject\x20to\x20any\x20SLA\x20or\x20deprecation\x20policy.\n\n\x0b\
    \n\x03\x04\x1e\x01\x12\x04\x98\x06\x08\x1d\n\x89\x03\n\x04\x04\x1e\x02\0\
    \x12\x04\x9f\x06\x02\x12\x1a\xfa\x02\x20Optional\x20user-provided\x20nam\
    e\x20for\x20this\x20snapshot.\n\x20If\x20the\x20name\x20is\x20not\x20pro\
    vided\x20in\x20the\x20request,\x20the\x20server\x20will\x20assign\x20a\
    \x20random\n\x20name\x20for\x20this\x20snapshot\x20on\x20the\x20same\x20\
    project\x20as\x20the\x20subscription.\n\x20Note\x20that\x20for\x20REST\
    \x20API\x20requests,\x20you\x20must\x20specify\x20a\x20name.\x20\x20See\
    \x20the\n\x20<a\x20href=\"/pubsub/docs/admin#resource_names\">resource\
    \x20name\x20rules</a>.\n\x20Format\x20is\x20`projects/{project}/snapshot\
    s/{snap}`.\n\n\x0f\n\x05\x04\x1e\x02\0\x04\x12\x06\x9f\x06\x02\x98\x06\
    \x1f\n\r\n\x05\x04\x1e\x02\0\x05\x12\x04\x9f\x06\x02\x08\n\r\n\x05\x04\
    \x1e\x02\0\x01\x12\x04\x9f\x06\t\r\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\
    \x9f\x06\x10\x11\n\xad\x04\n\x04\x04\x1e\x02\x01\x12\x04\xaa\x06\x02\x1a\
    \x1a\x9e\x04\x20The\x20subscription\x20whose\x20backlog\x20the\x20snapsh\
    ot\x20retains.\n\x20Specifically,\x20the\x20created\x20snapshot\x20is\
    \x20guaranteed\x20to\x20retain:\n\x20\x20(a)\x20The\x20existing\x20backl\
    og\x20on\x20the\x20subscription.\x20More\x20precisely,\x20this\x20is\n\
    \x20\x20\x20\x20\x20\x20defined\x20as\x20the\x20messages\x20in\x20the\
    \x20subscription's\x20backlog\x20that\x20are\n\x20\x20\x20\x20\x20\x20un\
    acknowledged\x20upon\x20the\x20successful\x20completion\x20of\x20the\n\
    \x20\x20\x20\x20\x20\x20`CreateSnapshot`\x20request;\x20as\x20well\x20as\
    :\n\x20\x20(b)\x20Any\x20messages\x20published\x20to\x20the\x20subscript\
    ion's\x20topic\x20following\x20the\n\x20\x20\x20\x20\x20\x20successful\
    \x20completion\x20of\x20the\x20CreateSnapshot\x20request.\n\x20Format\
    \x20is\x20`projects/{project}/subscriptions/{sub}`.\n\n\x0f\n\x05\x04\
    \x1e\x02\x01\x04\x12\x06\xaa\x06\x02\x9f\x06\x12\n\r\n\x05\x04\x1e\x02\
    \x01\x05\x12\x04\xaa\x06\x02\x08\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\
    \xaa\x06\t\x15\n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\xaa\x06\x18\x19\nT\
    \n\x04\x04\x1e\x02\x02\x12\x04\xad\x06\x02!\x1aF\x20See\x20<a\x20href=\"\
    /pubsub/docs/labels\">\x20Creating\x20and\x20managing\x20labels</a>.\n\n\
    \x0f\n\x05\x04\x1e\x02\x02\x04\x12\x06\xad\x06\x02\xaa\x06\x1a\n\r\n\x05\
    \x04\x1e\x02\x02\x06\x12\x04\xad\x06\x02\x15\n\r\n\x05\x04\x1e\x02\x02\
    \x01\x12\x04\xad\x06\x16\x1c\n\r\n\x05\x04\x1e\x02\x02\x03\x12\x04\xad\
    \x06\x1f\x20\n\x91\x02\n\x02\x04\x1f\x12\x06\xb4\x06\0\xbb\x06\x01\x1a\
    \x82\x02\x20Request\x20for\x20the\x20UpdateSnapshot\x20method.<br><br>\n\
    \x20<b>ALPHA:</b>\x20This\x20feature\x20is\x20part\x20of\x20an\x20alpha\
    \x20release.\x20This\x20API\x20might\x20be\n\x20changed\x20in\x20backwar\
    d-incompatible\x20ways\x20and\x20is\x20not\x20recommended\x20for\x20prod\
    uction\n\x20use.\x20It\x20is\x20not\x20subject\x20to\x20any\x20SLA\x20or\
    \x20deprecation\x20policy.\n\n\x0b\n\x03\x04\x1f\x01\x12\x04\xb4\x06\x08\
    \x1d\n,\n\x04\x04\x1f\x02\0\x12\x04\xb6\x06\x02\x18\x1a\x1e\x20The\x20up\
    dated\x20snapshot\x20object.\n\n\x0f\n\x05\x04\x1f\x02\0\x04\x12\x06\xb6\
    \x06\x02\xb4\x06\x1f\n\r\n\x05\x04\x1f\x02\0\x06\x12\x04\xb6\x06\x02\n\n\
    \r\n\x05\x04\x1f\x02\0\x01\x12\x04\xb6\x06\x0b\x13\n\r\n\x05\x04\x1f\x02\
    \0\x03\x12\x04\xb6\x06\x16\x17\nl\n\x04\x04\x1f\x02\x01\x12\x04\xba\x06\
    \x02,\x1a^\x20Indicates\x20which\x20fields\x20in\x20the\x20provided\x20s\
    napshot\x20to\x20update.\n\x20Must\x20be\x20specified\x20and\x20non-empt\
    y.\n\n\x0f\n\x05\x04\x1f\x02\x01\x04\x12\x06\xba\x06\x02\xb6\x06\x18\n\r\
    \n\x05\x04\x1f\x02\x01\x06\x12\x04\xba\x06\x02\x1b\n\r\n\x05\x04\x1f\x02\
    \x01\x01\x12\x04\xba\x06\x1c'\n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\xba\
    \x06*+\n\xff\x01\n\x02\x04\x20\x12\x06\xc1\x06\0\xd6\x06\x01\x1a\xf0\x01\
    \x20A\x20snapshot\x20resource.<br><br>\n\x20<b>ALPHA:</b>\x20This\x20fea\
    ture\x20is\x20part\x20of\x20an\x20alpha\x20release.\x20This\x20API\x20mi\
    ght\x20be\n\x20changed\x20in\x20backward-incompatible\x20ways\x20and\x20\
    is\x20not\x20recommended\x20for\x20production\n\x20use.\x20It\x20is\x20n\
    ot\x20subject\x20to\x20any\x20SLA\x20or\x20deprecation\x20policy.\n\n\
    \x0b\n\x03\x04\x20\x01\x12\x04\xc1\x06\x08\x10\n)\n\x04\x04\x20\x02\0\
    \x12\x04\xc3\x06\x02\x12\x1a\x1b\x20The\x20name\x20of\x20the\x20snapshot\
    .\n\n\x0f\n\x05\x04\x20\x02\0\x04\x12\x06\xc3\x06\x02\xc1\x06\x12\n\r\n\
    \x05\x04\x20\x02\0\x05\x12\x04\xc3\x06\x02\x08\n\r\n\x05\x04\x20\x02\0\
    \x01\x12\x04\xc3\x06\t\r\n\r\n\x05\x04\x20\x02\0\x03\x12\x04\xc3\x06\x10\
    \x11\nU\n\x04\x04\x20\x02\x01\x12\x04\xc6\x06\x02\x13\x1aG\x20The\x20nam\
    e\x20of\x20the\x20topic\x20from\x20which\x20this\x20snapshot\x20is\x20re\
    taining\x20messages.\n\n\x0f\n\x05\x04\x20\x02\x01\x04\x12\x06\xc6\x06\
    \x02\xc3\x06\x12\n\r\n\x05\x04\x20\x02\x01\x05\x12\x04\xc6\x06\x02\x08\n\
    \r\n\x05\x04\x20\x02\x01\x01\x12\x04\xc6\x06\t\x0e\n\r\n\x05\x04\x20\x02\
    \x01\x03\x12\x04\xc6\x06\x11\x12\n\xd4\x05\n\x04\x04\x20\x02\x02\x12\x04\
    \xd2\x06\x02,\x1a\xc5\x05\x20The\x20snapshot\x20is\x20guaranteed\x20to\
    \x20exist\x20up\x20until\x20this\x20time.\n\x20A\x20newly-created\x20sna\
    pshot\x20expires\x20no\x20later\x20than\x207\x20days\x20from\x20the\x20t\
    ime\x20of\x20its\n\x20creation.\x20Its\x20exact\x20lifetime\x20is\x20det\
    ermined\x20at\x20creation\x20by\x20the\x20existing\n\x20backlog\x20in\
    \x20the\x20source\x20subscription.\x20Specifically,\x20the\x20lifetime\
    \x20of\x20the\n\x20snapshot\x20is\x20`7\x20days\x20-\x20(age\x20of\x20ol\
    dest\x20unacked\x20message\x20in\x20the\x20subscription)`.\n\x20For\x20e\
    xample,\x20consider\x20a\x20subscription\x20whose\x20oldest\x20unacked\
    \x20message\x20is\x203\x20days\n\x20old.\x20If\x20a\x20snapshot\x20is\
    \x20created\x20from\x20this\x20subscription,\x20the\x20snapshot\x20--\
    \x20which\n\x20will\x20always\x20capture\x20this\x203-day-old\x20backlog\
    \x20as\x20long\x20as\x20the\x20snapshot\n\x20exists\x20--\x20will\x20exp\
    ire\x20in\x204\x20days.\x20The\x20service\x20will\x20refuse\x20to\x20cre\
    ate\x20a\n\x20snapshot\x20that\x20would\x20expire\x20in\x20less\x20than\
    \x201\x20hour\x20after\x20creation.\n\n\x0f\n\x05\x04\x20\x02\x02\x04\
    \x12\x06\xd2\x06\x02\xc6\x06\x13\n\r\n\x05\x04\x20\x02\x02\x06\x12\x04\
    \xd2\x06\x02\x1b\n\r\n\x05\x04\x20\x02\x02\x01\x12\x04\xd2\x06\x1c'\n\r\
    \n\x05\x04\x20\x02\x02\x03\x12\x04\xd2\x06*+\nT\n\x04\x04\x20\x02\x03\
    \x12\x04\xd5\x06\x02!\x1aF\x20See\x20<a\x20href=\"/pubsub/docs/labels\">\
    \x20Creating\x20and\x20managing\x20labels</a>.\n\n\x0f\n\x05\x04\x20\x02\
    \x03\x04\x12\x06\xd5\x06\x02\xd2\x06,\n\r\n\x05\x04\x20\x02\x03\x06\x12\
    \x04\xd5\x06\x02\x15\n\r\n\x05\x04\x20\x02\x03\x01\x12\x04\xd5\x06\x16\
    \x1c\n\r\n\x05\x04\x20\x02\x03\x03\x12\x04\xd5\x06\x1f\x20\n\x8e\x02\n\
    \x02\x04!\x12\x06\xdc\x06\0\xe0\x06\x01\x1a\xff\x01\x20Request\x20for\
    \x20the\x20GetSnapshot\x20method.<br><br>\n\x20<b>ALPHA:</b>\x20This\x20\
    feature\x20is\x20part\x20of\x20an\x20alpha\x20release.\x20This\x20API\
    \x20might\x20be\n\x20changed\x20in\x20backward-incompatible\x20ways\x20a\
    nd\x20is\x20not\x20recommended\x20for\x20production\n\x20use.\x20It\x20i\
    s\x20not\x20subject\x20to\x20any\x20SLA\x20or\x20deprecation\x20policy.\
    \n\n\x0b\n\x03\x04!\x01\x12\x04\xdc\x06\x08\x1a\nb\n\x04\x04!\x02\0\x12\
    \x04\xdf\x06\x02\x16\x1aT\x20The\x20name\x20of\x20the\x20snapshot\x20to\
    \x20get.\n\x20Format\x20is\x20`projects/{project}/snapshots/{snap}`.\n\n\
    \x0f\n\x05\x04!\x02\0\x04\x12\x06\xdf\x06\x02\xdc\x06\x1c\n\r\n\x05\x04!\
    \x02\0\x05\x12\x04\xdf\x06\x02\x08\n\r\n\x05\x04!\x02\0\x01\x12\x04\xdf\
    \x06\t\x11\n\r\n\x05\x04!\x02\0\x03\x12\x04\xdf\x06\x14\x15\n\x92\x02\n\
    \x02\x04\"\x12\x06\xe6\x06\0\xf2\x06\x01\x1a\x83\x02\x20Request\x20for\
    \x20the\x20`ListSnapshots`\x20method.<br><br>\n\x20<b>ALPHA:</b>\x20This\
    \x20feature\x20is\x20part\x20of\x20an\x20alpha\x20release.\x20This\x20AP\
    I\x20might\x20be\n\x20changed\x20in\x20backward-incompatible\x20ways\x20\
    and\x20is\x20not\x20recommended\x20for\x20production\n\x20use.\x20It\x20\
    is\x20not\x20subject\x20to\x20any\x20SLA\x20or\x20deprecation\x20policy.\
    \n\n\x0b\n\x03\x04\"\x01\x12\x04\xe6\x06\x08\x1c\ng\n\x04\x04\"\x02\0\
    \x12\x04\xe9\x06\x02\x15\x1aY\x20The\x20name\x20of\x20the\x20project\x20\
    in\x20which\x20to\x20list\x20snapshots.\n\x20Format\x20is\x20`projects/{\
    project-id}`.\n\n\x0f\n\x05\x04\"\x02\0\x04\x12\x06\xe9\x06\x02\xe6\x06\
    \x1e\n\r\n\x05\x04\"\x02\0\x05\x12\x04\xe9\x06\x02\x08\n\r\n\x05\x04\"\
    \x02\0\x01\x12\x04\xe9\x06\t\x10\n\r\n\x05\x04\"\x02\0\x03\x12\x04\xe9\
    \x06\x13\x14\n6\n\x04\x04\"\x02\x01\x12\x04\xec\x06\x02\x16\x1a(\x20Maxi\
    mum\x20number\x20of\x20snapshots\x20to\x20return.\n\n\x0f\n\x05\x04\"\
    \x02\x01\x04\x12\x06\xec\x06\x02\xe9\x06\x15\n\r\n\x05\x04\"\x02\x01\x05\
    \x12\x04\xec\x06\x02\x07\n\r\n\x05\x04\"\x02\x01\x01\x12\x04\xec\x06\x08\
    \x11\n\r\n\x05\x04\"\x02\x01\x03\x12\x04\xec\x06\x14\x15\n\xca\x01\n\x04\
    \x04\"\x02\x02\x12\x04\xf1\x06\x02\x18\x1a\xbb\x01\x20The\x20value\x20re\
    turned\x20by\x20the\x20last\x20`ListSnapshotsResponse`;\x20indicates\x20\
    that\x20this\n\x20is\x20a\x20continuation\x20of\x20a\x20prior\x20`ListSn\
    apshots`\x20call,\x20and\x20that\x20the\x20system\n\x20should\x20return\
    \x20the\x20next\x20page\x20of\x20data.\n\n\x0f\n\x05\x04\"\x02\x02\x04\
    \x12\x06\xf1\x06\x02\xec\x06\x16\n\r\n\x05\x04\"\x02\x02\x05\x12\x04\xf1\
    \x06\x02\x08\n\r\n\x05\x04\"\x02\x02\x01\x12\x04\xf1\x06\t\x13\n\r\n\x05\
    \x04\"\x02\x02\x03\x12\x04\xf1\x06\x16\x17\n\x93\x02\n\x02\x04#\x12\x06\
    \xf8\x06\0\xff\x06\x01\x1a\x84\x02\x20Response\x20for\x20the\x20`ListSna\
    pshots`\x20method.<br><br>\n\x20<b>ALPHA:</b>\x20This\x20feature\x20is\
    \x20part\x20of\x20an\x20alpha\x20release.\x20This\x20API\x20might\x20be\
    \n\x20changed\x20in\x20backward-incompatible\x20ways\x20and\x20is\x20not\
    \x20recommended\x20for\x20production\n\x20use.\x20It\x20is\x20not\x20sub\
    ject\x20to\x20any\x20SLA\x20or\x20deprecation\x20policy.\n\n\x0b\n\x03\
    \x04#\x01\x12\x04\xf8\x06\x08\x1d\n(\n\x04\x04#\x02\0\x12\x04\xfa\x06\
    \x02\"\x1a\x1a\x20The\x20resulting\x20snapshots.\n\n\r\n\x05\x04#\x02\0\
    \x04\x12\x04\xfa\x06\x02\n\n\r\n\x05\x04#\x02\0\x06\x12\x04\xfa\x06\x0b\
    \x13\n\r\n\x05\x04#\x02\0\x01\x12\x04\xfa\x06\x14\x1d\n\r\n\x05\x04#\x02\
    \0\x03\x12\x04\xfa\x06\x20!\n\x9e\x01\n\x04\x04#\x02\x01\x12\x04\xfe\x06\
    \x02\x1d\x1a\x8f\x01\x20If\x20not\x20empty,\x20indicates\x20that\x20ther\
    e\x20may\x20be\x20more\x20snapshot\x20that\x20match\x20the\n\x20request;\
    \x20this\x20value\x20should\x20be\x20passed\x20in\x20a\x20new\x20`ListSn\
    apshotsRequest`.\n\n\x0f\n\x05\x04#\x02\x01\x04\x12\x06\xfe\x06\x02\xfa\
    \x06\"\n\r\n\x05\x04#\x02\x01\x05\x12\x04\xfe\x06\x02\x08\n\r\n\x05\x04#\
    \x02\x01\x01\x12\x04\xfe\x06\t\x18\n\r\n\x05\x04#\x02\x01\x03\x12\x04\
    \xfe\x06\x1b\x1c\n\x93\x02\n\x02\x04$\x12\x06\x85\x07\0\x89\x07\x01\x1a\
    \x84\x02\x20Request\x20for\x20the\x20`DeleteSnapshot`\x20method.<br><br>\
    \n\x20<b>ALPHA:</b>\x20This\x20feature\x20is\x20part\x20of\x20an\x20alph\
    a\x20release.\x20This\x20API\x20might\x20be\n\x20changed\x20in\x20backwa\
    rd-incompatible\x20ways\x20and\x20is\x20not\x20recommended\x20for\x20pro\
    duction\n\x20use.\x20It\x20is\x20not\x20subject\x20to\x20any\x20SLA\x20o\
    r\x20deprecation\x20policy.\n\n\x0b\n\x03\x04$\x01\x12\x04\x85\x07\x08\
    \x1d\ne\n\x04\x04$\x02\0\x12\x04\x88\x07\x02\x16\x1aW\x20The\x20name\x20\
    of\x20the\x20snapshot\x20to\x20delete.\n\x20Format\x20is\x20`projects/{p\
    roject}/snapshots/{snap}`.\n\n\x0f\n\x05\x04$\x02\0\x04\x12\x06\x88\x07\
    \x02\x85\x07\x1f\n\r\n\x05\x04$\x02\0\x05\x12\x04\x88\x07\x02\x08\n\r\n\
    \x05\x04$\x02\0\x01\x12\x04\x88\x07\t\x11\n\r\n\x05\x04$\x02\0\x03\x12\
    \x04\x88\x07\x14\x15\n\x89\x02\n\x02\x04%\x12\x06\x8f\x07\0\xa6\x07\x01\
    \x1a\xfa\x01\x20Request\x20for\x20the\x20`Seek`\x20method.<br><br>\n\x20\
    <b>ALPHA:</b>\x20This\x20feature\x20is\x20part\x20of\x20an\x20alpha\x20r\
    elease.\x20This\x20API\x20might\x20be\n\x20changed\x20in\x20backward-inc\
    ompatible\x20ways\x20and\x20is\x20not\x20recommended\x20for\x20productio\
    n\n\x20use.\x20It\x20is\x20not\x20subject\x20to\x20any\x20SLA\x20or\x20d\
    eprecation\x20policy.\n\n\x0b\n\x03\x04%\x01\x12\x04\x8f\x07\x08\x13\n+\
    \n\x04\x04%\x02\0\x12\x04\x91\x07\x02\x1a\x1a\x1d\x20The\x20subscription\
    \x20to\x20affect.\n\n\x0f\n\x05\x04%\x02\0\x04\x12\x06\x91\x07\x02\x8f\
    \x07\x15\n\r\n\x05\x04%\x02\0\x05\x12\x04\x91\x07\x02\x08\n\r\n\x05\x04%\
    \x02\0\x01\x12\x04\x91\x07\t\x15\n\r\n\x05\x04%\x02\0\x03\x12\x04\x91\
    \x07\x18\x19\n\x0e\n\x04\x04%\x08\0\x12\x06\x93\x07\x02\xa5\x07\x03\n\r\
    \n\x05\x04%\x08\0\x01\x12\x04\x93\x07\x08\x0e\n\xbe\x05\n\x04\x04%\x02\
    \x01\x12\x04\x9f\x07\x04'\x1a\xaf\x05\x20The\x20time\x20to\x20seek\x20to\
    .\n\x20Messages\x20retained\x20in\x20the\x20subscription\x20that\x20were\
    \x20published\x20before\x20this\n\x20time\x20are\x20marked\x20as\x20ackn\
    owledged,\x20and\x20messages\x20retained\x20in\x20the\n\x20subscription\
    \x20that\x20were\x20published\x20after\x20this\x20time\x20are\x20marked\
    \x20as\n\x20unacknowledged.\x20Note\x20that\x20this\x20operation\x20affe\
    cts\x20only\x20those\x20messages\n\x20retained\x20in\x20the\x20subscript\
    ion\x20(configured\x20by\x20the\x20combination\x20of\n\x20`message_reten\
    tion_duration`\x20and\x20`retain_acked_messages`).\x20For\x20example,\n\
    \x20if\x20`time`\x20corresponds\x20to\x20a\x20point\x20before\x20the\x20\
    message\x20retention\n\x20window\x20(or\x20to\x20a\x20point\x20before\
    \x20the\x20system's\x20notion\x20of\x20the\x20subscription\n\x20creation\
    \x20time),\x20only\x20retained\x20messages\x20will\x20be\x20marked\x20as\
    \x20unacknowledged,\n\x20and\x20already-expunged\x20messages\x20will\x20\
    not\x20be\x20restored.\n\n\r\n\x05\x04%\x02\x01\x06\x12\x04\x9f\x07\x04\
    \x1d\n\r\n\x05\x04%\x02\x01\x01\x12\x04\x9f\x07\x1e\"\n\r\n\x05\x04%\x02\
    \x01\x03\x12\x04\x9f\x07%&\n\xa8\x01\n\x04\x04%\x02\x02\x12\x04\xa4\x07\
    \x04\x18\x1a\x99\x01\x20The\x20snapshot\x20to\x20seek\x20to.\x20The\x20s\
    napshot's\x20topic\x20must\x20be\x20the\x20same\x20as\x20that\x20of\n\
    \x20the\x20provided\x20subscription.\n\x20Format\x20is\x20`projects/{pro\
    ject}/snapshots/{snap}`.\n\n\r\n\x05\x04%\x02\x02\x05\x12\x04\xa4\x07\
    \x04\n\n\r\n\x05\x04%\x02\x02\x01\x12\x04\xa4\x07\x0b\x13\n\r\n\x05\x04%\
    \x02\x02\x03\x12\x04\xa4\x07\x16\x17\nH\n\x02\x04&\x12\x06\xa9\x07\0\xab\
    \x07\x01\x1a:\x20Response\x20for\x20the\x20`Seek`\x20method\x20(this\x20\
    response\x20is\x20empty).\n\n\x0b\n\x03\x04&\x01\x12\x04\xa9\x07\x08\x14\
    b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
